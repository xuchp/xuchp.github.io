<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>丶冫氵灬</title>
    <meta name="description" content="blog">
    <meta name="generator" content="VitePress v1.2.2">
    <link rel="preload stylesheet" href="/assets/style.BKParVJw.css" as="style">
    
    <script type="module" src="/assets/app.CB4UpjbZ.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.BvW0rtPM.js">
    <link rel="modulepreload" href="/assets/chunks/theme.BAfuLQXN.js">
    <link rel="modulepreload" href="/assets/TypeScript_20.工程层面的类型能力：类型声明、类型指令与命名空间.md.DaOzUMHc.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar has-sidebar top" data-v-ae24b3ad data-v-ccf7ddec><div class="wrapper" data-v-ccf7ddec><div class="container" data-v-ccf7ddec><div class="title" data-v-ccf7ddec><div class="VPNavBarTitle has-sidebar" data-v-ccf7ddec data-v-ab179fa1><a class="title" href="/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>丶冫氵灬</span><!--[--><!--]--></a></div></div><div class="content" data-v-ccf7ddec><div class="content-body" data-v-ccf7ddec><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ccf7ddec><!----><div id="docsearch"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><span class="DocSearch-Button-Key">Meta</span><span class="DocSearch-Button-Key">K</span></span></button></div></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ccf7ddec data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/examples/markdown-examples.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Examples</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>要点整理</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/InterviewVue/01.%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Vue%E7%9A%84%E7%90%86%E8%A7%A3.html" data-v-43f1e123><!--[-->Vue<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/InterviewJS/js.html" data-v-43f1e123><!--[-->JavaScript<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/node/1.%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3node%E4%B8%AD%E6%A8%A1%E5%9D%97%E7%9A%84%E6%A6%82%E5%BF%B5.html" data-v-43f1e123><!--[-->Node<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/TypeScript/1.%E5%BC%80%E7%AF%87%EF%BC%9A%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%20TypeScript.html" data-v-43f1e123><!--[-->TypeScript<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>要点整理2</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/basic/css.html" data-v-43f1e123><!--[-->所有<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>前端基础</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/JavaScript/%E7%AC%AC1%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AF%20JavaScript.html" data-v-43f1e123><!--[-->JavaScript<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>vue</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/vue%E6%95%99%E7%A8%8B/index.html" data-v-43f1e123><!--[-->vue教程<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/Vue%E6%8F%92%E4%BB%B6/%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5svg.html" data-v-43f1e123><!--[-->vue插件<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/Vue+TS/TS%20%E6%89%A9%E5%B1%95%E8%B7%AF%E7%94%B1meta.html" data-v-43f1e123><!--[-->vue+TS<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/vue-challenge/CSS%20Features.html" data-v-43f1e123><!--[-->vue挑战<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>HarmonyOS</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/harmonyOS/%E5%85%A5%E9%97%A8.html" data-v-43f1e123><!--[-->HarmonyOS<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ccf7ddec data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ccf7ddec data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ccf7ddec data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ccf7ddec data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-ccf7ddec><div class="divider-line" data-v-ccf7ddec></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-575e6a36><div class="curtain" data-v-575e6a36></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575e6a36><span class="visually-hidden" id="sidebar-aria-label" data-v-575e6a36> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-575e6a36><section class="VPSidebarItem level-0 has-active" data-v-575e6a36 data-v-b8d55f3b><!----><div class="items" data-v-b8d55f3b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/1.开篇：用正确的方式学习 TypeScript.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>1.开篇：用正确的方式学习 TypeScript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>10.结构化类型系统：类型兼容性判断的幕后</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>11.类型系统层级：从 Top Type 到 Bottom Type</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/12.类型里的逻辑运算：条件类型与 infer.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>12.类型里的逻辑运算：条件类型与 infer</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>13.内置工具类型基础：别再妖魔化工具类型了！</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/14.反方向类型推导：用好上下文相关类型.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>14.反方向类型推导：用好上下文相关类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/15.数类型：协变与逆变的比较.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>15.数类型：协变与逆变的比较</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/16.了解类型编程与类型体操的意义，找到平衡点.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>16.了解类型编程与类型体操的意义，找到平衡点</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/17.内置工具类型进阶：类型编程进阶.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>17.内置工具类型进阶：类型编程进阶</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/18.基础类型新成员：模板字符串类型入门.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>18.基础类型新成员：模板字符串类型入门</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>19.类型编程新范式：模板字符串工具类型进阶</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/2.工欲善其事：打造最舒适的 TypeScript 开发环境.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>2.工欲善其事：打造最舒适的 TypeScript 开发环境</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>20.工程层面的类型能力：类型声明、类型指令与命名空间</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>23.全链路 TypeScript 工具库，找到适合你的工具</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>24.说说 TypeScript 和 ECMAScript 之间那些事儿</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>25.装饰器与反射元数据：了解装饰器基本原理与应用</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>26.控制反转与依赖注入：基于装饰器的依赖注入实现</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/27.TSConfig 全解（上）：构建相关配置.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>27.TSConfig 全解（上）：构建相关配置</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>28.TSConfig 全解（下）：检查相关、工程相关配置</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>29.基于 Prisma + NestJs 的 Node API ：前置知识储备</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/3.进入类型的世界：理解原始类型与对象类型.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>3.进入类型的世界：理解原始类型与对象类型</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>31.玩转 TypeScript AST：AST Checker 与 CodeMod</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/32.感谢相伴：是结束，也是开始.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>32.感谢相伴：是结束，也是开始</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/33.漫谈篇：面试中的 TypeScript.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>33.漫谈篇：面试中的 TypeScript</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/4.掌握字面量类型与枚举，让你的类型再精确一些.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>4.掌握字面量类型与枚举，让你的类型再精确一些</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/5.函数与 Class 中的类型：详解函数重载与面向对象.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>5.函数与 Class 中的类型：详解函数重载与面向对象</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/6.探秘内置类型：any、unknown、never 与类型断言.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>6.探秘内置类型：any、unknown、never 与类型断言</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/7.类型编程好帮手：TypeScript 类型工具（上）.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>7.类型编程好帮手：TypeScript 类型工具（上）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/8.类型编程好帮手：TypeScript 类型工具（下）.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>8.类型编程好帮手：TypeScript 类型工具（下）</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/TypeScript/9.类型编程基石：TypeScript 中无处不在的泛型.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>9.类型编程基石：TypeScript 中无处不在的泛型</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>章节内容</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _TypeScript_20_%E5%B7%A5%E7%A8%8B%E5%B1%82%E9%9D%A2%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%83%BD%E5%8A%9B%EF%BC%9A%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" data-v-39a288b8><div><p>我们已经结束了 TypeScript 类型能力的学习，这一节将进入 TypeScript 的实战应用篇。实战篇主要包括了工程能力、框架集成、ECMAScript 语法、TSConfig 解析以及 Node API 开发这五个部分。</p><p>在这一节，我们主要介绍 TypeScript 的工程能力基础，包括类型指令、类型声明、命名空间这么几个部分。这些概念不仅可以帮助你了解到 TypeScript 工程能力的核心理念，也是接下来实战篇内容的前置基础。</p><p>要开始学习工程能力，其实我们可以从一个很简单的场景开始。如果你已经有一定 TypeScript 的使用经验，那你很有可能遇到过这么一个场景：出现了莫名其妙的类型报错，但你又不知道从何入手解决，想让 TypeScript 直接忽略掉这一行出错的代码？此时，类型指令就是你最需要的工具。</p><blockquote><p>本节代码见：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flinbudu599%2FTypeScript-Tiny-Book%2Ftree%2Fmain%2Fpackages%2F17-declaration" target="_blank" rel="noreferrer">Declaration</a></p></blockquote><h2 id="类型检查指令" tabindex="-1">类型检查指令 <a class="header-anchor" href="#类型检查指令" aria-label="Permalink to &quot;类型检查指令&quot;">​</a></h2><p>在前端世界的许多工具中，其实都提供了 <strong>行内注释（Inline Comments）</strong> 的能力，用于支持在某一处特定代码<strong>使用特殊的配置来覆盖掉全局配置</strong>。最常见的即是 ESLint 与 Prettier 提供的禁用检查能力，如 <code>/* eslint-disable-next-lint */</code>、<code>&lt;!-- prettier-ignore --&gt;</code> 等。TypeScript 中同样提供了数个行内注释（这里我们称为类型指令），来进行单行代码或单文件级别的配置能力。这些指令均以 <code>// @ts-</code> 开头 ，我们依次来介绍。</p><h3 id="ts-ignore-与-ts-expect-error" tabindex="-1">ts-ignore 与 ts-expect-error <a class="header-anchor" href="#ts-ignore-与-ts-expect-error" aria-label="Permalink to &quot;ts-ignore 与 ts-expect-error&quot;">​</a></h3><p><code>ts-ignore</code> 应该是使用最为广泛的一个类型指令了，它的作用就是直接禁用掉对下一行代码的类型检查：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-ignore</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>基本上所有的类型报错都可以通过这个指令来解决，但由于它本质是上 ignore 而不是 disable，也就意味着如果下一行代码并没有问题，那使用 ignore 反而就是一个错误了。因此 TypeScript 随后又引入了一个更严格版本的 ignore，即 <code>ts-expect-error</code>，它只有在<strong>下一行代码真的存在错误时</strong>才能被使用，否则它会给出一个错误：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-expect-error</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-expect-error 错误使用此指令，报错</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在这里第二个 expect-error 指令会给出一个报错：<strong>无意义的 expect-error 指令</strong>。</p><p>那这两个功能相同的指令应该如何取舍？我的建议是<strong>在所有地方都不要使用 ts-ignore</strong>，直接把这个指令打入冷宫封存起来。原因在上面我们也说了，对于这类 ignore 指令，本来就应当确保<strong>下一行真的存在错误时</strong>才去使用。</p><p>这两个指令只能对单行代码生效，但如果我们有非常多的类型报错要处理（比如正在将一个 JavaScript 文件迁移到 TypeScript），难道要一个个为所有报错的地方都添加上禁用检查指令？当然不，正如 ESLint 中可以使用 <code>/* eslint-disable-next-line */</code> 禁用下一行代码检查，也可以使用 <code>/* eslint-disable */</code> 禁用整个文件检查一样， TypeScript 中也提供了对整个文件生效的类型指令：<code>ts-check</code> 与 <code>ts-nocheck</code>。</p><h3 id="ts-check-与-ts-nocheck" tabindex="-1">ts-check 与 ts-nocheck <a class="header-anchor" href="#ts-check-与-ts-nocheck" aria-label="Permalink to &quot;ts-check 与 ts-nocheck&quot;">​</a></h3><p>我们首先来看 ts-nocheck ，你可以把它理解为一个作用于整个文件的 ignore 指令，使用了 ts-nocheck 指令的 TS 文件将不再接受类型检查：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-nocheck 以下代码均不会抛出错误</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;linbudu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>那么 <code>ts-check</code> 呢？这看起来是一个多余的指令，因为默认情况下 TS 文件不是就会被检查吗？实际上，这两个指令还可以用在 JS 文件中。要明白这一点，首先我们要知道，TypeScript 并不是只能检查 TS 文件，对于 JS 文件它也可以通过类型推导与 JSDoc 的方式进行不完全的类型检查。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// JavaScript 文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 JSDoc 标注变量类型</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  prop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上面的代码中，声明了初始值的 myAge 与 <code>Foo.prop</code> 都能被推导出其类型，而无初始值的 myName 也可以通过 JSDoc 标注的方式来显式地标注类型。</p><p>但我们知道 JavaScript 是弱类型语言，表现之一即是变量可以<strong>被赋值为与初始值类型不一致的值</strong>，比如上面的例子进一步改写：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;90&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 与初始值类型不同</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 与 JSDoc 标注类型不同</span></span></code></pre></div><p>我们的赋值操作在类型层面显然是不成立的，但我们是在 JavaScript 文件中，因此这里并不会有类型报错。如果希望在 JS 文件中也能享受到类型检查，此时 <code>ts-check</code> 指令就可以登场了：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错！</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;200&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错！</span></span></code></pre></div><p>这里我们的 <code>ts-check</code> 指令为 JavaScript 文件也带来了类型检查，而我们同时还可以使用 <code>ts-expect-error</code> 指令来忽略掉单行的代码检查：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-check</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {string}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-expect-error</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> myName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 599</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 18</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @ts-expect-error</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myAge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;200&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// OK</span></span></code></pre></div><p>而 <code>ts-nocheck</code> 在 JS 文件中的作用和 TS 文件其实也一致，即禁用掉对当前文件的检查。如果我们希望开启对所有 JavaScript 文件的检查，只是忽略掉其中少数呢？此时我们在 TSConfig 中启用 <code>checkJs</code> 配置，来开启<strong>对所有包含的 JS 文件的类型检查</strong>，然后使用 <code>ts-nocheck</code> 来忽略掉其中少数的 JS 文件。</p><p>除了类型指令以外，在实际项目开发中还有一个你会经常打交道的概念：类型声明。</p><h2 id="类型声明" tabindex="-1">类型声明 <a class="header-anchor" href="#类型声明" aria-label="Permalink to &quot;类型声明&quot;">​</a></h2><p>在此前我们其实就已经接触到了类型声明，它实际上就是 <code>declare</code> 语法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> f1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  prop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>我们可以直接访问这些声明：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> otherProp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;prop&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><p>但不能为这些声明变量赋值：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// × 不允许在环境上下文中使用初始值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// √ Foo</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReturnType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo&gt;;</span></span></code></pre></div><p>这些类型声明就像我们在 TypeScript 中的类型标注一样，会存放着特定的类型信息，同时由于它们并不具有实际逻辑，我们可以很方便地使用类型声明来进行类型兼容性的比较、工具类型的声明与测试等等。</p><p>除了手动书写这些声明文件，更常见的情况是你的 TypeScript 代码在编译后生成声明文件：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 源代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> input.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;林不渡&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FooCls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  prop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这段代码在编译后会生成一个 <code>.js</code> 文件和一个 <code>.d.ts</code> 文件，而后者即是类型声明文件：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 生成的类型定义</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">input</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FooCls</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    prop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样一来，如果别的文件或是别的项目导入了这段代码，它们就能够从这些类型声明获得对应部分的类型，这也是类型声明的核心作用：<strong>将类型独立于 <code>.js</code> 文件进行存储</strong>。别人在使用你的代码时，就能够获得这些额外的类型信息。同时，如果你在使用别人没有携带类型声明的 <code>.js</code> 文件，也可以通过类型声明进行类型补全，我们在后面还会了解更多。</p><p>接下来，我们要学习如何通过 TypeScript 类型声明的能力，让项目中的类型覆盖更加完整。</p><h2 id="让类型定义全面覆盖你的项目" tabindex="-1">让类型定义全面覆盖你的项目 <a class="header-anchor" href="#让类型定义全面覆盖你的项目" aria-label="Permalink to &quot;让类型定义全面覆盖你的项目&quot;">​</a></h2><p>在开始学习下面的内容前，不妨先想想你是否遇到过这么几个场景？</p><ul><li>想要使用一个 npm 包，但它发布的时间太早，根本没有携带类型定义，于是你的项目里就出现了这么一处没有被类型覆盖的地方。</li><li>你想要在代码里导入一些非代码文件，反正 Webpack 会帮你处理，但是可恶的 TS 又报错了？</li><li>这个项目在运行时动态注入了一些全局变量（如 <code>window.errorReporter</code>），你想要在代码里直接这样访问，却发现类型又报错了...</li></ul><p>这些问题都可以通过类型声明来解决，这也是它的核心能力：<strong>通过额外的类型声明文件，在核心代码文件以外去提供对类型的进一步补全</strong>。类型声明文件，即 <code>.d.ts</code> 结尾的文件，它会自动地被 TS 加载到环境中，实现对应部分代码的类型补全。</p><p>声明文件中并不包含实际的代码逻辑，它做的事只有一件：<strong>为 TypeScript 类型检查与推导提供额外的类型信息</strong>，而使用的语法仍然是 TypeScript 的 declare 关键字，只不过现在我们要进一步学习其它打开方式了。</p><p>要详细学习声明文件与 declare 关键字，我们不妨先来看看如何解决上面的问题。首先是无类型定义的 npm 包，我们可以通过 declare module 的方式来提供其类型：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pkg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>这里的 pkg 是一个没有类型定义的 npm 包（实际并不存在），我们来看如何为它添加类型提示。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pkg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>现在我们的 res 就具有了 boolean 类型！<code>declare module &#39;pkg&#39;</code> 会为默认导入 <code>foo</code> 添加一个具有 handler 的类型，虽然这里的 <code>pkg</code> 根本不存在。我们也可以在 <code>declare module</code> 中使用默认导出：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pkg2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handler;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;pkg2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><blockquote><p>在 <code>&#39;pkg&#39;</code> 的类型声明中，你也可以使用 <code>export const</code> ，效果是一致的，但由于对 <code>&#39;pkg2&#39;</code> 我们使用了默认导入，因此必须要有一个 <code>export default</code>。</p></blockquote><p>除了为缺失类型的模块声明类型以外，使用类型声明我们还可以为非代码文件，如图片、CSS文件等声明类型。</p><p>对于非代码文件，比如说 markdown 文件，假设我们希望导入一个 <code>.md</code> 文件，由于其本质和 npm 包一样是一条导入语句，因此我们可以类似地使用 declare module 语法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> raw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./note.md&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> content</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> raw.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;NOTE&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`NOTE${</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDay</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// declare.d.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;*.md&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> raw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> raw;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>对于非代码文件的导入，更常见的其实是 <code>.css</code>、<code>.module.css</code>、<code>.png</code> 这一类，但基本语法都相似，我们在后面还会见到更多。</p><p>总结一下，<code>declare module</code> 通常用于为没有提供类型定义的库进行类型的补全，以及为非代码文件提供基本类型定义。但在实际使用中，如果一个库没有内置类型定义，TypeScript 也会提示你，是否要安装 <code>@types/xxx</code> 这样的包。那这个包又是什么？</p><h3 id="definitelytyped" tabindex="-1">DefinitelyTyped <a class="header-anchor" href="#definitelytyped" aria-label="Permalink to &quot;DefinitelyTyped&quot;">​</a></h3><p>简单来说，<code>@types/</code> 开头的这一类 npm 包均属于 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FDefinitelyTyped%2FDefinitelyTyped" target="_blank" rel="noreferrer">DefinitelyTyped</a> ，它是 TypeScript 维护的，专用于为社区存在的<strong>无类型定义的 JavaScript 库</strong>添加类型支持，常见的有 <code>@types/react</code> <code>@types/lodash</code> 等等。通过 DefinitelyTyped 来提供类型定义的包常见的有几种情况，如 Lodash 这样的库仍然有大量 JavaScript 项目使用，将类型定义内置在里面不一定是所有人都需要的，反而会影响包的体积。还有像 React 这种不是用纯 JavaScript / TypeScript 书写的库，需要自己来手写类型声明（React 是用 Flow 写的，这是一门同样为 JavaScript 添加类型的语言，或者说语法）。</p><p>举例来说，只要你安装了 <code>@types/react</code>，TypeScript 会自动将其加载到环境中（实际上所有 <code>@types/</code> 下的包都会自动被加载），并作为 react 模块内部 API 的声明。但这些类型定义并不一定都是通过 <code>declare module</code>，我们下面介绍的命名空间 namespace 其实也可以实现一样的能力。</p><p>先来看 <code>@types/node</code> 中与 <code>@types/react</code> 中分别是如何进行类型声明的：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @types/node</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readFileSync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** 省略 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @types/react</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SetStateAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt;];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以看到，<code>@types/node</code> 中仍然使用 <code>declare module</code> 的方式为 <code>fs</code> 这个内置模块声明了类型，而 <code>@types/react</code> 则使用的是我们没见过的 <code>declare namespace</code> 。别担心，我们会在后面详细介绍。</p><p>回到上面的最后一个问题，如果第三方库并不是通过导出来使用，而是直接在全局注入了变量，如 CDN 引入与某些监控埋点 SDK 的引入，我们需要通过 <code>window.xxx</code> 的方式访问，而类型声明很显然并不存在。此时我们仍然可以通过类型声明，但不再是通过 <code>declare module</code> 了。</p><h3 id="扩展已有的类型定义" tabindex="-1">扩展已有的类型定义 <a class="header-anchor" href="#扩展已有的类型定义" aria-label="Permalink to &quot;扩展已有的类型定义&quot;">​</a></h3><p>对全局变量的声明，还是以 window 为例，实际上我们如果 Ctrl + 点击代码中的 window，会发现它已经有类型声明了：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalThis;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这行代码来自于 <code>lib.dom.d.ts</code> 文件，它定义了对浏览器文档对象模型的类型声明，这就是 TypeScript 提供的内置类型，也是“出厂自带”的类型检查能力的依据。类似的，还有内置的 <code>lib.es2021.d.ts</code> 这种文件定义了对 ECMAScript 每个版本的类型声明新增或改动等等。</p><p>我们要做的，实际上就是在内置类型声明的基础之上，再新增一部分属性。而别忘了，在 JavaScript 中当你访问全局变量时，是可以直接忽略 <code>window</code> 的：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span></code></pre></div><p>反过来，在类型声明中，如果我们直接声明一个变量，那就相当于将它声明在了全局空间中：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 类型声明</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> errorReporter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实际使用</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorReporter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;err!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>而如果我们就是想将它显式的添加到已有的 <code>Window</code> 接口中呢？在接口一节中我们其实已经了解到，如果你有多个同名接口，那么<strong>这些接口实际上是会被合并的</strong>，这一特性在类型声明中也是如此。因此，我们再声明一个 Window 接口即可：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  userTracker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userTracker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;click!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>类似的，我们也可以扩展来自 <code>@types/</code> 包的类型定义：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> module</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bump</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { bump } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;fs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>总结一下这两个部分，TypeScript 通过 DefinitelyTyped ，也就是 <code>@types/</code> 系列的 npm 包来为无类型定义的 JavaScript npm 包提供类型支持，这些类型定义 的 npm 包内部其实就是数个 <code>.d.ts</code> 这样的声明文件。</p><p>而这些声明文件主要通过 declare / namespace 的语法进行类型的描述，我们可以通过项目内额外的声明文件，来实现为非代码文件的导入，或者是全局变量添加上类型声明。而对于多个类型声明文件，如果我们想复用某一个已定义的类型呢？此时三斜线指令就该登场了。</p><h2 id="三斜线指令" tabindex="-1">三斜线指令 <a class="header-anchor" href="#三斜线指令" aria-label="Permalink to &quot;三斜线指令&quot;">​</a></h2><p>三斜线指令就像是声明文件中的导入语句一样，它的作用就是<strong>声明当前的文件依赖的其他类型声明</strong>。而这里的“其他类型声明”包括了 TS 内置类型声明（<code>lib.d.ts</code>）、三方库的类型声明以及你自己提供的类型声明文件等。</p><p>三斜线指令本质上就是一个自闭合的 XML 标签，其语法大致如下：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;./other.d.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lib</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dom&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span></code></pre></div><p><strong>需要注意的是，三斜线指令必须被放置在文件的顶部才能生效</strong>。</p><p>这里的三条指令作用其实都是声明当前文件依赖的外部类型声明，只不过使用的方式不同：分别使用了 path、types、lib 这三个不同属性，我们来依次解析。</p><p>使用 path 的 reference 指令，其 path 属性的值为一个相对路径，指向你项目内的其他声明文件。而在编译时，TS 会沿着 path 指定的路径不断深入寻找，最深的那个没有其他依赖的声明文件会被最先加载。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// @types/node 中的示例</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;fs.d.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span></code></pre></div><p>使用 types 的 reference 指令，其 types 的值是一个包名，也就是你想引入的 <code>@types/</code> 声明，如上面的例子中我们实际上是在声明当前文件对 <code>@types/node</code> 的依赖。而如果你的代码文件（<code>.ts</code>）中声明了对某一个包的类型导入，那么在编译产生的声明文件（<code>.d.ts</code>）中会自动包含引用它的指令。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> types</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span></code></pre></div><p>使用 lib 的 reference 指令类似于 types，只不过这里 lib 导入的是 TypeScript 内置的类型声明，如下面的例子我们声明了对 <code>lib.dom.d.ts</code> 的依赖：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite/client.d.ts</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lib</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dom&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span></code></pre></div><p>而如果我们使用 <code>/// &lt;reference lib=&quot;esnext.promise&quot; /&gt;</code>，那么将依赖的就是 <code>lib.esnext.promise.d.ts</code> 文件。</p><p>这三种指令的目的都是引入当前文件所依赖的其他类型声明，只不过适用场景不同而已。</p><p>如果说三斜线指令的作用就像导入语句一样，那么命名空间（namespace）就像一个模块文件一样，将一组强相关的逻辑收拢到一个命名空间内部。</p><h2 id="命名空间" tabindex="-1">命名空间 <a class="header-anchor" href="#命名空间" aria-label="Permalink to &quot;命名空间&quot;">​</a></h2><p>假设一个场景，我们的项目里需要接入多个平台的支付 SDK，最开始只有微信支付和支付宝：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeChatPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ALiPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>然后又多了美团支付、虚拟货币支付（比如 Q 币）、信用卡支付等等：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeChatPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ALiPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MeiTuanPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreditCardPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QQCoinPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span></code></pre></div><p>随着业务的不断发展，项目中可能需要引入越来越多的支付 SDK，甚至还有比特币和以太坊，此时将这些所有的支付都放在一个文件内未免过于杂乱了。这些支付方式其实大致可以分成两种：现实货币与虚拟货币。此时我们就可以使用命名空间来区分这两类 SDK：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RealCurrency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeChatPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ALiPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MeiTuanPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreditCardPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualCurrency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QQCoinPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BitCoinPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ETHPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>注意，这里的代码是在 <code>.ts</code> 文件中的，此时它是具有实际逻辑意义的，也不能和类型混作一谈。</p></blockquote><p>而命名空间的使用类似于枚举：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> weChatPaySDK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RealCurrency.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WeChatPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>唯一需要注意的是，命名空间内部实际上就像是一个独立的代码文件，因此其中的变量需要导出以后，才能通过 <code>RealCurrency.WeChatPaySDK</code> 这样的形式访问。</p><p>如果你开始学习前端的时间较早，一定会觉得命名空间的编译产物很眼熟——它就像是上古时期里使用的伪模块化方案：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RealCurrency;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">RealCurrency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WeChatPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RealCurrency.WeChatPaySDK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WeChatPaySDK;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ALiPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RealCurrency.ALiPaySDK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ALiPaySDK;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MeiTuanPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RealCurrency.MeiTuanPaySDK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MeiTuanPaySDK;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CreditCardPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RealCurrency.CreditCardPaySDK </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CreditCardPaySDK;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})(RealCurrency </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (RealCurrency </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}));</span></span></code></pre></div><p>实际上，命名空间的作用也正是实现简单的模块化功能，在 TypeScript 中引入它时（<a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Frelease-notes%2Ftypescript-1-5.html%23namespace-keyword" target="_blank" rel="noreferrer">1.5 版本</a>），前端的模块化方案还处于混沌时期。</p><p>命名空间的内部还可以再嵌套命名空间，比如在虚拟货币中再新增区块链货币一类，此时嵌套的命名空间也需要被导出：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualCurrency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QQCoinPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BlockChainCurrency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BitCoinPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ETHPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ethPaySDK</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VirtualCurrency.BlockChainCurrency.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ETHPaySDK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>类似于类型声明中的同名接口合并，命名空间也可以进行合并，但需要通过三斜线指令来声明导入。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// animal.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ProtectedAnimals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// dog.ts</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;animal.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// corgi.ts</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dog.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Corgi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> corgiBark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>实际使用时需要导入全部的依赖文件：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;animal.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dog.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">reference</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;corgi.ts&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Animal.Dog.Corgi.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">corgiBark</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>除了在 <code>.ts</code> 文件中使用以外，命名空间也可以在声明文件中使用，即 <code>declare namespace</code>：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dog</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Dog</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Animal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Cat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>但如果你在 <code>@types/</code> 系列的包下，想要通过 namespace 进行模块的声明，还需要注意将其导出，然后才会加载到对应的模块下。以 <code>@types/react</code> 为例：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> React;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 省略了不必要的类型标注</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">S</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">initialState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>首先我们声明了一个命名空间 React，然后使用 <code>export = React</code> 将它导出了，这样我们就能够在从 react 中导入方法时，获得命名空间内部的类型声明，如 useState。</p><p>从这一个角度来看，<code>declare namespace</code> 其实就类似于普通的 <code>declare</code> 语法，只是内部的类型我们不再需要使用 <code>declare</code> 关键字（比如我们直接在 namespace 内部 <code>function useState(): []</code> 即可）。</p><p>而还有一行 <code>export as namespace React</code> ，它的作用是在启用了 <code>--allowUmdGlobalAccess</code> 配置的情况下，允许将这个模块作为全局变量使用（也就是不导入直接使用），这一特性同样也适用于通过 CDN 资源导入模块时的变量类型声明。</p><p>除了这两处 namespace 使用，React 中还利用 namespace 合并的特性，在全局的命名空间中注入了一些类型：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">declare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JSX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Element</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> React</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReactElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; { }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这也是为什么我们可以在全局使用 <code>JSX.Element</code> 作为类型标注。</p><p>除了类型声明中的导入——三斜线指令，以及类型声明中的模块——命名空间以外，TypeScript 还允许你将这些类型去导入到代码文件中。</p><h2 id="仅类型导入" tabindex="-1">仅类型导入 <a class="header-anchor" href="#仅类型导入" aria-label="Permalink to &quot;仅类型导入&quot;">​</a></h2><p>在 TypeScript 中，当我们导入一个类型时其实并不需要额外的操作，和导入一个实际值是完全一样的：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// foo.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FooType</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// index.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Foo, FooType } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>虽然类型导入和值导入存在于同一条导入语句中，在编译后的 JS 代码里还是只会有值导入存在，同时在编译的过程中，值与类型所在的内存空间也是分开的。</p><p>在这里我们只能通过名称来区分值和类型，但为每一个类型都加一个 Type 后缀也太奇怪了。实际上，我们可以更好地区分值导入和类型导入，只需要通过 <code>import type</code> 语法即可：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { FooType } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这样会造成导入语句数量激增，如果你想同时保持较少的导入语句数量又想区分值和类型导入，也可以使用同一导入语句内的方式（需要 4.6 版本以后才支持）：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Foo, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FooType } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;./foo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这实际上是我个人编码习惯的一部分，即<strong>对导入语句块的规范整理</strong>。在大型项目中一个文件顶部有几十条导入语句是非常常见的，它们可能来自第三方库、UI库、项目内工具方法、样式文件、类型，项目内工具方法可能又分成 constants、hooks、utils、config 等等。如果将这些所有类型的导入都混乱地堆放在一起，对于后续的维护无疑是灾难。因此，我通常会将这些导入按照实际意义进行组织，顺序大致是这样：</p><ul><li>一般最上面会是 React；</li><li>第三方 UI 组件，然后是项目内封装的其他组件；</li><li>第三方工具库，然后是项目内封装的工具方法，具体 hooks 和 utils 等分类的顺序可以按照自己偏好来；</li><li>类型导入，包括第三方库的类型导入、项目内的类型导入等；</li><li>样式文件，<code>CSS-IN-JS</code> 方案的组件应该被放在第二条中其他组件部分。</li></ul><p>示例如下：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Button, Dialog } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ui&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ChildComp } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./child&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { store } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/store&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useCookie } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/hooks/useCookie&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { SOME_CONSTANTS } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/utils/constants&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { FC } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/typings/foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Shared } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@/typings/shared&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> styles </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./index.module.scss&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="总结与预告" tabindex="-1">总结与预告 <a class="header-anchor" href="#总结与预告" aria-label="Permalink to &quot;总结与预告&quot;">​</a></h2><p>在这一节，我们主要了解了 TypeScript 在工程层面的基础能力，包括<strong>类型指令</strong>、<strong>类型声明</strong>、<strong>命名空间</strong>三个部分。</p><p>类型声明相关的能力几乎是所有规模的工程都会使用到的（你总会遇到没有提供类型定义的库吧），通过大量的额外类型声明我们可以实现更复杂、更准确的类型保护，以及为上古时期的 JavaScript npm 包提供类型定义，即 DefinitelyTyped。但类型指令却相反，它绝对不应该被滥用，无论是相当于后门的 <code>ts-ignore</code> 还是稍显安全的 <code>ts-expect-error</code> 。我们会在后面介绍如何通过 ESLint 规则来进行对应地约束。</p><p>而三斜线指令与命名空间这两个概念，虽然已经不再被大量使用，但了解它们诞生与存在的意义同样对理解整个 TypeScript 工程能力很有帮助。在下一节，我们还会与三斜线指令再次碰面。</p><p>无论你是在将 TypeScript 集成到什么框架或者工具里，其实你在做的只是一件事，那就是<strong>类型，类型，类型！</strong>。包括我们在下一节所要学习的 React 与 TypeScript 结合实战，其实本质上也是在学习如何让你的 React 组件也拥有可靠的类型支持。</p><h2 id="扩展阅读" tabindex="-1">扩展阅读 <a class="header-anchor" href="#扩展阅读" aria-label="Permalink to &quot;扩展阅读&quot;">​</a></h2><h3 id="通过-jsdoc-在-js-文件中获得类型提示" tabindex="-1">通过 JSDoc 在 JS 文件中获得类型提示 <a class="header-anchor" href="#通过-jsdoc-在-js-文件中获得类型提示" aria-label="Permalink to &quot;通过 JSDoc 在 JS 文件中获得类型提示&quot;">​</a></h3><p>在上面我们提到了可以在 JS 文件中通过 JSDoc 来标注变量类型，而既然有了类型标注，那么自然也能享受到像 TS 文件中一样的类型提示了。但这里我们需要使用更强大一些的 JSDoc 能力：在 <code>@type {}</code> 中使用导入语句！</p><p>以拥有海量配置项的 Webpack 为例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {import(&quot;webpack&quot;).Configuration}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config;</span></span></code></pre></div><p>此时你会发现已经拥有了如臂使指的类型提示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3074e724e8ef48f9ba02fae7e2c70b71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p><p>类似的，也可以直接进行导出：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> { import(&#39;webpack&#39;).Configuration }</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({});</span></span></code></pre></div><p>当然，Webpack 本身也支持通过 ts 文件进行配置，在使用 TS 进行配置时，一种方式是简单地使用它提供的类型作为一个对象的标注。而目前更常见的一种方式其实是框架内部提供 <code>defineConfig</code> 这样的方法，让你能直接获得类型提示，如 Vite 中的做法：</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineConfig } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> react </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@vitejs/plugin-react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">react</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-d4a0bba5><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d4a0bba5><span class="visually-hidden" id="doc-footer-aria-label" data-v-d4a0bba5>Pager</span><div class="pager" data-v-d4a0bba5><a class="VPLink link pager-link prev" href="/TypeScript/2.工欲善其事：打造最舒适的 TypeScript 开发环境.html" data-v-d4a0bba5><!--[--><span class="desc" data-v-d4a0bba5>Previous page</span><span class="title" data-v-d4a0bba5>2.工欲善其事：打造最舒适的 TypeScript 开发环境</span><!--]--></a></div><div class="pager" data-v-d4a0bba5><a class="VPLink link pager-link next" href="/TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html" data-v-d4a0bba5><!--[--><span class="desc" data-v-d4a0bba5>Next page</span><span class="title" data-v-d4a0bba5>21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"interviewvue_06.请说一下你对响应式的理解.md\":\"DNbA049F\",\"interviewvue_04.谈谈对vue组件化的理解.md\":\"aTZG3uSq\",\"interviewvue_05.为什么需要虚拟dom进行diff检测差异.md\":\"e95GbG-6\",\"interviewvue_15.new vue()这个过程中究竟做了什么.md\":\"Cb1t68Vw\",\"interviewvue_13.watch和watcheffect的区别.md\":\"FySKc89K\",\"interviewvue_01.谈谈你对vue的理解.md\":\"BLAoL0kF\",\"interviewjs_js.md\":\"QHrKSufg\",\"interviewvue_11.watch_computed.md\":\"Brj4jSYR\",\"interviewvue_12.解释 ref和reactive区别.md\":\"BeZ4yqUP\",\"interviewvue_25.vue的过滤器了解吗？过滤器的使用场景.md\":\"BNihZrlT\",\"interviewvue_24.函数组件的优势.md\":\"w2OcynNl\",\"interviewvue_20.请说明vue中key的作用和原理.md\":\"CS4O56it\",\"interviewvue_19.vue中diff算法原理.md\":\"qWHzBaMz\",\"interviewvue_02.谈谈你对spa的理解.md\":\"CQgLVr_6\",\"interviewvue_07.vue中如何检测数组变化.md\":\"C3HOJuRH\",\"interviewvue_16.vue.observable你有了解过吗.md\":\"CGX8pJ6U\",\"interviewvue_17.v-if和v-for哪个优先级更高.md\":\"DLPJRUGE\",\"interviewvue_18.生命周期有哪些.md\":\"CtYf1mCk\",\"interviewvue_03.vue为什么需要虚拟dom.md\":\"CWgm9Y-I\",\"interviewvue_10.v-if和 v-show的优先级.md\":\"B_sdzeDk\",\"interviewvue_09.vue.set方法是如何实现的.md\":\"BDZHc3ZS\",\"interviewvue_14.如何将template转化成render函数.md\":\"DbttKNR4\",\"interviewvue_22.vue.extend方法的作用.md\":\"a0-MAo6j\",\"interviewvue_23.vue组件data为什么必须是一个函数.md\":\"BH9dJKyU\",\"interviewvue_30.vue 中.sync修饰符的作用？.md\":\"BVXe0wtn\",\"interviewvue_28.vue中的slot是怎样实现的？什么时候使用它.md\":\"soZZw2zL\",\"interviewvue_29.说说你对双向绑定的理解，以及它的实现原理.md\":\"1TV5W9Zh\",\"interviewvue_26.v-once的使用场景有哪些.md\":\"DIaVEQs2\",\"interviewvue_08.vue 中如何进行依赖收集.md\":\"BGpopPmn\",\"interviewvue_27.vue.mixin的原理和使用场景.md\":\"CMU1bQCy\",\"interviewvue_21.vue.use是干什么的.md\":\"D5lPB4ko\",\"interviewvue_32.组件中写 name 选项有哪些好处及作用.md\":\"BfK6Jqi1\",\"interviewvue_31.vue 中递归组件的理解.md\":\"ClLh-by9\",\"interviewvue_33.vue 常见的修饰符有哪些，有什么应用场景.md\":\"DwNLek2b\",\"interviewvue_34.vue中异步组件的作用和原理.md\":\"DJ_BdMlQ\",\"interviewvue_35.说说你对 nexttick 的理解.md\":\"rq02E1X-\",\"interviewvue_36.keep-alive平时在哪里使用.md\":\"upTt6oIM\",\"interviewvue_38.vue 中使用了哪些设计模式.md\":\"DCMKoVYg\",\"interviewvue_37.自定义指令的应用场景.md\":\"CL9CC9xl\",\"interviewvue_50.mutation 和 action 的区别.md\":\"BMrX3P17\",\"interviewvue_52.vue3中 compositionapi 的优势是？.md\":\"D9Pgfcqq\",\"interviewvue_51.有使用过 vuex 的 module 吗？在什么情况下会使用.md\":\"BfMBF3PC\",\"interviewvue_54.vue 项目中的错误如何处理的.md\":\"14SCs0cY\",\"interviewvue_53.vue3 有了解过吗？能说说跟 vue2 的区别吗？.md\":\"BUQTBn5V\",\"interviewvue_49.页面刷新后 vuex 的数据丢失怎么解决.md\":\"uQX6myjf\",\"interviewvue_39.vue 中的性能优化有哪些.md\":\"DAErv_2y\",\"interviewvue_42.vue 项目中有封装过 axios 吗？主要是封装哪方面的？.md\":\"C4PddoAI\",\"interviewvue_48.如何监听 vuex 中数据的变化.md\":\"D3Jdks2-\",\"interviewvue_43.vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？.md\":\"DSBDTue3\",\"interviewvue_46.vue 项目本地开发完后部署到服务器后报 404 是什么原因呢.md\":\"CtNiErAk\",\"interviewvue_40.单页应用首屏加载慢的怎么解决.md\":\"eBtBXQWl\",\"interviewvue_47.谈谈你对 vuex 的个人理解.md\":\"DWTgGi1i\",\"interviewvue_41.vue 项目中你是如何解决跨域的呢.md\":\"C1-JYnK5\",\"interviewvue_45.vue-router 几种模式的区别.md\":\"CQ_-7pXY\",\"interviewvue_44.vue-router 有几种钩子函数，具体是什么及执行流程是怎样的？.md\":\"DApc2LQj\",\"javascript_第1章-什么是 javascript.md\":\"By9IUgio\",\"javascript_第2章-html 中的 javascript.md\":\"B0W7-Vy-\",\"typescript_1.开篇：用正确的方式学习 typescript.md\":\"BbNoD8_G\",\"interviewvue_55.vue3 中模板编译优化.md\":\"DLg0wVxw\",\"typescript_10.结构化类型系统：类型兼容性判断的幕后.md\":\"B8VuQH2u\",\"javascript_第3章-语言基础.md\":\"Dk0iC6_R\",\"typescript_11.类型系统层级：从 top type 到 bottom type.md\":\"D9m2cOkV\",\"typescript_12.类型里的逻辑运算：条件类型与 infer.md\":\"J52DI92m\",\"typescript_16.了解类型编程与类型体操的意义，找到平衡点.md\":\"CBkH8zjm\",\"typescript_15.数类型：协变与逆变的比较.md\":\"BmwOwh19\",\"typescript_14.反方向类型推导：用好上下文相关类型.md\":\"BtKIbTH0\",\"typescript_13.内置工具类型基础：别再妖魔化工具类型了！.md\":\"BcH4D0D_\",\"typescript_18.基础类型新成员：模板字符串类型入门.md\":\"zk8R-u0B\",\"typescript_2.工欲善其事：打造最舒适的 typescript 开发环境.md\":\"CcaMI3OP\",\"typescript_19.类型编程新范式：模板字符串工具类型进阶.md\":\"K1nvguuH\",\"typescript_17.内置工具类型进阶：类型编程进阶.md\":\"GxRR67fd\",\"typescript_20.工程层面的类型能力：类型声明、类型指令与命名空间.md\":\"DaOzUMHc\",\"typescript_23.全链路 typescript 工具库，找到适合你的工具.md\":\"Ds-3GASr\",\"typescript_22.让 eslint 来约束你的 typescript 代码：配置与规则集介绍.md\":\"BMhmUE1E\",\"typescript_24.说说 typescript 和 ecmascript 之间那些事儿.md\":\"DAC5rHiw\",\"typescript_21.在 react 中愉快地使用 typescript：内置类型与泛型坑位.md\":\"Cx6yTKeX\",\"typescript_25.装饰器与反射元数据：了解装饰器基本原理与应用.md\":\"DJBXjFUY\",\"typescript_27.tsconfig 全解（上）：构建相关配置.md\":\"CfOEsLMM\",\"typescript_26.控制反转与依赖注入：基于装饰器的依赖注入实现.md\":\"Wtxm-AB9\",\"typescript_28.tsconfig 全解（下）：检查相关、工程相关配置.md\":\"Bzm6yT6S\",\"typescript_29.基于 prisma _ nestjs 的 node api ：前置知识储备.md\":\"DylK1jZ_\",\"typescript_3.进入类型的世界：理解原始类型与对象类型.md\":\"tA5nMN1e\",\"typescript_32.感谢相伴：是结束，也是开始.md\":\"BCZkoR9-\",\"typescript_30.基于 prisma _ nestjs 的 node api ：项目开发与基于 heroku 部署.md\":\"wFb1FPB_\",\"typescript_33.漫谈篇：面试中的 typescript.md\":\"Dpoeg9q2\",\"typescript_4.掌握字面量类型与枚举，让你的类型再精确一些.md\":\"QgBL4dJ6\",\"typescript_31.玩转 typescript ast：ast checker 与 codemod.md\":\"Bs1iMSOO\",\"typescript_6.探秘内置类型：any、unknown、never 与类型断言.md\":\"DTgGpisf\",\"typescript_5.函数与 class 中的类型：详解函数重载与面向对象.md\":\"B2kC6Gxh\",\"typescript_7.类型编程好帮手：typescript 类型工具（上）.md\":\"uZScPDsP\",\"vue_ts_ts 扩展路由meta.md\":\"DybCOrmT\",\"typescript_8.类型编程好帮手：typescript 类型工具（下）.md\":\"BFnep8vG\",\"vue插件_cdn 引入.md\":\"BIn-vYG4\",\"vue插件_pinia 缓存持久化.md\":\"BwE6hlo0\",\"vue插件_批量导入svg.md\":\"Rf1ab7wk\",\"typescript_9.类型编程基石：typescript 中无处不在的泛型.md\":\"m81jjaBl\",\"basic_ios 兼容问题.md\":\"DvvdVh10\",\"basic_git.md\":\"Ch3pNC0E\",\"basic_html.md\":\"CZxVaJST\",\"basic_css.md\":\"CZMBQQ5p\",\"basic_javascript 核心原理精讲.md\":\"BaoSuzkU\",\"basic_ts.md\":\"CKwAkYcX\",\"basic_webpack.md\":\"Curq1ntt\",\"basic_vue.md\":\"CCtqNhls\",\"examples_api-examples.md\":\"BZHddti9\",\"node_1.如何理解node中模块的概念.md\":\"DBXfvEMx\",\"index.md\":\"IBelSA5o\",\"examples_markdown-examples.md\":\"DVsgz6QT\",\"vue-challenge_css features.md\":\"3D-x-3v_\",\"basic_js.md\":\"B-7zrD2p\",\"vue-challenge_components.md\":\"DG5-KcSQ\",\"harmonyos_入门.md\":\"BBIesDDt\",\"vue教程_index.md\":\"Bpr4Cwpt\",\"vue-challenge_lifecycle.md\":\"Ds9L5FvV\",\"vue-challenge_web component.md\":\"C0NCj55d\",\"vue教程_vue3核心语法_setup语法糖.md\":\"B4hpGbYP\",\"vue-challenge_composable function.md\":\"BmDvfj5R\",\"vue-challenge_global apt general.md\":\"Bf1TOIvZ\",\"vue-challenge_event handling.md\":\"aD2TxR91\",\"vue-challenge_unility function.md\":\"BDbLXoiB\",\"vue-challenge_reactivity advanced.md\":\"BwEsg8a3\",\"vue-challenge_directives.md\":\"77TUWfs7\",\"vue-challenge_composition api.md\":\"CEwroulS\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"丶冫氵灬\",\"description\":\"blog\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":{\"level\":[2,6],\"label\":\"章节内容\"},\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"Examples\",\"link\":\"/examples/markdown-examples\"},{\"text\":\"要点整理\",\"items\":[{\"text\":\"Vue\",\"link\":\"/InterviewVue/01.谈谈你对Vue的理解.md\"},{\"text\":\"JavaScript\",\"link\":\"/InterviewJS/js.md\"},{\"text\":\"Node\",\"link\":\"/node/1.如何理解node中模块的概念.md\"},{\"text\":\"TypeScript\",\"link\":\"/TypeScript/1.开篇：用正确的方式学习 TypeScript.md\"}]},{\"text\":\"要点整理2\",\"items\":[{\"text\":\"所有\",\"link\":\"/basic/css.md\"}]},{\"text\":\"前端基础\",\"items\":[{\"text\":\"JavaScript\",\"link\":\"/JavaScript/第1章-什么是 JavaScript.md\"}]},{\"text\":\"vue\",\"items\":[{\"text\":\"vue教程\",\"link\":\"vue教程/index.md\"},{\"text\":\"vue插件\",\"link\":\"Vue插件/批量导入svg.md\"},{\"text\":\"vue+TS\",\"link\":\"Vue+TS/TS 扩展路由meta.md\"},{\"text\":\"vue挑战\",\"link\":\"/vue-challenge/CSS Features.md\"}]},{\"text\":\"HarmonyOS\",\"items\":[{\"text\":\"HarmonyOS\",\"link\":\"/harmonyOS/入门.md\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"sidebar\":{\"/InterviewJS/\":[{\"items\":[{\"text\":\"js\",\"link\":\"/InterviewJS/js.html\"}]}],\"/InterviewVue/\":[{\"items\":[{\"text\":\"01.谈谈你对Vue的理解\",\"link\":\"/InterviewVue/01.谈谈你对Vue的理解.html\"},{\"text\":\"02.谈谈你对spa的理解\",\"link\":\"/InterviewVue/02.谈谈你对spa的理解.html\"},{\"text\":\"03.Vue为什么需要虚拟DOM\",\"link\":\"/InterviewVue/03.Vue为什么需要虚拟DOM.html\"},{\"text\":\"04.谈谈对Vue组件化的理解\",\"link\":\"/InterviewVue/04.谈谈对Vue组件化的理解.html\"},{\"text\":\"05.为什么需要虚拟DOM进行diff检测差异\",\"link\":\"/InterviewVue/05.为什么需要虚拟DOM进行diff检测差异.html\"},{\"text\":\"06.请说一下你对响应式的理解\",\"link\":\"/InterviewVue/06.请说一下你对响应式的理解.html\"},{\"text\":\"07.Vue中如何检测数组变化\",\"link\":\"/InterviewVue/07.Vue中如何检测数组变化.html\"},{\"text\":\"08.Vue 中如何进行依赖收集\",\"link\":\"/InterviewVue/08.Vue 中如何进行依赖收集.html\"},{\"text\":\"09.Vue.set方法是如何实现的\",\"link\":\"/InterviewVue/09.Vue.set方法是如何实现的.html\"},{\"text\":\"10.v-if和 v-show的优先级\",\"link\":\"/InterviewVue/10.v-if和 v-show的优先级.html\"},{\"text\":\"11.watch&computed\",\"link\":\"/InterviewVue/11.watch&computed.html\"},{\"text\":\"12.解释 ref和reactive区别\",\"link\":\"/InterviewVue/12.解释 ref和reactive区别.html\"},{\"text\":\"13.watch和watchEffect的区别\",\"link\":\"/InterviewVue/13.watch和watchEffect的区别.html\"},{\"text\":\"14.如何将template转化成render函数\",\"link\":\"/InterviewVue/14.如何将template转化成render函数.html\"},{\"text\":\"15.new Vue()这个过程中究竟做了什么\",\"link\":\"/InterviewVue/15.new Vue()这个过程中究竟做了什么.html\"},{\"text\":\"16.Vue.observable你有了解过吗\",\"link\":\"/InterviewVue/16.Vue.observable你有了解过吗.html\"},{\"text\":\"17.v-if和v-for哪个优先级更高\",\"link\":\"/InterviewVue/17.v-if和v-for哪个优先级更高.html\"},{\"text\":\"18.生命周期有哪些\",\"link\":\"/InterviewVue/18.生命周期有哪些.html\"},{\"text\":\"19.Vue中diff算法原理\",\"link\":\"/InterviewVue/19.Vue中diff算法原理.html\"},{\"text\":\"20.请说明Vue中key的作用和原理\",\"link\":\"/InterviewVue/20.请说明Vue中key的作用和原理.html\"},{\"text\":\"21.Vue.use是干什么的\",\"link\":\"/InterviewVue/21.Vue.use是干什么的.html\"},{\"text\":\"22.Vue.extend方法的作用\",\"link\":\"/InterviewVue/22.Vue.extend方法的作用.html\"},{\"text\":\"23.Vue组件data为什么必须是一个函数\",\"link\":\"/InterviewVue/23.Vue组件data为什么必须是一个函数.html\"},{\"text\":\"24.函数组件的优势\",\"link\":\"/InterviewVue/24.函数组件的优势.html\"},{\"text\":\"25.Vue的过滤器了解吗？过滤器的使用场景\",\"link\":\"/InterviewVue/25.Vue的过滤器了解吗？过滤器的使用场景.html\"},{\"text\":\"26.v-once的使用场景有哪些\",\"link\":\"/InterviewVue/26.v-once的使用场景有哪些.html\"},{\"text\":\"27.Vue.mixin的原理和使用场景\",\"link\":\"/InterviewVue/27.Vue.mixin的原理和使用场景.html\"},{\"text\":\"28.Vue中的slot是怎样实现的？什么时候使用它\",\"link\":\"/InterviewVue/28.Vue中的slot是怎样实现的？什么时候使用它.html\"},{\"text\":\"29.说说你对双向绑定的理解，以及它的实现原理\",\"link\":\"/InterviewVue/29.说说你对双向绑定的理解，以及它的实现原理.html\"},{\"text\":\"30.Vue 中.sync修饰符的作用？\",\"link\":\"/InterviewVue/30.Vue 中.sync修饰符的作用？.html\"},{\"text\":\"31.Vue 中递归组件的理解\",\"link\":\"/InterviewVue/31.Vue 中递归组件的理解.html\"},{\"text\":\"32.组件中写 name 选项有哪些好处及作用\",\"link\":\"/InterviewVue/32.组件中写 name 选项有哪些好处及作用.html\"},{\"text\":\"33.Vue 常见的修饰符有哪些，有什么应用场景\",\"link\":\"/InterviewVue/33.Vue 常见的修饰符有哪些，有什么应用场景.html\"},{\"text\":\"34.Vue中异步组件的作用和原理\",\"link\":\"/InterviewVue/34.Vue中异步组件的作用和原理.html\"},{\"text\":\"35.说说你对 nextTick 的理解\",\"link\":\"/InterviewVue/35.说说你对 nextTick 的理解.html\"},{\"text\":\"36.keep-alive平时在哪里使用\",\"link\":\"/InterviewVue/36.keep-alive平时在哪里使用.html\"},{\"text\":\"37.自定义指令的应用场景\",\"link\":\"/InterviewVue/37.自定义指令的应用场景.html\"},{\"text\":\"38.Vue 中使用了哪些设计模式\",\"link\":\"/InterviewVue/38.Vue 中使用了哪些设计模式.html\"},{\"text\":\"39.Vue 中的性能优化有哪些\",\"link\":\"/InterviewVue/39.Vue 中的性能优化有哪些.html\"},{\"text\":\"40.单页应用首屏加载慢的怎么解决\",\"link\":\"/InterviewVue/40.单页应用首屏加载慢的怎么解决.html\"},{\"text\":\"41.Vue 项目中你是如何解决跨域的呢\",\"link\":\"/InterviewVue/41.Vue 项目中你是如何解决跨域的呢.html\"},{\"text\":\"42.Vue 项目中有封装过 axios 吗？主要是封装哪方面的？\",\"link\":\"/InterviewVue/42.Vue 项目中有封装过 axios 吗？主要是封装哪方面的？.html\"},{\"text\":\"43.Vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？\",\"link\":\"/InterviewVue/43.Vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？.html\"},{\"text\":\"44.Vue-Router 有几种钩子函数，具体是什么及执行流程是怎样的？\",\"link\":\"/InterviewVue/44.Vue-Router 有几种钩子函数，具体是什么及执行流程是怎样的？.html\"},{\"text\":\"45.Vue-Router 几种模式的区别\",\"link\":\"/InterviewVue/45.Vue-Router 几种模式的区别.html\"},{\"text\":\"46.Vue 项目本地开发完后部署到服务器后报 404 是什么原因呢\",\"link\":\"/InterviewVue/46.Vue 项目本地开发完后部署到服务器后报 404 是什么原因呢.html\"},{\"text\":\"47.谈谈你对 vuex 的个人理解\",\"link\":\"/InterviewVue/47.谈谈你对 vuex 的个人理解.html\"},{\"text\":\"48.如何监听 vuex 中数据的变化\",\"link\":\"/InterviewVue/48.如何监听 vuex 中数据的变化.html\"},{\"text\":\"49.页面刷新后 vuex 的数据丢失怎么解决\",\"link\":\"/InterviewVue/49.页面刷新后 vuex 的数据丢失怎么解决.html\"},{\"text\":\"50.mutation 和 action 的区别\",\"link\":\"/InterviewVue/50.mutation 和 action 的区别.html\"},{\"text\":\"51.有使用过 vuex 的 module 吗？在什么情况下会使用\",\"link\":\"/InterviewVue/51.有使用过 vuex 的 module 吗？在什么情况下会使用.html\"},{\"text\":\"52.Vue3中 CompositionAPI 的优势是？\",\"link\":\"/InterviewVue/52.Vue3中 CompositionAPI 的优势是？.html\"},{\"text\":\"53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？\",\"link\":\"/InterviewVue/53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？.html\"},{\"text\":\"54.Vue 项目中的错误如何处理的\",\"link\":\"/InterviewVue/54.Vue 项目中的错误如何处理的.html\"},{\"text\":\"55.Vue3 中模板编译优化\",\"link\":\"/InterviewVue/55.Vue3 中模板编译优化.html\"}]}],\"/JavaScript/\":[{\"items\":[{\"text\":\"第1章-什么是 JavaScript\",\"link\":\"/JavaScript/第1章-什么是 JavaScript.html\"},{\"text\":\"第2章-HTML 中的 JavaScript\",\"link\":\"/JavaScript/第2章-HTML 中的 JavaScript.html\"},{\"text\":\"第3章-语言基础\",\"link\":\"/JavaScript/第3章-语言基础.html\"}]}],\"/TypeScript/\":[{\"items\":[{\"text\":\"1.开篇：用正确的方式学习 TypeScript\",\"link\":\"/TypeScript/1.开篇：用正确的方式学习 TypeScript.html\"},{\"text\":\"10.结构化类型系统：类型兼容性判断的幕后\",\"link\":\"/TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html\"},{\"text\":\"11.类型系统层级：从 Top Type 到 Bottom Type\",\"link\":\"/TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html\"},{\"text\":\"12.类型里的逻辑运算：条件类型与 infer\",\"link\":\"/TypeScript/12.类型里的逻辑运算：条件类型与 infer.html\"},{\"text\":\"13.内置工具类型基础：别再妖魔化工具类型了！\",\"link\":\"/TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html\"},{\"text\":\"14.反方向类型推导：用好上下文相关类型\",\"link\":\"/TypeScript/14.反方向类型推导：用好上下文相关类型.html\"},{\"text\":\"15.数类型：协变与逆变的比较\",\"link\":\"/TypeScript/15.数类型：协变与逆变的比较.html\"},{\"text\":\"16.了解类型编程与类型体操的意义，找到平衡点\",\"link\":\"/TypeScript/16.了解类型编程与类型体操的意义，找到平衡点.html\"},{\"text\":\"17.内置工具类型进阶：类型编程进阶\",\"link\":\"/TypeScript/17.内置工具类型进阶：类型编程进阶.html\"},{\"text\":\"18.基础类型新成员：模板字符串类型入门\",\"link\":\"/TypeScript/18.基础类型新成员：模板字符串类型入门.html\"},{\"text\":\"19.类型编程新范式：模板字符串工具类型进阶\",\"link\":\"/TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html\"},{\"text\":\"2.工欲善其事：打造最舒适的 TypeScript 开发环境\",\"link\":\"/TypeScript/2.工欲善其事：打造最舒适的 TypeScript 开发环境.html\"},{\"text\":\"20.工程层面的类型能力：类型声明、类型指令与命名空间\",\"link\":\"/TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html\"},{\"text\":\"21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位\",\"link\":\"/TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html\"},{\"text\":\"22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍\",\"link\":\"/TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html\"},{\"text\":\"23.全链路 TypeScript 工具库，找到适合你的工具\",\"link\":\"/TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html\"},{\"text\":\"24.说说 TypeScript 和 ECMAScript 之间那些事儿\",\"link\":\"/TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html\"},{\"text\":\"25.装饰器与反射元数据：了解装饰器基本原理与应用\",\"link\":\"/TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html\"},{\"text\":\"26.控制反转与依赖注入：基于装饰器的依赖注入实现\",\"link\":\"/TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html\"},{\"text\":\"27.TSConfig 全解（上）：构建相关配置\",\"link\":\"/TypeScript/27.TSConfig 全解（上）：构建相关配置.html\"},{\"text\":\"28.TSConfig 全解（下）：检查相关、工程相关配置\",\"link\":\"/TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html\"},{\"text\":\"29.基于 Prisma + NestJs 的 Node API ：前置知识储备\",\"link\":\"/TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html\"},{\"text\":\"3.进入类型的世界：理解原始类型与对象类型\",\"link\":\"/TypeScript/3.进入类型的世界：理解原始类型与对象类型.html\"},{\"text\":\"30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署\",\"link\":\"/TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html\"},{\"text\":\"31.玩转 TypeScript AST：AST Checker 与 CodeMod\",\"link\":\"/TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html\"},{\"text\":\"32.感谢相伴：是结束，也是开始\",\"link\":\"/TypeScript/32.感谢相伴：是结束，也是开始.html\"},{\"text\":\"33.漫谈篇：面试中的 TypeScript\",\"link\":\"/TypeScript/33.漫谈篇：面试中的 TypeScript.html\"},{\"text\":\"4.掌握字面量类型与枚举，让你的类型再精确一些\",\"link\":\"/TypeScript/4.掌握字面量类型与枚举，让你的类型再精确一些.html\"},{\"text\":\"5.函数与 Class 中的类型：详解函数重载与面向对象\",\"link\":\"/TypeScript/5.函数与 Class 中的类型：详解函数重载与面向对象.html\"},{\"text\":\"6.探秘内置类型：any、unknown、never 与类型断言\",\"link\":\"/TypeScript/6.探秘内置类型：any、unknown、never 与类型断言.html\"},{\"text\":\"7.类型编程好帮手：TypeScript 类型工具（上）\",\"link\":\"/TypeScript/7.类型编程好帮手：TypeScript 类型工具（上）.html\"},{\"text\":\"8.类型编程好帮手：TypeScript 类型工具（下）\",\"link\":\"/TypeScript/8.类型编程好帮手：TypeScript 类型工具（下）.html\"},{\"text\":\"9.类型编程基石：TypeScript 中无处不在的泛型\",\"link\":\"/TypeScript/9.类型编程基石：TypeScript 中无处不在的泛型.html\"}]}],\"/Vue+TS/\":[{\"items\":[{\"text\":\"TS 扩展路由meta\",\"link\":\"/Vue+TS/TS 扩展路由meta.html\"}]}],\"/Vue插件/\":[{\"items\":[{\"text\":\"CDN 引入\",\"link\":\"/Vue插件/CDN 引入.html\"},{\"text\":\"Pinia 缓存持久化\",\"link\":\"/Vue插件/Pinia 缓存持久化.html\"},{\"text\":\"批量导入svg\",\"link\":\"/Vue插件/批量导入svg.html\"}]}],\"/basic/\":[{\"items\":[{\"text\":\"JavaScript 核心原理精讲\",\"link\":\"/basic/JavaScript 核心原理精讲.html\"},{\"text\":\"css\",\"link\":\"/basic/css.html\"},{\"text\":\"git\",\"link\":\"/basic/git.html\"},{\"text\":\"html\",\"link\":\"/basic/html.html\"},{\"text\":\"iOS 兼容问题\",\"link\":\"/basic/iOS 兼容问题.html\"},{\"text\":\"js\",\"link\":\"/basic/js.html\"},{\"text\":\"ts\",\"link\":\"/basic/ts.html\"},{\"text\":\"vue\",\"link\":\"/basic/vue.html\"},{\"text\":\"webpack\",\"link\":\"/basic/webpack.html\"}]}],\"/examples/\":[{\"items\":[{\"text\":\"api-examples\",\"link\":\"/examples/api-examples.html\"},{\"text\":\"markdown-examples\",\"link\":\"/examples/markdown-examples.html\"}]}],\"/harmonyOS/\":[{\"items\":[{\"text\":\"入门\",\"link\":\"/harmonyOS/入门.html\"}]}],\"/node/\":[{\"items\":[{\"text\":\"1.如何理解node中模块的概念\",\"link\":\"/node/1.如何理解node中模块的概念.html\"}]}],\"/vue-challenge/\":[{\"items\":[{\"text\":\"CSS Features\",\"link\":\"/vue-challenge/CSS Features.html\"},{\"text\":\"Components\",\"link\":\"/vue-challenge/Components.html\"},{\"text\":\"Composable Function\",\"link\":\"/vue-challenge/Composable Function.html\"},{\"text\":\"Composition API\",\"link\":\"/vue-challenge/Composition API.html\"},{\"text\":\"Directives\",\"link\":\"/vue-challenge/Directives.html\"},{\"text\":\"Event Handling\",\"link\":\"/vue-challenge/Event Handling.html\"},{\"text\":\"Global APT General\",\"link\":\"/vue-challenge/Global APT General.html\"},{\"text\":\"LifeCycle\",\"link\":\"/vue-challenge/LifeCycle.html\"},{\"text\":\"Reactivity Advanced\",\"link\":\"/vue-challenge/Reactivity Advanced.html\"},{\"text\":\"Unility Function\",\"link\":\"/vue-challenge/Unility Function.html\"},{\"text\":\"Web Component\",\"link\":\"/vue-challenge/Web Component.html\"}]}],\"/vue教程/\":[{\"items\":[{\"text\":\"Vue3核心语法\",\"items\":[{\"text\":\"setup语法糖\",\"link\":\"/vue教程/Vue3核心语法/setup语法糖.html\"}],\"collapsed\":false},{\"text\":\"index\",\"link\":\"/vue教程/index.html\"}]}]}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>