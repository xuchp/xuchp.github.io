import{_ as e,c as a,o as t,a7 as _}from"./chunks/framework.DIkKG9z6.js";const f=JSON.parse('{"title":"7. Vue 中如何检测数组变化","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/07.Vue中如何检测数组变化.md","filePath":"InterviewVue/07.Vue中如何检测数组变化.md"}'),r={name:"InterviewVue/07.Vue中如何检测数组变化.md"},o=_('<h1 id="_7-vue-中如何检测数组变化" tabindex="-1">7. Vue 中如何检测数组变化 <a class="header-anchor" href="#_7-vue-中如何检测数组变化" aria-label="Permalink to &quot;7. Vue 中如何检测数组变化&quot;">​</a></h1><h3 id="_1-1-实现数组劫持" tabindex="-1">1.1 实现数组劫持 <a class="header-anchor" href="#_1-1-实现数组劫持" aria-label="Permalink to &quot;1.1 实现数组劫持&quot;">​</a></h3><ul><li>数组考虑性能的原因没有用<code>defineProperty</code>对数组的每一项进行拦截，而是选择重写数组(<code>push、shift、pop、splice、unshift、sort、reverse</code>)方法</li><li>数组中如果是对象数据类型也会进行递归劫持</li></ul><h3 id="_1-2-数组的缺点" tabindex="-1">1.2 数组的缺点 <a class="header-anchor" href="#_1-2-数组的缺点" aria-label="Permalink to &quot;1.2 数组的缺点&quot;">​</a></h3><ul><li>数组的索引和长度变化是无法监控的</li></ul>',5),i=[o];function s(l,n,c,u,d,h){return t(),a("div",null,i)}const V=e(r,[["render",s]]);export{f as __pageData,V as default};
