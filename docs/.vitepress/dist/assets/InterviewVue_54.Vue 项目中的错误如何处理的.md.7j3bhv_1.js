import{_ as s,c as i,o as a,a7 as e}from"./chunks/framework.DIkKG9z6.js";const c=JSON.parse('{"title":"54. Vue 项目中的错误如何处理的","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/54.Vue 项目中的错误如何处理的.md","filePath":"InterviewVue/54.Vue 项目中的错误如何处理的.md"}'),n={name:"InterviewVue/54.Vue 项目中的错误如何处理的.md"},t=e(`<h1 id="_54-vue-项目中的错误如何处理的" tabindex="-1">54. Vue 项目中的错误如何处理的 <a class="header-anchor" href="#_54-vue-项目中的错误如何处理的" aria-label="Permalink to &quot;54. Vue 项目中的错误如何处理的&quot;">​</a></h1><h3 id="_1-1-errorcapture-钩子" tabindex="-1">1.1 errorCapture 钩子 <a class="header-anchor" href="#_1-1-errorcapture-钩子" aria-label="Permalink to &quot;1.1 errorCapture 钩子&quot;">​</a></h3><p>可以捕获来自后代组件的错误，如果全局的 config.errorHandler 被定义，所有的错误仍会发送给它，因此这些错误仍然会向单一的分析服务的地方进行汇报</p><blockquote><p>父组件(errorCapture) -&gt; 子组件(errorCapture) -&gt; 孙子组件出错时，错误会一直向上抛。如果 errorCapture 中返回 false 则会阻断传播</p></blockquote><h3 id="_1-2-全局设置错误处理" tabindex="-1">1.2 全局设置错误处理 <a class="header-anchor" href="#_1-2-全局设置错误处理" aria-label="Permalink to &quot;1.2 全局设置错误处理&quot;">​</a></h3><p>如果在组件渲染时出现运行错误，错误将会被传递至全局 Vue.config.errorHandler 配置函数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(err, vm, info)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_1-3-接口异常处理" tabindex="-1">1.3 接口异常处理 <a class="header-anchor" href="#_1-3-接口异常处理" aria-label="Permalink to &quot;1.3 接口异常处理&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance.interceptors.response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> err.response</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (res.status </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 400</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            handleqerror</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(response) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 统一处理异常接口</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span></code></pre></div><blockquote><p>收集到错误后，提交到前端监控系统中，这样我们可以分析前端代码的异常信息</p></blockquote>`,10),h=[t];function l(p,k,r,E,d,o){return a(),i("div",null,h)}const y=s(n,[["render",l]]);export{c as __pageData,y as default};
