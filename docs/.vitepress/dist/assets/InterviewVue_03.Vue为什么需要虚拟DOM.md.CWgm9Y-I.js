import{_ as e,c as a,o as i,a7 as t}from"./chunks/framework.BvW0rtPM.js";const M=JSON.parse('{"title":"3.Vue为什么需要虚拟DOM.md","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/03.Vue为什么需要虚拟DOM.md","filePath":"InterviewVue/03.Vue为什么需要虚拟DOM.md"}'),l={name:"InterviewVue/03.Vue为什么需要虚拟DOM.md"},o=t('<h1 id="_3-vue为什么需要虚拟dom-md" tabindex="-1">3.Vue为什么需要虚拟DOM.md <a class="header-anchor" href="#_3-vue为什么需要虚拟dom-md" aria-label="Permalink to &quot;3.Vue为什么需要虚拟DOM.md&quot;">​</a></h1><h3 id="_1-1-基本概念" tabindex="-1">1.1 基本概念 <a class="header-anchor" href="#_1-1-基本概念" aria-label="Permalink to &quot;1.1 基本概念&quot;">​</a></h3><blockquote><p>基本所有框架都引入了虚拟 DOM 来对真实的 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM</p></blockquote><ul><li>Virtual DOM 就是用 js 对象来描述真实 DOM，是对真实 DOM 的抽象，由于直接操作DOM 性能低但是 js 层的操作效率高，可以将 DOM 操作转化成对象操作，最终通过 diff 算法比对差异进行更新 DOM(减少了对真实 DOM 的操作)</li><li>虚拟 DOM 不依赖真实平台环境从而也可以实现跨平台</li></ul><h3 id="_1-2补充-vdom-是如何生成的" tabindex="-1">1.2补充：VDOM 是如何生成的 <a class="header-anchor" href="#_1-2补充-vdom-是如何生成的" aria-label="Permalink to &quot;1.2补充：VDOM 是如何生成的&quot;">​</a></h3><ul><li>在 vue 中我们常常回味组件编写模板- template</li><li>这个模板会被编译器编译为渲染函数 - Render</li><li>在接下来的挂载过程中会调用 render 函数，返回的对象就是虚拟 DOM</li><li>会在后续的 patch 过程中进一步转化为真实 DOM</li></ul><h3 id="_1-3-再次补充-vdom-如何做-diff" tabindex="-1">1.3 再次补充：VDOM 如何做 diff <a class="header-anchor" href="#_1-3-再次补充-vdom-如何做-diff" aria-label="Permalink to &quot;1.3 再次补充：VDOM 如何做 diff&quot;">​</a></h3><ul><li>挂载过程结束后，会记录第一次生成的 VDOM - oldVNode</li><li>当响应式数据发生变化时，将会引起组件刷新 render，此时就会生成新的 VDOM - newVNode</li><li>使用 oldVNode 和 newVNode 做 diff 操作，将更改的部分应到真实 DOM 上，从而转化为最小量的 DOM 操作，高效更新视图。</li></ul>',8),d=[o];function r(_,n,u,s,c,D){return i(),a("div",null,d)}const h=e(l,[["render",r]]);export{M as __pageData,h as default};
