import{_ as a,c as s,o as e,a7 as n}from"./chunks/framework.BvW0rtPM.js";const g=JSON.parse('{"title":"一、Vue2 篇","description":"","frontmatter":{},"headers":[],"relativePath":"basic/vue.md","filePath":"basic/vue.md"}'),t={name:"basic/vue.md"},i=n(`<h1 id="一、vue2-篇" tabindex="-1">一、Vue2 篇 <a class="header-anchor" href="#一、vue2-篇" aria-label="Permalink to &quot;一、Vue2 篇&quot;">​</a></h1><h2 id="_1-关于生命周期" tabindex="-1">1. 关于生命周期 <a class="header-anchor" href="#_1-关于生命周期" aria-label="Permalink to &quot;1. 关于生命周期&quot;">​</a></h2><h4 id="_1-1-生命周期有哪些-发送请求在-created-还是-mounted" tabindex="-1">1.1 生命周期有哪些？发送请求在 created 还是 mounted ？ <a class="header-anchor" href="#_1-1-生命周期有哪些-发送请求在-created-还是-mounted" aria-label="Permalink to &quot;1.1 生命周期有哪些？发送请求在 created 还是 mounted ？&quot;">​</a></h4><p>Vue2.x 系统自带有8个</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeCreated</span></span>
<span class="line"><span>created</span></span>
<span class="line"><span>beforeMount</span></span>
<span class="line"><span>mounted</span></span>
<span class="line"><span>beforeUpdate</span></span>
<span class="line"><span>updated</span></span>
<span class="line"><span>beforeDestroy</span></span>
<span class="line"><span>destoryed</span></span></code></pre></div><p>发送请求在 created 还是 mounted ？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>这个问题具体要看项目和业务的情况了,因为组件的加载顺序是,父组件引入了子组件,那么先执行父的前 3 个生命周期,再执行子组件的 4 个生命周期,那么我们的业务是父组件引入子组件,并且优先加载子组件的数据,那么在父组件中的请求要放 mounted 中,如果当前组件没有依赖关系,那么放在那个生命周期中请求都是可以的.</span></span></code></pre></div><h4 id="_1-2-为什么发送请求不在-beforecreate-里-beforecreate-和-created-有什么区别" tabindex="-1">1.2 为什么发送请求不在 beforeCreate 里？beforeCreate 和 created 有什么区别？ <a class="header-anchor" href="#_1-2-为什么发送请求不在-beforecreate-里-beforecreate-和-created-有什么区别" aria-label="Permalink to &quot;1.2 为什么发送请求不在 beforeCreate 里？beforeCreate 和 created 有什么区别？&quot;">​</a></h4><p>为什么发送请求不在 beforeCreate 里</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>因为:如果请求是在 methods 中封装好的,在 beforeCreate 调用的时候, beforeCreate 阶段是拿不到 methods 里面的方法的(会报错了).</span></span></code></pre></div><p>beforeCreate 和 created 有什么区别？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeCreate 中没有$data</span></span>
<span class="line"><span>created 中有$data</span></span>
<span class="line"><span></span></span>
<span class="line"><span>created 中可以拿到 methods 的方法的</span></span>
<span class="line"><span>beforeCreate 拿不到 methods 方法</span></span></code></pre></div><h4 id="_1-3-在created-中如何获取-dom" tabindex="-1">1.3 在created 中如何获取 dom <a class="header-anchor" href="#_1-3-在created-中如何获取-dom" aria-label="Permalink to &quot;1.3 在created 中如何获取 dom&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 只要写异步代码，获取 dom 是在异步中获取的，就可以了</span></span>
<span class="line"><span>   例如 setTimeout(),请求,Promise.xxx()等等...</span></span>
<span class="line"><span>2. 使用 Vue 系统内置的 this.$nextTick()</span></span></code></pre></div><h4 id="_1-4一旦进入组件会执行哪些生命周期" tabindex="-1">1.4一旦进入组件会执行哪些生命周期？ <a class="header-anchor" href="#_1-4一旦进入组件会执行哪些生命周期" aria-label="Permalink to &quot;1.4一旦进入组件会执行哪些生命周期？&quot;">​</a></h4><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeCreated</span></span>
<span class="line"><span>created</span></span>
<span class="line"><span>beforeMount</span></span>
<span class="line"><span>mounted</span></span></code></pre></div><h4 id="_1-5-第二次或者第-n-次进入组件会执行哪些生命周期" tabindex="-1">1.5 第二次或者第 N 次进入组件会执行哪些生命周期？ <a class="header-anchor" href="#_1-5-第二次或者第-n-次进入组件会执行哪些生命周期" aria-label="Permalink to &quot;1.5 第二次或者第 N 次进入组件会执行哪些生命周期？&quot;">​</a></h4><p>如果当前组件加入了 keep-alive,只会执行一个生命周期</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>activated</span></span></code></pre></div><p>如果没有加入 keep-alive</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeCreated</span></span>
<span class="line"><span>created</span></span>
<span class="line"><span>beforeMount</span></span>
<span class="line"><span>mounted</span></span></code></pre></div><h4 id="_1-6-父组件引入子组件-那么生命周期执行的顺序是" tabindex="-1">1.6 父组件引入子组件，那么生命周期执行的顺序是？ <a class="header-anchor" href="#_1-6-父组件引入子组件-那么生命周期执行的顺序是" aria-label="Permalink to &quot;1.6 父组件引入子组件，那么生命周期执行的顺序是？&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>父：beforeCreated、created、beforeMount</span></span>
<span class="line"><span>子：beforeCreated、created、beforeMount、mounted</span></span>
<span class="line"><span>父：mounted</span></span></code></pre></div><h4 id="_1-7-加入-keep-alive-会执行哪些生命周期" tabindex="-1">1.7 加入 keep-alive 会执行哪些生命周期 <a class="header-anchor" href="#_1-7-加入-keep-alive-会执行哪些生命周期" aria-label="Permalink to &quot;1.7 加入 keep-alive 会执行哪些生命周期&quot;">​</a></h4><p>如果使用了 keep-alive 组件,当前的组件会额外新增 2 个生命周期(系统 8+ 2)</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>activated</span></span>
<span class="line"><span>deactivated</span></span></code></pre></div><p>如果当前组价加入了 keep-alive,第一次进入这个组件会执行 5 个生命周期</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeCreated</span></span>
<span class="line"><span>created</span></span>
<span class="line"><span>beforeMount</span></span>
<span class="line"><span>mounted</span></span>
<span class="line"><span>activated</span></span></code></pre></div><h4 id="_1-8-你在什么情况下用过哪些生命周期-说一说生命周期的使用场景" tabindex="-1">1.8 你在什么情况下用过哪些生命周期？说一说生命周期的使用场景 <a class="header-anchor" href="#_1-8-你在什么情况下用过哪些生命周期-说一说生命周期的使用场景" aria-label="Permalink to &quot;1.8 你在什么情况下用过哪些生命周期？说一说生命周期的使用场景&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>created		===&gt; 单组件请求</span></span>
<span class="line"><span>mounted		===&gt; 同步可以获取 dom,如果子组件请求后父组件请求</span></span>
<span class="line"><span>activated	===&gt; 判断 id 是否相等,如果不相同发起请求</span></span>
<span class="line"><span>destroyed	===&gt; 关闭页面,记录视频播放的时间,初始化的时候从上一次的历史开始播放</span></span></code></pre></div><h2 id="_2-关于组件" tabindex="-1">2.关于组件 <a class="header-anchor" href="#_2-关于组件" aria-label="Permalink to &quot;2.关于组件&quot;">​</a></h2><h4 id="_2-1-组件传值-通信-的方式" tabindex="-1">2.1 组件传值(通信)的方式 <a class="header-anchor" href="#_2-1-组件传值-通信-的方式" aria-label="Permalink to &quot;2.1 组件传值(通信)的方式&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>父传后代(后代拿到了父的数据)</span></span>
<span class="line"><span>1. 父组件引入子组件,绑定数据 </span></span>
<span class="line"><span>			&lt;List :str1=&quot;str1&quot;&gt;&lt;/List&gt;</span></span>
<span class="line"><span>		子组件通过 props 来接收</span></span>
<span class="line"><span>      props:{</span></span>
<span class="line"><span>        str1:{</span></span>
<span class="line"><span>          type:String,</span></span>
<span class="line"><span>          default:&#39;&#39;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>  ***这种方式: 父传子很方便,但是父传给孙子辈分的组件很麻烦(父-&gt;子,子-&gt;孙子)</span></span>
<span class="line"><span>  这种方式: 子组件不能直接修改父组件的数据</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>2. 	子组件直接使用父组件的数据</span></span>
<span class="line"><span>子组件通过: this.$parent.xxx 使用父组件的数据</span></span>
<span class="line"><span>这种方式: 子组件可以直接修改父组件的数据</span></span>
<span class="line"><span>3. 依赖注入</span></span>
<span class="line"><span>    父组件</span></span>
<span class="line"><span>    &lt;script&gt;</span></span>
<span class="line"><span>      provide(){</span></span>
<span class="line"><span>        return {</span></span>
<span class="line"><span>          val1:&#39;这是父组件的依赖&#39;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>    &lt;/scirpt&gt;</span></span>
<span class="line"><span>    后代组件:</span></span>
<span class="line"><span>    &lt;script&gt;</span></span>
<span class="line"><span>      inject:[&#39;val1&#39;]</span></span>
<span class="line"><span>    &lt;script&gt;</span></span>
<span class="line"><span>优势:父组件可以直接向某个后代组件传值(不用一级一级传递)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>后代传父(父拿到了后代的数据)</span></span>
<span class="line"><span>1. 子组件传值给父组件</span></span>
<span class="line"><span>	子组件定义自定义事件 this.$emit</span></span>
<span class="line"><span>2. 父组件直接拿到子组件的数据</span></span>
<span class="line"><span>	&lt;List ref=&quot;child&quot;&gt;&lt;/List&gt;</span></span>
<span class="line"><span>	this.$refs.child.xxx</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>平辈之间的传值(兄弟可以拿到数据)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>通过新建 bus.js 文件来做</span></span></code></pre></div><p>bus.js</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><h4 id="_2-2-父组件如何直接修改子组件的值" tabindex="-1">2.2 父组件如何直接修改子组件的值 <a class="header-anchor" href="#_2-2-父组件如何直接修改子组件的值" aria-label="Permalink to &quot;2.2 父组件如何直接修改子组件的值&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;List ref=&quot;child&quot;&gt;&lt;/List&gt;</span></span>
<span class="line"><span>	this.$refs.child.xxx = &#39;xxxxxx&#39;;</span></span></code></pre></div><h4 id="_2-3-子组件如何直接修改父组件的值" tabindex="-1">2.3 子组件如何直接修改父组件的值 <a class="header-anchor" href="#_2-3-子组件如何直接修改父组件的值" aria-label="Permalink to &quot;2.3 子组件如何直接修改父组件的值&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>子组件中可以使用:this.$parent.xxx去修改</span></span></code></pre></div><h4 id="_2-4-如何找到父组件" tabindex="-1">2.4 如何找到父组件 <a class="header-anchor" href="#_2-4-如何找到父组件" aria-label="Permalink to &quot;2.4 如何找到父组件&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$parent</span></span></code></pre></div><h4 id="_2-5-如何找到根组件" tabindex="-1">2.5 如何找到根组件 <a class="header-anchor" href="#_2-5-如何找到根组件" aria-label="Permalink to &quot;2.5 如何找到根组件&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$root</span></span></code></pre></div><h4 id="_2-6-keep-alive" tabindex="-1">2.6 keep-alive <a class="header-anchor" href="#_2-6-keep-alive" aria-label="Permalink to &quot;2.6 keep-alive&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>keep-alive 是什么: 缓存当前组件的</span></span></code></pre></div><h4 id="_2-7-插槽slot" tabindex="-1">2.7 插槽slot <a class="header-anchor" href="#_2-7-插槽slot" aria-label="Permalink to &quot;2.7 插槽slot&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>匿名插槽: 没有名字的插槽</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>具名插槽: 有名字的插槽</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>作用域插槽: 传值,传递类似于父组件向子组件传值,接收需要解构</span></span></code></pre></div><h4 id="_2-8-provide-inject" tabindex="-1">2.8 provide/inject <a class="header-anchor" href="#_2-8-provide-inject" aria-label="Permalink to &quot;2.8 provide/inject&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>provide/inject ===&gt; 依赖注入,用于向后代组件传值</span></span></code></pre></div><h4 id="_2-9-如何封装组件" tabindex="-1">2.9 如何封装组件 <a class="header-anchor" href="#_2-9-如何封装组件" aria-label="Permalink to &quot;2.9 如何封装组件&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>组件一定要难点,涉及到的知识点:slot,组件通信...</span></span></code></pre></div><h2 id="_3-关于vuex" tabindex="-1">3. 关于Vuex <a class="header-anchor" href="#_3-关于vuex" aria-label="Permalink to &quot;3. 关于Vuex&quot;">​</a></h2><h4 id="_3-1-vuex-有哪些属性" tabindex="-1">3.1 Vuex 有哪些属性 <a class="header-anchor" href="#_3-1-vuex-有哪些属性" aria-label="Permalink to &quot;3.1 Vuex 有哪些属性&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>state: 		==&gt;	定义全局共享属性</span></span>
<span class="line"><span>getters: 	==&gt;	针对 state 数据进行二次计算</span></span>
<span class="line"><span>mutations:==&gt;	存放同步的方法</span></span>
<span class="line"><span>actions: 	==&gt;	存放异步方法的,并且是用来提交 mutations</span></span>
<span class="line"><span>modules: 	==&gt;	把 vuex 再次进行模块之间的划分</span></span></code></pre></div><h4 id="_3-2-vuex-使用-state-值" tabindex="-1">3.2 Vuex 使用 state 值 <a class="header-anchor" href="#_3-2-vuex-使用-state-值" aria-label="Permalink to &quot;3.2 Vuex 使用 state 值&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$store.state.xxx</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>辅助函数: mapState</span></span></code></pre></div><p>以上两种方式都也可以拿到 state 的值, 那么区别是什么?</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>使用 this.$store.state.xxx 时可以直接修改 vuex 的 state 数据的</span></span>
<span class="line"><span>使用辅助函数的形式, 是不可以修改的</span></span></code></pre></div><h4 id="_3-3-vuex-的-getters-值修改" tabindex="-1">3.3 Vuex 的 getters 值修改 <a class="header-anchor" href="#_3-3-vuex-的-getters-值修改" aria-label="Permalink to &quot;3.3 Vuex 的 getters 值修改&quot;">​</a></h4><p>面试官可能会这样问:组件中使用了 getters 中的内容, 组件是采用 v-model 的形式会发生什么?</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>getters 是不可以修改的</span></span></code></pre></div><h4 id="_3-4-vuex-的-mutations-和-actions-区别" tabindex="-1">3.4 Vuex 的 mutations 和 actions 区别 <a class="header-anchor" href="#_3-4-vuex-的-mutations-和-actions-区别" aria-label="Permalink to &quot;3.4 Vuex 的 mutations 和 actions 区别&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>相同点:	mutations 和 actions 都是用来存放全局方法的,这个全局方法 return的值拿不到</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>区别:	 </span></span>
<span class="line"><span>	mutations	==&gt;	同步</span></span>
<span class="line"><span>	actions		===&gt;异步的,返回的是一个 Promise 对象,他可以执行相关的异步操作</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mutations 是来修改 state 的值的,actions 的作用是来提交 mutations 的</span></span></code></pre></div><h4 id="_3-5-vuex-持久化存储" tabindex="-1">3.5 Vuex 持久化存储 <a class="header-anchor" href="#_3-5-vuex-持久化存储" aria-label="Permalink to &quot;3.5 Vuex 持久化存储&quot;">​</a></h4><p>在页面中使用 state 的值:1, 然后把 1 修改成 2, 然后刷新页面又回到了 1, 为什么?</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vuex 本身不是持久化存储数据的. Vuex是一个状态管理仓库(state:全局属性)==&gt; 就是存放全局属性的地方</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>实现持久化存储: 1. 自己写 localStorage 2. 使用 vuex-persistedstate 插件</span></span></code></pre></div><h2 id="_4-关于路由" tabindex="-1">4. 关于路由 <a class="header-anchor" href="#_4-关于路由" aria-label="Permalink to &quot;4. 关于路由&quot;">​</a></h2><h4 id="_4-1-路由的模式和区别" tabindex="-1">4.1 路由的模式和区别 <a class="header-anchor" href="#_4-1-路由的模式和区别" aria-label="Permalink to &quot;4.1 路由的模式和区别&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> 路由模式:history,hash</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>区别: </span></span>
<span class="line"><span>1. 关于找不到当前页面发送请求的问题</span></span>
<span class="line"><span>	history 会给后端发送一次请求而 hash 不会</span></span>
<span class="line"><span>2. 关于项目打包前端自测问题</span></span>
<span class="line"><span>	hash 是可以看到内容的</span></span>
<span class="line"><span>	history 默认情况下看不到内容</span></span>
<span class="line"><span>3. 关于表象不同</span></span>
<span class="line"><span>	hash:#</span></span>
<span class="line"><span>	history:/</span></span></code></pre></div><h4 id="_4-2-子路由和动态路由" tabindex="-1">4.2 子路由和动态路由 <a class="header-anchor" href="#_4-2-子路由和动态路由" aria-label="Permalink to &quot;4.2 子路由和动态路由&quot;">​</a></h4><h4 id="_4-3-路由传值" tabindex="-1">4.3 路由传值 <a class="header-anchor" href="#_4-3-路由传值" aria-label="Permalink to &quot;4.3 路由传值&quot;">​</a></h4><h4 id="_4-4-导航故障" tabindex="-1">4.4 导航故障 <a class="header-anchor" href="#_4-4-导航故障" aria-label="Permalink to &quot;4.4 导航故障&quot;">​</a></h4><p>同页面跳转出现</p><p>解决:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> VueRouter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue-router&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> routerPush</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.push</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">location</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> routerPush.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, location).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">error</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">error)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_4-5-router-和-route-的区别" tabindex="-1">4.5 $router 和$route 的区别 <a class="header-anchor" href="#_4-5-router-和-route-的区别" aria-label="Permalink to &quot;4.5 $router 和$route 的区别&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$router:不仅包含当前路由, 还包含整个路由的属性和方法</span></span>
<span class="line"><span>$route:包含当前路由对象</span></span></code></pre></div><h4 id="_4-6-导航守卫" tabindex="-1">4.6 导航守卫 <a class="header-anchor" href="#_4-6-导航守卫" aria-label="Permalink to &quot;4.6 导航守卫&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 全局守卫</span></span>
<span class="line"><span>	beforeEach:路由进入之前</span></span>
<span class="line"><span>	afterEach: 路由进入之后</span></span>
<span class="line"><span>2. 路由独享守卫</span></span>
<span class="line"><span>	beforeEnter:路由进入之前</span></span>
<span class="line"><span>3. 组件内守卫</span></span>
<span class="line"><span>	beforeRouteEnter:路由进入之前</span></span>
<span class="line"><span>	beforeRouteUpdate:路由更新之前</span></span>
<span class="line"><span>	beforeRouteLeave:路由离开之前</span></span></code></pre></div><h2 id="_5-关于-api" tabindex="-1">5.关于 API <a class="header-anchor" href="#_5-关于-api" aria-label="Permalink to &quot;5.关于 API&quot;">​</a></h2><h4 id="_5-1-set" tabindex="-1">5.1 $set <a class="header-anchor" href="#_5-1-set" aria-label="Permalink to &quot;5.1 $set&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>面试官:你有没有碰到过,数据更新试图没有更新的问题===&gt;$set</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>this.$set(target, key,  修改后的值)</span></span></code></pre></div><h4 id="_5-2-nexttick" tabindex="-1">5.2 $nextTick <a class="header-anchor" href="#_5-2-nexttick" aria-label="Permalink to &quot;5.2 $nextTick&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$nextTick 返回的参数[函数], 是一个异步的。功能: 获取更新后的 dom</span></span></code></pre></div><h4 id="_5-3-refs" tabindex="-1">5.3 $refs <a class="header-anchor" href="#_5-3-refs" aria-label="Permalink to &quot;5.3 $refs&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>来获取 dom 的</span></span></code></pre></div><h4 id="_5-4-el" tabindex="-1">5.4 $el <a class="header-anchor" href="#_5-4-el" aria-label="Permalink to &quot;5.4 $el&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$el: 获取当前组件的根节点</span></span></code></pre></div><h4 id="_5-5-data" tabindex="-1">5.5 $data <a class="header-anchor" href="#_5-5-data" aria-label="Permalink to &quot;5.5 $data&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$data: 获取当前组件 data 的数据</span></span></code></pre></div><h4 id="_5-6-children" tabindex="-1">5.6 $children <a class="header-anchor" href="#_5-6-children" aria-label="Permalink to &quot;5.6 $children&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$children: 是获取当前组件的所有子组件的</span></span></code></pre></div><h4 id="_5-7-parent" tabindex="-1">5.7 $parent <a class="header-anchor" href="#_5-7-parent" aria-label="Permalink to &quot;5.7 $parent&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>找到当前组件的父组件,如果找不到返回自身</span></span></code></pre></div><h4 id="_5-8-root" tabindex="-1">5.8 $root <a class="header-anchor" href="#_5-8-root" aria-label="Permalink to &quot;5.8 $root&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>找到根组件</span></span></code></pre></div><h4 id="_5-9-data-自定义数据" tabindex="-1">5.9 data 自定义数据 <a class="header-anchor" href="#_5-9-data-自定义数据" aria-label="Permalink to &quot;5.9 data 自定义数据&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>数据定义在 data 的 return 内和 return 外的区别:</span></span>
<span class="line"><span>1. return 外: 单纯修改这个数据是不可以修改的,因为没有 set 和 get</span></span>
<span class="line"><span>2. return 内: 是可以修改的</span></span></code></pre></div><h4 id="_5-10-computed-计算属性" tabindex="-1">5.10 computed 计算属性 <a class="header-anchor" href="#_5-10-computed-计算属性" aria-label="Permalink to &quot;5.10 computed 计算属性&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>computed 计算属性的结果值, 可以修改吗? 可以的,需要通过 get/set 写法</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>当前组件 v-model 绑定的值是 computed 来的,可以修改吗? 可以的, 需要通过 get/set 写法</span></span></code></pre></div><h4 id="_5-11-watch" tabindex="-1">5.11 watch <a class="header-anchor" href="#_5-11-watch" aria-label="Permalink to &quot;5.11 watch&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span></code></pre></div><h4 id="_5-12-methods-和-computed-区别" tabindex="-1">5.12 methods 和 computed 区别 <a class="header-anchor" href="#_5-12-methods-和-computed-区别" aria-label="Permalink to &quot;5.12 methods 和 computed 区别&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>computed 是有缓存机制的, methods是没有缓存机制的(调用几次执行几次)</span></span></code></pre></div><h2 id="_6-关于指令" tabindex="-1">6. 关于指令 <a class="header-anchor" href="#_6-关于指令" aria-label="Permalink to &quot;6. 关于指令&quot;">​</a></h2><h4 id="_6-1-如何自定义指令" tabindex="-1">6.1 如何自定义指令 <a class="header-anchor" href="#_6-1-如何自定义指令" aria-label="Permalink to &quot;6.1 如何自定义指令&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>全局指令:  main.js</span></span>
<span class="line"><span>Vue.directive(&#39;demo&#39;,{</span></span>
<span class="line"><span>	inserted: function(a, b, c){</span></span>
<span class="line"><span>		console.log(a, b, c)</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>})</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>局部指令: 某一个组件内</span></span>
<span class="line"><span>&lt;script&gt;</span></span>
<span class="line"><span>export default {</span></span>
<span class="line"><span>	directives: {</span></span>
<span class="line"><span>		demo: {</span></span>
<span class="line"><span>			bind: function (el) {</span></span>
<span class="line"><span>				console.log(el,1)</span></span>
<span class="line"><span>			}</span></span>
<span class="line"><span>		}</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre></div><h4 id="_6-2-vue-单向绑定" tabindex="-1">6.2 vue 单向绑定 <a class="header-anchor" href="#_6-2-vue-单向绑定" aria-label="Permalink to &quot;6.2 vue 单向绑定&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>双向绑定: v-model</span></span>
<span class="line"><span>单向绑定: v-bind</span></span></code></pre></div><h4 id="_6-3-v-if-和-v-for-的优先级" tabindex="-1">6.3 v-if 和 v-for 的优先级 <a class="header-anchor" href="#_6-3-v-if-和-v-for-的优先级" aria-label="Permalink to &quot;6.3 v-if 和 v-for 的优先级&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>vue2 中, v-for 的优先级大于 v-if</span></span>
<span class="line"><span>Vue3 中, v-if 的优先级大于 v-for</span></span></code></pre></div><h2 id="_7-关于原理" tabindex="-1">7. 关于原理 <a class="header-anchor" href="#_7-关于原理" aria-label="Permalink to &quot;7. 关于原理&quot;">​</a></h2><h4 id="_7-1-nexttick-原理" tabindex="-1">7.1 $nextTick 原理 <a class="header-anchor" href="#_7-1-nexttick-原理" aria-label="Permalink to &quot;7.1 $nextTick 原理&quot;">​</a></h4><p>微任务:Promise.then setImmediate MutationObserver</p><p>宏任务:setTimeout</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>$nextTick(callback){</span></span>
<span class="line"><span>	return new Promise.resolve().then(callback())</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="_7-2" tabindex="-1">7.2 <a class="header-anchor" href="#_7-2" aria-label="Permalink to &quot;7.2&quot;">​</a></h4>`,127),p=[i];function l(o,c,d,h,r,u){return e(),s("div",null,p)}const k=a(t,[["render",l]]);export{g as __pageData,k as default};
