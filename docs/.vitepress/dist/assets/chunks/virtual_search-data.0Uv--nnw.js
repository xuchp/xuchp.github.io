const e={map:'[{"语言基础":["0.0","58.0"],"语法":["0.1","58.1"],"区分大小写":["0.2","58.2"],"标识符":["0.3","58.3"],"注释":["0.4","58.4"],"严格模式":["0.5","58.5"],"关键字和保留字":["0.6","58.6"],"关键字":["0.7","58.7"],"保留字":["0.8","58.8"],"始终保留":["0.9","58.9"],"严格模式下保留":["0.10","58.10"],"模块代码中保留":["0.11","58.11"],"变量":["0.12","58.12"],"var":["0.13","0.14","0.15","58.13","58.14","58.15","101.55"],"let":["0.16","58.16"],"for":["0.20","58.20"],"const":["0.21","58.21"],"声明风格及最佳实践":["0.22","58.22"],"数据类型":["0.23","58.23","96.0"],"typeof":["0.24","58.24"],"undefined":["0.25","58.25"],"null":["0.26","58.26","61.2","101.3"],"boolean":["0.27","58.27"],"布尔值和不同类型之间的转换规则":["0.28","58.28"],"number":["0.29","58.29"],"数值字面量格式":["0.30","58.30"],"浮点值":["0.31","58.31"],"值的范围":["0.32","58.32"],"nan":["0.33","58.33"],"数值转换":["0.34","58.34"],"string":["0.35","58.35"],"字符字面量":["0.36","58.36"],"字符串的特点":["0.37","58.37"],"转换为字符串":["0.38","58.38"],"模板字面量":["0.39","58.39"],"字符串插值":["0.40","58.40"],"模板字面量标签函数":["0.41","58.41"],"原始字符串":["0.42","58.42"],"symbol":["0.43","0.48","0.49","0.50","0.51","0.52","0.53","0.54","0.55","0.56","0.57","0.58","0.59","58.43","58.48","58.49","58.50","58.51","58.52","58.53","58.54","58.55","58.56","58.57","58.58","58.59"],"符号的基本使用":["0.44","58.44"],"使用全局符号注册表":["0.45","58.45"],"使用符号作为属性":["0.46","58.46"],"常用内置符号":["0.47","58.47"],"object":["0.60","58.60"],"操作符":["0.61","58.61"],"一元操作符":["0.62","58.62"],"递增":["0.63","58.63"],"一元加和减":["0.64","58.64"],"位操作符":["0.65","58.65"],"按位非":["0.66","58.66"],"按位与":["0.67","58.67"],"按位或":["0.68","58.68"],"左移":["0.69","58.69"],"有符号右移":["0.70","58.70"],"无符号右移":["0.71","58.71"],"布尔操作符":["0.72","58.72"],"逻辑非":["0.73","58.73"],"逻辑与":["0.74","58.74"],"逻辑或":["0.75","58.75"],"乘性操作符":["0.76","58.76"],"乘法操作符":["0.77","58.77"],"除法运算符":["0.78","58.78"],"取模运算符":["0.79","58.79"],"指数操作符":["0.80","58.80"],"加性操作符":["0.81","58.81"],"加法操作符":["0.82","58.82"],"减法操作符":["0.83","58.83"],"关系操作符":["0.84","58.84"],"相等操作符":["0.85","58.85"],"等于和不等于":["0.86","58.86"],"全等和不全等":["0.87","58.87"],"条件操作符":["0.88","58.88"],"赋值操作符":["0.89","58.89"],"逗号操作符":["0.90","58.90"],"语句":["0.91","58.91"],"补充":["4.1"],"解释":["12.0","113.14","113.18","113.25","113.29","118.3"],"如何将":["14.0"],"不稳定结构":["55.3"],"v":["55.4","55.5"],"稳定":["55.6"],"什么是":["56.0","97.13"],"javascript":["56.1","56.2","56.7","86.31"],"ecmascript":["56.3","82.1"],"dom":["56.4","56.5","111.0"],"bom":["56.6"],"html":["57.0","99.0"],"script":["57.1"],"最近":["59.0"],"为什么说":["59.1"],"如何系统学习":["59.2"],"这门课程是如何设计的":["59.3"],"写在最后":["59.4"],"课程中的代码":["59.6"],"在正式开始小册的学习前":["60.0"],"vs":["60.1"],"其他插件":["60.2"],"playground":["60.3"],"ts":["60.4","78.2","78.3"],"更方便的类型兼容性检查":["60.5"],"总结":["60.6","89.9","91.13"],"扩展阅读":["60.7","61.10","62.16","63.13","64.7","66.6","68.5","70.5","71.11","72.4","73.5","75.6","76.7","78.12","79.18","82.7","83.12","84.6","87.6","89.10"],"require":["60.8"],"通常来说":["61.0"],"原始类型的类型标注":["61.1"],"void":["61.3","63.3","72.2"],"数组的类型标注":["61.4"],"对象的类型标注":["61.5"],"修饰接口属性":["61.6"],"type":["61.7","74.2"],"总结与预告":["61.9","62.14","63.12","64.6","65.8","66.5","67.8","68.4","69.10","70.4","71.10","72.3","73.4","75.5","76.6","77.4","78.11","79.17","80.43","81.13","82.6","83.11","84.5","85.33","86.42","87.5","88.5"],"unique":["61.11"],"了解了原始类型与对象类型以后":["62.0"],"字面量类型与联合类型":["62.2"],"字面量类型":["62.4"],"联合类型":["62.6","69.4"],"对象字面量类型":["62.8"],"枚举":["62.10"],"常量枚举":["62.12"],"类型控制流分析中的字面量类型":["62.18"],"在前面的入门环节中":["63.0"],"函数":["63.1"],"函数的类型签名":["63.2"],"可选参数与":["63.4"],"重载":["63.5"],"异步函数":["63.6"],"class":["63.7","67.6"],"类与类成员的类型签名":["63.8"],"修饰符":["63.9"],"静态成员":["63.10"],"继承":["63.11","96.7"],"私有构造函数":["63.14"],"solid":["63.15"],"此前我们学习基础类型标注":["64.0"],"内置类型":["64.1"],"虚无的":["64.2"],"类型断言":["64.3"],"双重断言":["64.4"],"非空断言":["64.5"],"类型层级初探":["64.8"],"上一节":["65.0","76.0","77.0"],"类型别名":["65.1"],"联合类型与交叉类型":["65.2"],"索引类型":["65.3"],"索引签名类型":["65.4"],"索引类型查询":["65.5"],"索引类型访问":["65.6"],"映射类型":["65.7"],"上一节我们主要了解了类型别名":["66.0"],"类型查询操作符":["66.1"],"类型守卫":["66.2"],"基于":["66.3"],"类型断言守卫":["66.4"],"接口的合并":["66.7"],"更强大的可辨识联合类型分析":["66.8"],"从这一节开始":["67.0"],"类型别名中的泛型":["67.1"],"泛型约束与默认值":["67.2"],"多泛型关联":["67.3"],"对象类型中的泛型":["67.4"],"函数中的泛型":["67.5"],"内置方法中的泛型":["67.7"],"在":["68.0","68.3","73.0","87.4"],"结构化类型系统":["68.1"],"标称类型系统":["68.2"],"类型":["68.6"],"如果说类型系统是":["69.0"],"判断类型兼容性的方式":["69.1"],"从原始类型开始":["69.2"],"向上探索":["69.3"],"装箱类型":["69.5"],"top":["69.6"],"向下探索":["69.7"],"类型层级链":["69.8"],"其他比较场景":["69.9"],"在完成类型层级一节的学习后":["70.0"],"条件类型基础":["70.1"],"infer":["70.2","71.12"],"分布式条件类型":["70.3"],"在很多时候":["71.0"],"工具类型的分类":["71.1"],"属性修饰工具类型":["71.2"],"思考":["71.3","71.5","71.7","71.9"],"结构工具类型":["71.4"],"集合工具类型":["71.6"],"模式匹配工具类型":["71.8"],"typescript":["72.0","80.3","82.2","91.0"],"无处不在的上下文类型":["72.1"],"将更少参数的函数赋值给具有更多参数的函数类型":["72.5"],"如何比较函数的签名类型":["73.1"],"协变与逆变":["73.2"],"tsconfig":["73.3"],"联合类型与兄弟类型下的比较":["73.6"],"非函数签名包装类型的变换":["73.7"],"在学习":["74.0"],"从类型编程到类型体操":["74.1"],"此前":["75.0"],"属性修饰进阶":["75.1"],"结构工具类型进阶":["75.2"],"集合工具类型进阶":["75.3"],"模式匹配工具类型进阶":["75.4"],"requiredkeys":["75.7"],"mutablekeys":["75.8"],"模板字符串类型的基础使用":["76.1"],"模板字符串类型的类型表现":["76.2"],"结合索引类型与映射类型":["76.3"],"专用工具类型":["76.4"],"模板字符串类型与模式匹配":["76.5"],"基于重映射的":["76.8"],"从最简单的模式匹配说起":["77.1"],"结构转换":["77.2"],"最后一步":["77.3"],"我们已经结束了":["78.0"],"类型检查指令":["78.1"],"类型声明":["78.4"],"让类型定义全面覆盖你的项目":["78.5"],"definitelytyped":["78.6"],"扩展已有的类型定义":["78.7"],"三斜线指令":["78.8"],"命名空间":["78.9"],"仅类型导入":["78.10"],"通过":["78.13"],"这一节我们要介绍的是":["79.0"],"项目初始化":["79.1"],"项目配置":["79.2"],"组件声明":["79.3"],"组件泛型":["79.4"],"泛型坑位":["79.5"],"usestate":["79.6"],"usecallback":["79.7"],"usereducer":["79.8"],"useref":["79.9"],"内置类型定义":["79.10"],"其他内置类型":["79.11"],"componentprops":["79.12"],"reactelement":["79.13"],"其他工程实践":["79.14"],"项目中的类型声明文件":["79.15"],"组件与组件类型":["79.16"],"fc":["79.19"],"关于":["80.0"],"基本的":["80.1"],"配置":["80.2"],"一般严格组":["80.4"],"语法统一约束":["80.5","80.28"],"array":["80.6","96.16","96.17","96.18"],"await":["80.7"],"consistent":["80.8","80.9","80.12"],"prefer":["80.10","80.11","80.15","80.16","80.21","80.41"],"non":["80.13"],"promise":["80.14","101.65"],"类型约束":["80.17","80.30"],"no":["80.18","80.22","80.23","80.24","80.25","80.26","80.32","80.33","80.34","80.37","80.38"],"能力约束":["80.19","80.36"],"ban":["80.20","80.31"],"较为严格组":["80.27"],"method":["80.29"],"explicit":["80.35"],"switch":["80.39"],"restrict":["80.40"],"triple":["80.42"],"在前面两节":["81.0"],"开发阶段":["81.1"],"项目开发":["81.2"],"启动":["81.4"],"在失败时执行":["81.6"],"代码生成":["81.7"],"类型相关":["81.8"],"校验阶段":["81.9"],"逻辑校验":["81.10"],"类型覆盖检查":["81.11"],"构建阶段":["81.12"],"这一节":["82.0"],"可选链":["82.3"],"空值合并":["82.4"],"逻辑赋值":["82.5"],"演进中的":["82.8"],"record":["82.9"],"面向表达式的":["82.10"],"响应式编程与observable":["82.11"],"函数式理念的进一步发展":["82.12"],"tc39":["82.13"],"上一节我们了解了":["83.0"],"装饰器大起底":["83.1"],"类装饰器":["83.2"],"方法装饰器":["83.3"],"访问符装饰器":["83.4"],"属性装饰器":["83.5"],"参数装饰器":["83.6"],"装饰器的执行机制":["83.7"],"多个同类装饰器的执行顺序":["83.8"],"反射":["83.9"],"反射元数据":["83.10"],"装饰器的坎坷进历程":["83.13"],"reflect":["83.14"],"上一节学习了装饰器与反射元数据的基本使用后":["84.0"],"控制反转与依赖注入":["84.1"],"基于依赖注入的路由实现":["84.2"],"实现一个简易":["84.3"],"基于内置元数据实现":["84.4"],"类型严格的装饰器":["84.7"],"在前面的内容中":["85.0"],"构建相关":["85.1"],"构建源码相关":["85.2"],"特殊语法相关":["85.3"],"experimentaldecorators":["85.4"],"jsx":["85.5"],"target":["85.6"],"构建解析相关":["85.7"],"files":["85.8"],"baseurl":["85.9"],"rootdir":["85.10"],"rootdirs":["85.11"],"types":["85.12"],"moduleresolution":["85.13"],"modulesuffixes":["85.14"],"noresolve":["85.15"],"paths":["85.16","94.7"],"resolvejsonmodule":["85.17"],"构建产物相关":["85.18"],"构建输出相关":["85.19"],"outdir":["85.20"],"preserveconstenums":["85.21"],"noemit":["85.22"],"module":["85.23","93.11"],"importhelpers":["85.24"],"downleveliteration":["85.25"],"importsnotusedasvalues":["85.26"],"声明文件相关":["85.27"],"declaration":["85.28"],"declarationmap":["85.29"],"emitdeclarationonly":["85.30"],"source":["85.31"],"构建产物代码格式化配置":["85.32"],"上一节我们介绍了构建相关的":["86.0"],"检查相关":["86.1"],"允许类":["86.2"],"allowumdglobalaccess":["86.3"],"allowunreachablecode":["86.4"],"allowunusedlabels":["86.5"],"禁止类":["86.6"],"类型检查":["86.7"],"noimplicitany":["86.8"],"useunknownincatchvariables":["86.9"],"逻辑检查":["86.10"],"nofallthroughcasesinswitch":["86.11"],"noimplicitoverride":["86.12"],"noimplicitreturns":["86.13"],"noimplicitthis":["86.14"],"nopropertyaccessfromindexsignature":["86.15"],"nounusedlocals":["86.16"],"严格检查":["86.17"],"exactoptionalpropertytypes":["86.18"],"alwaysstrict":["86.19"],"strict":["86.20"],"strictbindcallapply":["86.21"],"strictfunctiontypes":["86.22"],"strictnullchecks":["86.23"],"strictpropertyinitialization":["86.24"],"skiplibcheck":["86.25"],"工程相关":["86.26"],"project":["86.27"],"composite":["86.28"],"兼容性":["86.29"],"isolatedmodules":["86.30"],"allowjs":["86.32"],"checkjs":["86.33"],"模块相关":["86.34"],"esmoduleinterop":["86.35"],"编译器相关":["86.36"],"incremental":["86.37"],"watch":["86.38","113.11"],"编译器检查":["86.39"],"其它工程相关":["86.40"],"extends":["86.41"],"在这一节":["87.0"],"heroku":["87.1","88.1"],"nestjs":["87.2","87.7"],"prisma":["87.3"],"data":["87.8"],"orm":["87.9"],"同时":["88.0"],"连接到":["88.2"],"初次部署":["88.3"],"api":["88.4"],"前置知识":["89.0"],"使用":["89.1","89.2"],"ast":["89.3","89.11"],"示例":["89.4","89.5","89.6","89.7","89.8"],"在本节开始前":["90.0"],"是结束":["90.1"],"也是开始":["90.2"],"致谢":["90.3"],"interface":["91.1"],"及格线":["91.2","91.5","91.8","91.11"],"优秀回答":["91.3","91.6","91.9","91.12"],"类型兼容性比较":["91.4"],"any":["91.7"],"工具类型实现":["91.10"],"扩展路由的meta":["92.0"],"cdn":["93.1"],"安装":["93.2"],"基本用法":["93.3"],"预设的":["93.4"],"参数":["93.5"],"produrl":["93.6"],"modules":["93.7"],"enableindevmode":["93.8"],"generatescripttag":["93.9"],"generatecsslinktag":["93.10"],"其他的":["93.12"],"pinia":["94.0"],"一":["94.1","95.1","103.0"],"二":["94.2","95.2"],"三":["94.3","95.3"],"四":["94.4","95.4"],"key":["94.5"],"storage":["94.6"],"serializer":["94.8"],"beforerestore":["94.9"],"afterrestore":["94.10"],"debug":["94.11"],"批量导入":["95.0"],"五":["95.5"],"数据类型分类":["96.1"],"数据类型检测":["96.2"],"数据类型转换":["96.3"],"浅拷贝和深拷贝":["96.4"],"浅拷贝":["96.5"],"深拷贝":["96.6"],"常见的实现继承的方法":["96.8"],"如何实现":["96.9"],"闭包":["96.10","101.37"],"闭包的定义":["96.11"],"闭包产生的原因":["96.12"],"闭包的表现形式":["96.13"],"json":["96.14"],"数组":["96.15"],"数组扁平化":["96.19"],"数组排序":["96.21"],"排序分类":["96.23"],"sort":["96.24","101.51"],"css":["97.0","97.3","97.4","97.14"],"介绍一下":["97.1"],"line":["97.2"],"用":["97.5"],"一个盒子不给宽度和高度如何实现水平垂直居中":["97.6"],"display":["97.7","97.15"],"对":["97.8"],"清除浮动有哪些方式":["97.9"],"在网页中应该使用奇数还是偶数的字体大小":["97.10"],"position":["97.11"],"写一个左中右布局占满屏幕":["97.12"],"opacity":["97.16"],"before":["97.17"],"怎么让":["97.18"],"rem":["97.19"],"webkit":["97.20"],"响应式":["97.21"],"布局方案":["97.22"],"行内元素有哪些":["99.1"],"页面导入样式时":["99.2"],"title":["99.3"],"img":["99.4"],"png":["99.5"],"什么是语义化标签":["99.6"],"ios":["100.0","100.2"],"如何关闭":["100.1"],"禁止":["100.3","100.4","100.6"],"禁止下载图片":["100.5"],"js":["101.0","101.2","101.5","101.6","101.11","101.15","101.20","101.29","101.42"],"延迟加载":["101.1"],"和":["101.4"],"面试的时候怎么看":["101.7"],"考题":["101.8"],"考题二":["101.9","101.13","101.17","101.58"],"考题三":["101.10","101.14","101.18","101.59"],"考题一":["101.12","101.16","101.57"],"考题四":["101.19"],"方式一":["101.21","101.30","101.43","101.61"],"方式二":["101.22","101.31","101.44","101.62"],"方式三":["101.23","101.32","101.45","101.63"],"方式四":["101.24","101.46"],"方式五":["101.25"],"slice":["101.26","101.27"],"splice":["101.28"],"找出多维数组最大值":["101.33"],"给字符串新增方法实现功能":["101.34"],"找出字符串出现最多次数的字符以及次数":["101.35"],"new":["101.36"],"原型链":["101.41"],"说一下":["101.47"],"共同点":["101.48"],"区别":["101.49"],"场景":["101.50"],"深拷贝和浅拷贝":["101.52"],"localstorage":["101.53"],"自适应":["101.54"],"作用域考题":["101.56"],"将下列对象进行合并":["101.60"],"箭头函数和普通函数有什么区别":["101.64"],"find":["101.66"],"some":["101.67"],"tstststst":["102.0"],"webpack":["104.0","104.1"],"markdown":["106.0"],"syntax":["106.1"],"custom":["106.2"],"more":["106.3"],"image":["107.0"],"如何理解node中模块的概念":["109.0"],"软件工程的本质是什么":["109.1"],"模块化的方案":["109.2"],"动态":["110.0"],"题目":["110.1","110.5","111.1","111.5","111.9","111.12","111.15","112.1","112.4","112.7","113.1","113.6","113.9","113.12","113.16","113.20","113.23","113.27","114.1","114.4","114.8","114.11","114.14","114.17","115.1","115.4","116.1","117.1","118.1","119.1","120.1"],"答案":["110.2","110.6","111.2","111.6","111.10","111.13","111.16","112.2","112.5","112.8","112.10","113.2","113.4","113.7","113.10","113.13","113.17","113.21","113.24","113.28","114.2","114.5","114.9","114.12","114.15","114.18","115.2","115.5","116.2","117.2","118.2","119.2"],"解答":["110.3","110.7","111.3","111.7","114.6"],"全局":["110.4"],"props":["111.4"],"函数式组件":["111.8"],"渲染函数":["111.11"],"树组件":["111.14"],"切换器":["112.0"],"计数器":["112.3"],"实现本地存储函数":["112.6"],"鼠标坐标":["112.9"],"生命周期钩子":["113.0","117.0"],"ref":["113.3"],"响应性丢失":["113.5"],"可写的计算属性":["113.8"],"浅层":["113.15"],"依赖注入":["113.19"],"effect":["113.22"],"自定义":["113.26"],"大写":["114.0"],"优化性能的指令":["114.3"],"切换焦点的指令":["114.7"],"防抖点击指令":["114.10"],"激活的样式":["114.13"],"实现简易的":["114.16"],"阻止冒泡事件":["115.0"],"按键修饰符":["115.3"],"下一次":["116.0"],"原始值":["118.0"],"until":["119.0"],"自定义元素":["120.0"],"options":["121.1"],"setup":["121.3"],"目录":["122.0"]},{"0":["0.33","0.34","53.0","58.33","58.34","61.3","61.8","62.10","88.5","96.3","96.16","96.23","107.50"],"1":["0.17","0.22","0.34","0.60","0.77","0.78","0.82","0.83","1.0","1.1","1.2","1.3","1.4","1.5","2.1","2.2","2.3","3.1","3.2","3.3","6.1","6.2","6.3","7.1","7.2","8.1","8.2","9.0","10.1","10.2","10.3","11.1","11.2","11.3","12.1","12.2","18.1","18.2","19.1","19.2","20.1","20.2","21.1","21.2","21.3","22.1","22.2","26.1","26.2","27.1","27.2","27.3","28.1","28.2","28.3","29.1","29.2","29.3","31.1","31.2","34.1","34.2","34.3","35.1","36.1","36.2","36.3","36.4","37.1","37.2","37.3","43.1","47.1","47.2","47.3","47.4","54.1","54.2","54.3","55.1","55.2","57.1","58.17","58.22","58.34","58.60","58.77","58.78","58.82","58.83","69.1","69.4","69.9","70.3","79.9","82.10","82.11","83.2","89.7","90.1","92.0","96.2","96.3","96.5","96.6","96.8","96.13","96.19","96.23","97.21","97.22","101.3","101.5","101.6","101.7","101.8","101.31","101.32","101.38","101.40","101.41","101.49","101.52","101.64","103.1","103.2","103.3","103.4","103.5","103.6","103.7","103.8","103.9","103.11","103.15","107.1","107.2","107.3","107.4","107.5","107.6","107.7","107.8","107.9","107.13","107.19","107.27","107.34","107.36","107.58","107.60","107.67","107.69","107.80","107.82","107.83","107.84","107.89","107.123","107.128","107.136","115.2","121.0","121.7"],"2":["0.18","0.63","0.65","0.82","0.83","1.2","2.0","2.2","6.2","8.2","18.2","19.2","20.2","26.2","29.2","31.2","34.2","36.2","37.2","47.2","54.2","55.2","57.1","58.18","58.63","58.65","58.82","58.83","69.1","69.4","69.9","70.3","82.9","89.7","96.2","96.3","96.6","96.8","96.16","96.19","96.23","97.21","101.39","103.3","103.10","103.11","107.3","107.4","107.7","107.9","107.10","107.11","107.12","107.13","107.14","107.15","107.16","107.17","107.18","107.19","107.20","107.21","107.22","107.23","107.24","107.25","107.26","107.27","107.28","107.29","107.30","107.31","107.32","107.33","107.34","107.35","107.36","107.37","107.38","107.39","107.40","107.41","107.42","107.43","107.44","107.45","107.46","107.47","107.48","107.49","107.50","107.51","107.52","107.53","107.54","107.55","107.56","107.57","107.58","107.59","107.60","107.61","107.62","107.63","107.64","107.65","107.66","107.67","107.68","107.69","107.70","107.71","107.72","107.73","107.74","107.75","107.76","107.77","107.80","107.83","107.87","107.89","107.90","107.91","107.92","107.93","107.96","107.103","107.110","107.118","107.121","107.128","107.130","107.140","121.2"],"3":["0.19","0.34","0.71","1.3","2.3","3.0","3.3","6.3","21.3","27.3","28.3","29.3","36.3","37.3","47.3","54.3","56.6","58.19","58.34","58.71","69.4","69.9","70.3","82.13","96.3","96.6","96.8","96.19","96.23","101.40","103.4","103.13","107.6","107.7","107.8","107.19","107.22","107.23","107.38","107.39","107.44","107.50","107.54","107.58","107.60","107.61","107.62","107.65","107.67","107.69","107.70","107.73","107.74","107.76","107.77","107.78","107.79","107.80","107.81","107.82","107.83","107.84","107.85","107.86","107.87","107.88","107.89","107.90","107.91","107.92","107.93","107.94","107.95","107.96","107.97","107.98","107.99","107.100","107.101","107.102","107.103","107.104","107.105","107.106","107.107","107.108","107.109","107.110","107.111","107.112","107.113","107.114","107.115","107.116","107.117","107.118","107.119","107.120","107.121","107.122","107.123","107.124","107.125","107.126","107.127","107.128","107.129","107.130","107.131","107.132","107.133","107.134","107.135","107.136","107.137","107.138","107.139","107.140","121.4"],"4":["1.4","4.0","36.4","47.4","66.8","70.3","85.14","96.3","96.6","96.8","96.19","101.33","107.27","107.28","107.31","107.32","107.40","107.45","107.55","107.67","107.69","107.70","107.73","107.76","107.77","107.92","107.100","107.103","107.106","107.107","107.117","107.118","107.136","121.5"],"5":["0.5","5.0","58.5","66.8","70.3","90.1","96.3","96.6","96.19","101.33","103.6","107.23","107.34","107.36","107.37","107.38","107.39","107.40","107.46","107.93","107.110","107.112","107.114","107.115","107.117","107.118","107.139","107.140","121.6"],"6":["0.47","6.0","58.47","66.8","96.6","96.23","103.7","103.12","103.13","107.43","107.44","107.45","107.46","107.121","107.123","107.124","121.7"],"7":["0.80","7.0","58.80","66.8","85.14","103.8","103.14","103.15","103.16","107.49","107.50","107.128","107.130","107.133","107.136","107.137","107.139","107.140","121.8"],"8":["8.0","57.1","103.9","107.53","107.54","107.55"],"9":["9.0"],"10":["10.0","101.19"],"11":["11.0"],"13":["13.0"],"15":["15.0"],"16":["16.0"],"17":["17.0"],"18":["6.3","18.0"],"19":["19.0"],"20":["20.0"],"21":["21.0"],"22":["22.0","89.7"],"23":["23.0"],"24":["24.0"],"25":["25.0"],"26":["26.0"],"27":["27.0"],"28":["28.0"],"29":["29.0"],"30":["30.0","31.0"],"31":["0.65","58.65"],"32":["32.0"],"33":["33.0"],"34":["34.0","96.23"],"35":["35.0"],"36":["36.0"],"37":["37.0"],"38":["38.0"],"39":["39.0"],"40":["40.0"],"41":["41.0"],"42":["42.0"],"43":["43.0"],"44":["44.0"],"45":["45.0"],"46":["46.0"],"47":["47.0"],"48":["48.0"],"49":["49.0"],"50":["50.0"],"51":["51.0"],"52":["52.0"],"53":["53.0"],"54":["54.0"],"55":["55.0"],"76":["96.23"],"100":["107.82"],"200":["65.1"],"211":["96.23"],"222":["96.23"],"301":["65.1"],"324":["0.32","58.32"],"456":["96.23"],"599":["63.5","64.2","67.5","69.8","78.3","79.9"],"999":["89.7"],"2022":["82.13","89.8"],"2023":["105.0"],"2024":["93.0"],"ecmascript":["0.2","0.4","0.5","0.12","0.23","0.24","0.32","0.33","0.39","0.47","0.73","0.76","0.80","0.86","58.2","58.4","58.5","58.12","58.23","58.24","58.32","58.33","58.39","58.47","58.73","58.76","58.80","58.86","62.10","82.0","82.2","82.12","83.0","83.10","83.13","85.6"],"中一切都是区分大小写的":["0.2","58.2"],"所谓标识符":["0.3","58.3"],"就是变量":["0.3","58.3"],"采用":["0.4","58.4"],"新增了严格模式的概念":["0.5","58.5"],"严格模式是一种不同的":["0.5","58.5"],"bash":["0.7","58.7","79.1","80.1","88.2","95.1"],"break":["0.7","58.7"],"do":["0.7","58.7","82.10"],"in":["0.7","58.7","66.3","71.2","71.4","75.1","75.2","88.4"],"ecma":["0.8","58.8","82.1"],"enum":["0.9","58.9","62.10","80.15","84.2","107.49"],"implements":["0.10","58.10","89.5"],"await":["0.11","58.11"],"中有":["0.12","58.12"],"关键字":["0.13","58.13","70.2","71.8","107.49"],"要定义变量":["0.13","58.13"],"可以使用":["0.13","58.13"],"声明作用域":["0.14","58.14"],"使用":["0.14","0.15","57.1","58.14","58.15","61.4","79.4","85.8","94.4","99.2","111.3"],"操作符定义的变量会成为包含它的函数的局部变量":["0.14","58.14"],"比如":["0.14","58.14","61.0","62.0","64.1","66.2","67.2","67.5","68.3","77.3","78.9","86.35","87.3","88.1","89.4"],"在一个函数内部定义了一个变量":["0.14","58.14"],"就意味着该变量将在函数退出时被销毁":["0.14","58.14"],"js":["0.14","0.31","0.90","9.0","34.2","36.3","58.14","58.31","58.90","60.4","60.8","78.13","80.2","83.9","85.5","86.5","86.35","87.3","88.4","93.3","96.2","96.5","96.8","96.19","96.23","101.1","101.8","101.9","101.10","101.12","101.13","101.14","101.16","101.17","101.18","101.19","101.25","101.28","101.30","101.31","101.32","101.33","101.34","101.35","101.43","101.44","101.45","101.46","101.50","101.52","101.58","101.59","101.60","101.63"],"function":["0.14","9.0","21.3","58.14","61.6","61.8","63.2","63.4","63.5","66.2","67.2","67.5","67.7","68.1","78.4","80.14","80.31","82.12","83.2","83.9","84.4","84.7","86.22","89.1","89.8","96.2","96.8","96.19","96.23","101.8","101.10","101.16","101.19","101.35","101.44","101.45","101.46","101.58","101.63"],"test":["0.14","58.14"],"声明提升":["0.15","58.15"],"时":["0.15","58.15","72.2","74.0","84.2"],"下面的代码不会报错":["0.15","58.15"],"这是因为使用了这个关键字声明的变量会自动提升到函数的作用域顶部":["0.15","58.15"],"声明":["0.16","0.21","58.16","58.21"],"和":["0.16","13.0","17.0","18.2","50.0","56.5","56.6","58.16","63.8","64.5","69.6","71.4","71.5","74.1","75.8","79.0","81.12","82.1","82.9","84.4","86.23","86.35","89.9","96.2","96.3","96.9","97.15","97.16","97.17","97.19","99.2","99.3","99.4","101.3","101.57","101.66","101.67","107.96"],"var":["0.16","0.17","0.25","58.16","58.17","58.25","78.4","78.7","96.8","96.19","96.23","101.9","101.13","101.14","101.17","101.19","101.31","101.32","101.33","101.35","101.50","101.52","101.58"],"的作用差不多":["0.16","58.16"],"但是有着非常重要的区别":["0.16","58.16"],"最明显的区别就是":["0.16","58.16"],"暂时性死区":["0.17","58.17"],"let":["0.17","0.20","0.21","0.31","6.3","58.17","58.20","58.21","58.31","64.3","66.4","96.19","96.23","101.55","101.57"],"与":["0.17","0.18","6.3","58.17","58.18","60.4","60.8","61.2","61.7","63.11","64.1","64.8","66.3","68.3","69.6","70.5","71.2","71.8","75.2","76.4","77.1","77.2","78.2","78.3","79.2","79.7","79.9","79.13","80.2","80.8","80.9","80.11","80.29","81.2","82.0","82.1","82.9","82.10","83.0","83.4","83.5","83.6","85.0","85.4","85.5","85.6","85.8","85.12","85.20","85.22","85.24","85.26","86.3","86.15","86.16","86.25","86.35","86.39","87.2","87.8","87.9","89.0","89.3","89.11","91.1","121.8"],"全局声明":["0.18","58.18"],"循环中的":["0.20","58.20"],"在":["0.20","0.33","15.0","52.0","58.20","58.33","61.2","61.4","61.8","61.11","62.4","63.3","63.9","63.10","65.6","66.8","69.5","75.2","77.1","77.2","78.10","78.13","79.3","79.10","79.16","79.19","81.0","82.3","82.10","82.13","83.9","94.2","95.2","95.5","107.23","107.50","110.3"],"出现之前":["0.20","58.20"],"的行为与":["0.21","58.21"],"基本相同":["0.21","58.21"],"唯一一个重要的区别是用它声明变量时必须同时初始化变量":["0.21","58.21"],"且尝试修改":["0.21","58.21"],"操作符":["0.24","58.24","65.5","66.1","66.3"],"因为":["0.24","58.24","75.8"],"的类型系统是松散的":["0.24","58.24"],"类型":["0.25","0.26","0.27","0.29","0.35","0.43","0.60","58.25","58.26","58.27","58.29","58.35","58.43","58.60","63.3","64.2","64.3","64.5","65.1","68.3","69.5","69.7","79.3","79.6","94.5","94.6","94.7","94.8","94.9","94.10","94.11","107.80"],"类型只有一个值":["0.25","58.25"],"就是特殊值":["0.25","58.25"],"当":["0.25","58.25"],"类型同样只有一个值":["0.26","58.26"],"即特殊值":["0.26","58.26"],"逻辑上讲":["0.26","58.26"],"类型是":["0.27","58.27"],"数据类型":["0.28","58.28"],"转换为":["0.28","0.34","58.28","58.34","121.8"],"true":["0.28","0.34","0.86","36.3","58.28","58.34","58.86","64.2","66.3","67.7","77.1","96.3"],"十进制":["0.30","58.30"],"直接写出来即可":["0.30","58.30"],"八进制":["0.30","58.30"],"要定义浮点值":["0.31","58.31"],"数值中必须包含小数点":["0.31","58.31"],"而且小数点后面必须至少有一个数字":["0.31","58.31"],"虽然小数点前面不是必须有整数":["0.31","58.31"],"但推荐加上":["0.31","58.31"],"floatnumber1":["0.31","58.31"],"可以保存的最小数值保存在":["0.32","58.32"],"number":["0.32","0.33","0.34","36.3","58.32","58.33","58.34","60.5","61.1","61.6","63.2","63.5","66.1","66.2","66.3","67.1","67.2","67.4","67.5","68.3","72.2","72.5","75.2","76.1","76.3","79.9","87.3","96.3","107.77"],"min":["0.32","58.32"],"value":["0.32","58.32","83.3","83.4","83.10"],"中":["0.32","0.33","30.0","52.0","58.32","58.33","61.2","62.4","63.3","63.10","66.1","67.7","68.0","70.3","75.2","78.10","82.2","82.3","82.10","86.42","96.5","107.50"],"这个值多数浏览器是":["0.32","58.32"],"5e":["0.32","58.32"],"有一个特殊的值叫":["0.33","58.33"],"意思是":["0.33","58.33"],"不是数值":["0.33","58.33"],"not":["0.33","58.33"],"a":["0.33","55.4","58.33","61.3","65.1","65.2","71.5","71.6","75.3","75.8","82.5","83.2","84.1","96.19","96.23","101.14"],"用于表示本来要返回数值的操作失败了":["0.33","58.33"],"而不是抛出错误":["0.33","58.33"],"有":["0.34","58.34"],"个函数可以将非数值转换为数值":["0.34","58.34"],"parseint":["0.34","58.34","96.3"],"parsefloat":["0.34","58.34","96.3"],"是转型函数":["0.34","58.34"],"可用于任何数据类型":["0.34","58.34"],"后两个函数主要用于将字符串转化为数值":["0.34","58.34"],"函数基于如下规则执行转换":["0.34","58.34"],"布尔值":["0.34","58.34","80.40"],"false":["0.34","58.34","67.2","77.1","96.3"],"数值":["0.34","58.34"],"直接返回":["0.34","58.34"],"null":["0.34","58.34","61.1","61.8","64.2","64.5","79.9","80.15","80.23","86.23","96.1","96.2","96.3"],"返回":["0.34","58.34","66.3","70.2","96.3"],"undefined":["0.34","58.34","61.1","61.2","61.8","64.5","66.1","86.13","86.23","94.7","94.9","94.10","96.1","96.6","101.3","113.14"],"nan":["0.34","0.82","0.83","58.34","58.82","58.83"],"字符串":["0.34","58.34","64.1"],"应用一下规则":["0.34","58.34"],"如果字符串包含数值字符":["0.34","58.34"],"包括数字字符前面带加":["0.34","58.34"],"减号的情况":["0.34","58.34"],"则转换为一个十进制数":["0.34","58.34"],"因此":["0.34","58.34","69.6","83.2","83.10"],"字符串数据类型包含一些字符字面量":["0.36","58.36"],"用于表示非打印字符或有其他用途的字符":["0.36","58.36"],"字面量":["0.36","58.36"],"含义":["0.36","58.36"],"n":["0.36","58.36","67.5","84.3"],"换行":["0.36","58.36"],"t":["0.36","58.36","67.1","67.2","70.2","70.3","71.2","71.4","75.1","75.2","75.4","75.8","76.1","76.4"],"字符串是不可变的":["0.37","58.37"],"有两种方式将一个值转换为字符串":["0.38","58.38"],"模板字面量最常用的一个特性是支持字符串插值":["0.40","58.40"],"也就是可以在一个连续定义中插入一个或多个":["0.40","58.40"],"值":["0.40","58.40","97.7"],"模板字面量也支持定义标签函数":["0.41","58.41"],"使用模板字面量也可以直接获取原始的模板字面量内容":["0.42","58.42"],"符号需要使用":["0.44","58.44"],"symbol":["0.44","0.45","58.44","58.45","61.11","84.7","85.25","96.6"],"函数初始化":["0.44","58.44"],"因为符号本身是基本类型":["0.44","58.44"],"所以":["0.44","58.44"],"typeof":["0.44","58.44","66.1","66.2","66.4","78.7","96.2"],"如果运行时的不同部分需要共享和重用符号实例":["0.45","58.45"],"那么可以用一个字符串作为键":["0.45","58.45"],"在全局符号注册表中创建并重用符号":["0.45","58.45"],"for":["0.45","55.5","58.45","80.10","85.25","96.19","96.23"],"对每个字符串键都执行幂等操作":["0.45","58.45"],"第一次使用某个字符串调用时":["0.45","58.45"],"它会检查全局运行时注册表":["0.45","58.45"],"凡是可以使用字符串或数值作为属性的地方":["0.46","58.46"],"也引入了一批常用内置符号":["0.47","58.47"],"well":["0.47","58.47"],"known":["0.47","58.47"],"asynciterator":["0.48","58.48"],"hasinstance":["0.49","58.49"],"isconcatspreadable":["0.50","58.50"],"iterator":["0.51","58.51","85.25"],"match":["0.52","58.52"],"replace":["0.53","58.53","77.2"],"search":["0.54","58.54","77.1","77.2"],"species":["0.55","58.55"],"split":["0.56","58.56","77.2"],"toprimitive":["0.57","58.57"],"tostringtag":["0.58","58.58"],"unscopables":["0.59","58.59"],"每个":["0.60","58.60"],"实例都有如下属性和方法":["0.60","58.60"],"只操作一个值的操作符叫一元操作符":["0.62","58.62"],"递减操作符":["0.63","58.63"],"递增和递减操作符有两个版本":["0.63","58.63"],"前缀版和后缀版":["0.63","58.63"],"两个版本的区别是后缀版的递增和递减在语句被求值后才发生":["0.63","58.63"],"这":["0.63","58.63"],"对操作符可以用作于任何值":["0.63","58.63"],"一元加和减操作符对大多数开发者来说并不陌生":["0.64","58.64"],"它们在":["0.64","58.64"],"正值以真正的二进制格式存储":["0.65","58.65"],"即":["0.65","58.65","61.3","64.5","70.2","82.1","83.3","83.10","87.8"],"位中的每一位都代表":["0.65","58.65"],"的幂":["0.65","58.65"],"按位非操作符用波浪符":["0.66","58.66"],"表示":["0.66","0.67","0.68","0.73","0.74","0.75","0.77","0.78","0.79","0.86","58.66","58.67","58.68","58.73","58.74","58.75","58.77","58.78","58.79","58.86"],"按位与操作符用和号":["0.67","58.67"],"按位或操作符用管道符":["0.68","58.68"],"同样有两个操作数":["0.68","58.68"],"按位或遵循如下真值表":["0.68","58.68"],"左移操作符用两个小于号":["0.69","58.69"],"有符号右移由两个大于号":["0.70","58.70"],"无符号右移用":["0.71","58.71"],"个大于号表示":["0.71","58.71"],"逻辑非操作符由一个叹号":["0.73","58.73"],"可应用给":["0.73","58.73"],"中的任何值":["0.73","58.73"],"这个操作符始终返回布":["0.73","58.73"],"逻辑与操作符由两个和号":["0.74","58.74"],"应用到两个值":["0.74","58.74"],"逻辑与操作符遵循如下真值表":["0.74","58.74"],"第一个操作数":["0.74","0.75","58.74","58.75"],"第二个操作数":["0.74","0.75","58.74","58.75"],"结果":["0.74","0.75","58.74","58.75"],"逻辑或操作符由两个管道符":["0.75","58.75"],"逻辑或操作符遵循如下真值表":["0.75","58.75"],"乘法操作符由一个星号":["0.77","58.77"],"可以用于计算两个数值的乘积":["0.77","58.77"],"特殊值处理":["0.77","0.78","0.79","58.77","58.78","58.79"],"如果操作数都是数值":["0.77","0.78","58.77","58.78"],"除法操作符由一个斜杠":["0.78","58.78"],"可以用于计算第一个操作数除以第二个操作数的商":["0.78","58.78"],"则执行常规的除法运算":["0.78","58.78"],"取模":["0.79","58.79"],"余数":["0.79","58.79"],"操作符由一个百分比符号":["0.79","58.79"],"用于求两个数的和":["0.82","58.82"],"两个操作数都是数值执行规则":["0.82","58.82"],"如果有任一操作数是":["0.82","0.83","58.82","58.83"],"则返回":["0.82","0.83","58.82","58.83"],"也是使用很频繁的一种操作符":["0.83","58.83"],"计算规则":["0.83","58.83"],"如果两个操作数都是数值":["0.83","58.83"],"则执行数学减法运算并返回结果":["0.83","58.83"],"关系操作符执行比较两个值的操作":["0.84","58.84"],"包括小于":["0.84","58.84"],"大于":["0.84","58.84"],"小于等于":["0.84","58.84"],"第一组是等于和不等于":["0.85","58.85"],"中的等于操作符用两个等于号":["0.86","58.86"],"如果操作数相等":["0.86","58.86"],"则会返回":["0.86","58.86"],"不等于操作符用叹号和等于号":["0.86","58.86"],"如果两个操作数不相等":["0.86","58.86"],"这两个操作符都会先进行类型转换":["0.86","58.86"],"通常称为强制类型转换":["0.86","58.86"],"全等和不全等操作符与相等和不相等操作符类似":["0.87","58.87"],"variable":["0.88","58.88"],"boolean":["0.88","58.88","61.1","61.6","63.5","66.3","67.2","67.7","76.1","79.3","80.37","96.3"],"expression":["0.88","58.88","65.6","82.10"],"简单赋值用等于号":["0.89","58.89"],"逗号操作符可以用来在一条语句中执行多个操作":["0.90","58.90"],"如下所示":["0.90","58.90"],"后续整理":["0.91","58.91"],"声明式框架":["1.1"],"vue":["1.1","4.1","5.0","9.0","15.0","16.0","21.3","22.1","23.0","25.0","30.0","31.0","33.0","38.0","39.0","41.0","42.0","44.0","45.0","61.0","110.1","110.2","110.6","111.1","111.2","111.6","111.9","111.10","111.13","111.16","112.1","112.2","112.4","112.5","112.7","112.8","112.9","112.10","113.1","113.2","113.3","113.4","113.6","113.7","113.9","113.10","113.12","113.13","113.16","113.17","113.21","113.23","113.24","113.27","113.28","113.29","114.1","114.2","114.4","114.5","114.8","114.9","114.11","114.12","114.14","114.15","114.17","114.18","115.2","115.4","115.5","116.1","116.2","117.1","117.2","118.2","119.2","120.1"],"的核心特点":["1.1"],"用起来简单":["1.1"],"那我们就有必要知道":["1.1"],"命令式和声明式的区别":["1.1"],"mvvm":["1.2"],"模式":["1.2"],"说起":["1.2"],"理解基本概念":["2.1"],"spa":["2.1"],"single":["2.1"],"page":["2.1","62.10"],"优缺点":["2.2"],"单页面应用":["2.2"],"解决方案":["2.3"],"基本概念":["3.1"],"基本所有框架都引入了虚拟":["3.1"],"2补充":["3.2"],"再次补充":["3.3"],"谈谈对":["4.0"],"中的每一个组件都有一个渲染函数":["4.1"],"既然":["5.0"],"vue2":["6.2","6.3","18.1","53.0","103.0"],"处理缺陷":["6.2"],"vue3":["6.3","52.0","53.0","121.3"],"实现对比":["6.3"],"javascript":["6.3","28.3","56.0","59.1","59.2","61.2","61.3","61.5","61.8","61.11","62.10","63.11","64.2","65.6","65.7","66.1","66.3","69.5","76.1","77.4","78.6","82.1","82.3","82.5","82.12","83.13","85.23","86.14","86.21","89.2","89.7","96.9","96.10"],"obj":["6.3","64.5","65.6"],"name":["6.3","28.3","32.0","36.3","55.1","60.5","61.6","63.2","66.4","72.2","76.3","77.3","78.3","84.4","88.4","89.7","93.11","96.8","101.9","101.18"],"jw":["6.3"],"age":["6.3","60.5","61.6","72.2","76.3","87.3","89.7"],"依赖收集流程":["8.1"],"set方法是如何实现的":["9.0"],"不允许在已经创建的实例上动态添加新的响应式属性":["9.0"],"export":["9.0","36.3","62.10","68.3","75.1","75.3","77.2","78.9","78.10","79.3","81.7","84.2","87.3","87.4","89.6"],"set":["9.0","83.4","83.9","84.4","85.25","101.30"],"target":["9.0","83.2","83.9","83.10","84.4","84.7","85.24"],"key":["9.0","20.1","65.4","66.3","83.10","84.2","84.4"],"val":["9.0"],"是开发环境":["9.0"],"没定义或者是基础类型则报错":["9.0"],"if":["9.0","17.0","55.4","63.5","66.2","96.3","96.23"],"process":["9.0"],"env":["9.0","88.2","88.4"],"node":["9.0","60.4","60.8","79.2","81.2","84.2","85.12","85.13","86.38","87.0","88.4","88.5"],"watch":["11.0","13.0","81.6"],"ref":["12.0","113.15","113.26","121.4","121.6","121.7"],"watcheffect":["13.0"],"的区别":["13.0","97.16","99.3","101.3","101.53","101.55"],"template":["14.0","31.1","80.40","110.6","111.16","112.1","112.2","112.5","113.3","113.4","113.6","113.7","114.11","114.12","114.14","114.15","115.5"],"转化成":["14.0"],"render":["14.0","31.2"],"函数":["14.0","63.0","63.6","79.3","85.24","88.1"],"new":["15.0","67.7","68.1","84.1","96.8","96.9","96.16","101.30"],"这个过程中究竟做了什么":["15.0"],"的时候":["15.0"],"v":["17.0","26.2","29.3","37.3","75.1","83.4","114.6","114.16","115.4"],"中的生命周期":["18.1"],"主要的生命周期":["18.1"],"创建前后":["18.1"],"挂载前后":["18.1"],"更新前后":["18.1"],"v2":["18.2"],"v3":["18.2"],"中的生命周期对比":["18.2"],"生命周期":["18.2"],"diff":["19.2","55.1"],"比较流程":["19.2"],"先比较是否是相同节点":["19.2"],"的概念":["20.1","55.2"],"use":["21.1","21.3"],"实现原理":["21.3"],"typescript":["21.3","59.1","59.2","59.3","59.4","60.0","60.1","60.3","60.4","60.5","60.6","61.3","61.4","61.5","61.6","61.8","61.9","61.11","62.2","62.4","62.6","62.8","62.12","62.18","63.2","63.3","63.4","63.5","63.9","63.10","63.11","63.12","63.14","64.1","64.2","64.3","64.4","64.5","64.6","64.8","65.0","65.1","65.4","65.6","65.7","66.1","66.2","66.3","66.4","66.7","67.1","67.2","67.3","67.4","67.5","67.7","68.0","68.1","68.2","68.3","68.4","69.0","69.1","69.2","69.4","69.5","69.8","69.9","70.1","70.2","70.3","71.2","71.4","71.8","71.12","72.1","72.2","72.5","73.1","73.4","74.0","75.0","75.1","75.2","75.3","75.4","75.8","76.1","76.2","76.3","76.4","76.5","77.1","77.2","77.3","78.0","78.2","78.3","78.4","78.6","78.7","78.9","78.10","78.11","79.0","79.2","79.3","79.8","79.9","79.10","79.12","79.13","79.15","80.1","80.6","80.8","80.9","80.12","80.39","80.41","80.43","81.0","81.7","81.10","81.11","81.12","81.13","82.0","82.13","83.0","83.1","83.2","83.7","83.8","83.10","83.13","84.1","84.2","84.3","84.4","84.7","85.0","85.6","85.12","85.15","85.24","85.26","86.8","86.15","86.18","86.22","86.23","86.24","86.25","86.30","86.35","87.0","87.3","87.4","88.3","89.1","89.2","89.4","89.5","89.6","89.7","89.8","89.9","91.2","91.5","95.4","107.38","107.45","107.46","107.50","107.54","107.77"],"plugin":["21.3"],"extend":["22.1"],"概念":["22.1"],"使用基础":["22.1"],"组件":["23.0","79.3","85.5"],"data":["23.0"],"为什么必须是一个函数":["23.0"],"根实例对象":["23.0"],"可以是对象也可以是函数":["23.0"],"单例":["23.0"],"函数组件的优势":["24.0"],"函数式组件的特性":["24.0"],"的过滤器了解吗":["25.0"],"过滤器的使用场景":["25.0"],"过滤器实质不改变原始数据":["25.0"],"只是对数据进行加工处理后返回过滤后的数据再进行调用处理":["25.0"],"once":["26.2","114.6"],"使用场景":["26.2","36.2","70.4"],"html":["26.2","31.0","31.1","36.2","55.1","55.4","55.5","79.12","80.2","97.6"],"单个元素":["26.2"],"span":["26.2","55.1","55.4"],"插槽的分类和原理":["28.3"],"默认插槽":["28.3"],"具名插槽":["28.3"],"div":["28.3","55.1","55.4","55.5","79.9","97.6","112.5","113.4"],"slot":["28.3"],"title":["28.3","99.4"],"content":["28.3"],"组件中的":["29.3"],"model":["29.3","88.4"],"组件上的":["29.3"],"默认会利用名为":["29.3"],"sync":["30.0"],"修饰符的作用":["30.0"],"中递归组件的理解":["31.0"],"el":["31.0","31.1"],"menu":["31.0","31.1"],"模板递归":["31.1"],"渲染函数递归":["31.2"],"jsx":["31.2","79.19"],"组件中写":["32.0"],"常见的修饰符有哪些":["33.0"],"异步组件的写法":["34.2"],"回调写法":["34.2"],"components":["34.2","86.27"],"my":["34.2","77.3"],"动态组件可以采用":["36.2"],"keep":["36.2","36.3","36.4"],"alive":["36.2","36.3"],"进行缓存":["36.2"],"原理":["36.3"],"default":["36.3","62.10","86.35","88.4"],"abstract":["36.3","89.5"],"不会放到对应的lifecycle":["36.3"],"props":["36.3","79.3"],"include":["36.3","77.1","77.2","85.8","85.10"],"patterntypes":["36.3"],"白名单":["36.3"],"exclude":["36.3","85.8"],"黑名单":["36.3"],"max":["36.3"],"string":["36.3","60.5","61.1","61.4","61.6","63.2","63.5","65.1","65.4","66.1","66.2","66.3","67.1","67.2","67.5","69.1","69.5","70.2","72.1","72.2","76.1","76.3","76.4","76.5","77.1","77.2","78.3","78.4","79.6","81.10","83.7","84.3","84.4","84.7","87.3","88.4","94.5","94.7","96.3","101.2","101.34","107.80","107.87"],"最大连接数":["36.3"],"created":["36.3"],"this":["36.3","73.3","84.1","84.3","86.14","88.4","96.8","96.9","101.64","106.2"],"cache":["36.3"],"alive中数据更新问题":["36.4"],"指令的生命周期":["37.2"],"常见的指令编写":["37.3"],"图片懒加载":["37.3"],"lazy":["37.3"],"防抖":["37.3"],"debounce":["37.3"],"按钮权限":["37.3"],"中使用了哪些设计模式":["38.0"],"单例模式":["38.0"],"单例模式就是整个程序有且仅有一个实例":["38.0"],"中的性能优化有哪些":["39.0"],"数据层级不宜过深":["39.0"],"合理设置响应式数据":["39.0"],"单页应用首屏加载速度慢的怎么解决":["40.0"],"使用路由懒加载":["40.0"],"异步组件":["40.0"],"实现组件拆分":["40.0"],"项目中你是如何解决跨域的呢":["41.0"],"跨域是浏览器同源策略导致的":["41.0"],"常见权限控制":["43.1"],"登录鉴权":["43.1"],"用户登录后返回":["43.1"],"router":["44.0","45.0"],"有几种钩子函数":["44.0"],"具体是什么及执行流程是怎样的":["44.0"],"几种模式的区别":["45.0"],"缺点":["47.3"],"页面刷新后":["49.0"],"mutation":["50.0"],"action":["50.0","79.8"],"有使用过":["51.0"],"vuex":["51.0"],"的":["51.0","66.4","68.4","73.7","82.5","87.3","89.1","89.9"],"module":["51.0","80.35","86.35"],"吗":["51.0"],"compositionapi":["52.0"],"的优势是":["52.0"],"有了解过吗":["53.0"],"能说说跟":["53.0"],"的区别吗":["53.0"],"更注重模块上的拆分":["53.0"],"接口异常处理":["54.3"],"patchflags":["55.1"],"优化":["55.1"],"算法无法避免新旧虚拟dom":["55.1"],"中无用的比较操作":["55.1"],"通过":["55.1","86.27","96.24"],"来标记动态内容":["55.1"],"可以实现快速":["55.1"],"算法":["55.1"],"h1":["55.1","99.3"],"hello":["55.1","76.1"],"jiang":["55.1"],"blocktree":["55.2"],"为什么我们还要提出":["55.2"],"所谓的不稳定结构就是":["55.3"],"p":["55.4","67.7","71.2","71.4","75.4","79.3"],"flag":["55.4","73.3"],"随着":["55.5"],"变量的变化也会导致虚拟dom":["55.5"],"树变得不稳定":["55.5"],"fragment":["55.6"],"是什么":["56.1","80.0","97.14","97.21"],"虽然":["56.1","82.1"],"实现":["56.2","63.11"],"在基本层面上":["56.3"],"文档对象模型":["56.4"],"级别":["56.5"],"domlevel1":["56.5"],"由":["56.5","82.13"],"core":["56.5"],"ie3":["56.6"],"netscape":["56.6","82.1"],"navigator":["56.6"],"提供的浏览器对象模型":["56.6"],"的不同版本":["56.7"],"中的":["57.0","64.2","73.3","82.2","83.0","85.16","87.3","96.9"],"元素":["57.1"],"元素有下列":["57.1"],"个属性":["57.1"],"async":["57.1","85.24","88.3","101.1"],"可选":["57.1","93.6"],"表示应该立即开始下载脚本":["57.1"],"但不能阻止其他页面动作":["57.1"],"比如下载资源或等待其他脚本加载":["57.1"],"只对外部脚本文件有效":["57.1"],"charset":["57.1"],"src":["57.1","79.15","85.8","85.11","85.13","88.3","107.65","107.80"],"软件开发设计公司":["59.0"],"the":["59.0","81.7","88.4"],"software":["59.0"],"house":["59.0"],"针对":["59.0"],"可能超越":["59.1"],"我们知道":["59.1","60.8","70.1","87.3"],"一直以灵活性著称":["59.1"],"在实际开发时":["59.1"],"我们不需要确定一个变量的类型":["59.1"],"就能直接访问可能并不存在的属性":["59.1"],"所以无需为每一步操作都定义类型":["59.1"],"在小型项目中":["59.1"],"这种灵活性可以有效提高开发效率":["59.1"],"帮助我们掌控全局":["59.1"],"但随着项目规模的增大":["59.1"],"这些变量类型的数量也会成倍增加":["59.1"],"你总有记错":["59.1"],"遗漏的时候":["59.1"],"此时":["59.1","71.6"],"随着越来越多的前端开发者开始尝试学习和使用":["59.2"],"理论上":["59.2"],"应该已经完全取代":["59.2"],"了":["59.2"],"但实际上并没有":["59.2"],"一方面":["59.2"],"就像我们前面所说":["59.2"],"项目规模较小或部分开发者仍然更偏爱灵活的":["59.2"],"另一方面":["59.2"],"作为":["59.2","61.5"],"中不存在的概念":["59.2"],"类型能力相关的学习成本让很多开发者停留在入门阶段":["59.2"],"无法前进":["59.2"],"按照我们上面讲到的学习路径":["59.3"],"这门课程也将分为":["59.3"],"类型能力篇":["59.3"],"语法篇和工程实践篇":["59.3"],"从下图中也能看出":["59.3"],"我们会将重点更多地放在类型部分":["59.3"],"img":["59.3","71.6","80.1","107.82"],"我们会从":["59.3"],"无论你处于哪个阶段":["59.4"],"只要想开始学习":["59.4"],"这门课程就是适合你的":["59.4"],"小册中的所有代码都会存放在":["59.6"],"我们还有一件事要做":["60.0"],"那就是搭建":["60.0"],"的开发环境":["60.0"],"一个舒适":["60.0"],"code":["60.1","67.4","86.4"],"配置与插件":["60.1"],"本身就是由":["60.1"],"编写的":["60.1"],"因此它对":["60.1"],"有着非常全面的支持":["60.1"],"包括类型检查":["60.1"],"补全等功能":["60.1"],"我们需要的两个":["60.1"],"ts":["60.1","60.8","64.1","74.1","78.5","78.8","78.10","79.1","79.15","80.2","80.20","80.21","81.2","85.10","87.3","87.4","88.3","88.4","89.1","89.2","89.3","95.2","107.13","107.23","107.46"],"插件都来自于社区":["60.1"],"这两个插件分别提供了":["60.1"],"除了":["60.2","60.8","64.1","96.2"],"懒人福音":["60.3"],"如果你只是想拥有一个简单的环境":["60.3"],"能写":["60.3"],"能检查错误":["60.3"],"能快速地调整":["60.3"],"文件的快速执行":["60.4"],"dev":["60.4"],"当然":["60.4","62.8","63.11"],"如果你主要是想执行":["60.4"],"文件":["60.4","60.8","80.2","85.5","85.10"],"就像":["60.4","77.2","87.2"],"index":["60.4","78.10","107.77"],"这样快速地验证代码逻辑":["60.4"],"这个时候你就需要":["60.4"],"以及":["60.4","61.8","71.4","83.3","83.7","83.10"],"这一类工具了":["60.4"],"它们能直接执行":["60.4"],"并且支持监听文件重新执行":["60.4"],"同时":["60.4","67.6","86.8"],"它们也支持跳过类型检查这一步骤来获得更快的执行体验":["60.4"],"对于":["60.4","61.8","71.6","79.2","80.2"],"某些时候":["60.5"],"我们在进行类型比较时":["60.5"],"需要使用一个具有具体类型的变量与一个类型进行赋值操作":["60.5"],"比如下面这个例子中":["60.5"],"interface":["60.5","61.6","61.7","62.6","65.4","66.3","66.7","67.4","72.1","76.3","78.4","78.7","79.3","80.9","80.32","81.7","86.15","86.18","107.43"],"foo":["60.5","63.2","63.5","63.10","63.14","64.5","66.2","66.3","67.2","75.1","75.2","76.3","77.3","78.4","78.10","83.2","83.7","83.8","83.10","86.24","101.16"],"bar":["60.5","63.5","66.3","75.2","77.3"],"在这一节中":["60.6","62.14","64.6","68.4","79.17"],"我们主要了解了":["60.6","78.11"],"开发环境的搭建":["60.6"],"extension":["60.8","106.0"],"中最早使用的是":["60.8"],"commonjs":["60.8","85.23","86.35"],"来进行模块的导入":["60.8"],"文件的导入以外":["60.8"],"中还支持以扩展的形式来提供自定义扩展名的模块加载机制":["60.8"],"这也是":["60.8"],"允许你去":["60.8"],"一个":["60.8","97.21"],"学习一件新事物的较好方式是和你已掌握的做对比":["61.0"],"通过二者之间通用的概念帮你快速熟悉新的事物":["61.0"],"在掌握了":["61.0"],"首先":["61.1","69.2","83.8","88.2","107.44"],"我们来看":["61.1"],"javascript的内置原始类型":["61.1"],"除了最常见的":["61.1"],"分别表示":["61.2"],"你是否看到过以下的":["61.3"],"代码呢":["61.3"],"href":["61.3"],"清除缓存":["61.3"],"这里的":["61.3","76.1"],"等价于":["61.3","75.2"],"数组同样是我们最常用的类型之一":["61.4"],"中有两种方式来声明一个数组类型":["61.4"],"const":["61.4","61.8","62.12","64.5","67.2","67.5","72.2","72.5","78.3","78.10","79.3","79.6","79.8","79.9","81.10","84.3","89.1","89.6","96.23","101.55"],"arr1":["61.4","101.52"],"arr2":["61.4"],"array":["61.4","96.19","96.23"],"这两种方式是完全等价的":["61.4"],"但其实更多是以前者为主":["61.4"],"如果你将鼠标悬浮在":["61.4"],"上":["61.4","84.2"],"会发现它显示的类型签名是":["61.4"],"数组是我们在日常开发大量使用的数据结构":["61.4"],"但在某些情况下":["61.4"],"元组":["61.4","61.9"],"tuple":["61.4","82.9"],"来代替数组要更加妥当":["61.4"],"比如一个数组中只存放固定长度的变量":["61.4"],"但我们进行了超出长度地访问":["61.4"],"中使用最频繁的数据结构":["61.5"],"对象的类型标注是我们本节要重点关注的部分":["61.5"],"接下来我们会学习如何在":["61.5"],"中声明对象":["61.5"],"修饰对象属性":["61.5"],"类似于上面的元组可选":["61.6"],"在接口结构中同样通过":["61.6"],"来标记一个属性为可选":["61.6"],"idescription":["61.6"],"male":["61.6","89.7"],"func":["61.6","63.5","64.5","70.2"],"object":["61.8","66.1","66.3","69.5","75.1","75.2","81.10","84.7","87.3","96.5","101.61"],"一个空对象":["61.8"],"这三者的使用可能也会让部分同学感到困惑":["61.8"],"所以我也专门解释下":["61.8"],"首先是":["61.8","70.5","79.6","80.2","82.1","82.12"],"的使用":["61.8","87.3","89.1"],"被":["61.8"],"原型链折磨过的同学应该记得":["61.8"],"原型链的顶端是":["61.8"],"这也就意味着所有的原始类型与对象类型最终都指向":["61.8"],"中就表现为":["61.8"],"包含了所有的类型":["61.8"],"void":["61.8","64.1","64.2","75.2","78.4","84.7","89.5","94.9","94.10","99.1","107.77"],"需要关闭":["61.8"],"strictnullchecks":["61.8"],"tmp1":["61.8"],"tmp2":["61.8"],"这一节":["61.9","65.8","76.0","77.4","82.6","83.11"],"我们一起学习了":["61.9"],"中原始类型":["61.9"],"对象类型":["61.9","63.0","69.2"],"数组":["61.9"],"的类型标注":["61.9"],"中代表着一个唯一的值类型":["61.11"],"它类似于字符串类型":["61.11"],"可以作为对象的属性名":["61.11"],"并用于避免错误修改":["61.11"],"对象":["61.11","101.11","107.23"],"class":["61.11","63.8","63.9","63.10","63.11","63.14","64.0","68.1","73.1","78.9","83.2","83.7","83.8","83.10","84.1","84.3","86.12","86.24","87.3","87.4","89.5","97.6","101.43"],"内部属性的情况":["61.11"],"而在":["61.11"],"我们已经能完成简单场景的类型标注了":["62.0"],"但这还远远不够":["62.0"],"我们还可以让这些类型标注更精确一些":["62.0"],"有一个接口结构":["62.0"],"我们可以使用联合类型加上字面量类型":["62.2"],"把上面的例子改写成这样":["62.2"],"最开始你可能觉得很神奇":["62.4"],"success":["62.4"],"不是一个值吗":["62.4"],"为什么它也可以作为类型":["62.4"],"这叫做":["62.4"],"literal":["62.4","80.15","80.37","80.38"],"而联合类型你可以理解为":["62.6"],"它代表了":["62.6"],"一组类型的可用集合":["62.6"],"只要最终赋值的类型属于联合类型的成员之一":["62.6"],"就可以认为符合这个联合类型":["62.6"],"联合类型对其成员并没有任何限制":["62.6"],"除了上面这样对同一类型字面量的联合":["62.6"],"我们还可以将各种类型混合到一起":["62.6"],"类似的":["62.8","85.6"],"对象字面量类型就是一个对象类型的值":["62.8"],"这也就意味着这个对象的值全都为字面量值":["62.8"],"枚举并不是":["62.10"],"中原生的概念":["62.10"],"在其他语言中它都是老朋友了":["62.10"],"java":["62.10","82.1"],"c":["62.10","84.1"],"swift":["62.10"],"等":["62.10","77.1","77.3","83.10","86.39","87.3","88.4","89.8"],"目前也已经存在给":["62.10"],"引入枚举支持的":["62.10"],"proposal":["62.10","82.11","82.12"],"提案":["62.10","82.8","83.0"],"但还未被提交给":["62.10"],"tc39":["62.10","82.1","82.8","82.10"],"仍处于":["62.10"],"stage":["62.10","82.9","82.10","82.11"],"阶段":["62.10"],"如果要和":["62.10"],"中现有的概念对比":["62.10"],"我想最贴切的可能就是你曾经写过的":["62.10"],"constants":["62.10"],"文件了":["62.10"],"home":["62.10"],"url":["62.10","88.2","88.4","97.21"],"url1":["62.10"],"常量枚举和枚举相似":["62.12"],"只是其声明多了一个":["62.12"],"我们了解了字面量类型和枚举的使用":["62.14"],"除了手动声明字面量类型以外":["62.18"],"实际上":["62.18","65.2","76.2","82.5"],"也会在某些情况下将变量类型推导为字面量类型":["62.18"],"看这个例子":["62.18"],"我们了解了日常开发中最常用的":["63.0"],"基础的变量类型标注":["63.0"],"包括原始类型":["63.0"],"字面量类型与枚举类型":["63.0"],"而实际开发中还有一个重要的朋友":["63.0"],"如果说变量的类型是描述了这个变量的值类型":["63.2"],"那么函数的类型就是描述了":["63.2"],"函数入参类型与函数返回值类型":["63.2"],"它们同样使用":["63.2"],"的语法进行类型标注":["63.2"],"我们直接看最简单的例子":["63.2"],"return":["63.2","63.3","63.5","67.2","67.7","79.3","79.9","83.2","84.4","86.13","89.6","96.23"],"length":["63.2","96.23","101.19"],"在函数类型中同样存在着类型推导":["63.2"],"比如在这个例子中":["63.2"],"你可以不写返回值处的类型":["63.2"],"一个没有返回值":["63.3"],"即没有调用":["63.3"],"语句":["63.3","66.2"],"rest":["63.4"],"参数":["63.4","107.27","107.80","107.87","107.96","107.103","107.110","107.121"],"在很多时候":["63.4"],"我们会希望函数的参数可以更灵活":["63.4"],"比如它不一定全都必传":["63.4"],"当你不传入参数时函数会使用此参数的默认值":["63.4"],"正如在对象类型中我们使用":["63.4"],"描述一个可选属性一样":["63.4"],"在函数类型中我们也使用":["63.4"],"描述一个可选参数":["63.4"],"在函数逻辑中注入可选参数默认值":["63.4"],"foo1":["63.4"],"在某些逻辑较复杂的情况下":["63.5"],"函数可能有多组入参类型和返回值类型":["63.5"],"else":["63.5","66.2"],"在这个实例中":["63.5"],"函数的返回类型基于其入参":["63.5"],"generator":["63.6","88.4"],"函数等类型签名":["63.6"],"对于异步函数":["63.6"],"异步":["63.6"],"一个函数的主要结构即是参数":["63.8"],"逻辑和返回值":["63.8"],"对于逻辑的类型标注其实就是对普通代码的标注":["63.8"],"所以我们只介绍了对参数以及返回值地类型标注":["63.8"],"而到了":["63.8"],"中其实也一样":["63.8"],"它的主要结构只有":["63.8"],"构造函数":["63.8","83.10"],"属性":["63.8","83.10"],"方法":["63.8","65.7","67.6","84.2"],"访问符":["63.8"],"accessor":["63.8"],"中我们能够为":["63.9"],"成员添加这些修饰符":["63.9"],"public":["63.9"],"private":["63.9"],"protected":["63.9"],"readonly":["63.9","71.3","75.8"],"除":["63.9","80.2"],"以外":["63.9","64.1"],"其他三位都属于访问性修饰符":["63.9"],"而":["63.9","64.2","65.6","83.4","83.10","85.4","85.13","86.3","87.2","87.3","96.2"],"你可以使用":["63.10"],"static":["63.10","97.11"],"关键字来标识一个成员为静态成员":["63.10"],"抽象类":["63.11"],"既然说到":["63.11"],"那就一定离不开继承":["63.11"],"一样":["63.11"],"中也使用":["63.11"],"extends":["63.11","66.7","69.1","69.4","69.8","69.9","70.1","70.2","70.3","70.5","71.4","73.1","75.1","75.2","75.3","75.4","76.1","76.4","76.5","77.1","77.2","84.7"],"关键字来实现继承":["63.11"],"base":["63.11"],"derived":["63.11"],"对于这里的两个类":["63.11"],"比较严谨的称呼是":["63.11"],"基类":["63.11"],"派生类":["63.11"],"如果你觉得叫父类与子类更容易理解也没问题":["63.11"],"关于基类与派生类":["63.11"],"我们需要了解的主要是":["63.11"],"派生类对基类成员的访问与覆盖操作":["63.11"],"基类中的哪些成员能够被派生类访问":["63.11"],"完全是由其访问性修饰符决定的":["63.11"],"在这一节":["63.12","66.5","67.8","69.10","70.4","71.10","73.4","76.6","78.11","80.43","86.42","89.9"],"我们了解了":["63.12","65.0","68.4","79.17","81.0"],"中的函数与类":["63.12"],"它们分别代表了面向过程与面向对象的编程理念":["63.12"],"对于函数":["63.12"],"上面说到":["63.14"],"我们通常不会对类的构造函数进行访问性修饰":["63.14"],"如果我们一定要试试呢":["63.14"],"原则":["63.15"],"原则是面向对象编程中的基本原则":["63.15"],"它包括以下这些五项基本原则":["63.15"],"s":["63.15","101.35"],"单一功能原则":["63.15"],"一个类应该仅具有一种职责":["63.15"],"这也意味着只存在一种原因使得需要修改类的代码":["63.15"],"如对于一个数据实体的操作":["63.15"],"其读操作和写操作也应当被视为两种不同的职责":["63.15"],"并被分配到两个类中":["63.15"],"更进一步":["63.15"],"对实体的业务逻辑和对实体的入库逻辑也都应该被拆分开来":["63.15"],"o":["63.15","86.39","96.23","101.17"],"开放封闭原则":["63.15"],"一个类应该是可扩展但不可修改的":["63.15"],"即假设我们的业务中支持通过微信":["63.15"],"支付宝登录":["63.15"],"字面量类型与枚举":["64.0"],"函数与":["64.0"],"等概念时":["64.0"],"实际上一直在用":["64.0"],"any":["64.1","64.3","64.8","65.0","66.4","67.5","69.6","70.2","70.5","71.4","75.2","75.4","78.10","80.33","83.2","107.77"],"unknown":["64.1","64.3","64.8","65.0","67.4","69.6","84.4","89.5","91.7"],"never":["64.1","64.2","69.6","69.7","69.8","70.2","70.3","75.2","75.3","75.8","76.8"],"有些时候":["64.1","110.5","119.1"],"我们的":["64.1","84.3"],"代码并不需要十分精确严格的类型标注":["64.1"],"console":["64.1","84.3","96.8","96.23","101.16"],"log":["64.1","84.3","96.8","96.23","101.16"],"方法就能够接受任意类型的参数":["64.1"],"不管你是数组":["64.1"],"对象或是其他的":["64.1"],"统统来者不拒":["64.1"],"那么":["64.1","66.3","84.2"],"我们难道要把所有类型用联合类型串起来":["64.1"],"这当然不现实":["64.1"],"为了能够表示":["64.1"],"任意类型":["64.1"],"中提供了一个内置类型":["64.1"],"来表示所谓的任意类型":["64.1"],"此时我们就可以使用":["64.1"],"作为参数的类型":["64.1"],"message":["64.1"],"optionalparams":["64.1"],"在这里":["64.1","75.3"],"一个被标记为":["64.1"],"类型的参数可以接受任意类型的值":["64.1"],"是":["64.1","67.5","96.5","121.3"],"是不是有点不好理解":["64.2"],"我们看一个联合类型的例子就能":["64.2"],"get":["64.2","82.11","83.4","84.2","84.3"],"到一些了":["64.2"],"type":["64.2","64.8","65.1","65.4","67.1","67.2","67.3","68.2","69.1","69.2","69.4","69.6","69.8","69.9","70.2","70.3","70.5","71.2","71.4","71.12","72.2","73.0","75.1","75.2","75.3","75.4","75.8","76.1","76.3","76.4","76.5","77.1","77.2","78.10","79.12","80.6","80.8","80.9","80.12","80.13","80.26","80.39","80.41","81.8","82.13","84.7","85.26","86.39","89.7","93.11","95.4","96.8"],"unionwithnever":["64.2"],"linbudu":["64.2","66.4","67.5","69.1","69.8","77.3","80.39","83.2","89.7","89.8"],"将鼠标悬浮在类型别名之上":["64.2"],"你会发现这里显示的类型是":["64.2"],"类型被直接无视掉了":["64.2"],"仍然存在":["64.2"],"这是因为":["64.2","68.1","72.1"],"作为类型表示一个空类型":["64.2"],"就像没有返回值的函数使用":["64.2"],"来作为返回值类型标注一样":["64.2"],"类型就像":["64.2"],"一样代表":["64.2"],"这里有类型":["64.2"],"但是个空类型":["64.2"],"警告编译器不准报错":["64.3"],"类型断言能够显式告知类型检查程序当前这个变量的类型":["64.3"],"可以进行类型分析地修正":["64.3"],"它其实就是一个将变量的已有类型更改为新指定类型的操作":["64.3"],"它的基本语法是":["64.3"],"as":["64.3","80.8","80.16","84.4"],"newtype":["64.3"],"你可以将":["64.3"],"类型断言到一个具体的类型":["64.3"],"unknownvar":["64.3"],"如果在使用类型断言时":["64.4"],"原类型与断言类型之间差异过大":["64.4"],"也就是指鹿为马太过离谱":["64.4"],"离谱到了指鹿为霸王龙的程度":["64.4"],"会给你一个类型报错":["64.4"],"非空断言其实是类型断言的简化":["64.5"],"它使用":["64.5"],"语法":["64.5","78.4","82.2","85.4"],"prop":["64.5","78.4","83.7"],"的形式标记前面的一个声明一定是非空的":["64.5"],"实际上就是剔除了":["64.5"],"比如这个例子":["64.5"],"declare":["64.5","68.3","78.4","78.7","84.7"],"我们学习了":["64.6","73.4","80.43"],"中的内置类型":["64.6","65.0"],"这一节的知识点其实都和":["64.8"],"的类型层级有所关联":["64.8"],"我们会在后面的类型系统部分有专门一节进行详细地讲述":["64.8"],"这里只做简单地描述来供有兴趣的同学提前了解":["64.8"],"前面我们已经说到":["64.8"],"属于":["64.8","86.28"],"top":["64.8","73.0"],"类型别名可以说是":["65.1"],"类型编程中最重要的一个功能":["65.1"],"从一个简单的函数类型别名":["65.1"],"到让你眼花缭乱的类型体操":["65.1"],"都离不开类型别名":["65.1"],"虽然很重要":["65.1"],"但它的使用却并不复杂":["65.1"],"我们通过":["65.1"],"关键字声明了一个类型别名":["65.1"],"同时它的类型等价于":["65.1"],"类型别名的作用主要是对一组类型或一个特定类型结构进行封装":["65.1"],"以便于在其它地方进行复用":["65.1"],"比如抽离一组联合类型":["65.1"],"statuscode":["65.1"],"在原始类型与对象类型一节":["65.2"],"我们了解了联合类型":["65.2"],"但实际上":["65.2","89.1"],"联合类型还有一个和它有点像的孪生兄弟":["65.2"],"交叉类型":["65.2"],"它和联合类型的使用位置一样":["65.2"],"只不过符号是":["65.2"],"即按位与运算符":["65.2"],"正如联合类型的符号是":["65.2"],"它代表了按位或":["65.2"],"即只需要符合联合类型中的一个类型":["65.2"],"既可以认为实现了这个联合类型":["65.2"],"如":["65.2","67.7","75.5","77.3","78.5","80.2","80.12","80.39","82.4","83.10","85.24","86.30","88.4"],"b":["65.2","71.6","75.3","75.8","82.5","84.1","99.3"],"只需要实现":["65.2"],"或":["65.2","85.10"],"索引类型指的不是某一个特定的类型工具":["65.3"],"它其实包含三个部分":["65.3"],"索引签名类型主要指的是在接口或类型别名中":["65.4"],"通过以下语法来":["65.4"],"快速声明一个键值类型一致的类型结构":["65.4"],"allstringtypes":["65.4"],"这时":["65.4"],"即使你还没声明具体的属性":["65.4"],"对于这些类型结构的属性访问也将全部被视为":["65.4"],"刚才我们已经提到了索引类型查询":["65.5"],"也就是":["65.5","77.1"],"keyof":["65.5","66.5","71.2","71.4","75.1","75.2","76.3"],"严谨地说":["65.5"],"它可以将对象中的所有键转换为对应字面量类型":["65.5"],"中我们可以通过":["65.6"],"的方式来动态访问一个对象属性":["65.6"],"即计算属性":["65.6"],"表达式会先被执行":["65.6"],"然后使用返回值来访问属性":["65.6"],"中我们也可以通过类似的方式":["65.6"],"只不过这里的":["65.6"],"要换成类型":["65.6"],"类型编程的第一步":["65.7"],"不同于索引类型包含好几个部分":["65.7"],"映射类型指的就是一个确切的类型工具":["65.7"],"看到映射这个词你应该能联想到":["65.7"],"中数组的":["65.7"],"map":["65.7","83.10","85.25","85.31"],"实际上也是如此":["65.7"],"映射类型的主要作用即是":["65.7"],"基于键名映射到键值类型":["65.7"],"概念不好理解":["65.7"],"我们直接来看例子":["65.7"],"我们认识了类型工具中的类型别名":["65.8"],"联合类型":["65.8","73.4"],"索引类型以及映射类型":["65.8"],"这些工具代表了类型工具中用于创建新类型的部分":["65.8"],"但它们实现创建的方式却五花八门":["65.8"],"联合类型与交叉类型":["66.0"],"索引类型与映射类型这几样类型工具":["66.0"],"熟悉又陌生的":["66.1"],"存在两种功能不同的":["66.1"],"我们最常见的一种":["66.1"],"操作符就是":["66.1"],"用于检查变量类型的":["66.1"],"它会返回":["66.1"],"等值":["66.1"],"而除此以外":["66.1"],"中提供了非常强大的类型推导能力":["66.2"],"它会随着你的代码逻辑不断尝试收窄类型":["66.2"],"这一能力称之为":["66.2"],"类型的控制流分析":["66.2"],"也可以简单理解为类型推导":["66.2"],"这么说有点抽象":["66.2"],"我们可以想象有一条河流":["66.2"],"它从上而下流过你的程序":["66.2"],"随着代码的分支分出一条条支流":["66.2"],"在最后重新合并为一条完整的河流":["66.2"],"在河流流动的过程中":["66.2"],"如果遇到了有特定条件才能进入的河道":["66.2"],"switch":["66.2","86.11"],"case":["66.2","77.3","86.11"],"语句等":["66.2"],"那河流流过这里就会收集对应的信息":["66.2"],"等到最后合并时":["66.2"],"它们就会嚷着交流":["66.2"],"我刚刚流过了一个只有字符串类型才能进入的代码分支":["66.2"],"我刚刚流过了一个只有函数类型才能进入的代码分支":["66.2"],"就这样":["66.2"],"它会把整个程序的类型信息都收集完毕":["66.2"],"input":["66.2","67.5","83.7","89.5","106.2"],"instanceof":["66.3","96.2","101.22"],"的类型保护":["66.3"],"并不是":["66.3"],"中新增的概念":["66.3"],"而是":["66.3"],"中已有的部分":["66.3"],"它可以通过":["66.3"],"的方式来判断":["66.3"],"是否存在于":["66.3"],"或其原型链上":["66.3"],"说明存在":["66.3"],"既然能起到区分作用":["66.3"],"中自然也可以用它来保护类型":["66.3"],"fooonly":["66.3"],"shared":["66.3","79.15"],"如果你写过测试用例或者使用过":["66.4"],"nodejs":["66.4","87.2","87.3"],"assert":["66.4"],"模块":["66.4"],"那对断言这个概念应该不陌生":["66.4"],"import":["66.4","75.1","78.10","79.4","79.8","79.10","79.12","80.12","81.10","83.10","84.1","85.26","86.35","87.3","87.4","89.1","89.2","89.4","89.6","93.3","95.4","111.13"],"from":["66.4","75.1","79.8","79.12","80.12","81.10","84.1","86.35","87.3","87.4","89.1","89.2","89.4","89.6","93.3"],"我们学习了一批新的类型工具":["66.5"],"包括操作符":["66.5"],"在交叉类型一节中":["66.7"],"你可能会注意到":["66.7","73.3","74.1"],"接口和类型别名都能直接使用交叉类型":["66.7"],"但除此以外":["66.7"],"接口还能够使用继承进行合并":["66.7"],"在继承时子接口可以声明同名属性":["66.7"],"但并不能覆盖掉父接口中的此属性":["66.7"],"子接口中的属性类型需要能够兼容":["66.7"],"父接口中的属性类型":["66.7"],"struct1":["66.7"],"primitiveprop":["66.7"],"类型控制流分析其实是一直在不断增强的":["66.8"],"我们正式进入到":["67.0"],"类型编程进阶篇":["67.0"],"的学习":["67.0"],"能来到这里意味着你已经对":["67.0"],"在类型工具学习中":["67.1"],"我们已经接触过类型别名中的泛型":["67.1"],"比如类型别名如果声明了泛型坑位":["67.1"],"那其实就等价于一个接受参数的函数":["67.1"],"factory":["67.1","67.2","89.1"],"上面这个类型别名的本质就是一个函数":["67.1"],"就是它的变量":["67.1"],"返回值则是一个包含":["67.1"],"的联合类型":["67.1"],"我们可以写段伪代码来加深一下记忆":["67.1"],"像函数可以声明一个参数的默认值一样":["67.2"],"泛型同样有着默认值的设定":["67.2"],"这样在你调用时就可以不带任何参数了":["67.2"],"默认会使用我们声明的默认值来填充":["67.2"],"再看个伪代码帮助理解":["67.2"],"typearg":["67.2"],"我们不仅可以同时传入多个泛型参数":["67.3"],"还可以让这几个泛型参数之间也存在联系":["67.3"],"我们可以先看一个简单的场景":["67.3"],"条件类型下的多泛型参数":["67.3"],"conditional":["67.3","70.3"],"condition":["67.3","70.3"],"truthyresult":["67.3"],"由于泛型提供了对类型结构的复用能力":["67.4"],"我们也经常在对象类型结构中使用泛型":["67.4"],"最常见的一个例子应该还是响应类型结构的泛型处理":["67.4"],"ires":["67.4"],"tdata":["67.4"],"假设我们有这么一个函数":["67.5"],"它可以接受多个类型的参数并进行对应处理":["67.5"],"对于字符串":["67.5","77.3"],"返回部分截取":["67.5"],"对于数字":["67.5"],"返回它的":["67.5"],"倍":["67.5"],"对于对象":["67.5"],"修改它的属性并返回":["67.5"],"这个时候":["67.5"],"我们要如何对函数进行类型声明":["67.5"],"大法好":["67.5"],"handle":["67.5","89.5"],"还是用联合类型来包括所有可能类型":["67.5"],"第一种我们肯定要直接":["67.5"],"pass":["67.5"],"第二种虽然麻烦了一点":["67.5"],"但似乎可以满足需要":["67.5"],"但如果我们真的调用一下就知道不合适了":["67.5"],"shouldbestring":["67.5"],"shouldbenumber":["67.5"],"中的泛型":["67.6"],"中的泛型和函数中的泛型非常类似":["67.6"],"只不过函数中泛型参数的消费方是参数和返回值类型":["67.6"],"中的泛型消费方则是属性":["67.6"],"乃至装饰器等":["67.6"],"中为非常多的内置对象都预留了泛型坑位":["67.7"],"promise":["67.7","75.1"],"resolve":["67.7"],"reject":["67.7"],"在你填充":["67.7"],"的泛型以后":["67.7"],"其内部的":["67.7"],"方法也自动填充了泛型":["67.7"],"我们学习了类型编程中的":["67.8"],"你可能遇见过以下这样":["68.0"],"看起来不太对":["68.0"],"但竟然能正常运行":["68.0"],"首先回到我们开头提出的问题":["68.1"],"如果我们为":["68.1"],"cat":["68.1","89.7"],"类新增一个独特的方法":["68.1"],"这个时候的表现才是符合预期的":["68.1"],"即我们只能用真实的":["68.1"],"类来进行调用":["68.1"],"meow":["68.1"],"eat":["68.1"],"dog":["68.1","73.1","73.2","73.7","89.7"],"feedcat":["68.1"],"报错":["68.1"],"nominal":["68.2"],"typing":["68.2","92.0"],"system":["68.2"],"要求":["68.2"],"两个可兼容的类型":["68.2"],"其名称必须是完全一致的":["68.2"],"比如以下代码":["68.2"],"中模拟标称类型系统":["68.3"],"再看一遍这句话":["68.3"],"类型的重要意义之一是限制了数据的可用操作与实际意义":["68.3"],"这往往是通过类型附带的":["68.3"],"额外信息":["68.3"],"来实现的":["68.3"],"类似于元数据":["68.3"],"要在":["68.3"],"中实现":["68.3"],"其实我们也只需要为类型额外附加元数据即可":["68.3"],"cny":["68.3"],"usd":["68.3"],"我们分别附加上它们的单位信息即可":["68.3"],"但同时又需要保留原本的信息":["68.3"],"即原本的":["68.3"],"我们可以通过交叉类型的方式来实现信息的附加":["68.3"],"的结构化类型系统是":["68.4"],"基于类型结构进行比较":["68.4"],"类型系统与类型检查":["68.6"],"对于类型":["68.6"],"类型系统":["68.6"],"类型检查":["68.6"],"你可以认为它们是不同的概念":["68.6"],"限制了数据的可用操作":["68.6"],"意义":["68.6"],"允许的值的集合":["68.6"],"中的重要基础知识":["69.0"],"那么类型层级就是类型系统中的重要概念之一":["69.0"],"对于没有类型语言经验学习的同学":["69.0"],"在开始前":["69.1"],"我们需要先了解一下如何直观地判断两个类型的兼容性":["69.1"],"本节中我们主要使用条件类型来判断类型兼容性":["69.1"],"类似这样":["69.1"],"result":["69.1","96.19"],"如果返回":["69.1"],"了解了类型兼容性判断的方式后":["69.2"],"我们就可以开始探讨类型层级了":["69.2"],"我们从原始类型":["69.2"],"后文统称为基础类型":["69.2"],"和它们对应的字面量类型开始":["69.2"],"result1":["69.2","70.1"],"直到穹顶之上":["69.3"],"我们之前讲过":["69.4"],"在联合类型中":["69.4"],"只需要符合其中一个类型":["69.4"],"我们就可以认为实现了这个联合类型":["69.4"],"用条件类型表达是这样的":["69.4"],"result7":["69.4"],"原始类型与对象类型":["69.5"],"一节中":["69.5"],"我们已经讲到了":["69.5"],"中装箱对象":["69.5"],"中的体现":["69.5"],"以及在原型链顶端傲视群雄的":["69.5"],"对象与":["69.5"],"很明显":["69.5"],"类型会是":["69.5"],"类型的子类型":["69.5"],"那中间还有吗":["69.5"],"还真有":["69.5"],"而且你不一定能猜到":["69.5"],"我们直接看从":["69.5"],"再往上":["69.6"],"我们就到达了类型层级的顶端":["69.6"],"是不是很快":["69.6"],"这里只有":["69.6"],"这两兄弟":["69.6"],"我们在探秘内置类型":["69.6"],"一节中已经了解":["69.6"],"是系统中设定为":["69.6"],"的两个类型":["69.6"],"它们无视一切因果律":["69.6"],"是类型世界的规则产物":["69.6"],"直到万物虚无":["69.7"],"向下地探索其实就简单多了":["69.7"],"首先我们能确认一定有个":["69.7"],"因为它代表了":["69.7"],"虚无":["69.7"],"的类型":["69.7"],"一个根本不存在的类型":["69.7"],"对于这样的类型":["69.7"],"它会是任何类型的子类型":["69.7"],"结合我们上面得到的结论":["69.8"],"可以书写出这样一条类型层级链":["69.8"],"typechain":["69.8"],"除了我们上面提到的类型比较":["69.9"],"其实还存在着一些比较情况":["69.9"],"我们稍作补充":["69.9"],"对于基类和派生类":["69.9"],"通常情况下":["69.9","86.35"],"派生类会完全保留基类的结构":["69.9"],"而只是自己新增新的属性与方法":["69.9"],"在结构化类型的比较下":["69.9"],"其类型自然会存在子类型关系":["69.9"],"更不用说派生类本身就是":["69.9"],"基类得到的":["69.9"],"联合类型的判断":["69.9"],"前面我们只是判断联合类型的单个成员":["69.9"],"那如果是多个成员呢":["69.9"],"result36":["69.9"],"我们从一个原始类型开始构造类型层级链":["69.10"],"向上触及了":["69.10"],"这一节学习条件类型对你来说已经没有什么困难了":["70.0"],"条件类型的语法类似于我们平时常用的三元表达式":["70.1"],"它的基本语法如下":["70.1"],"伪代码":["70.1"],"valuea":["70.1"],"valueb":["70.1"],"result2":["70.1"],"typea":["70.1"],"typeb":["70.1"],"但需要注意的是":["70.1"],"条件类型中使用":["70.1"],"判断类型的兼容性":["70.1"],"而非判断类型的全等性":["70.1"],"这是因为在类型层面中":["70.1"],"对于能够进行赋值操作的两个变量":["70.1"],"我们":["70.1"],"并不需要它们的类型完全相等":["70.1"],"只需要具有兼容性":["70.1"],"而两个完全相同的类型":["70.1"],"其":["70.1"],"自然也是成立的":["70.1"],"条件类型绝大部分场景下会和泛型一起使用":["70.1"],"泛型参数的实际类型会在实际调用时才被填充":["70.1"],"类型别名中显式传入":["70.1"],"或者函数中隐式提取":["70.1"],"而条件类型在这一基础上":["70.1"],"可以基于填充后的泛型参数做进一步的类型操作":["70.1"],"在上面的例子中":["70.2","72.5"],"假如我们不再比较填充的函数类型是否是":["70.2"],"args":["70.2","75.2","75.4"],"的子类型":["70.2"],"而是要拿到其返回值类型呢":["70.2"],"或者说":["70.2","71.6"],"我们希望拿到填充的类型信息的一部分":["70.2"],"而不是只是用它来做条件呢":["70.2"],"中支持通过":["70.2"],"关键字来":["70.2"],"在条件类型中提取类型的某一部分信息":["70.2"],"比如上面我们要提取函数返回值类型的话":["70.2"],"可以这么放":["70.2"],"functionreturntype":["70.2"],"r":["70.2","107.82"],"看起来是新朋友":["70.2"],"其实还是老伙计":["70.2"],"上面的代码其实表达了":["70.2"],"当传入的类型参数满足":["70.2"],"这样一个结构":["70.2"],"不用管":["70.2"],"当它是":["70.2"],"就行":["70.2"],"位置的值":["70.2"],"否则":["70.2"],"分布式条件类型听起来真的很高级":["70.3"],"但这里和分布式和分布式服务并不是一回事":["70.3"],"distributive":["70.3"],"也称条件类型的分布式特性":["70.3"],"只不过是条件类型在满足一定情况下会执行的逻辑而已":["70.3"],"我们来看一个例子":["70.3","76.5"],"res1":["70.3"],"res2":["70.3"],"这个例子可能让你感觉充满了疑惑":["70.3"],"某些地方似乎和我们学习的知识并不一样":["70.3"],"先不说这两个理论上应该执行结果一致的类型别名":["70.3"],"为什么在":["70.3"],"中诡异地返回了一个联合类型":["70.3"],"仔细观察这两个类型别名的差异你会发现":["70.3"],"唯一的差异就是在":["70.3"],"我们详细地解读了条件类型这一重要类型工具的使用方式":["70.4"],"分布式特性以及":["70.4"],"isany":["70.5"],"isunknown":["70.5"],"上面我们通过比较":["70.5"],"hack":["70.5"],"的手段得到了":["70.5"],"isnever":["70.5"],"那你一定会想是否能实现":["70.5"],"当然可以":["70.5"],"只不过它们的实现稍微复杂一些":["70.5"],"并且并不完全依赖分布式条件类型":["70.5"],"上面已经提到我们并不能通过":["70.5"],"这样的形式来判断一个类型是否是":["70.5"],"而是要利用":["70.5"],"的另一个特性":["70.5"],"工具类型其实都被妖魔化了":["71.0"],"它仿佛是武林中人人追捧的武功秘籍":["71.0"],"修炼难度极其苛刻":["71.0"],"掌握它就能立刻类型编程功力大涨":["71.0"],"成为武林盟主傲世群雄":["71.0"],"内置的工具类型按照类型操作的不同":["71.1"],"其实也可以大致划分为这么几类":["71.1"],"对属性的修饰":["71.1"],"包括对象属性和数组元素的可选":["71.1"],"必选":["71.1"],"只读":["71.1"],"这一部分的工具类型主要使用":["71.2","71.4","71.8"],"属性修饰":["71.2"],"映射类型":["71.2","71.4"],"索引类型":["71.2","71.4"],"相关":["71.2","85.31","86.31","86.38"],"索引类型签名":["71.2"],"索引类型访问":["71.2"],"索引类型查询均有使用":["71.2"],"因此这里直接用索引类型指代":["71.2"],"在内置工具类型中":["71.2"],"访问性修饰工具类型包括以下三位":["71.2"],"partial":["71.2","71.3","75.1"],"现在我们了解了":["71.3"],"条件类型":["71.4","71.8"],"结构工具类型其实又可以分为两类":["71.4"],"结构声明":["71.4"],"结构处理":["71.4"],"结构声明工具类型即快速声明一个结构":["71.4"],"比如内置类型中的":["71.4"],"record":["71.4","87.8"],"k":["71.4","75.1","75.2"],"其中":["71.4","83.4","85.4","85.5","85.13","85.20","85.28","86.39"],"即为键的类型":["71.4"],"这里使用":["71.4"],"标明":["71.4"],"传入的":["71.4"],"pick":["71.5","75.2"],"omit":["71.5","75.2"],"是基于键名的":["71.5"],"如果我们需要":["71.5"],"基于键值类型":["71.5"],"呢":["71.5"],"比如仅对函数类型的属性":["71.5"],"除了将一个对象结构拆分为多个子结构外":["71.5"],"对这些子结构的":["71.5"],"互斥处理":["71.5"],"也是结构工具类型需要解决的问题之一":["71.5"],"互斥处理指的是":["71.5"],"假设你的对象存在三个属性":["71.5"],"这一部分的工具类型主要使用条件类型":["71.6"],"条件类型分布式特性":["71.6"],"在开始集合类型前":["71.6"],"我们不妨先聊一聊数学中的集合概念":["71.6"],"对于两个集合来说":["71.6"],"通常存在":["71.6"],"交集":["71.6","75.3"],"并集":["71.6","75.3"],"差集":["71.6","75.3"],"补集":["71.6"],"这么几种情况":["71.6"],"用图表示是这样的":["71.6"],"我们搭配上图来依次解释这些概念":["71.6"],"两个集合的合并":["71.6"],"合并时重复的元素只会保留一份":["71.6"],"这也是联合类型的表现行为":["71.6"],"两个集合的相交部分":["71.6"],"即同时存在于这两个集合内的元素组成的集合":["71.6"],"两个集合来说":["71.6"],"相对于":["71.6"],"的差集即为":["71.6"],"中独有而":["71.6"],"中不存在的元素":["71.6"],"的组成的集合":["71.6"],"中剔除了":["71.6"],"中也存在的元素以后剩下的部分":["71.6"],"补集是差集的特殊情况":["71.6"],"目前为止我们的集合类型都停留在一维的层面":["71.7"],"即联合类型之间的集合运算":["71.7"],"infer":["71.8","71.9","75.1","75.4","77.0","77.1","77.2"],"在条件类型一节中我们已经差不多了解了":["71.8"],"关键字的使用":["71.8"],"而更严格地说":["71.8"],"其实代表了一种":["71.8"],"模式匹配":["71.8"],"pattern":["71.8"],"matching":["71.8"],"的思路":["71.8"],"如正则表达式":["71.8"],"glob":["71.8"],"中等都体现了这一概念":["71.8"],"首先是对函数类型签名的模式匹配":["71.8"],"我们对":["71.10"],"约束":["71.12"],"在某些时候":["71.12"],"我们可能对":["71.12"],"提取的类型值有些要求":["71.12"],"比如我只想要数组第一个为字符串的成员":["71.12"],"如果第一个成员不是字符串":["71.12"],"那我就不要了":["71.12"],"先写一个提取数组第一个成员的工具类型":["71.12"],"firstarrayitemtype":["71.12"],"拥有非常强大的类型推导能力":["72.0"],"不仅会在你声明一个变量时自动推导其类型":["72.0"],"也会基于函数内部逻辑自动推导其返回值类型":["72.0"],"还会在你使用":["72.0"],"首先举一个最常见的例子":["72.1"],"window":["72.1","78.5","78.7","101.18"],"onerror":["72.1"],"event":["72.1"],"source":["72.1","85.29"],"line":["72.1"],"col":["72.1"],"err":["72.1"],"在这个例子里":["72.1"],"虽然我们并没有为":["72.1"],"的各个参数声明类型":["72.1"],"但是它们也已经获得了正确的类型":["72.1"],"当然你肯定能猜到":["72.1"],"的类型声明已经内置了":["72.1"],"handler":["72.1","83.7","83.10","89.5"],"简化":["72.1"],"onerroreventhandlernonnull":["72.1"],"返回值类型下的特殊情况":["72.2"],"我们前面说到":["72.2"],"上下文类型同样会推导并约束函数的返回值类型":["72.2"],"但存在这么个特殊的情况":["72.2"],"当内置函数类型的返回值类型为":["72.2"],"customhandler":["72.2"],"handler1":["72.2"],"在这一节里":["72.3"],"我们学习了上下文类型这":["72.3"],"我们看到了这么一段代码":["72.5"],"arr":["72.5","96.19","96.24","101.31","101.32","101.33","101.50","107.77"],"list":["72.5","84.2"],"全面梳理类型系统的层级关系":["73.0"],"从":["73.0","81.7"],"到":["73.0"],"bottom":["73.0"],"首先要明确的是":["73.1"],"我们不会使用函数类型去和其他类型":["73.1"],"如对象类型":["73.1"],"比较":["73.1"],"因为这并没有意义":["73.1"],"本文中只会对两个函数类型进行比较":["73.1"],"来看示例":["73.1"],"给出三个具有层级关系的类":["73.1"],"分别代表动物":["73.1"],"狗":["73.1"],"柯基":["73.1"],"animal":["73.1","73.2"],"aspet":["73.1"],"bark":["73.1"],"corgi":["73.1","73.2"],"cute":["73.1"],"对于一个接受":["73.1"],"类型并返回":["73.1"],"类型的函数":["73.1"],"我们可以这样表示":["73.1"],"我们上一节得到的结论是":["73.2"],"考虑":["73.2"],"当有函数类型":["73.2"],"仅有":["73.2"],"成立":["73.2"],"即能被视作此函数的子类型":["73.2"],"这里的参数类型与返回值类型实际上可以各自独立出来看":["73.2"],"strictfunctiontypes":["73.3"],"如果你曾经翻过":["73.3"],"配置":["73.3","80.1","86.27","93.11","94.4","107.3"],"这一项配置":["73.3"],"但它在文档中的描述其实相对简略了些":["73.3"],"在比较两个函数类型是否兼容时":["73.3"],"将对函数参数进行更严格的检查":["73.3"],"when":["73.3"],"enabled":["73.3"],"causes":["73.3"],"functions":["73.3","88.1"],"parameters":["73.3"],"to":["73.3"],"be":["73.3"],"checked":["73.3"],"more":["73.3","88.4"],"correctly":["73.3"],"而实际上":["73.3"],"这里的更严格指的即是":["73.3"],"对函数参数类型启用逆变检查":["73.3"],"函数类型的兼容性比较":["73.4"],"这应该带给了你一些新的启发":["73.4"],"原来不只是原始类型":["73.4"],"对象类型等可以比较":["73.4"],"在上面我们只关注了显式的父子类型关系":["73.6"],"实际上在类型层级中还有隐式的父子类型关系":["73.6"],"我们在最开始一直以函数体作为包装类型来作为协变与逆变的转变前提":["73.7"],"后面虽然提到了使用数组的作为包装类型":["73.7"],"但只是一笔带过":["73.7"],"重点还是在函数体方面":["73.7"],"现在":["73.7"],"如果我们就是就是要考虑类似数组这种包装类型呢":["73.7"],"比如直接一个简单的笼子":["73.7"],"cage":["73.7"],"很多同学可能会遇到这些疑惑":["74.0"],"这些额外的类型代码":["74.0"],"上面我用了":["74.1"],"类型编程":["74.1"],"类型体操":["74.1"],"这两个不同的词":["74.1"],"这是因为我通常把":["74.1"],"中的类型操作分为这两类":["74.1"],"对于类型编程":["74.1"],"它是":["74.1","78.6","121.3"],"对实际开发中真的有帮助的类型操作":["74.1"],"下限非常之低":["74.1"],"比如其实我们就是简单地用个泛型":["74.1"],"这也属于类型编程":["74.1"],"而它的上限也很高":["74.1"],"比如底层框架中让人眼花缭乱的操作":["74.1"],"但我们不需要用一个具体的界限来进行划分":["74.1"],"只需要知道":["74.1"],"只要是真的对实际开发有帮助的类型操作":["74.1"],"无论实现多么复杂":["74.1"],"都能被归类于类型编程当中":["74.1"],"那么类型体操又是什么样的":["74.1"],"在此之前":["74.1"],"challenges":["74.2"],"最后":["74.2","90.3"],"我们再来说下如何进一步进阶类型编程能力":["74.2"],"challenge":["74.2"],"我们已经了解了":["75.0","77.3"],"中内置工具类型的实现原理":["75.0"],"在内置工具类型一节中":["75.1","75.4"],"对属性修饰工具类型的进阶主要分为这么几个方向":["75.1"],"深层的属性修饰":["75.1"],"基于已知属性的部分修饰":["75.1"],"以及基于属性类型的部分修饰":["75.1"],"首先是深层属性修饰":["75.1"],"还记得我们在":["75.1"],"关键字一节首次接触到递归的工具类型吗":["75.1"],"promisevalue":["75.1"],"可以看到":["75.1"],"此时我们只是在条件类型成立时":["75.1"],"再次调用了这个工具类型而已":["75.1"],"在某一次递归到条件类型不成立时":["75.1"],"就会直接返回这个类型值":["75.1"],"那么对于":["75.1"],"required":["75.1","89.4"],"其实我们也可以进行这样地处理":["75.1"],"deeppartial":["75.1"],"简单起见":["75.1"],"我们直接使用了":["75.1"],"作为泛型约束与条件":["75.1"],"这意味着也有可能传入函数":["75.1"],"数组等类型":["75.1"],"但毕竟我们对这个类型知根知底":["75.1"],"就可以假设只会传入对象结构":["75.1"],"因此也只需要对对象类型进行处理了":["75.1"],"为了更直观地验证它的效果":["75.1"],"我们使用":["75.1"],"tsd":["75.1"],"这一工具类型单元测试库来进行验证":["75.1"],"效果大概是这样":["75.1"],"expecttype":["75.1","77.3"],"deeppartialstruct":["75.1"],"前面对结构工具类型主要给出了两个进阶方向":["75.2"],"基于键值类型的":["75.2"],"子结构的互斥处理":["75.2"],"首先是基于键值类型的":["75.2"],"我们就称之为":["75.2"],"pickbyvaluetype":["75.2","76.8"],"好了":["75.2"],"它的实现方式其实还是类似部分属性修饰中那样":["75.2"],"将对象拆分为两个部分":["75.2"],"处理完毕再组装":["75.2"],"只不过":["75.2"],"现在我们无法预先确定要拆分的属性了":["75.2"],"而是需要":["75.2"],"基于期望的类型去拿到所有此类型的属性名":["75.2"],"如想":["75.2"],"出所有函数类型的值":["75.2"],"那就要先拿到所有的函数类型属性名":["75.2"],"先来一个":["75.2"],"functionkeys":["75.2","75.7"],"工具类型":["75.2"],"funcstruct":["75.2"],"这个写法我们是第一次见":["75.2"],"但我们可以拆开来看":["75.2"],"先看看前面的":["75.2"],"部分":["75.2","77.2","86.27"],"为何在条件类型成立时它返回了键名":["75.2"],"而非索引类型查询":["75.2"],"tmp":["75.2"],"res":["75.2"],"baz":["75.2","77.3"],"resequal":["75.2"],"我们获得了一个":["75.2"],"在集合工具类型中我们给到的进阶方向":["75.3"],"其实就是从一维原始类型集合":["75.3"],"扩展二维的对象类型":["75.3"],"在对象类型之间进行交并补差集的运算":["75.3"],"以及对同名属性的各种处理情况":["75.3"],"对于对象类型的交并补差集":["75.3"],"我们仍然沿用":["75.3"],"降级":["75.3"],"的处理思路":["75.3"],"把它简化为可以用基础工具类型处理的问题即可":["75.3"],"对象类型的交并补差集基本上可以降维到对象属性名集合的交并补差集问题":["75.3"],"比如交集就是两个对象属性名的交集":["75.3"],"使用属性名的交集访问其中一个对象":["75.3"],"就可以获得对象之间的交集结构":["75.3"],"不考虑同名属性冲突下":["75.3"],"复习一下前面的一维集合":["75.3"],"concurrence":["75.3"],"intersection":["75.3"],"difference":["75.3"],"我们对模式匹配工具类型的进阶方向其实只有深层嵌套这么一种":["75.4"],"特殊位置的":["75.4"],"处理其实大部分时候也是通过深层嵌套实现":["75.4"],"比如此前我们实现了提取函数的首个参数类型":["75.4"],"firstparameter":["75.4"],"functiontype":["75.4"],"arg":["75.4"],"这一节我们了解了属性修饰":["75.5"],"结构":["75.5","83.10"],"集合":["75.5"],"模式匹配这四大类的工具类型进阶":["75.5"],"也通过这些进阶类型了解到了常用的类型编程方式":["75.5"],"对一个对象结构拆分为多个子结构再分别处理":["75.5"],"optionalkeys":["75.7"],"在属性修饰工具类型中我们只实现了":["75.7"],"它的实现相对简单":["75.7"],"因为只需要判断类型即可":["75.7"],"那如果":["75.7"],"我们要获取一个接口中所有可选或必选的属性呢":["75.7"],"现在没法通过类型判断":["75.7"],"要怎么去收集属性":["75.7"],"这一部分的实际意义不大":["75.7"],"因此我特意放在扩展阅读里":["75.7"],"下面的":["75.7"],"immutablekeys":["75.8"],"则要更加复杂一些":["75.8"],"修饰符无法简单地通过结构化类型比较":["75.8"],"我们需要一个能对只读这一特性进行判断的辅助工具类型":["75.8"],"直接看例子再讲解":["75.8"],"equal":["75.8"],"x":["75.8","86.22"],"y":["75.8"],"我们对内置工具类型的进阶方向进行了实现":["76.0"],"它们中的部分工具类型确实相对烧脑和难以理解":["76.0"],"我们来看一个最简单的使用例子":["76.1"],"world":["76.1"],"greeting":["76.1"],"就是一个模板字符串类型":["76.1"],"它内部通过与":["76.1"],"中模板字符串相同的语法":["76.1"],"使用了另一个类型别名":["76.1"],"其最终的类型就是":["76.1"],"将两个字符串类型值组装在一起返回":["76.1"],"除了使用确定的类型别名以外":["76.1"],"模板字符串类型当然也支持通过泛型参数传入":["76.1"],"需要注意的是":["76.1","81.12"],"并不是所有值都能被作为模板插槽":["76.1"],"greet":["76.1"],"由于模板字符串类型最终的产物还是字符串字面量类型":["76.2"],"因此只要插槽位置的类型匹配":["76.2"],"字符串字面量类型就可以被认为是模板字符串类型的子类型":["76.2"],"比如我们上面的版本号":["76.2"],"说到模板字符串插槽中传入联合类型的自动分发特性时":["76.3"],"你可能会想到我们此前接触的一个能够生成联合类型的工具":["76.3"],"索引类型查询操作符":["76.3"],"基于":["76.3","88.4","89.8"],"模板字符串类型":["76.3","76.6"],"我们可以基于已有的对象类型来实现精确到字面量的类型推导":["76.3"],"job":["76.3","89.7"],"这些工具类型专用于字符串字面量类型":["76.4"],"包括":["76.4","78.11","85.10"],"uppercase":["76.4"],"lowercase":["76.4","77.3"],"capitalize":["76.4","77.3"],"uncapitalize":["76.4"],"看名字就能知道它们的作用":["76.4"],"字符串大写":["76.4"],"字符串小写":["76.4"],"首字母大写与首字母小写":["76.4"],"heavy":["76.4"],"respect":["76.4"],"模式匹配工具类型的核心理念就是对符合约束的某个类型结构":["76.5"],"提取其某一个位置的类型":["76.5"],"比如函数结构中的参数与返回值类型":["76.5"],"而如果我们将一个字符串类型视为一个结构":["76.5"],"就能够在其中也应用模式匹配相关的能力":["76.5"],"而我们此前所缺少的就是模板字符串类型的能力":["76.5"],"模板插槽不仅可以声明一个占位的坑":["76.5"],"也可以声明一个要提取的部分":["76.5"],"reversename":["76.5"],"str":["76.5","77.1","77.2","101.35"],"我们学习了一个新的内置类型能力":["76.6"],"它既是内置类型":["76.6"],"也是内置类型工具":["76.6"],"我们在这一节了解了重映射这一能力":["76.8"],"它使得我们可以在映射类型中去修改映射后的键名":["76.8"],"而如果映射后的键名变成了":["76.8"],"那么这个属性将不会出现在最终的接口结构中":["76.8"],"我们了解了模板字符串类型的基础内容":["77.0"],"它与数个类型工具的协作":["77.0"],"以及将作为本节核心内容的":["77.0"],"模板字符串类型与模式匹配产生的化学反应":["77.0"],"我们还是照例先复习一下":["77.0"],"如何在模板插槽中使用":["77.0"],"trim":["77.1","77.4"],"includes":["77.1"],"最简单的模式匹配只有一层条件类型语句":["77.1"],"也就意味着我们不需要对模式匹配的结果做结构转换等操作":["77.1"],"对比到字符串类型变量的方法":["77.1"],"trimleft":["77.1"],"trimright":["77.1"],"startswith":["77.1"],"endswith":["77.1"],"我们从比较有代表性的":["77.1"],"看起":["77.1"],"对应实现一个类型层面的版本":["77.1"],"判断传入的字符串字面量类型中是否含有某个字符串":["77.1"],"r1":["77.1"],"r2":["77.1"],"类型中":["77.1"],"我们在":["77.1"],"join":["77.2"],"看起来":["77.2"],"好像是挺复杂的实现":["77.2"],"但仔细想想它和":["77.2"],"其实没有啥区别":["77.2"],"判断是":["77.2"],"否能将字符串字面量划分为目标部分与其他部分":["77.2"],"那":["77.2"],"不是只需要":["77.2"],"将目标部分替换为新的部分":["77.2"],"按照原本的结构组合好":["77.2"],"就行了吗":["77.2"],"就像我们在对象层面的集合类型中学习的那样":["77.2"],"一切复杂的工具类型最终都可以转换为数个简单工具类型的组合":["77.2"],"实现中":["77.2"],"我们有两个纯做结构判断的":["77.2"],"插槽":["77.2"],"现在它们也能真正的派上用场了":["77.2"],"replacement":["77.2"],"head":["77.2"],"tail":["77.2"],"既然这两个插槽派上了用场":["77.2"],"我们就需要给它们正式点的名字":["77.2"],"这两个名字我们后面还会常常见到":["77.2"],"它们就表示开头与结尾的匹配部分":["77.2"],"这里我们其实是先判断字符串字面量中是否包含":["77.2"],"那样":["77.2"],"在包含也就是结构符合时":["77.2"],"将匹配得到的":["77.2"],"部分夹上":["77.2"],"我们就实现了一个类型版本的":["77.2"],"林不渡也不是不能渡":["77.2"],"replaceres1":["77.2"],"林不渡":["77.2","79.3"],"不":["77.2"],"不渡也不是不能":["77.2"],"不发生替换":["77.2"],"仍然是":["77.2"],"转换":["77.3"],"在上一节":["77.3"],"内置的":["77.3"],"等工具类型":["77.3"],"知道它们是在内部实现的层面支持了字符串值的变换":["77.3"],"其实基于这些工具类型":["77.3"],"我们完全可以实现几乎所有常见的":["77.3"],"camel":["77.3"],"snake":["77.3"],"lin":["77.3"],"bu":["77.3"],"du":["77.3"],"delimiter":["77.3"],"按照指定分隔符划分":["77.3"],"也包括":["77.3"],"首先需要明确的一点是":["77.3"],"无论是值还是字面量类型":["77.3"],"我们并没有办法去智能拆分":["77.3"],"mynameislinbudu":["77.3"],"在不注入判断逻辑的情况下":["77.3"],"计算机并不知道如何进行分词":["77.3"],"如果是已经具有了一种":["77.3"],"的字符串":["77.3"],"is":["77.3","88.4","106.2"],"此时我们要拆分就容易多了":["77.3"],"拆分其实就是":["77.3"],"转换的基础":["77.3"],"我们本节介绍的":["77.3"],"转换一定是建立在":["77.3"],"传入字符串已经拥有了一种":["77.3"],"的情况":["77.3","101.50"],"我们先以":["77.3"],"camelcase":["77.3"],"为最终产物":["77.3"],"了解如何从":["77.3"],"snakecase":["77.3"],"转换到":["77.3"],"也就是下划线转小驼峰":["77.3"],"如何实现":["77.3"],"snakecase2camelcase":["77.3"],"foobarbaz":["77.3"],"看这清晰明确的结构":["77.3"],"不用模式匹配简直暴殄天物":["77.3"],"我们需要做的就是按照":["77.3"],"进行结构匹配":["77.3"],"然后将除了首个字符串单元":["77.3"],"我们完成了模板字符串类型的进阶学习":["77.4"],"仿照着":["77.4"],"中字符串变量的方法实现了":["77.4"],"类型能力的学习":["78.0"],"这一节将进入":["78.0"],"的实战应用篇":["78.0"],"在前端世界的许多工具中":["78.1"],"其实都提供了":["78.1"],"行内注释":["78.1"],"ignore":["78.2","78.3"],"expect":["78.2","80.21"],"error":["78.2","80.21"],"应该是使用最为广泛的一个类型指令了":["78.2"],"它的作用就是直接禁用掉对下一行代码的类型检查":["78.2"],"check":["78.3","80.39","106.3"],"nocheck":["78.3"],"我们首先来看":["78.3"],"你可以把它理解为一个作用于整个文件的":["78.3"],"指令":["78.3","114.13"],"使用了":["78.3"],"指令的":["78.3"],"文件将不再接受类型检查":["78.3"],"以下代码均不会抛出错误":["78.3"],"在此前我们其实就已经接触到了类型声明":["78.4"],"它实际上就是":["78.4"],"f1":["78.4"],"在开始学习下面的内容前":["78.5"],"不妨先想想你是否遇到过这么几个场景":["78.5"],"想要使用一个":["78.5"],"npm":["78.5","78.6","80.1","93.4"],"包":["78.5","83.10","93.4"],"但它发布的时间太早":["78.5"],"根本没有携带类型定义":["78.5"],"于是你的项目里就出现了这么一处没有被类型覆盖的地方":["78.5"],"你想要在代码里导入一些非代码文件":["78.5"],"反正":["78.5"],"webpack":["78.5","85.16","89.0"],"会帮你处理":["78.5"],"但是可恶的":["78.5"],"又报错了":["78.5"],"这个项目在运行时动态注入了一些全局变量":["78.5"],"errorreporter":["78.5"],"你想要在代码里直接这样访问":["78.5"],"却发现类型又报错了":["78.5"],"这些问题都可以通过类型声明来解决":["78.5"],"这也是它的核心能力":["78.5"],"通过额外的类型声明文件":["78.5"],"简单来说":["78.6"],"types":["78.6","79.2","79.10","79.15","80.31","80.34","80.35"],"开头的这一类":["78.6"],"包均属于":["78.6"],"维护的":["78.6"],"专用于为社区存在的":["78.6"],"无类型定义的":["78.6"],"库":["78.6","87.3"],"添加类型支持":["78.6"],"常见的有":["78.6"],"对全局变量的声明":["78.7"],"还是以":["78.7"],"为例":["78.7"],"实际上我们如果":["78.7"],"ctrl":["78.7"],"点击代码中的":["78.7"],"会发现它已经有类型声明了":["78.7"],"globalthis":["78.7"],"三斜线指令就像是声明文件中的导入语句一样":["78.8"],"它的作用就是":["78.8"],"声明当前的文件依赖的其他类型声明":["78.8"],"而这里的":["78.8"],"其他类型声明":["78.8"],"包括了":["78.8"],"内置类型声明":["78.8"],"lib":["78.8","85.6"],"d":["78.8","85.10","85.30","88.4"],"三方库的类型声明以及你自己提供的类型声明文件等":["78.8"],"三斜线指令本质上就是一个自闭合的":["78.8"],"xml":["78.8"],"标签":["78.8","88.4"],"其语法大致如下":["78.8"],"假设一个场景":["78.9"],"我们的项目里需要接入多个平台的支付":["78.9"],"sdk":["78.9"],"最开始只有微信支付和支付宝":["78.9"],"wechatpaysdk":["78.9"],"alipaysdk":["78.9"],"然后又多了美团支付":["78.9"],"虚拟货币支付":["78.9"],"q":["78.9"],"币":["78.9"],"信用卡支付等等":["78.9"],"meituanpaysdk":["78.9"],"creditcardpaysdk":["78.9"],"qqcoinpaysdk":["78.9"],"随着业务的不断发展":["78.9"],"项目中可能需要引入越来越多的支付":["78.9"],"甚至还有比特币和以太坊":["78.9"],"此时将这些所有的支付都放在一个文件内未免过于杂乱了":["78.9"],"这些支付方式其实大致可以分成两种":["78.9"],"现实货币与虚拟货币":["78.9"],"此时我们就可以使用命名空间来区分这两类":["78.9"],"namespace":["78.9"],"realcurrency":["78.9"],"当我们导入一个类型时其实并不需要额外的操作":["78.10"],"和导入一个实际值是完全一样的":["78.10"],"footype":["78.10"],"在工程层面的基础能力":["78.11"],"类型指令":["78.11"],"jsdoc":["78.13","89.8"],"文件中获得类型提示":["78.13"],"在上面我们提到了可以在":["78.13"],"文件中通过":["78.13"],"来标注变量类型":["78.13"],"react":["79.0","79.1","79.2","79.3","79.8","79.10","79.12","79.16","79.17","79.19","81.0","85.5","86.35","88.4","89.6"],"项目中的":["79.0"],"集成":["79.0"],"能进行非常紧密而自然的协作":["79.0"],"毕竟":["79.0"],"这里我们使用":["79.1"],"vite":["79.1","79.2","93.3","95.2"],"来进行项目搭建":["79.1"],"在终端输入以下代码":["79.1"],"npx":["79.1","80.1"],"create":["79.1","79.19"],"输入项目名":["79.1"],"选择":["79.1"],"先不急着开始":["79.2"],"我们先观察基于":["79.2"],"创建的初始项目里都包含了哪些配置":["79.2"],"首先是依赖":["79.2"],"可以看到在":["79.2"],"devdependencies":["79.2"],"中包含了":["79.2"],"dom":["79.2","79.9","116.0"],"包的作用我们在前面一节已经了解过":["79.2"],"会自动加载":["79.2"],"modules":["79.2","85.12"],"下的类型定义来在全局使用":["79.2"],"首先我们来想想":["79.3"],"中如何声明一个":["79.3"],"最简单的方式肯定是直接声明一个函数":["79.3"],"tsx":["79.3","79.4","79.6","85.5"],"container":["79.3","79.6","79.9","84.3","84.4","97.6"],"对于组件的":["79.3"],"我们可以就像在函数中标注参数类型一样":["79.3"],"icontainerprops":["79.3"],"visible":["79.3"],"使用简单函数和使用":["79.4"],"fc":["79.4"],"的重要差异之一就在于":["79.4"],"时你无法再使用组件泛型":["79.4"],"组件泛型即指":["79.4"],"为你的组件属性再次添加一个泛型":["79.4"],"比如这样":["79.4"],"propswithchildren":["79.4"],"常见的泛型坑位主要还是来自于日常使用最多的":["79.5"],"可以由输入值隐式推导或者显式传入泛型":["79.6"],"推导为":["79.6"],"state1":["79.6"],"setstate1":["79.6"],"usememo":["79.7"],"然后是":["79.7"],"它们的泛型参数分别表示包裹的函数和计算产物":["79.7"],"使用方式类似":["79.7"],"也分为":["79.7"],"可以被视为更复杂一些的":["79.8"],"usestate":["79.8","79.10","86.35","89.6"],"它们关注的都是数据的变化":["79.8"],"不同的是":["79.8"],"中只能由":["79.8"],"reducer":["79.8"],"按照特定的":["79.8"],"来修改数据":["79.8"],"但":["79.8","82.1","88.1"],"则可以随意修改":["79.8"],"有三个泛型坑位":["79.8"],"分别为":["79.8"],"函数的类型签名":["79.8"],"数据的结构以及初始值的计算函数":["79.8"],"我们直接看实际使用即可":["79.8"],"initialstate":["79.8"],"useimperativehandle":["79.9"],"的常见使用场景主要包括两种":["79.9"],"存储一个":["79.9"],"元素引用和持久化保存一个值":["79.9"],"这两者情况对应的类型其实也是不同的":["79.9"],"domref":["79.9"],"htmldivelement":["79.9"],"valueref":["79.9"],"operateref":["79.9"],"current":["79.9"],"getboundingclientrect":["79.9"],"除了上面介绍的泛型坑位以外":["79.10"],"中想要用好":["79.10"],"的另一个关键因素就是使用":["79.10"],"提供的类型定义":["79.10"],"最常见的就是事件类型":["79.10"],"比如输入框值变化时的":["79.10"],"changeevent":["79.10"],"和鼠标事件通用的":["79.10"],"mouseevent":["79.10"],"还有一部分内置类型并不是日常开发中常用的":["79.11"],"当你基于原生":["79.12"],"元素去封装组件时":["79.12"],"通常会需要将这个原生元素的所有":["79.12"],"属性都保留下来作为组件的属性":["79.12"],"此时你肯定不能一个个声明所有属性":["79.12"],"那么就可以使用":["79.12"],"来提取出一个元素上所有的属性":["79.12"],"reactnode":["79.13"],"在前面的例子中你可能注意到了":["79.13"],"这两个类型":["79.13"],"介绍了上面的项目配置与组件声明":["79.14"],"泛型坑位相关内容以后":["79.14"],"在实际应用中使用":["79.15"],"进行开发时":["79.15"],"我们往往需要大量的类型代码":["79.15"],"而如何存放这些类型代码":["79.15"],"其实就需要预先有一个明确的规范":["79.15"],"目前我使用的方式是":["79.15"],"在项目中使用一个专门的文件夹存放类型代码":["79.15"],"其中又按照这些类型的作用进行了划分":["79.15"],"其分布大致是这样的":["79.15"],"text":["79.15","88.4","107.87"],"project":["79.15","85.11"],"biz":["79.15"],"父子组件中一个常见的场景是":["79.16"],"父组件导入各个子组件":["79.16"],"传递属性时会进行额外的数据处理":["79.16"],"其结果的类型被这多个子组件共享":["79.16"],"而这个类型又仅被父子组件消费":["79.16"],"不应当放在全局的类型定义中":["79.16"],"并不是完美的":["79.19"],"在前面组件声明部分我们已经了解了使用函数声明组件":["79.19"],"以及使用":["79.19","80.2"],"声明组件的两种形式":["79.19"],"也明确了主要差异":["79.19"],"函数声明组件需要额外的返回值类型标注":["79.19"],"element":["79.19"],"才能校验组件合法":["79.19"],"并且可以再使用组件泛型来进一步确保类型安全":["79.19"],"可以简化函数的声明":["79.19"],"但是无法使用组件泛型":["79.19"],"在这一部分":["79.19"],"我们再来了解下这两者更多的差异":["79.19"],"以及为什么说":["79.19"],"举例来说":["79.19"],"app":["79.19","107.82"],"的最新模板代码里":["79.19"],"已经不再使用":["79.19"],"eslint":["80.0","80.1","80.2","80.3","86.41","89.11"],"我想应该没有过多介绍的必要":["80.0"],"即使你没有主动了解过它":["80.0"],"也一定被动接触过":["80.0"],"它带给你的印象并不一定很好":["80.0"],"有可能是满屏的红色波浪线":["80.0"],"也可能是成千上万条的报错输出":["80.0"],"但你可能也很享受经过":["80.0"],"最简单的方式就是通过":["80.1"],"自带的初始化功能":["80.1"],"然后回答一系列问题即可":["80.1"],"init":["80.1","83.7"],"config":["80.1","93.3","95.2"],"如果你选择了使用":["80.1"],"它会自动为你安装":["80.1"],"一系列工具":["80.1"],"比如上面我们最终安装了这些依赖":["80.1"],"对于已有":["80.1"],"配置的项目":["80.1"],"如果要配置":["80.1"],"其实也很简单":["80.1"],"prettier":["80.2"],"git":["80.2","88.1"],"hooks":["80.2","86.27"],"通常在实际项目开发时":["80.2"],"我们并不会仅仅使用":["80.2"],"还有一系列辅助的工具":["80.2"],"比如我们可以同时使用":["80.2"],"lint":["80.2"],"staged":["80.2"],"确保项目代码在提交前被格式化过":["80.2"],"这一部分我们就来介绍在":["80.2"],"基础上再添加":["80.2"],"它同样是代码格式化工具":["80.2"],"但和":["80.2"],"并不完全等价":["80.2"],"代码文件以外":["80.2"],"也支持":["80.2"],"css":["80.2","93.10","97.1","97.5","97.13","100.2","100.5","110.0","110.4"],"less":["80.2"],"这样的样式文件":["80.2"],"dsl":["80.2"],"声明如":["80.2"],"graphql":["80.2"],"等等":["80.2","85.6"],"我个人的习惯是将除核心代码文件以外的部分":["80.2"],"json":["80.2","81.7","85.8","85.9","85.10","85.11","85.17","86.27","89.7","94.8","96.6"],"markdown":["80.2"],"等全交给":["80.2"],"进行格式化":["80.2"],"的核心差异在于它并不包括":["80.2"],"no":["80.2"],"xxx":["80.2"],"不允许某些语法":["80.2"],"prefer":["80.2"],"对于多种功能一致的语法":["80.2"],"推荐使用其中某一种":["80.2"],"下的":["80.3"],"规则集推荐":["80.3"],"在前面我们只是介绍了如何配置":["80.3"],"相关的工程":["80.3"],"还没有具体介绍":["80.3"],"下应使用哪些":["80.3"],"规则":["80.3"],"为了帮助你更好地挑选适用于自己需要的规则":["80.3"],"接下来我们会来介绍一批推荐使用的":["80.3"],"包括其意图":["80.3"],"中同时支持使用":["80.6"],"thenable":["80.7"],"只允许对异步函数":["80.7"],"assertions":["80.8"],"支持通过":["80.8","80.9"],"definitions":["80.9"],"声明对象类型":["80.9"],"此规则可将其收束到统一的声明方式":["80.9"],"即仅使用其中的一种":["80.9"],"先说我是怎么做的":["80.9"],"of":["80.10","81.7","84.1","85.25"],"在你使用":["80.10"],"nullish":["80.11","82.4"],"coalescing":["80.11","82.4"],"optional":["80.11","82.3"],"chain":["80.11"],"imports":["80.12"],"约束使用":["80.12"],"进行类型的导入":["80.12"],"compileroptions":["80.12","85.11","86.27","86.28"],"nullable":["80.13"],"assertion":["80.13"],"style":["80.13","80.29","107.123"],"member":["80.15"],"对于枚举成员值":["80.15"],"只允许使用普通字符串":["80.15"],"数字":["80.15"],"正则":["80.15"],"而不允许变量复制":["80.15"],"模板字符串等需要计算的操作":["80.15"],"unnecessary":["80.18","80.25","80.26","80.37"],"comment":["80.20"],"禁止":["80.20"],"extra":["80.22"],"non":["80.22","80.23","80.24"],"constraint":["80.26"],"signature":["80.29"],"方法签名的声明方式有":["80.29"],"property":["80.29","82.3"],"禁止部分值被作为类型标注":["80.31"],"此规则能够对每一种被禁用的类型提供特定的说明来在触发此规则报错时给到良好的提示":["80.31"],"这条规则常见的场景是禁用":["80.31"],"empty":["80.32"],"explicit":["80.33"],"不允许显式的":["80.33"],"inferrable":["80.34"],"不允许不必要的类型标注":["80.34"],"但可配置为允许类的属性成员":["80.34"],"boundary":["80.35"],"compare":["80.37"],"throw":["80.38","82.10"],"不允许直接":["80.38"],"exhaustiveness":["80.39"],"的判定变量为联合类型时":["80.39"],"其每一个类型分支都需要被处理":["80.39"],"possibletypes":["80.39"],"expressions":["80.40"],"模板字符串中的计算表达式其返回值必须是字符串":["80.40"],"此规则可以被配置为允许数字":["80.40"],"reduce":["80.41"],"parameter":["80.41","107.80"],"我们在泛型一节中曾经介绍过数组":["80.41"],"方法的各种重载":["80.41"],"比如下面这种":["80.41"],"slash":["80.42"],"reference":["80.42"],"这一规则的目的在于禁止你使用三斜线指令":["80.42"],"这一部分的工具主要在项目开发阶段使用":["81.1"],"tsc":["81.4","81.6","86.38","89.1"],"onfailure":["81.6"],"echo":["81.6"],"beep":["81.6"],"compilation":["81.6"],"failed":["81.6"],"schema":["81.7","81.10","88.4"],"如以下代码":["81.7"],"shape":["81.7"],"size":["81.7"],"以下工具库主要针对类型":["81.8"],"包括提供通用工具类型与对工具类型进行测试":["81.8"],"fest":["81.8"],"不用多介绍了":["81.8"],"以下这些工具通常用于在项目逻辑中进行具有实际逻辑的校验":["81.9"],"zod":["81.10"],"核心优势在于与":["81.10"],"的集成":["81.10"],"如能从":["81.10"],"中直接提取出类型":["81.10"],"z":["81.10"],"user":["81.10","83.8","84.2","87.3"],"username":["81.10"],"parse":["81.10","94.8"],"ludwig":["81.10"],"coverage":["81.11"],"以下工具主要在构建阶段起作用":["81.12"],"esbuild":["81.12","86.30"],"应该无需过多介绍":["81.12"],"compiler":["81.12","89.1","89.9"],"还是存在一些构建层面的差异":["81.12"],"这一节我们汇总了各个场景下的":["81.13"],"我们来讲解":["82.0"],"这个单词":["82.1"],"没有关系":["82.1"],"正确发音近似于":["82.1"],"诶可码":["82.1"],"script":["82.1"],"确实是有关系的":["82.1"],"的全称是":["82.1"],"european":["82.1"],"computer":["82.1"],"manufacturers":["82.1"],"association":["82.1"],"欧洲计算机制造商协会":["82.1"],"它并不是为了卖货而生的":["82.1"],"这一国际组织的存在主要是维护各种计算机的相关标准":["82.1"],"从硬件到软件到编程语言等等":["82.1"],"最初创建":["82.1"],"这门语言的公司是网景":["82.1"],"主推产品即为网景浏览器":["82.1"],"由于在和微软":["82.1"],"ie":["82.1"],"目前在":["82.2"],"已经合入的":["82.2"],"语法主要有这么几个":["82.2"],"可选链":["82.2"],"chainning":["82.3"],"如果访问一个嵌套多层的属性":["82.3"],"为了避免出现":["82.3"],"cannot":["82.3"],"read":["82.3"],"如果说可选链是为了取代":["82.4"],"逻辑与":["82.4"],"那么空值合并就是为了取代":["82.4"],"逻辑或":["82.4"],"而逻辑或的主要使用场景之一就是提供默认值":["82.4"],"logical":["82.5"],"assignment":["82.5"],"逻辑赋值是在复合赋值的基础上演进而来":["82.5"],"或者说关系一致":["82.5"],"都是将一个操作符和赋值符号结合在一起":["82.5"],"比如我们最常见的复合赋值":["82.5"],"我们了解了让人傻傻分不清楚的":["82.6"],"除了我们上面讲到的可选链":["82.8"],"空值合并":["82.8"],"内置的不可变数据类型":["82.9"],"有相当一部分提案实际上有着函数式编程的理念背景":["82.10"],"如果你了解过":["82.11"],"rxjs":["82.11"],"那么肯定马上就":["82.11"],"到了这个提案想要干啥":["82.11"],"如果你对面向表达式的语法感到兴趣":["82.12"],"那么我想下面这几个函数式操作符相关的提案也会引起你的关注":["82.12"],"如果你想详细了解它们的使用与差异":["82.12"],"可以阅读笔者此前的文章":["82.12"],"你应该了解的":["82.12"],"函数操作符相关提案的最新进展":["82.12"],"pipeline":["82.12"],"operator":["82.12"],"它引入了":["82.12"],"语法来实现数据流编程的范式":["82.12"],"如以下的":["82.12"],"代码":["82.12","89.1"],"one":["82.12"],"中的类型提案":["82.13"],"年":["82.13"],"月会议中":["82.13"],"团队推进的":["82.13"],"annotations":["82.13"],"的关系":["83.0"],"以及可选链与空值合并这两个":["83.0"],"其实":["83.0"],"还有一个":["83.0"],"类装饰器是直接作用在类上的装饰器":["83.2"],"它在执行时的入参只有一个":["83.2"],"那就是这个类本身":["83.2"],"而不是类的原型对象":["83.2"],"我们可以通过类装饰器来覆盖类的属性与方法":["83.2"],"如果你在类装饰器中返回一个新的类":["83.2"],"它甚至可以篡改掉整个类的实现":["83.2"],"addproperty":["83.2"],"addmethod":["83.2"],"classdecorator":["83.2","84.4","84.7"],"prototype":["83.2","83.10","96.8","101.23"],"newinstancemethod":["83.2"],"方法装饰器的入参包括":["83.3"],"类的原型":["83.3","83.5","83.6"],"方法名":["83.3","84.2"],"方法的属性描述符":["83.3"],"propertydescriptor":["83.3"],"而通过属性描述符你可以控制这个方法的内部实现":["83.3"],"可变性":["83.3"],"writable":["83.3"],"访问符装饰器并不常见":["83.4"],"甚至访问符对于部分同学来说也是陌生的":["83.4"],"但它其实就是":["83.4"],"这样的方法":["83.4"],"getter":["83.4"],"在你访问这个属性":["83.4"],"时触发":["83.4"],"setter":["83.4"],"属性装饰器在独立使用时能力非常有限":["83.5"],"它的入参只有":["83.5"],"属性名称":["83.5"],"返回值会被忽略":["83.5"],"参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器":["83.6"],"它的入参包括":["83.6"],"参数名":["83.6"],"装饰器的执行机制中主要包括":["83.7"],"执行时机":["83.7"],"执行原理":["83.7"],"执行顺序":["83.7"],"这三个概念":["83.7"],"首先是执行时机":["83.7"],"还记得我们在最开始说的吗":["83.7"],"装饰器的本质就是一个函数":["83.7"],"因此只要在类上定义了它":["83.7"],"即使不去实例化这个类或者读取静态成员":["83.7"],"它也会正常执行":["83.7"],"很多时候":["83.7","89.8"],"其实我们也并不会实例化具有装饰器的类":["83.7"],"而是通过反射元数据的能力来消费":["83.7"],"这一点我们后面会讲到":["83.7"],"而装饰器的执行原理":["83.7"],"我们可以通过编译后的代码来了解":["83.7"],"cls":["83.7"],"constructor":["83.7","84.1","101.25"],"param":["83.7"],"method":["83.7","83.10","84.2"],"这一段代码编译的产物会是这样的":["83.7"],"另外":["83.8"],"我们也可以使用多个同种装饰器":["83.8"],"比如一个类上可以有好多个类装饰器":["83.8"],"deprecated":["83.8"],"internal":["83.8"],"provide":["83.8","84.3","84.4"],"这种情况下":["83.8"],"这些装饰器的执行顺序又是怎样的":["83.8"],"其顺序分为两步":["83.8"],"由上至下":["83.8"],"reflect":["83.9","83.10"],"es6":["83.9","85.6","85.23","85.25","86.14","96.5","101.43"],"中被首次引入":["83.9"],"它主要是为了配合":["83.9"],"proxy":["83.9"],"保留一份方法原始的实现逻辑":["83.9"],"如以下来自阮一峰老师的":["83.9"],"标准入门中":["83.9"],"一节的代码":["83.9"],"metadata":["83.10","84.2"],"不同于反射":["83.10"],"这一提案虽然同样很早就被提出":["83.10"],"但至今都未真正的成为":["83.10"],"的一部分":["83.10"],"原因在于元数据和装饰器提案的联系非常紧密":["83.10"],"随着装饰器提案迟迟不能推进":["83.10"],"元数据当然也无法独自向前":["83.10"],"想要使用反射元数据":["83.10"],"你还需要安装":["83.10"],"并在入口文件中的顶部":["83.10"],"反射元数据提案":["83.10"],"为顶级对象":["83.10"],"新增了一批专用于元数据读写的":["83.10"],"api":["83.10","87.0","89.1","89.2","89.9","118.0","121.1","121.3"],"definemetadata":["83.10"],"getmetadata":["83.10"],"那么元数据又是什么":["83.10"],"你可以将元数据理解为":["83.10"],"用于描述数据的数据":["83.10"],"如某个方法的参数信息":["83.10"],"返回值信息就可称为该方法的元数据":["83.10"],"那么元数据又存储在哪里":["83.10"],"提案中专门说明了这一点":["83.10"],"为类或类属性添加了元数据后":["83.10"],"或是构造函数的原型":["83.10"],"根据静态成员还是实例成员决定":["83.10"],"会具有":["83.10"],"该属性内部包含一个":["83.10"],"键为属性键":["83.10"],"值为元数据键值对":["83.10"],"也就是说":["83.10","87.3"],"静态成员的元数据信息存储于构造函数":["83.10"],"实例成员的元数据信息存储于构造函数的原型上":["83.10"],"我们来简单使用下元数据的注册与提取":["83.10"],"proto":["83.10"],"的入参包括元数据":["83.10"],"元数据":["83.10"],"目标类":["83.10"],"以及一个可选的属性":["83.10"],"在这里我们的三个调用分别是在":["83.10"],"正如我们在开头提到的":["83.13"],"装饰器从被作为一个提案提出开始":["83.13"],"很是经历了一番风雨":["83.13"],"下面我们就来具体介绍一下它到底都经历了些什么":["83.13"],"首先需要明确的是":["83.13"],"目前":["83.13"],"中的装饰器":["83.13"],"和我们这节学习的":["83.13"],"装饰器基本是两件完全不同的事物":["83.13"],"装饰器提案":["83.13"],"距离最开始提出已经过去了数年":["83.13"],"decorate":["83.14"],"如果你去观察了装饰器的编译代码":["83.14"],"会发现":["83.14"],"这一节我们将在其基础上来了解":["84.0"],"控制反转即":["84.1"],"inversion":["84.1"],"control":["84.1"],"它是面向对象编程中的一种设计模式":["84.1"],"可以用来很好地解耦代码":["84.1"],"由于控制反转出现的时间较晚":["84.1"],"因而没有被包括在四人组的设计模式一书当中":["84.1"],"但它仍然是一种设计模式":["84.1"],"假设我们存在多个具有依赖关系的类":["84.1"],"可能会想当然这么写":["84.1"],"moda":["84.1"],"modb":["84.1"],"本节的代码是我最初在深入浅出":["84.2"],"一书中学习到的内容":["84.2"],"个人认为非常适合用于加深对依赖注入的理解":["84.2"],"因此在其基础上进一步完善后":["84.2"],"作为本节的实例代码":["84.2"],"我们的最终目的就是实现上面基于装饰器的路由能力":["84.2"],"以及启动一个":["84.2"],"server":["84.2"],"来完成对这个路由的承接":["84.2"],"分析一下我们需要哪些能力":["84.2"],"最重要的就是把每个方法对应的请求路径":["84.2"],"请求方法和具体实现绑定起来":["84.2"],"也就是在":["84.2"],"我们需要调用":["84.2"],"userlist":["84.2"],"并将返回值作为响应":["84.2"],"在方法的装饰器":["84.2"],"post":["84.2"],"我们就可以将请求方法":["84.2"],"请求路径":["84.2"],"方法实现等信息注册为元数据":["84.2"],"然后通过一个统一的提取手段来将它们组装起来":["84.2"],"ioc":["84.2","84.3","87.2"],"path":["84.2","86.27","89.2"],"middleware":["84.2"],"request":["84.2"],"容器":["84.3"],"实现一个简单的":["84.3"],"容器可以很好地帮助我们总结装饰器":["84.3"],"依赖注入":["84.3"],"元数据的相关知识":["84.3"],"以及理解":["84.3"],"控制反转":["84.3"],"的本质":["84.3"],"关于这个容器":["84.3"],"我们最终想实现的使用方式是这样的":["84.3"],"driver":["84.3"],"adapt":["84.3"],"consumer":["84.3"],"驱动已生效于":["84.3"],"car":["84.3"],"inject":["84.3","84.4"],"run":["84.3"],"先来梳理一下思路":["84.3"],"要实现这么个效果":["84.3"],"首先我们需要一个容器":["84.3"],"即控制反转中提到的":["84.3"],"独立的控制方":["84.3"],"其实最难的一部分我们已经解决了":["84.4"],"即如何存储并对应地进行注入":["84.4"],"现在要做的不过是升级优化一下":["84.4"],"支持在不传入标识符时使用内置元数据作为标识符":["84.4"],"首先对":["84.4"],"做改造":["84.4"],"classstruct":["84.4"],"在这两节":["84.5"],"我们花了相当长的篇幅对装饰器相关的概念与实际应用进行了一次彻底介绍":["84.5"],"从装饰器语法到不同类型装饰器的使用":["84.5"],"在这一节的代码中":["84.7"],"我们并没有特别关注类型的严格性":["84.7"],"实际上装饰器的类型定义也是如此":["84.7"],"tfunction":["84.7"],"propertydecorator":["84.7"],"propertykey":["84.7"],"这些类型定义使用的是非常宽泛的类型":["84.7"],"并没有进行对应的约束":["84.7"],"而如果将这些类型进行约束":["84.7"],"实际上我们就可以实现一个类型严格的装饰器":["84.7"],"如我们希望装饰器":["84.7"],"我们已经学习了":["85.0"],"在工程中的许多实践":["85.0"],"包括类型声明":["85.0"],"emitdecoratormetadata":["85.4"],"这两个选项都和装饰器有关":["85.4"],"选项用于启用装饰器的":["85.4"],"配置则影响装饰器实际运行时的元数据相关逻辑":["85.4"],"jsxfactory":["85.5"],"jsxfragmentfactory":["85.5"],"jsximportsource":["85.5"],"这部分配置主要涉及":["85.5"],"相关的语法特性":["85.5"],"配置将直接影响":["85.5"],"组件的构建表现":["85.5"],"常见的主要有":["85.5"],"将":["85.5"],"组件转换为对":["85.5"],"createelement":["85.5"],"调用":["85.5","86.35"],"生成":["85.5","86.39"],"preserve":["85.5"],"原样保留":["85.5"],"你可以接着让其他的编译器进行处理":["85.5"],"native":["85.5"],"类似于":["85.5","85.14","85.16","88.1"],"但会生成":["85.5"],"如果你希望使用特殊的":["85.5"],"nolib":["85.6"],"配置决定了你的构建代码使用的语法":["85.6"],"常用值包括":["85.6"],"es5":["85.6","86.19"],"es2018":["85.6"],"es2021":["85.6"],"esnext":["85.6"],"基于目前的":["85.6"],"版本所支持的最新版本":["85.6"],"某些来自于更高版本":["85.6"],"的语法":["85.6"],"会在编译到更低版本时进行语法的降级":["85.6"],"常见的如异步函数":["85.6"],"箭头函数":["85.6"],"bigint":["85.6"],"数据类型等":["85.6"],"这部分配置主要控制源码解析":["85.7"],"这三个选项决定了将被包括到本次编译的代码文件":["85.8"],"我们可以描述本次包含的所有文件":["85.8"],"但不能使用":["85.8"],"或者":["85.8","85.13"],"这种方式":["85.8"],"每个值都需要是完整的文件路径":["85.8"],"适合在小型项目时使用":["85.8"],"这一配置可以定义文件进行解析的根目录":["85.9"],"它通常会是一个相对路径":["85.9"],"然后配合":["85.9"],"tsconfig":["85.9","85.10","86.0","86.27","86.42"],"配置决定了项目文件的根目录":["85.10"],"默认情况下它是项目内":["85.10"],"的所有":["85.10"],"文件的最长公共路径":["85.10"],"这里有几处需要注意":["85.10"],"指的是":["85.10"],"files":["85.10"],"中包括的":["85.10"],"这些文件一般来说不会和":["85.10"],"位于同一目录层级":["85.10"],"不包括":["85.10"],"就是复数版本的":["85.11"],"rootdir":["85.11"],"它接收一组值":["85.11"],"并且会将这些值均视为平级的根目录":["85.11"],"zh":["85.11"],"en":["85.11"],"jp":["85.11"],"typeroots":["85.12"],"默认情况下":["85.12","85.15","85.26","86.25","107.50"],"会加载":["85.12"],"下的所有声明文件":["85.12"],"包括嵌套的":["85.12"],"这一配置指定了模块的解析策略":["85.13"],"可以配置为":["85.13"],"classic":["85.13"],"为默认值":["85.13"],"主要作向后兼容用":["85.13"],"基本不推荐使用":["85.13"],"首先来看":["85.13"],"解析模式":["85.13"],"从名字也能看出来它其实就是与":["85.13"],"一致的解析模式":["85.13"],"假设我们有个":["85.13"],"此配置在":["85.14"],"版本被引入":["85.14"],"启用了这一配置后":["85.17"],"你就可以直接导入":["85.17"],"outfile":["85.20"],"这两个选项决定了构建产物的输出文件":["85.20"],"配置的值将包括所有的构建产物":["85.20"],"在字面量类型与枚举一节中了解过":["85.21"],"noemitonerror":["85.22"],"这一配置控制最终":["85.23"],"产物使用的模块标准":["85.23"],"常见的包括":["85.23"],"noemithelpers":["85.24"],"由于":["85.24"],"在编译时除了抹除类型":["85.24"],"还需要基于":["85.24"],"进行语法降级":["85.24"],"这一功能往往需要一些辅助函数":["85.24"],"将新语法转换为旧语法的实现":["85.24"],"在同样能实现语法降级的":["85.24"],"babel":["85.24","89.0","89.1"],"新增了":["85.25"],"循环":["85.25"],"它可以用于循环遍历所有部署了":["85.25"],"接口的数据结构":["85.25"],"如数组":["85.25"],"甚至还包括字符串":["85.25"],"在默认情况下":["85.25"],"preservevalueimports":["85.26"],"就在编译时去抹除仅类型导入":["85.26"],"但如果你希望保留这些类型导入语句":["85.26"],"可以通过更改":["85.26"],"配置的值来改变其行为":["85.26"],"此配置的值为":["85.26"],"declarationdir":["85.28"],"这两个选项主要控制声明文件的输出":["85.28"],"选项会为声明文件也生成":["85.29"],"此配置会让最终构建结果只包含构建出的声明文件":["85.30"],"以下配置均和":["85.31"],"以下选项主要控制产物代码中的代码格式化":["85.32"],"或者说代码风格相关":["85.32"],"我们就放在一起介绍了":["85.32"],"newline":["85.32"],"指定文件的结尾使用":["85.32"],"crlf":["85.32"],"还是":["85.32"],"这一节我们介绍了构建相关的配置":["85.33"],"这部分的配置主要控制对源码中语法与类型检查的严格程度":["86.1"],"这一部分的配置关注的语法通常是有害的":["86.2"],"这一配置会允许你直接使用":["86.3"],"umd":["86.3"],"格式的模块而不需要先导入":["86.3"],"比如你通过":["86.3"],"cdn":["86.3","93.3","93.12"],"引入或是任何方式来确保全局一定会有这个变量":["86.3"],"格式其实就是通用模块规范":["86.3"],"兼容了":["86.3"],"amd":["86.3"],"unreachable":["86.4"],"通常指的是无法执行到的代码":["86.4"],"也称":["86.4"],"dead":["86.4"],"label":["86.5"],"并不是我们经常会接触的概念":["86.5"],"它的语法大致是这样":["86.5"],"somelabel":["86.5"],"statement":["86.5"],"这部分配置的关注点其实除了类型":["86.6"],"在你没有为变量或参数指定类型":["86.8"],"也无法自动推导其类型时":["86.8"],"这里变量的类型就会被推导为":["86.8"],"启用此配置后":["86.9"],"try":["86.9"],"catch":["86.9"],"语句中":["86.9"],"这一配置确保在你的":["86.11"],"语句中不会存在连续执行多个":["86.11"],"语句的情况":["86.11"],"注意":["86.11","96.6"],"在函数与":["86.12"],"一节我们有讲到":["86.12"],"在派生类继承于基类时":["86.12"],"通常我们":["86.12"],"这一配置会确保所有返回值类型中不包含":["86.13"],"的函数":["86.13"],"在其内部所有的执行路径上都需要有":["86.13"],"代码中":["86.14"],"我们其实经常见到":["86.14"],"的指向也一直是一个很烦人的问题":["86.14"],"虽然在":["86.14"],"nouncheckedindexedaccess":["86.15"],"在索引类型一节我们知道":["86.15"],"可以通过索引签名类型来声明一个仅确定键值类型而不确定具体属性的接口":["86.15"],"这一配置会使得":["86.18"],"对可选属性":["86.18"],"即使用":["86.18"],"修饰的属性":["86.18"],"启用更严格检查":["86.18"],"如以下这个例子":["86.18"],"itheme":["86.18"],"还记得":["86.19"],"其实是一组规则的开关":["86.20"],"中可以通过":["86.21"],"bind":["86.21","96.9"],"call":["86.21","96.9","101.47"],"apply":["86.21","96.9","101.50"],"对函数类型启用更严格的检查":["86.22"],"即我们在函数类型比较一节中讲到的":["86.22"],"对参数类型启用逆变检查":["86.22"],"fn":["86.22"],"这是在任何规模项目内都应该开启的一条规则":["86.23"],"在这条规则关闭的情况下":["86.23"],"会被隐式地视为任何类型的子类型":["86.23"],"还记得我们前面的例子吗":["86.23"],"以下两个仅在关闭":["86.23"],"这一配置要求":["86.24"],"中的所有属性都需要存在一个初始值":["86.24"],"无论是在声明时就提供还是在构造函数中初始化":["86.24"],"prop1":["86.24"],"skipdefaultlibcheck":["86.25"],"references":["86.27"],"这一配置使得你可以将整个工程拆分成多个部分":["86.27"],"比如你的":["86.27"],"ui":["86.27","107.7"],"部分以及主应用等等":["86.27"],"这一功能和":["86.27"],"monorepo":["86.27"],"非常相似":["86.27"],"但它并不需要各个子项目拥有自己独立的":["86.27"],"package":["86.27"],"独立安装依赖":["86.27"],"独立构建等":["86.27"],"我们可以定义这些部分的引用关系":["86.27"],"为它们使用独立的":["86.27"],"我们常常提到的":["86.30"],"构建过程会使用":["86.30"],"配合其他构建器":["86.30"],"只有在开启此配置后":["86.32"],"通常用于配合":["86.33"],"allowjs":["86.33"],"allowsyntheticdefaultimports":["86.35"],"这两个配置主要还是为了解决":["86.35"],"es":["86.35"],"之间的兼容性问题":["86.35"],"esm":["86.35"],"cjs":["86.35"],"都不会有问题":["86.35"],"但如果是":["86.35"],"就可能遇到奇怪的问题":["86.35"],"中的源码中是这样导出的":["86.35"],"development":["86.35"],"exports":["86.35"],"children":["86.35"],"memo":["86.35","89.6"],"useeffect":["86.35"],"假设我们分别使用具名导入":["86.35"],"默认导入和命名空间导入来导入":["86.35"],"useref":["86.35"],"具名导入":["86.35"],"named":["86.35"],"默认导入":["86.35"],"我们可以通过":["86.38"],"来启动一个监听模式的":["86.38"],"它会在代码文件发生变化":["86.38"],"同样会对":["86.38"],"这里的配置主要用于检查编译器的工作情况":["86.39"],"或者在你需要进行编译器性能优化时使用":["86.39"],"它们会生成编译器工作的分析报告":["86.39"],"包括本次编译包含了哪些文件":["86.39"],"以及各个编译阶段":["86.39"],"i":["86.39","96.23","99.3"],"checking":["86.39"],"的耗时":["86.39"],"diagnostics":["86.39"],"extendeddiagnostics":["86.39"],"输出诊断信息":["86.39"],"会生成可读性更好的版本":["86.39"],"generatecpuprofile":["86.39"],"cpu":["86.39"],"的耗时报告":["86.39"],"这一配置可以类比到":["86.41"],"配置中的":["86.41"],"作用就是复用已有的文件":["86.41"],"我们了解了检查相关和工程相关的":["86.42"],"其中有些配置涉及前端领域的其他知识":["86.42"],"如在":["86.42"],"esmoduleinterop":["86.42"],"我们会使用":["87.0","89.8"],"来开发一个":["87.0"],"并将它部署在服务器上":["87.0"],"环境配置":["87.1"],"在正式开始前":["87.1"],"我们不妨提前配置好":["87.1"],"基础":["87.2","87.3"],"接下来":["87.2"],"我们来了解":["87.2"],"的基础概念":["87.2"],"是一个":["87.2","87.3"],"框架":["87.2"],"它和":["87.2"],"express":["87.2"],"koa":["87.2"],"egg":["87.2"],"的主要区别其实就两点":["87.2"],"应用风格":["87.2"],"框架能力":["87.2"],"我们先来说应用风格":["87.2"],"中大量地使用了装饰器以及依赖注入":["87.2"],"di":["87.2"],"相关的理念":["87.2"],"这一点官方团队自谦是受到了":["87.2"],"angular":["87.2"],"的启发":["87.2"],"而这也就意味着":["87.2"],"在开发规模较大的项目时":["87.2"],"nest":["87.2"],"也能够很好地保持项目间各个模块的引用关系清晰解耦":["87.2"],"其实随着项目规模的不断扩大":["87.2"],"会需要开发者更有意识去进行依赖关系的维护":["87.2"],"而框架能力其实也是许多团队与企业在技术选型时的重要参考因素":["87.2"],"在这一点上":["87.2"],"内置了路由":["87.2"],"请求":["87.2"],"表单":["87.2"],"校验":["87.2"],"ssr":["87.2","88.4"],"等能力":["87.2"],"是一个真正意义上的":["87.2"],"比较特殊":["87.3"],"orm":["87.3","87.8"],"为什么这么说呢":["87.3"],"relational":["87.3"],"mapping":["87.3"],"其实就是编程语言到":["87.3"],"sql":["87.3","87.9"],"的映射":["87.3"],"我们无需学习":["87.3"],"直接用最熟悉的代码调用方法":["87.3"],"即可与数据库进行交互":["87.3"],"目前基本都是通过":["87.3"],"文件进行定义的":["87.3"],"sequelize":["87.3"],"typeorm":["87.3","87.8"],"均是通过面向对象的方式进行数据库实体的定义":["87.3"],"entity":["87.3"],"primarygeneratedcolumn":["87.3"],"column":["87.3"],"id":["87.3","88.4","89.7"],"firstname":["87.3"],"lastname":["87.3"],"这就是":["87.3"],"nestjs":["87.4","87.5","88.4"],"中集成":["87.4"],"prisma":["87.4","87.5","88.2","88.4"],"其实也非常简单":["87.4"],"秉持着模块化的理念":["87.4"],"我们将":["87.4"],"相关的逻辑单独放到一个模块中":["87.4"],"新建":["87.4"],"service":["87.4","87.7"],"injectable":["87.4"],"onapplicationshutdown":["87.4"],"onapplicationbootstrap":["87.4"],"common":["87.4"],"prismaclient":["87.4"],"client":["87.4","88.4"],"prismaservice":["87.4"],"这一节我们学习了":["87.5"],"框架与":["87.5"],"应用目录结构的不同组织方式":["87.7"],"前面我们介绍了":["87.7"],"controller":["87.7"],"等文件的基本功能":["87.7"],"除此以外":["87.7"],"应用中其实存在着两种不同的文件组织风格":["87.7"],"按功能与按逻辑进行拆分":["87.7"],"按功能进行拆分":["87.7"],"即我们本节的应用使用的方式":["87.7"],"mapper":["87.8"],"active":["87.8"],"即使你此前已经有过":["87.8"],"的实践经验":["87.8"],"还有两个概念可能是你未了解过的":["87.8"],"typeorm的简介中提到":["87.8"],"supports":["87.8"],"both":["87.8"],"and":["87.8"],"patterns":["87.8"],"即它同时支持了这两种模式":["87.8"],"那么这两种模式对代码有什么影响":["87.8"],"querybuilder":["87.9"],"并不是唯一一种让我们可以不用写":["87.9"],"就能操作数据库的方式":["87.9"],"同时它也不是最贴近":["87.9"],"的方式":["87.9","103.11"],"query":["87.9"],"上一节最开始安装的环境应该差不多了":["88.0"],"初体验":["88.1"],"前端社区有非常多的免费云服务":["88.1"],"它们的作用各不相同":["88.1"],"但基本上能找到所有你需要的":["88.1"],"surge":["88.1"],"提供了快捷的静态页面部署":["88.1"],"vercel":["88.1"],"提供了与":["88.1"],"服务集成支持的静态页面部署":["88.1"],"页面指标统计以及免费的":["88.1"],"serverless":["88.1"],"netlify":["88.1"],"函数是收费的":["88.1"],"此外":["88.1"],"一些知名框架也提供了自己的云服务":["88.1"],"gatsby":["88.1"],"heroku":["88.2","88.3"],"数据库":["88.2"],"在你本地的":["88.2"],"文件中修改":["88.2"],"database":["88.2","88.4"],"ini":["88.2"],"postgres":["88.2"],"执行命令":["88.2"],"db":["88.2","88.4","109.1"],"push":["88.2","96.8","96.18"],"这一命令会将我们此前定义的":["88.2"],"万事俱备":["88.3"],"我们现在可以把应用部署到":["88.3"],"上了":["88.3"],"但也别太急":["88.3"],"我们的应用还需要进行一些额外的配置才能在":["88.3"],"上正常的工作":["88.3"],"首先是更改应用的端口号":["88.3"],"在部署这个应用时":["88.3"],"会随机分配一个端口号":["88.3"],"我们的应用需要使用这个端口号来启动":["88.3"],"而这个端口号会通过环境变量的方式提供":["88.3"],"修改":["88.3"],"main":["88.3","94.2","97.6","107.65","107.80"],"开发":["88.4"],"终于到了":["88.4"],"开发环节":["88.4"],"但这一部分的内容反倒最简短":["88.4"],"我们并不会把每一个实体":["88.4"],"文章":["88.4"],"分类":["88.4"],"的方法都实现完":["88.4"],"因为如果你已经有过类似的开发经验":["88.4"],"那这些内容对你来说意义不大":["88.4"],"而如果你此前并无相关开发经验":["88.4"],"更需要自己动手来试一试":["88.4"],"这里就以":["88.4"],"article":["88.4"],"相关的操作为例":["88.4"],"我们会实现全量查找":["88.4"],"的查找":["88.4"],"创建":["88.4","121.4","121.5"],"更新这四个接口":["88.4"],"在这个过程中":["88.4"],"你会了解到":["88.4"],"最基本的使用":["88.4"],"即路由处理与请求参数":["88.4"],"首先你需要确保已经完成了":["88.4"],"的生成与数据库同步":["88.4"],"我们最终的":["88.4"],"如下":["88.4","107.45","107.49"],"your":["88.4"],"file":["88.4"],"learn":["88.4"],"about":["88.4"],"it":["88.4"],"docs":["88.4"],"https":["88.4"],"pris":["88.4"],"ly":["88.4"],"provider":["88.4"],"datasource":["88.4"],"postgresql":["88.4"],"文章的标签":["88.4"],"tag":["88.4"],"cuid":["88.4"],"description":["88.4","89.8","93.11"],"文章的分类":["88.4"],"通过这两节的学习":["88.5"],"我们从":["88.5"],"开发并部署了一个":["88.5"],"的基本工作流程":["89.0"],"在本节的最开始":["89.0"],"我有必要郑重说明下":["89.0"],"我本身并不是科班出身":["89.0"],"没有系统学习过编译原理":["89.0"],"以下涉及编译原理的概念大部分来自于在社区的学习所得":["89.0"],"也欢迎你指出其中的错误":["89.0"],"我将认真对待并修正":["89.0"],"本节原本是被作为短小精悍的漫谈篇呈现的":["89.0"],"但有部分同学反馈对这部分知识确实有刚需":["89.0"],"因此进行了大量内容扩充后加入到正文篇中":["89.0"],"对大部分前端同学来说":["89.0"],"提到编译原理第一时间想到的就是":["89.0"],"即使你没有直接使用过它":["89.0"],"也一定间接地接触过":["89.0"],"不论是已经搭建好的项目还是更底层的":["89.0"],"编译处理":["89.1"],"我们其实仍然可以使用":["89.1"],"本身就将几乎所有":["89.1"],"都暴露了出来":["89.1"],"也就是说如果你希望更贴近":["89.1"],"的行为":["89.1"],"其实更应该使用":["89.1"],"然而相比":["89.1"],"的使用成本要高一些":["89.1"],"我们直接看一个官方例子的精简版本":["89.1"],"大致感受下其使用方式即可":["89.1"],"由于本节的重点并不是详细介绍":["89.1"],"因此并不会对其进行非常详细介绍":["89.1"],"makefactorialfunction":["89.1"],"创建代表函数名":["89.1"],"factorial":["89.1"],"identifier":["89.1"],"结点":["89.1"],"functionname":["89.1"],"createidentifier":["89.1"],"创建代表参数名":["89.1"],"morph":["89.2","89.3"],"上面的例子看下来":["89.2"],"可能有部分同学已经被劝退了":["89.2"],"这一堆眼花缭乱的":["89.2"],"我咋知道啥时候该用哪个":["89.2"],"难道还要先从头学一遍编译原理":["89.2"],"当然不":["89.2"],"你可以永远相信":["89.2"],"社区":["89.2"],"为了简化":["89.2"],"ast":["89.2","89.4","89.5","89.6","89.8"],"的操作":["89.2"],"我们本节的主角":["89.2"],"诞生了":["89.2"],"它的原名为":["89.2"],"simple":["89.2"],"从这两个名字你都能感受到它的目的":["89.2"],"让":["89.2"],"操作更简单一些":["89.2"],"意为变形":["89.2"],"我们直接来看它的使用方式":["89.2"],"直观地感受下它是如何实现更简单的":["89.2"],"操作的":["89.2"],"checker":["89.3","89.4","89.11"],"codemod":["89.3","89.4"],"了解了":["89.3"],"的基本使用":["89.3"],"接下来我们就通过几个具有实际意义的示例进一步掌握它":["89.3"],"这些示例基本都是我遇见过的实际场景":["89.3"],"如果不通过":["89.3"],"导入语句":["89.4"],"许多场景的":["89.4"],"操作中":["89.4"],"其实都会涉及对导入语句的处理":["89.4"],"会将你旧版本的导入更新为新版本的导入":["89.4"],"或者更换导入语句的导入路径":["89.4"],"模块名":["89.4"],"而在某些工程场景下":["89.4"],"也会检查代码中是否进行了必需的":["89.4"],"polyfill":["89.4"],"导入":["89.4"],"我们的源码如下":["89.4"],"readfilesync":["89.4"],"fs":["89.4"],"some":["89.4"],"操作后的代码如下":["89.4"],"添加装饰器":["89.5"],"在装饰器一节我们说到":["89.5"],"可以使用方法装饰器来测量一个方法的调用耗时":["89.5"],"但一个一个加未免太过麻烦":["89.5"],"更好的方式是通过":["89.5"],"来批量处理目标":["89.5"],"的目标方法":["89.5"],"nothandler":["89.5"],"eventhandler":["89.5"],"添加":["89.6"],"为":["89.6"],"组件添加":["89.6"],"是一个常见的优化手段":["89.6"],"我们是否可以通过":["89.6"],"操作来批量为组件添加":["89.6"],"我们的源码是这样的":["89.6"],"comp":["89.6"],"转类型定义":["89.7"],"这个例子可能是最最刚需的一个了":["89.7"],"把后端响应的":["89.7"],"放进去":["89.7"],"就得到了":["89.7"],"的类型定义":["89.7"],"我们输入的":["89.7"],"是这样的":["89.7"],"sex":["89.7"],"favors":["89.7"],"execrise":["89.7"],"writting":["89.7"],"programmer":["89.7"],"stack":["89.7"],"company":["89.7"],"alibaba":["89.7"],"pets":["89.7"],"最终输出的类型定义是这样的":["89.7"],"的任务过期检测":["89.8"],"我们可能会写一些存在过期时效的代码":["89.8"],"比如紧急更新":["89.8"],"临时":["89.8"],"bugfix":["89.8"],"如果在规模较为庞大的代码库中":["89.8"],"很可能你写完就忘记这个方法只是临时方法了":["89.8"],"这个示例中":["89.8"],"的形式来标记一个方法的过期时间":["89.8"],"并通过":["89.8"],"来检查此方法是否过期":["89.8"],"expires":["89.8"],"08":["89.8"],"01":["89.8"],"author":["89.8"],"这是一个临时的":["89.8"],"需要在下次更新时删除":["89.8"],"tempfix":["89.8"],"我们主要学习了如何使用":["89.9"],"在上面的介绍中":["89.11"],"听起来":["89.11"],"我想先感谢每一位读者":["90.0"],"感谢你们的肯定与支持":["90.0"],"天下没有不散的筵席":["90.1"],"小册的正文内容就到这里结束了":["90.1"],"不妨让我们再回顾下这一路我们都学习了什么":["90.1"],"类型基础部分":["90.1"],"节":["90.1"],"作为入门阶段到进阶阶段之间的过渡":["90.1"],"在这里我们":["90.1"],"在入门的基础上":["90.1"],"按照小册的节奏重新介绍了这些相对简单的概念":["90.1"],"虽然到这里":["90.2"],"小册的正文内容已经划上句点":["90.2"],"但这本小册还没有完全结束":["90.2"],"我们还会有数节漫谈篇内容作为番外":["90.2"],"这本小册之所以能成功面世":["90.3"],"离不开许多人在这个过程中的帮助":["90.3"],"在前端领域的重要性正在不断提升":["91.0"],"那么很自然地":["91.0"],"面试过程中对":["91.0"],"不论如何":["91.2"],"以下这些概念是你需要基本了解的":["91.2"],"否则很容易被怀疑是否真的深入使用过":["91.2"],"只是回答这些概念定义显得过于枯燥":["91.3"],"而且很容易被认为像是在背书":["91.3"],"因此你可以穿插自己在工程中的实践":["91.3"],"这一问题主要考察你是否了解":["91.4"],"使用鸭子类型":["91.5"],"能回答出上面这些内容已经不错了":["91.6"],"但你可是阅读完了这本小册的同学":["91.6"],"具体内容已经在小册中详细描述":["91.8"],"这里只做简单叙述":["91.8"],"面试的重要原则之一就是":["91.9"],"why":["91.9"],"在回答一个知识点的同时":["91.9"],"如果能把这个知识点背后的存在原因也讲述清楚":["91.9"],"很难不让面试官暗暗点头为你折服":["91.9"],"因此你可以考虑从以下这么几个角度出发来进行扩展":["91.9"],"为什么需要":["91.9"],"这一部分有可能需要你进行手写":["91.10"],"比较简单的工具类型手写可能包括":["91.11"],"在完成手写的基础上":["91.12"],"其实你也可以主动进行扩展":["91.12"],"这一节我们专项学习了几个可能在面试中被作为高频考点的":["91.13"],"项目根目录下创建":["92.0"],"date":["93.0","96.6","105.0"],"06":["93.0"],"引入":["93.1"],"下载":["93.2"],"yarn":["93.2"],"全局":["93.6"],"external":["93.7"],"是否在开发模式中启用":["93.8"],"自定义生成的":["93.9"],"自定义生成":["93.10"],"produrl":["93.12"],"缓存持久化":["94.0"],"安装":["94.1","107.2","107.13"],"pinia":["94.1"],"在仓库中添加配置项":["94.3"],"definestore":["94.3"],"的第二个参数中配置":["94.3"],"该插件的默认配置如下":["94.4"],"localstorage":["94.4","94.6"],"进行存储":["94.4"],"默认值":["94.5","94.6","94.7","94.8","94.9","94.10","97.11"],"store":["94.5"],"storagelike":["94.6"],"将数据持久化到":["94.6"],"用于指定":["94.7"],"state":["94.7"],"stringify":["94.8","96.6","96.14"],"context":["94.9","94.10","97.8"],"piniaplugincontext":["94.9","94.10"],"svg":["95.0","95.3"],"安装插件":["95.1"],"中配置":["95.2"],"icondirs":["95.2"],"是保存":["95.2"],"封装":["95.3"],"配置全局组件并引入插件":["95.4"],"基础数据类型":["96.1"],"的差异":["96.2"],"可以准确地判断复杂引用数据的类型":["96.2"],"但是不能正确判断基础数据类型":["96.2"],"也存在弊端":["96.2"],"他虽然可以判断基础数据类型":["96.2"],"除外":["96.2"],"但是引用数据类型中":["96.2"],"类型以外":["96.2"],"其他的也无法判断":["96.2"],"myinstanceof":["96.2"],"left":["96.2"],"right":["96.2"],"这里先用":["96.2"],"来判断基础类型":["96.2"],"强制类型转换":["96.3"],"tostring":["96.3"],"隐式类型转换":["96.3"],"逻辑运算符":["96.3"],"运算符":["96.3"],"关系操作符":["96.3"],"相等运算符":["96.3"],"while":["96.3"],"条件":["96.3"],"方法强制转换规则":["96.3"],"如果是布尔值":["96.3"],"分别被转换为":["96.3"],"如果数数字":["96.3"],"返回自身":["96.3"],"如果是":["96.3"],"自己创建一个新的对象":["96.5"],"来接受你要重新复制或引用的对象值":["96.5"],"如果对象属性是基本的数据类型":["96.5"],"复制的就是基本类型的值给新对象":["96.5"],"但如果属性是引用数据类型":["96.5"],"复制的就是内存中的地址":["96.5"],"如果其中一个对象改变了内存中的地址":["96.5"],"肯定会影响到另一个对象":["96.5"],"实现浅拷贝的方法":["96.5"],"assign":["96.5"],"的一个方法":["96.5"],"该方法可以用于":["96.5"],"浅拷贝只是创建了一个新的对象":["96.6"],"复制了原有对象的基本类型的值":["96.6"],"对于复杂引用数据类型":["96.6"],"其在堆内存中完全开辟了一块内存地址":["96.6"],"并将原有的对象完全复制过来存放":["96.6"],"深拷贝原理":["96.6"],"将一个对象从内存中完整地拷贝出来一份给目标对象":["96.6"],"并从堆内存中开辟一个全新的空间存放新对象":["96.6"],"且新对象的修改并不会改变原对象":["96.6"],"二者实现真正的分离":["96.6"],"实现深拷贝的方法":["96.6"],"乞丐版":["96.6"],"是目前开发中最简单的深拷贝的方法":["96.6"],"拷贝的对象的值如果有函数":["96.6"],"这几种类型":["96.6"],"经过":["96.6"],"序列化之后的字符串中的键值对会消失":["96.6"],"拷贝":["96.6"],"引用类型会变成字符串":["96.6"],"无法拷贝不可枚举的属性":["96.6"],"无法拷贝对象的原型链":["96.6"],"regexp":["96.6"],"引用类型会变成空对象":["96.6"],"继承是面向对象的":["96.7"],"一":["96.8"],"原型链继承":["96.8","101.44"],"原型链继承是比较常见的继承方式之一":["96.8"],"其中涉及的构造函数":["96.8"],"原型和实例":["96.8"],"每一个构造函数都有一个原型对象":["96.8"],"原型对象又包含一个指向构造函数的指针":["96.8"],"而实例则包含一个原型对象的指针":["96.8"],"parent1":["96.8"],"play":["96.8"],"child1":["96.8"],"child2":["96.8"],"s1":["96.8"],"s2":["96.8"],"image":["96.8","96.23","107.80","107.82"],"20240117094112987":["96.8"],"原型链继承内存空间是共享的":["96.8"],"当一个发生变化的时候":["96.8"],"另一个也随之进行变化":["96.8"],"的底层逻辑":["96.9"],"方法是前端代码开发中相当重要的概念":["96.9"],"并且与":["96.9"],"的指向密切相关":["96.9"],"原理介绍":["96.9"],"关键词的主要作用":["96.9"],"就是指向一个构造函数":["96.9"],"返回一个实例对象":["96.9"],"红宝书":["96.11"],"作用域链的基本概念":["96.12"],"返回一个函数":["96.13"],"是日常开发中经常用到的":["96.14"],"的构造器":["96.16"],"构造器用于创建一个新的数组":["96.16"],"通常推荐使用对象字面量的方式创建一个数组":["96.16"],"arg1":["96.16"],"arg2":["96.16"],"参数长度为":["96.16"],"或长度大于等于":["96.16"],"的判断":["96.17"],"的方法":["96.18"],"改变自身的方法":["96.18"],"pop":["96.18"],"reverse":["96.18"],"数组的扁平化其实就是讲一个嵌套多层的数组":["96.19"],"嵌套可以是任何层数":["96.19"],"转化为只有一层的数组":["96.19"],"扁平化实现方法":["96.19"],"普通的递归实现":["96.19"],"通过循环递归的方式":["96.19"],"一项一项地去遍历":["96.19"],"如果每一项还是数组":["96.19"],"那么就继续往下遍历":["96.19"],"利用递归程序的方法":["96.19"],"来实现数组的每一项的连接":["96.19"],"flatten":["96.19"],"时间复杂度":["96.21"],"比较类排序":["96.23"],"通过比较来决定元素之间的相对次序":["96.23"],"其时间复杂度不能突破":["96.23"],"nlogn":["96.23"],"因此也成为非线性时间比较类排序":["96.23"],"非比较类排序":["96.23"],"不通过比较来决定元素之间的相对次序":["96.23"],"它可以突破基于比较排序的时间下界":["96.23"],"以线性时间运行":["96.23"],"因此也称为线性时间非比较类排序":["96.23"],"20240117155801276":["96.23"],"冒泡排序":["96.23"],"bubblesort":["96.23"],"len":["96.23"],"j":["96.23"],"temp":["96.23"],"排序":["96.24"],"方法也可以实现数组的排序":["96.24"],"默认排序顺序是先将元素转换为字符串":["96.24"],"然后再进行排序":["96.24"],"语法是":["96.24"],"的盒子模型":["97.1"],"的盒子模型有哪些":["97.1"],"height":["97.2","107.82"],"选字符有哪些":["97.3"],"哪些属性可以继承":["97.3"],"选择符":["97.3"],"优先算法如何计算":["97.4"],"优先级比较":["97.4"],"important":["97.4"],"内联样式":["97.4"],"有哪些值":["97.7"],"说说他们的作用":["97.7"],"描述":["97.7"],"bfc":["97.8","97.9"],"块级格式化上下文":["97.8"],"block":["97.8"],"formatting":["97.8"],"方式一":["97.9"],"触发":["97.9"],"为什么呢":["97.10"],"有几种定位":["97.11"],"分别是根据什么定位的":["97.11"],"没有定位":["97.11"],"fixed":["97.11"],"其中左右两块固定":["97.12"],"200px":["97.12"],"中间自适应宽":["97.12"],"要求先加载中间块":["97.12"],"reset":["97.13"],"sprite":["97.14"],"none":["97.15"],"visibility":["97.15"],"rgba":["97.16"],"共同性":["97.16"],"after":["97.17"],"chrome":["97.18"],"支持小于":["97.18"],"em":["97.19","99.3"],"表单输入框":["97.20"],"可以响应多端":["97.21"],"什么情况下采用响应式布局":["97.22"],"数据不是特别多":["97.22"],"用户量不是特别大":["97.22"],"纯展示类的项目适合响应式布局":["97.22"],"例如":["97.22","107.54","107.82"],"公司的官网":["97.22"],"块级元素有哪些":["99.1"],"空":["99.1"],"元素有哪些":["99.1"],"行内元素":["99.1"],"link":["99.2"],"strong":["99.3"],"标签的":["99.4"],"jpg":["99.5"],"gif":["99.5"],"这些图片格式解释一下":["99.5"],"header":["99.6"],"footer":["99.6"],"兼容问题":["100.0"],"ios":["100.1","100.3","100.4","100.6"],"系统中元素被触摸时产生的半透明遮罩怎么去掉":["100.2"],"有哪些方式":["101.1"],"数据类型有哪些":["101.2"],"基本类型":["101.2"],"作者在设计":["101.3"],"有什么不同":["101.4"],"比较的是值":["101.4"],"微任务和宏任务":["101.5"],"是单线程的语言":["101.5"],"作用域":["101.6","101.15","113.22"],"除了函数外":["101.6"],"对象注意点":["101.11"],"obj1":["101.13"],"getname":["101.16"],"bytedance":["101.18"],"判断变量是不是数组":["101.20"],"isarray":["101.21"],"原型":["101.23"],"isprototypeof":["101.24"],"是干嘛的":["101.26"],"是来截取的":["101.27"],"数组去重":["101.29"],"indexof":["101.31"],"sort":["101.32"],"aaaaaaabbbbbbcccccbbbbaaaaaabbbbbcccaaa":["101.35"],"getmost":["101.35"],"操作符具体做了什么":["101.36"],"闭包可以解决什么问题":["101.39"],"闭包的优点":["101.39"],"闭包的缺点":["101.40"],"变量会驻留在内存中":["101.40"],"造成内存损耗问题":["101.40"],"原型可以解决什么问题":["101.41"],"继承有哪些方式":["101.42"],"借用构造函数":["101.45"],"组合式继承":["101.46"],"功能一致":["101.48"],"返回不同":["101.49"],"用":["101.50"],"背后的原理是什么":["101.51"],"v8":["101.51"],"引擎":["101.51"],"共同点":["101.52","101.53"],"复制":["101.52"],"浅拷贝":["101.52"],"只复制引用":["101.52"],"而未复制真正的值":["101.52"],"sessionstorage":["101.53"],"cookie":["101.53"],"在客户端存放数据":["101.53"],"淘宝无限适配移动端":["101.54"],"布局单位使用":["101.54"],"rem":["101.54"],"没有自身作用域":["101.58"],"解构":["101.62"],"自定义":["101.63"],"指向的问题":["101.64"],"的几种状态":["101.65"],"filter":["101.66"],"生命周期有哪些":["103.2"],"发送请求在":["103.2"],"为什么发送请求不在":["103.3"],"beforecreate":["103.3"],"里":["103.3"],"在created":["103.4"],"加入":["103.8"],"组件传值":["103.11"],"通信":["103.11"],"插件":["104.1"],"examples":["106.0"],"highlighting":["106.1"],"vitepress":["106.1"],"provides":["106.1"],"containers":["106.2"],"md":["106.2"],"info":["106.2"],"an":["106.2"],"png":["107.0"],"ide":["107.2","107.3"],"鸿蒙应用开发需要使用配套的":["107.2"],"huawei":["107.2"],"deveco":["107.2"],"安装完成后":["107.3"],"可按以下步骤完成初始化配置":["107.3"],"双击桌面快捷方式":["107.3"],"启动deveco":["107.3"],"创建项目":["107.4"],"下面我们创建第一个鸿蒙应用项目":["107.4"],"模拟器运行":["107.7"],"previewer":["107.7"],"预览器主要用于查看界面":["107.7"],"效果":["107.7"],"如需对项目进行更加深入的测试":["107.7"],"可以使用模拟器运行项目":["107.7"],"初次使用需要先安装模拟器":["107.7"],"真机运行":["107.8"],"使用模拟器运行应用时":["107.8"],"会占用电脑较多的资源":["107.8"],"并且有些功能无法进行测试":["107.8"],"当模拟器不满足要求时":["107.8"],"可选择真机运行":["107.8"],"真机运行的步骤如下":["107.8"],"准备一台装有":["107.8"],"harmony":["107.8"],"概述":["107.9","107.136","121.3"],"本地运行环境":["107.13"],"除去线上的运行环境":["107.13"],"我们也可以在本地搭建一个":["107.13"],"的运行环境":["107.13"],"vscode":["107.13"],"特殊语法":["107.27"],"可选参数":["107.27"],"可选参数通过参数名后的":["107.27"],"进行标识":["107.27"],"如以下案例中的":["107.27"],"gender":["107.27"],"函数声明特殊语法":["107.32"],"静态成员":["107.38"],"继承":["107.39"],"继承是面向对象编程中的重要机制":["107.39"],"允许一个类":["107.39"],"子类或派生类":["107.39"],"访问修饰符":["107.40"],"access":["107.40"],"语法说明":["107.43","107.49","107.53","107.69","107.77"],"接口定义":["107.43"],"接口使用":["107.43"],"多态":["107.44"],"是面相对象编程中的一个重要概念":["107.44"],"它可以使同一类型的对象具有不同的行为":["107.44"],"下面我们通过一个具体的案例来体会":["107.44"],"这一概念":["107.44"],"再创建一个":["107.44"],"接口的作用":["107.45"],"在传统的面向对象编程的场景中":["107.45"],"接口主要用于设计和组织代码":["107.45"],"使代码更加容易扩展和维护":["107.45"],"下面举例说明":["107.45"],"假如现在需要实现一个订单支付系统":["107.45"],"按照面向对象编程的习惯":["107.45"],"首先需要定义一个订单类":["107.45"],"order":["107.45"],"中的接口的特殊性":["107.46"],"枚举定义":["107.49"],"枚举的定义需使用":["107.49"],"赋值":["107.50"],"枚举实际上是一个对象":["107.50"],"而每个枚举值都是该对象的一个属性":["107.50"],"并且每个属性都有具体的值":["107.50"],"属性值只支持两种类型":["107.50"],"数字或字符串":["107.50"],"每个属性的值都是数字":["107.50"],"并且从":["107.50"],"避免命名冲突":["107.54"],"若多个模块中具有命名相同的变量":["107.54"],"函数等内容":["107.54"],"将这些内容导入到同一模块下就会出现命名冲突":["107.54"],"在上述案例的基础上":["107.54"],"又增加了一个":["107.54"],"modulec":["107.54"],"内容如下":["107.54"],"默认导入导出":["107.55"],"完整代码":["107.65"],"案例的完整代码见":["107.65"],"demos":["107.65","107.80"],"entry":["107.65","107.80"],"声明组件":["107.67"],"下面通过一个相对简单的案例来系统的学习":["107.67"],"arkts":["107.67","107.82","107.121","107.136"],"声明组件的语法":["107.67"],"案例的最终效果如下":["107.67"],"自定义组件的语法如下图所示":["107.69"],"foreach":["107.77"],"循环渲染的语法如下":["107.77"],"itemgenerator":["107.77"],"item":["107.77"],"keygenerator":["107.77"],"组件的参数类型为":["107.80","107.87"],"resource":["107.80"],"media":["107.80","107.82"],"pixelmap":["107.80"],"相关案例见":["107.80"],"ets":["107.80"],"pages":["107.80"],"component":["107.80"],"solution":["107.80"],"imageparameter":["107.80"],"下面对三种参数类型逐一进行介绍":["107.80"],"类型的参数用于通过路径的方式引用图片":["107.80"],"包括本地图片和网络图片":["107.80"],"图片尺寸":["107.82"],"图片尺寸可通过":["107.82"],"width":["107.82"],"方法和":["107.82"],"方法进行设置":["107.82","107.90"],"图片缩放":["107.83"],"当图片的原始大小与image组件不同时":["107.83"],"可通过":["107.83","107.123"],"图片插值":["107.84"],"当原图分辨率较低并且需要放大显示时":["107.84"],"字体大小":["107.89"],"字体大小可通过":["107.89"],"fontsize":["107.89"],"字体粗细":["107.90"],"字体粗细可通过":["107.90"],"fontweight":["107.90"],"该方法参数类型为":["107.90"],"字体颜色":["107.91"],"字体颜色可通过":["107.91"],"fontcolor":["107.91"],"最大行数和超长处理":["107.93"],"button":["107.96","111.5"],"组件有两种使用方式":["107.96"],"分别是":["107.96"],"不包含子组件":["107.96"],"包含子组件":["107.96"],"常用事件":["107.100","107.107"],"toggle":["107.103","107.107"],"组件的参数定义如下":["107.103","107.121"],"组件常用的事件为change事件":["107.107"],"焦点事件":["107.118"],"progress":["107.121"],"进度条样式":["107.123"],"调整进度条的样式":["107.123"],"使用说明":["107.128","107.140"],"可使用":["107.128"],"ohos":["107.128"],"选择器弹窗用于让用户从一个列表中选择一个具体的值":["107.136"],"内置了多种选择器弹窗":["107.136"],"显示自定义弹窗需要使用":["107.140"],"模块化规划":["109.0"],"管路数据":["109.1"],"管理变量":["109.1"],"global":["110.7"],"传送门":["111.0"],"验证":["111.4"],"请验证":["111.5"],"自定义类型校验validator函数可以返回特定的枚举类型":["111.7"],"h":["111.11"],"在这个挑战中":["111.12","111.15","113.20","115.1","118.1"],"你需要使用":["111.12"],"definecomponent":["111.13"],"ul":["111.16","114.14","114.15"],"全家桶":["113.3","113.11"],"immediate":["113.14"],"在侦听器创建时立即触发回调":["113.14"],"第一次调用时旧值是":["113.14"],"deep":["113.14"],"triggerref":["113.18"],"effectscope":["113.25"],"customref语法":["113.29"],"仅渲染元素和组件一次":["114.6"],"你需要阻止点击事件的冒泡":["115.1"],"stop":["115.2"],"修饰符":["115.2"],"在监听键盘事件时":["115.4"],"我们经常需要检查特定的按键":["115.4"],"允许为":["115.4"],"on":["115.4"],"添加按键修饰符让即使":["115.5"],"alt":["115.5"],"你将使用":["118.1"],"toraw":["118.3"],"options":["121.0"],"的弊端":["121.1"],"中一个新的配置项":["121.3"],"值是一个函数":["121.3"],"composition":["121.3"],"表演的舞台":["121.3"],"组件中所用到的":["121.3"],"基本类型的响应式数据":["121.4"],"作用":["121.4","121.8"],"reactive":["121.5","121.7"],"对比":["121.7"],"宏观角度看":["121.7"],"用来定义":["121.7"],"基本类型数据":["121.7"],"torefs":["121.8"],"toref":["121.8"],"将一个响应式对象中的每一个属性":["121.8"],"核心语法":["122.0"]},{"0":["0.30","0.31","0.65","0.86","58.30","58.31","58.65","58.86","70.5","79.8","80.39","81.7","96.19","96.24","101.35","107.8"],"1":["0.31","0.32","0.63","0.68","0.73","0.79","0.84","0.86","0.90","31.0","58.31","58.32","58.63","58.68","58.73","58.79","58.84","58.86","58.90","62.6","66.2","69.2","69.5","69.6","69.7","70.2","70.5","72.5","75.8","80.41","82.12","86.35","89.1","96.9","96.24","97.8","97.14","97.17","99.6","101.11","101.16","101.19","101.30","101.33","101.36","101.39","101.50","101.53","107.0","107.12","107.48","107.50","107.52","107.57","107.61","107.73","107.76","107.78","107.79","107.81","107.98","107.112","107.117","107.127","107.130","107.133","107.139"],"2":["0.60","0.79","0.86","7.2","9.0","10.2","11.2","12.2","21.2","22.2","27.2","28.2","28.3","53.0","58.60","58.79","58.86","61.1","62.6","69.2","69.5","69.6","69.7","70.2","72.5","75.8","80.2","80.15","80.41","82.12","86.35","92.0","96.5","96.9","96.13","97.22","101.5","101.6","101.31","101.32","101.41","101.50","101.52","101.58","103.12","103.16","107.85","107.86","107.88","107.99","107.106","107.124","107.137","121.7"],"3":["0.5","0.12","0.82","0.83","10.3","11.3","34.3","57.1","58.5","58.12","58.82","58.83","61.4","63.11","70.2","72.5","80.41","83.13","96.9","101.31","101.32","101.33","101.52","107.5","107.17","107.20","107.21","107.30","107.31","107.56","107.57","107.59","107.63","107.64","107.66","107.68","107.71","107.72","107.75"],"4":["0.83","58.83","63.11","69.9","96.9","101.31","101.32","107.8","107.22","107.30","107.61","107.68","107.74","107.101","107.102","107.104","107.105","107.115","107.137"],"5":["1.5","69.9","101.31","101.32","107.108","107.109","107.111","107.113","107.116"],"6":["0.39","58.39","90.1","96.3","101.50","107.42","107.119","107.120","107.122"],"7":["96.3","96.6","107.48","107.125","107.126","107.127","107.129","107.131","107.132","107.134","107.135","107.138"],"8":["90.1","107.52"],"10":["59.1","93.0","101.17","105.0"],"11":["0.34","58.34"],"12":["90.1","105.0"],"13":["90.1","101.33"],"18":["60.5","63.4","101.33"],"20":["0.65","58.65","101.44","101.46"],"22":["105.0"],"26":["0.21","58.21"],"27":["101.33"],"32":["0.71","58.71"],"33":["101.50"],"36":["0.21","58.21"],"43":["59.0","93.0"],"54":["101.50"],"80":["0.59","58.59","80.2"],"84":["59.0"],"89":["85.6"],"95":["87.2"],"100":["107.90"],"134":["0.32","58.32"],"200":["68.2"],"246":["101.50"],"262":["0.8","56.3","58.8"],"400":["65.1"],"500":["65.1"],"502":["65.1"],"599":["61.4","61.6","61.8","62.6","65.4","70.1","76.1","78.2","86.24"],"693":["0.32","58.32"],"797":["0.32","58.32"],"862":["0.32","58.32"],"900":["107.90"],"1000":["59.1"],"1996":["82.1"],"2015":["61.1"],"2020":["61.1"],"2021":["77.2"],"2022":["59.0","83.13"],"3000":["88.3"],"10000":["62.2","88.4"],"10001":["88.4"],"无论是变量":["0.2","58.2"],"函数名还是操作符":["0.2","58.2"],"函数":["0.3","58.3"],"属性或者函数参数的名称":["0.3","58.3"],"标识符可以由一个或多个下列字符组成":["0.3","58.3"],"c":["0.4","28.3","58.4","71.5","101.8","107.54"],"语言风格的注释":["0.4","58.4"],"javascript":["0.5","0.40","57.0","58.5","58.40","61.9","63.2","64.0","82.4","82.9","82.10","83.0","83.7","85.4"],"解析和执行模型":["0.5","58.5"],"typeof":["0.7","0.26","6.3","58.7","58.26","66.5","67.2","72.0","79.8","81.10","96.6"],"case":["0.7","58.7","63.15","77.4","80.39"],"else":["0.7","55.4","58.7","63.15","66.3","96.19","96.23"],"instanceof":["0.7","58.7","72.0"],"interface":["0.10","58.10","62.0","62.2","62.8","63.9","65.2","65.5","65.6","67.7","79.4","79.12","79.13","79.19","80.26","80.29","89.2","89.7","91.2","91.3"],"个关键字可以声明变量":["0.12","58.12"],"var":["0.12","0.18","58.12","58.18","67.7","83.7","83.9","85.4","101.8","101.21","101.22","101.23","101.25","101.30","101.40"],"操作符":["0.13","58.13"],"注意":["0.13","0.25","0.44","58.13","58.25","58.44","65.5","75.2","78.9","107.80"],"message":["0.14","25.0","58.14","88.4","107.28"],"hi":["0.14","58.14"],"局部变量":["0.14","58.14"],"console":["0.14","0.15","58.14","58.15","61.3","61.4","82.12","83.2","83.9","83.10","86.22","86.35","96.5","96.19","101.12","107.45","107.50","107.54"],"log":["0.14","0.15","58.14","58.15","61.3","61.4","82.12","83.2","83.9","83.10","86.22","86.35","96.19","107.45","107.50","107.54"],"出错":["0.14","58.14"],"uncaught":["0.14","58.14"],"referenceerror":["0.14","58.14"],"js":["0.15","0.16","0.17","0.21","0.33","0.34","0.44","0.45","0.66","13.0","54.3","55.1","55.4","55.5","58.15","58.16","58.17","58.21","58.33","58.34","58.44","58.45","58.66","78.3","78.10","85.13","85.24","85.25","86.3","86.33","96.3","96.6","101.3","101.22","101.23","101.24","101.27","101.40","101.54","101.57","101.61","101.62","111.1","114.4"],"function":["0.15","0.41","6.3","34.2","55.1","58.15","58.41","60.8","61.3","63.6","64.1","66.3","67.1","73.3","79.8","83.7","85.4","86.3","86.8","88.3","96.6","101.9","101.18","107.27","107.54"],"foo":["0.15","58.15","62.12","63.9","64.1","64.3","80.8","80.34","82.4","83.3","83.5","84.7","85.13"],"age":["0.15","0.21","58.15","58.21","63.4","72.1","78.3","101.43","101.44","101.45","101.46","107.27","107.44"],"声明的范围是块作用域":["0.16","58.16"],"而":["0.16","58.16","64.1","64.8","70.3","71.4","71.5","79.9","82.1","83.8","85.28","86.39","88.1","89.0"],"声明的范围是函数作用域":["0.16","58.16"],"if":["0.16","6.3","58.16","63.15","66.3","67.2","83.9","85.4","96.2","96.6","96.19","101.9","103.13","107.27"],"true":["0.16","0.27","0.74","0.75","0.88","58.16","58.27","58.74","58.75","58.88","61.6","62.6","63.5","69.4","70.5","72.1","72.2","76.1","86.35","88.4","94.3","96.2"],"的另一个重要区别":["0.17","58.17"],"就是":["0.17","58.17","69.1","89.0"],"声明的变量不会在作用域中被提升":["0.17","58.17"],"name":["0.17","58.17","61.8","62.8","63.4","65.2","66.1","66.7","67.5","72.1","76.4","78.2","83.9","86.15","87.8","89.2","93.12","107.27","107.44"],"关键字不同":["0.18","58.18"],"使用":["0.18","58.18","62.18","65.7","80.7","80.9","80.11","80.21","80.31","82.12","84.3","84.4","85.11","86.33","91.2","91.3"],"let":["0.18","0.25","0.44","0.45","0.90","31.2","58.18","58.25","58.44","58.45","58.90","60.5","64.1","64.2","76.2","76.3","78.4","80.39","82.12","83.2","83.7","96.2","96.5","96.6","96.8","107.32","107.46","121.4"],"条件声明":["0.19","58.19"],"循环定义的迭代变量会渗透到循环体外部":["0.20","58.20"],"改用":["0.20","58.20"],"之后":["0.20","58.20"],"这个问题就消失了":["0.20","58.20"],"因为迭代变量的作用域仅限于":["0.20","58.20"],"声明的变量会导致运行时错误":["0.21","58.21"],"typeerror":["0.21","58.21"],"给常量赋值":["0.21","58.21"],"不使用":["0.22","58.22"],"有两大数据类型":["0.23","58.23"],"基本数据类型":["0.23","58.23"],"所以需要一种手段来确定任意变量的数据类型":["0.24","58.24"],"操作符就是为此而生的":["0.24","58.24"],"对一个值使用":["0.24","58.24"],"或":["0.25","58.25","63.11","63.15","94.7","115.5"],"声明了变量但没有初始化时":["0.25","58.25"],"就相当于给变量赋予了":["0.25","58.25"],"值":["0.25","0.33","58.25","58.33"],"包含":["0.25","58.25"],"值表示一个空对象指针":["0.26","58.26"],"这也是给":["0.26","58.26"],"传一个":["0.26","58.26"],"会返回":["0.26","58.26"],"object":["0.26","6.3","21.3","36.3","39.0","58.26","69.6","69.8","80.31","86.35","96.2","96.6","107.23"],"ecmascript":["0.27","0.64","0.77","0.78","56.1","58.27","58.64","58.77","58.78","61.1","77.2","78.0","82.6"],"中使用最频繁的类型之一":["0.27","58.27"],"有两个字面值":["0.27","58.27"],"的值":["0.28","58.28","63.5","83.10"],"false":["0.28","0.74","0.75","0.86","0.88","58.28","58.74","58.75","58.86","58.88","66.4","69.4","70.5","79.3","82.4","96.2"],"对于八进制字面量":["0.30","58.30"],"第一个数字必须是零":["0.30","58.30"],"floatnumber2":["0.31","58.31"],"floatnumber3":["0.31","58.31"],"max":["0.32","36.2","58.32","79.8","97.21"],"相除会返回":["0.33","58.33"],"分子是非":["0.33","58.33"],"分母是有符号或无符号的":["0.33","58.33"],"则会返回":["0.33","58.33"],"infinity":["0.33","0.78","0.82","0.83","58.33","58.78","58.82","58.83","96.6"],"或者":["0.33","58.33","85.6","115.4"],"011":["0.34","58.34"],"忽略前面的":["0.34","58.34"],"如果字符串包含有效的浮点值格式如":["0.34","58.34"],"则会转换为相应的浮点值":["0.34","58.34"],"同样忽略前面的":["0.34","58.34"],"如果字符串包含有效的十六进制格式如":["0.34","58.34"],"0xf":["0.34","58.34"],"则会转换为与该十六进制值对应的十进制整数值":["0.34","58.34"],"如果是空字符串":["0.34","58.34","96.3"],"不包含字符":["0.34","58.34"],"则返回":["0.34","0.78","58.34","58.78"],"如果字符串包含出上述情况之外的其他字符":["0.34","58.34"],"对象":["0.34","58.34","121.8"],"调用":["0.34","58.34","83.8"],"valueof":["0.34","58.34","96.3"],"方法":["0.34","58.34","77.2","83.8","83.10","96.3","121.3"],"并按照上述规则转换返回的值":["0.34","58.34"],"如果转换结果为":["0.34","58.34"],"则调用":["0.34","58.34"],"tostring":["0.34","58.34"],"在按照转换字符串的规则转换":["0.34","58.34"],"字符串":["0.35","0.63","58.35","58.63"],"制表":["0.36","58.36"],"b":["0.36","58.36","70.2","71.5","80.11","96.5","96.6","96.24","101.8","101.14","101.17"],"退格":["0.36","58.36"],"r":["0.36","58.36"],"回车":["0.36","58.36"],"f":["0.36","58.36","84.1"],"换页":["0.36","58.36"],"意思就是一旦创建":["0.37","58.37"],"一个是":["0.38","58.38"],"新增了模板字面量定义字符串的能力":["0.39","58.39"],"技术上讲":["0.40","58.40"],"模板字面量不是字符串":["0.40","58.40"],"而是一种特殊的":["0.40","58.40"],"tag":["0.41","19.2","58.41","68.3"],"如换行符或":["0.42","58.42"],"unicode":["0.42","58.42"],"符号":["0.43","58.43"],"操作符对符号返回":["0.44","58.44"],"发现不存在对应的符号":["0.45","58.45"],"于是就会生成一个新符号实例并添加到注册表中":["0.45","58.45"],"后续使用相同字符串的调用同样会检查注册表":["0.45","58.45"],"发现存在与该字符串对应的符号":["0.45","58.45"],"然后就会返回该符号实例":["0.45","58.45"],"fooglobalsymbol":["0.45","58.45"],"都可以使用符号":["0.46","58.46"],"symbol":["0.47","58.47","61.1","61.8","96.3"],"用于暴露语言内部行为":["0.47","58.47"],"开发者":["0.47","58.47"],"可以直接访问":["0.47","58.47"],"重写或模拟这些行为":["0.47","58.47"],"constructor":["0.60","58.60","63.9","63.14","84.4","87.4","88.4","101.43","107.45"],"用于创建当前对象的函数":["0.60","58.60"],"hasownproperty":["0.60","58.60"],"propertyname":["0.60","58.60"],"unary":["0.62","58.62"],"意思就是不限于整数":["0.63","58.63"],"布尔值":["0.63","58.63"],"浮点值":["0.63","58.63"],"甚至对象都可以":["0.63","58.63"],"递增和递减操作符遵循如下规则":["0.63","58.63"],"中跟在高中数学中的用途一样":["0.64","58.64"],"第一位":["0.65","58.65"],"称为第":["0.65","58.65"],"位":["0.65","58.65"],"表示":["0.65","0.69","0.70","0.89","58.65","58.69","58.70","58.89"],"第二位表示":["0.65","58.65"],"它的作用是返回数值的一补数":["0.66","58.66"],"有两个操作数":["0.67","58.67"],"本质上":["0.67","58.67"],"按位与就是将两个数的每一个位对齐":["0.67","58.67"],"第一个数值的位":["0.68","58.68"],"第二个数值的位":["0.68","58.68"],"结果":["0.68","58.68"],"会将数值的所有":["0.71","58.71"],"位都向右移":["0.71","58.71"],"尔值":["0.73","58.73"],"无论应用到的是什么数据类型":["0.73","58.73"],"逻辑非操作符首先将操作数转换为布尔值":["0.73","58.73"],"然后再对其取反":["0.73","58.73"],"逻辑非操作符会遵循如下规则":["0.73","58.73"],"如果操作数是对象":["0.73","58.73"],"定义了":["0.76","58.76"],"则执行常规的乘法运算":["0.77","58.77"],"即两个正值相乘是正值":["0.77","58.77"],"两个负值相乘也是正值":["0.77","58.77"],"正负符号不同的值相乘得到负值":["0.77","58.77"],"如果":["0.77","0.78","58.77","58.78","85.25","96.24"],"不能表示乘积":["0.77","58.77"],"即两个正值相除是正值":["0.78","58.78"],"两个负值相除也是正值":["0.78","58.78"],"符号不同的值相除得到负值":["0.78","58.78"],"不能表示商":["0.78","58.78"],"如果操作数是数值":["0.79","58.79"],"则执行常规除法运算":["0.79","58.79"],"返回余数":["0.79","58.79"],"如果被除数是无限值":["0.79","58.79"],"新增了指数操作符":["0.80","58.80"],"math":["0.80","58.80","96.23"],"pow":["0.80","58.80"],"即加法和减法操作符":["0.81","58.81"],"如果是":["0.82","0.83","58.82","58.83","96.2"],"加":["0.82","58.82"],"减":["0.83","58.83"],"和大于等于":["0.84","58.84"],"执行规则":["0.84","58.84"],"如果操作数都是数值":["0.84","58.84"],"它们在比较之前执行转换":["0.85","58.85"],"再确定操作数是否相等":["0.86","58.86"],"转换规则":["0.86","58.86"],"如果任一操作数是布尔值":["0.86","58.86"],"则将其转换为数值再比较是否相等":["0.86","58.86"],"转换为":["0.86","58.86"],"如果一个操作数是字符串":["0.86","58.86"],"另一个操作数是数值":["0.86","58.86"],"只不过它们在比较相等时不转换操作数":["0.87","58.87"],"全等操作符由":["0.87","58.87"],"value":["0.88","9.0","29.3","58.88","67.7","80.39","83.2","83.9","84.2","86.35","107.110","107.121","121.7"],"将右手边的值赋给左手边的变量":["0.89","58.89"],"num1":["0.90","58.90"],"p98":["0.91","58.91"],"谈谈你对":["1.0","2.0","47.0"],"vue":["1.0","2.1","4.0","7.0","8.0","14.0","19.0","20.1","21.0","21.1","22.0","27.0","27.1","28.0","29.1","34.0","35.1","36.4","43.0","46.0","54.0","55.1","74.2","91.0","95.3","95.4","110.5","115.1"],"早在":["1.1"],"jq":["1.1"],"的时代":["1.1"],"编写的代码都是命令式的":["1.1"],"命令式框架重要特点就是关注过程":["1.1"],"声明式框架更加关注结果":["1.1"],"命令式的代码封装到了":["1.1"],"vuejs":["1.1","53.0"],"就要知道另一个东西叫":["1.2"],"mvc":["1.2"],"为什么要有这些模式呢":["1.2"],"目的":["1.2"],"职责划分":["1.2"],"采用虚拟":["1.3"],"dom":["1.3","3.1","5.0","55.3","78.7","78.8","93.4","103.4"],"传统更新页面":["1.3"],"区分编译":["1.4"],"打包":["1.4"],"时和运行":["1.4"],"application":["2.1"],"单页应用":["2.1"],"默认情况下我们编写":["2.1"],"react":["2.1","61.0","78.6","79.4","79.14","85.0","93.4"],"都只有一个":["2.1"],"html":["2.1","25.0","56.5","79.1","97.12","115.4"],"spa":["2.2"],"多页面应用":["2.2"],"mpa":["2.2"],"组成":["2.2","56.5"],"一个主页面和页面组件":["2.2"],"静态页面预渲染":["2.3"],"static":["2.3","83.2"],"site":["2.3"],"vue为什么需要虚拟dom":["3.0"],"来对真实的":["3.1"],"进行抽象":["3.1"],"也就是现在大家所熟知的":["3.1"],"vdom":["3.2","3.3"],"是如何生成的":["3.2"],"在":["3.2","6.2","50.0","53.0","59.1","63.2","64.5","68.6","72.5","75.1","79.0","81.10","82.1","84.4","85.6","85.24","86.28"],"如何做":["3.3"],"diff":["3.3","19.1"],"挂载过程结束后":["3.3"],"组件化的理解":["4.0"],"webcomponent":["4.0"],"watcher":["4.1","11.0"],"effect":["4.1"],"通过数据劫持可以精确探测数据变化":["5.0"],"为什么还要虚拟":["5.0"],"请说一下你对响应式的理解":["6.0"],"如何实现响应式数据":["6.1"],"数组和对象类型当值变化时如何劫持到":["6.1"],"的时候使用":["6.2"],"defineproperty":["6.2","86.35"],"observer":["6.3","18.1"],"data":["6.3","15.0","18.1","22.1","31.1","31.2","52.0","67.4","88.4"],"null":["6.3","9.0","36.3","72.2","76.1","79.19","80.22","80.24","80.40","85.5","94.7","96.6","101.40"],"return":["6.3","28.3","31.2","63.4","67.1","79.12","82.12","83.7","84.2","85.32","86.4","86.11","96.2","96.8","96.9","96.19","101.16","101.19","113.29"],"for":["6.3","17.0","31.1","36.3","96.6","101.35","111.16","114.14","114.15"],"实现数组劫持":["7.1"],"数组考虑性能的原因没有用":["7.1"],"每个属性都拥有自己的":["8.1"],"dep":["8.1"],"属性":["8.1","86.24","93.6","107.40"],"vue3":["8.2","55.0"],"依赖收集":["8.2"],"production":["9.0"],"isundef":["9.0"],"isprimitive":["9.0"],"warn":["9.0"],"cannot":["9.0","59.1"],"reactive":["9.0"],"property":["9.0","59.1","83.9","83.10"],"on":["9.0","76.3"],"undefined":["9.0","59.1","61.3","63.3","75.1","76.1","79.6","79.13","79.19","80.13","82.3","86.18","89.1","96.3","101.2","107.27"],"or":["9.0"],"primitive":["9.0"],"如果是数组":["9.0"],"v":["10.0","26.0","26.1","29.2","31.1","79.10","85.4","103.13","111.16","114.11","114.12","114.14","114.15"],"基本概念":["10.1","12.1"],"效果展示":["10.2"],"computed":["11.0"],"vue2中有三种":["11.0"],"watch":["11.2","36.3","81.4"],"和":["12.0","12.1","56.1","60.1","61.2","61.8","62.4","64.2","66.3","70.3","77.3","84.3","85.8","87.4","89.11","97.2","100.6","101.49","101.51","103.3","103.13","107.23","107.118","121.0"],"ref":["12.1","79.9","81.7","121.8"],"立即运行一个函数":["13.0"],"然后被动地追踪它的依赖":["13.0"],"当这些依赖改变时重新执行该函数":["13.0"],"侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数":["13.0"],"const":["13.0","21.3","36.3","60.8","61.6","62.10","63.4","64.3","64.4","65.1","66.1","66.2","68.2","72.1","73.3","78.2","78.9","79.4","79.7","79.10","79.12","80.8","80.15","80.16","80.34","80.41","82.3","82.4","84.2","85.5","85.13","85.25","86.3","86.23","86.35","88.3","89.2","101.57","101.59","101.60","107.54"],"中含有模板编译的功能":["14.0"],"它的主要作用是将用户编写的":["14.0"],"内部会进行初始化操作":["15.0"],"内部会初始化组件绑定的事件":["15.0"],"初始化组件的父子关系":["15.0"],"parent":["15.0","79.16","101.43","101.44","101.45","101.46"],"children":["15.0","79.13","79.19"],"root":["15.0","85.13"],"初始化响应式数据":["15.0"],"observable":["16.0","82.11"],"你有了解过吗":["16.0"],"哪个优先级更高":["17.0"],"生命周期有哪些":["18.0"],"销毁前后":["18.1"],"beforecreate":["18.1","18.2"],"初始化父子关系及事件":["18.1"],"数据观测":["18.1"],"之前被调用":["18.1"],"用此方法一般编写插件的时候会用到":["18.1"],"created":["18.1","18.2","103.2","103.3","103.9"],"描述":["18.2"],"组件实例被创建之初":["18.2"],"组件实例已经完全创建":["18.2"],"概念":["19.1","21.1","27.1","35.1","36.1","47.1"],"key":["19.2","20.2","36.3","65.6","75.2","83.7","86.15","94.4","94.6","96.6","101.14","115.4"],"相同节点比较属性":["19.2"],"并复用老节点":["19.2"],"将老的虚拟":["19.2"],"请说明":["20.0"],"的特殊":["20.1"],"attribute":["20.1","107.82"],"主要用在":["20.1"],"的作用":["20.2"],"安装":["21.1"],"插件的功能":["21.2"],"插件缓存":["21.3"],"installedplugins":["21.3"],"this":["21.3","26.2","28.3","63.10","83.7","85.4","86.21","87.3","87.4","101.15","101.16","101.18","101.19","101.43","101.44","101.45","101.46","101.48","106.0","107.45"],"构造器":["22.1"],"创建一个":["22.1"],"子类":["22.1"],"参数是一个包含组件选项的对象":["22.1"],"选项是特例":["22.1"],"分析":["22.2"],"不会产生数据污染的情况":["23.0"],"组件实例对象":["23.0"],"必须是函数":["23.0"],"目的是为了防止多个组件实例对象之间共用一个":["23.0"],"产生数据污染":["23.0"],"所以需要通过工厂函数返回全新的":["23.0"],"作为组件的数据源":["23.0"],"无状态":["24.0"],"无生命周期":["24.0"],"无":["24.0"],"我们也可以理解成纯函数":["25.0"],"filtera":["25.0"],"arg1":["25.0","72.1"],"arg2":["25.0","72.1"],"filter2":["25.0"],"once":["26.1"],"will":["26.2"],"never":["26.2","64.6","64.8","65.0","66.2","71.6","71.8","71.12","75.4","91.7"],"change":["26.2","76.3","107.107","107.117"],"msg":["26.2","113.3","113.4"],"有子元素":["26.2"],"div":["26.2","99.1","113.3","113.6","113.7","113.9","113.10","113.12","113.13","115.2"],"mixin":["27.1"],"mixin合并策略":["27.3"],"核心就是":["27.3"],"什么是插槽":["28.1"],"编译后的结果with":["28.3"],"t":["28.3","65.7","67.5","67.7","68.3","70.1","70.5","71.6","71.8","71.12","73.2","75.3","79.4","80.6","84.7"],"my":["28.3"],"h1":["28.3","85.5","113.3","113.4"],"标题":["28.3"],"说说你对双向绑定的理解":["29.0"],"双向绑定的概念":["29.1"],"表单元素的":["29.2"],"model":["29.2","87.3","114.16"],"的":["29.3","66.8","77.2","78.5","79.9","86.9","89.4","97.19"],"prop":["29.3","30.0","63.9","75.7","83.10","111.5"],"和名为":["29.3"],"input":["29.3","66.3","73.3","77.2","78.4","79.7","99.1"],"的事件":["29.3"],"对于组件而言":["29.3"],"就是value":["29.3"],"在有些情况下":["30.0"],"我们可能需要对一个":["30.0"],"进行":["30.0"],"双向绑定":["30.0"],"这时可以使用":["30.0","107.84"],"item":["31.0","31.1","55.5","72.5","111.16"],"根":["31.0"],"in":["31.1","36.3","55.5","65.7","67.1","83.10","87.3","96.6","111.16"],"resub":["31.1"],"renderchildren":["31.2"],"属性有哪些好处和作用":["32.0"],"增加":["32.0"],"选择会在":["32.0"],"有什么应用场景":["33.0"],"表单修饰符":["33.0"],"lazy":["33.0"],"异步组件概念":["34.1"],"component":["34.2","36.2","107.65","107.82"],"resolve":["34.2","82.12","89.2"],"reject":["34.2"],"settimeout":["34.2"],"render":["34.2","55.1"],"h":["34.2","111.12","111.13"],"说说你对":["35.0"],"nexttick":["35.1","103.15"],"keep":["36.0","103.8"],"include":["36.2","77.4"],"whitelist":["36.2"],"exclude":["36.2","71.6"],"blacklist":["36.2"],"count":["36.2","79.8","112.5"],"create":["36.3","107.4"],"缓存列表":["36.3"],"keys":["36.3"],"destroyed":["36.3"],"alive销毁时":["36.3"],"删除所有缓存":["36.3"],"prunecacheentry":["36.3"],"mounted":["36.3","103.2"],"监控缓存列表":["36.3"],"beforerouteenter":["36.4"],"在与":["36.4"],"router":["36.4"],"的项目":["36.4"],"自定义指令的使用场景":["37.0"],"指令的概念":["37.1"],"bind":["37.2"],"只调用一次":["37.2"],"指令第一次绑定到元素时调用":["37.2"],"在这里可以进行一次性的初始化设置":["37.2"],"has":["37.3"],"拖拽指令":["37.3"],"draggable":["37.3"],"mousemove":["37.3"],"mouseup":["37.3"],"mousedown":["37.3"],"dragenter":["37.3"],"dragover":["37.3"],"vuex":["38.0","47.3","48.0","49.0"],"中的":["38.0","63.9"],"store":["38.0","47.3","51.0","94.4","94.8"],"工厂模式":["38.0"],"传入参数即可创建实例":["38.0"],"通过":["39.0","78.6","87.4"],"freeze":["39.0"],"方法冻结属性":["39.0"],"使用数据时":["39.0"],"减少入口文件体积大小":["40.0"],"优化体验骨架屏":["40.0"],"抽离公共代码":["40.0"],"采用":["40.0"],"splitchunks":["40.0"],"这个是浏览器的行为":["41.0"],"协议":["41.0"],"主机名":["41.0"],"端口的不同都会导致跨域问题":["41.0"],"项目中有封装过":["42.0"],"axios":["42.0"],"吗":["42.0","63.15"],"token":["43.1"],"前端将":["43.1"],"保存到本地":["43.1"],"作为用户登录的凭证":["43.1"],"导航被触发":["44.0"],"在失活的组件调用":["44.0"],"beforerouteleave守卫":["44.0"],"调用全局的":["44.0"],"beforeeach":["44.0"],"有三种模式":["45.0"],"hash":["45.0"],"history":["45.0"],"状态修改":["47.2"],"组件中":["47.2"],"中":["47.3","59.1","61.11","63.2","68.4","70.2","77.1","84.4","85.24","94.6","107.23","121.3"],"原理":["47.4","103.15"],"对于":["47.4","70.5","73.1","78.3","79.9","80.0","107.100"],"如何监听":["48.0"],"的数据丢失怎么解决":["49.0"],"的区别":["50.0","97.15","101.66"],"中可以处理异步逻辑":["50.0"],"在什么情况下会使用":["51.0"],"使用单一状态树":["51.0"],"应用的所有状态会集中到一个比较大的对象":["51.0"],"当应用变得非常复杂时":["51.0"],"对象就有可能变得相当臃肿":["51.0"],"vue2":["52.0","103.2"],"中采用的是":["52.0"],"optionsapi":["52.0"],"用户提供的":["52.0"],"props":["52.0","79.12","79.19"],"methods":["52.0"],"中无法单独使用的模块":["53.0"],"需要引入完整的":["53.0"],"例如只想使用响应式部分":["53.0"],"但是需要引入完整的":["53.0"],"errorcapture":["54.1"],"钩子":["54.1"],"可以捕获来自后代组件的错误":["54.1"],"全局设置错误处理":["54.2"],"如果在组件渲染时出现运行错误":["54.2"],"错误将会被传递至全局":["54.2"],"instance":["54.3","83.2"],"interceptors":["54.3"],"response":["54.3"],"此":["55.1"],"template":["55.1","95.3","110.2","111.2","111.6","111.9","111.10","112.9","112.10","113.9","113.10","113.12","113.13","113.16","113.17","113.23","113.24","113.27","113.28","114.1","114.2","114.5","114.8","114.9","114.17","114.18","115.2","116.1","116.2","118.2","119.2","120.1"],"经过模板编译会编译成如下代码":["55.1"],"import":["55.1","55.4","55.5","79.2","80.42","82.13","85.5","87.2","87.8","88.4","99.2"],"createelementvnode":["55.1"],"as":["55.1","55.4","55.5","86.35"],"todisplaystring":["55.1","55.4"],"openblock":["55.1"],"createelementblock":["55.1"],"from":["55.1","59.1","78.10","79.2","79.4","79.10","85.5","86.39","87.8","88.4","95.4","111.13"],"export":["55.1","70.1","85.5","86.3","87.8","88.4","89.7","93.3","107.53","107.54"],"ctx":["55.1"],"只有":["55.2"],"block":["55.2","97.7"],"不就挺好的么":["55.2"],"问题出在":["55.2"],"在收集动态节点时是忽略虚拟":["55.2"],"fruits":["55.5"],"renderlist":["55.5"],"基本上是同义词":["56.1"],"但是":["56.1","66.3","74.1","82.11"],"ecma":["56.3"],"document":["56.4"],"前者提供了一中映射":["56.5"],"xml":["56.5"],"文档":["56.5"],"从而方便访问和操作文档任意部分的方式":["56.5"],"后者扩展了前者并增加了特定于":["56.5"],"api":["56.6","87.2","88.1","88.5","89.4","96.2","113.22","118.1","121.0"],"用于支持访问和操作浏览器的窗口":["56.6"],"主要针对浏览器窗口和子窗口":["56.6"],"frame":["56.6"],"属性指定的代码字符集":["57.1"],"这个属性很少使用":["57.1"],"因为大多数浏览器不在乎它的值":["57.1"],"crossorigin":["57.1"],"配置相关请求的":["57.1"],"cros":["57.1"],"跨域资源共享":["57.1"],"设置":["57.1","107.8"],"默认不适用":["57.1"],"annoymous":["57.1"],"配置文件请求不必设置凭据标志":["57.1"],"use":["57.1","83.7","86.35"],"credentials":["57.1"],"年前端市场状态的调查显示":["59.0"],"的受访者都在使用":["59.0"],"typescript":["59.0","59.6","60.8","61.2","62.0","62.10","63.6","63.15","64.0","65.2","65.5","67.0","67.6","68.6","69.6","69.7","70.5","71.6","71.10","73.0","73.3","74.1","75.7","77.0","78.5","78.8","79.7","79.16","79.17","79.19","80.15","80.29","80.34","80.35","80.37","82.6","83.3","83.5","83.6","85.10","85.11","86.1","86.11","86.13","86.14","86.39","86.42","87.2","87.8","88.4","89.0","90.1","90.2","91.4","91.13","94.2","107.39","107.40","107.44","107.110","107.123"],"灵活性就变成了埋在项目内的定时炸弹":["59.1"],"top":["59.1","69.10","77.2","91.9"],"errors":["59.1"],"projects":["59.1"],"最常见的错误就是":["59.1"],"read":["59.1"],"xxx":["59.1","107.80","121.4"],"of":["59.1","82.3"],"is":["59.1","87.3"],"许多时候":["59.2"],"高昂的学习成本往往来自于我们对":["59.2"],"不正确的认知":["59.2"],"以及错误的学习路径":["59.2"],"比如说":["59.2","76.8","83.10"],"有人认为":["59.2"],"把类型相关的概念学习完就算掌握":["59.2"],"有人过了一遍文档和社区文章":["59.2"],"简单地上手使用一下":["59.2"],"就觉得自己的":["59.2"],"水平已经相当不错了":["59.2"],"首先":["59.2","71.0","82.0"],"通过社区资源自学并没有什么问题":["59.2"],"但好内容太少":["59.2"],"找起来也需要很多时间":["59.2"],"其次":["59.2"],"的类型基础开始学习":["59.3"],"然后到泛型":["59.3"],"条件类型等这些首次见面的类型工具":["59.3"],"在这些类型工具的学习与使用中":["59.3"],"我们会遇到许多困惑":["59.3"],"这时不妨转换下方向":["59.3"],"来了解":["59.3"],"的类型系统":["59.3"],"只要你沿着课程中给出的路线":["59.4"],"完成这一路上的各种任务":["59.4"],"就一定能从新手成功迈向高级玩家":["59.4"],"同时我也希望":["59.4"],"便捷且顺手的开发环境":["60.0"],"不仅能大大提高学习效率":["60.0"],"也会对我们日常的开发工作有很大帮助":["60.0"],"这一节我们就来介绍":["60.0"],"vs":["60.0","60.6"],"code":["60.0","60.6","62.0","62.2","66.4","107.13"],"类型的自动导入":["60.1"],"快速移动":["60.1"],"文件":["60.1","78.3","78.7","79.0","81.2","81.6","85.17","92.0"],"的能力":["60.1","78.1"],"首先是":["60.1","75.7","88.4"],"importer":["60.1"],"这一插件会收集你项目内所有的类型定义":["60.1"],"在你敲出":["60.1"],"时提供这些类型来进行补全":["60.1"],"如果你选择了一个":["60.1"],"它还会自动帮你把这个类型导入进来":["60.1"],"效果如图所示":["60.1"],"img":["60.1","60.3","75.3","89.4","95.2","99.1","100.5","107.3","107.4","107.7","107.8","107.13","107.36","107.69","107.84"],"ts":["60.2","78.7","78.9","78.13","79.0","79.2","80.3","81.6","85.8","85.9","85.11","85.20","85.29","85.30","86.25","87.7","89.8","89.9","92.0","94.2","95.5"],"强相关的插件与配置":["60.2"],"tsconfig":["60.3","60.4","64.1","78.0","79.15","85.11","86.41"],"那官方提供的":["60.3"],"一定能满足你的需求":["60.3"],"你可以在这里编写":["60.3"],"你可以将其安装到项目本地或直接全局安装":["60.4"],"我个人更推荐安装到全局然后配置":["60.4"],"alias":["60.4","85.16","93.11"],"快速启动":["60.4"],"像":["60.4"],"tsn":["60.4"],"这样":["60.4","85.5"],"执行以下命令将":["60.4"],"安装到全局":["60.4"],"bash":["60.4","80.2","85.20","93.2"],"npm":["60.4","80.2","80.3","88.3","95.1"],"i":["60.4","80.1","80.3","95.1","96.19","101.35"],"g":["60.4"],"然后":["60.4","75.2","83.8"],"在项目中执行以下命令创建":["60.4"],"的项目配置文件":["60.4"],"json":["60.4","79.1","79.15","85.12","85.14","107.140"],"npx":["60.4"],"init":["60.4"],"如果全局安装了":["60.4"],"job":["60.5"],"林不渡":["60.5","79.9"],"包括了":["60.6"],"的配置":["60.6"],"插件":["60.6"],"这些工具库的工作原理":["60.8"],"它们的核心逻辑其实都是通过":["60.8"],"注册了":["60.8"],"文件的处理逻辑":["60.8"],"extenstions":["60.8"],"module":["60.8","80.2","86.39","87.7","107.54"],"filename":["60.8"],"content":["60.8","88.4"],"fs":["60.8"],"readfilesync":["60.8"],"utf8":["60.8"],"compile":["60.8"],"以后再去学习":["61.0"],"对于组件通信":["61.0"],"状态管理":["61.0"],"插槽等这些二者共有的概念":["61.0"],"es6":["61.1","63.8","82.1","89.0","96.18"],"es11":["61.1"],"又分别引入了":["61.1"],"个新的原始类型":["61.1"],"与":["61.1","61.9","64.6","65.0","65.2","68.1","68.6","71.5","79.17","80.6","81.0","85.31","86.42","91.7","91.8","91.9"],"这里有值":["61.2"],"但是个空值":["61.2"],"这里没有值":["61.2"],"而在":["61.2","67.7"],"expression":["61.3","63.2"],"的语法":["61.3"],"操作符会执行后面跟着的表达式并返回一个":["61.3"],"如你可以使用它来执行一个立即执行函数":["61.3"],"iife":["61.3"],"invoked":["61.3"],"能这么做是因为":["61.3"],"操作符强制":["61.3"],"将后面的函数声明转化为了表达式":["61.3"],"arr3":["61.4"],"lin":["61.4","69.4","76.5","77.1"],"bu":["61.4","69.4"],"du":["61.4","69.4"],"这种情况肯定是不符合预期的":["61.4"],"因为我们能确定这个数组中只有三个成员":["61.4"],"并希望在越界访问时给出类型报错":["61.4"],"这时我们可以使用元组类型进行类型标注":["61.4"],"arr4":["61.4"],"此时将会产生一个类型错误":["61.4"],"长度为":["61.4"],"的元组类型":["61.4"],"以及了解可能存在的使用误区":["61.5"],"这些内容能够帮助你建立起对":["61.5"],"中立体类型":["61.5"],"我们可以理解为前面的原始类型是":["61.5"],"平面类型":["61.5"],"的了解":["61.5"],"正式入门":["61.5"],"obj2":["61.6"],"linbudu":["61.6","61.8","62.8","64.4","65.4","66.1","69.2","69.7","70.1","72.2","76.1","76.4","77.1","77.2","78.3","79.6","79.10","83.10"],"无需实现":["61.6"],"也是合法的":["61.6"],"在这种情况下":["61.6","71.6"],"即使你在":["61.6"],"我也知道":["61.7"],"很多同学更喜欢用":["61.7"],"tmp3":["61.8","86.23"],"tmp4":["61.8","86.23"],"tmp5":["61.8"],"tmp6":["61.8"],"tmp7":["61.8"],"tmp8":["61.8"],"类似的还有":["61.8"],"boolean":["61.8","66.2","70.3","72.1","79.12","88.4","93.8","94.11","96.1","101.2","107.103"],"number":["61.8","62.0","63.4","64.5","65.1","65.6","66.4","66.7","68.2","70.1","70.3","71.4","72.1","75.7","76.2","78.3","79.8","80.41","81.7","86.24","87.8","89.7","96.1","101.2","101.4","101.28","107.19","107.27","107.32","107.44","107.45","107.82","107.89","107.90","107.91","107.121","107.123"],"string":["61.8","62.6","63.4","63.9","64.3","64.4","65.6","65.7","66.7","67.4","68.3","69.2","69.8","70.1","71.4","75.1","75.3","77.0","77.3","78.2","80.13","83.2","83.10","84.2","86.15","86.22","86.23","89.7","93.11","96.1","101.4","107.27","107.44","107.77","107.82","107.89","107.90","107.91","107.96","107.123"],"这几个":["61.8"],"装箱类型":["61.8"],"boxed":["61.8"],"types":["61.8","62.4","78.8","88.4"],"同样包含了一些超出预期的类型":["61.8"],"以及对数组的只读":["61.9"],"对象类型属性的访问性修饰":["61.9"],"这里的知识其实可以分为两类":["61.9"],"概念基本一致的部分":["61.9"],"如原始类型与数组类型需要重点掌握":["61.9"],"但因为思维方式基本没有变化":["61.9"],"类型并不具有这一特性":["61.11"],"一百个具有":["61.11"],"类型的对象":["61.11"],"它们的":["61.11"],"类型指的都是":["61.11"],"中的同一个类型":["61.11"],"为了实现":["61.11"],"独一无二":["61.11"],"它描述了响应的消息结构":["62.0"],"ires":["62.0"],"res":["62.2"],"它代表着比原始类型更精确的类型":["62.4"],"同时也是原始类型的子类型":["62.4"],"关于类型层级":["62.4"],"我们会在后面详细了解":["62.4"],"字面量类型主要包括":["62.4"],"字符串字面量类型":["62.4"],"数字字面量类型":["62.4"],"布尔字面量类型":["62.4"],"tmp":["62.6","62.8"],"mixed":["62.6"],"这里有几点需要注意的":["62.6"],"对于联合类型中的函数类型":["62.6"],"需要使用括号":["62.6"],"包裹起来":["62.6"],"obj":["62.8","66.1","82.3","96.6","101.35","101.59"],"setting":["62.10"],"url2":["62.10"],"share":["62.10"],"url3":["62.10"],"或是这样":["62.10"],"pageurl":["62.10"],"如果把这段代码替换为枚举":["62.10"],"会是如下的形式":["62.10"],"enum":["62.12","63.15","88.4"],"items":["62.12"],"bar":["62.12","64.1","75.1"],"baz":["62.12"],"包括字面量类型的分类":["62.14"],"与联合类型的结合使用":["62.14"],"image":["62.18"],"png":["62.18","88.2"],"你会发现":["62.18","77.3","79.19"],"函数能够帮助我们进一步抽离与封装代码逻辑":["63.0"],"所以掌握函数类型必不可少":["63.0"],"如果说函数代表着面向过程的编程":["63.0"],"那么":["63.0","78.3","96.24"],"class":["63.0","68.0","68.3","78.4","83.3","83.5","83.6","86.14","87.8","88.4","97.4","107.34","107.36","107.39","107.44","107.45","107.136"],"则代表着面向对象的编程":["63.0"],"而它也是":["63.0"],"它也能被正确推导为":["63.2"],"类型":["63.2","63.5","64.1","65.4","66.1","66.4","80.31","80.33","93.7","93.8","107.82","107.87","107.90","111.5"],"我们称":["63.2"],"这一声明函数的方式为":["63.2"],"函数声明":["63.2"],"declaration":["63.2"],"除了函数声明以外":["63.2"],"我们还可以通过":["63.2"],"函数表达式":["63.2"],"的函数":["63.3"],"其返回类型应当被标记为":["63.3"],"而不是":["63.3","78.2","80.11"],"即使它实际的值是":["63.3"],"inputage":["63.4"],"或使用":["63.4"],"并且从其内部逻辑中我们知道":["63.5"],"当":["63.5","96.16"],"为":["63.5","69.1","78.5","82.9","85.25","86.33"],"返回值为":["63.5"],"否则为":["63.5"],"而这里的类型签名完全没有体现这一点":["63.5"],"我们只知道它的返回值是这么个联合类型":["63.5"],"要想实现与入参关联的返回值类型":["63.5"],"我们可以使用":["63.5"],"提供的":["63.5"],"函数重载签名":["63.5"],"overload":["63.5"],"signature":["63.5"],"函数的类型签名":["63.6"],"其参数签名基本一致":["63.6"],"而返回值类型则稍微有些区别":["63.6"],"async":["63.6","80.14","83.3","87.4","89.4"],"asyncfunc":["63.6"],"我们也只需要关注这三个部分即可":["63.8"],"这里我要说明一点":["63.8"],"有的同学可能认为装饰器也是":["63.8"],"的结构":["63.8","75.2"],"但我个人认为它并不是":["63.8"],"携带的逻辑":["63.8"],"不应该被归类在这里":["63.8"],"而对于这些结构的具体意义以及":["63.8"],"的入门语法":["63.8"],"你可以阅读阮一峰老师的":["63.8"],"属于操作性修饰符":["63.9"],"就和":["63.9"],"意义一致":["63.9"],"这些修饰符应用的位置在成员命名前":["63.9"],"inputprop":["63.9"],"statichandler":["63.10"],"public":["63.10","63.11","83.10","88.4"],"instancehandler":["63.10"],"不同于实例成员":["63.10"],"在类的内部静态成员无法通过":["63.10"],"来访问":["63.10"],"需要通过":["63.10"],"这种形式进行访问":["63.10"],"我们在上面其实已经介绍过":["63.11"],"派生类中可以访问到使用":["63.11"],"protected":["63.11","68.3"],"修饰符的基类成员":["63.11"],"除了访问以外":["63.11"],"基类中的方法也可以在派生类中被覆盖":["63.11"],"但我们仍然可以通过":["63.11"],"super":["63.11","87.4"],"访问到基类中的方法":["63.11"],"print":["63.11"],"在派生类中覆盖基类方法时":["63.11"],"我们并不能确保派生类的这一方法能覆盖基类方法":["63.11"],"万一基类中不存在这个方法呢":["63.11"],"所以":["63.11"],"新增了":["63.11"],"override":["63.11"],"关键字":["63.11","70.4","77.0","78.5","107.53","107.69"],"来确保派生类尝试覆盖的方法一定在基类中存在定义":["63.11"],"我们着重了解其结构体的类型":["63.12"],"即参数类型":["63.12"],"可选参数与剩余参数":["63.12"],"与返回值类型的标注":["63.12"],"而对于类":["63.12"],"实际上我们了解的更多是新的语法":["63.12"],"private":["63.14","67.6"],"看起来好像没什么问题":["63.14"],"但是当你想要实例化这个类时":["63.14"],"一行美丽的操作就会出现":["63.14"],"类的构造函数被标记为私有":["63.14"],"且只允许在类内部访问":["63.14"],"原本在一个":["63.15"],"login":["63.15"],"方法中进行":["63.15"],"判断":["63.15","101.21","101.24"],"假设后面又新增了抖音登录":["63.15"],"美团登录":["63.15"],"难道要再加":["63.15"],"分支":["63.15","66.2"],"switch":["63.15","79.8"],"logintype":["63.15"],"的概念来进行映射":["64.0"],"或者说这可以看作是":["64.0"],"代码到":["64.0"],"作为一个":["64.1"],"rest":["64.1","77.3"],"参数":["64.1"],"也使用":["64.1"],"进行了标记":["64.1"],"这就意味着你可以使用任意类型的任意数量类型来调用这个方法":["64.1"],"除了显式的标记一个变量或参数为":["64.1"],"在某些情况下你的变量":["64.1"],"参数也会被隐式地推导为":["64.1"],"比如使用":["64.1"],"声明一个变量但不提供初始值":["64.1"],"以及不为函数参数提供类型标注":["64.1"],"均为":["64.1"],"func":["64.1","80.29"],"以上的函数声明在":["64.1"],"中启用了":["64.1"],"noimplicitany":["64.1"],"时会报错":["64.1"],"你可以显式为这两个参数指定":["64.1"],"或者暂时关闭这一配置":["64.1"],"不推荐":["64.1"],"类型的变量几乎无所不能":["64.1"],"它可以在声明后再次接受任意类型的值":["64.1"],"同时可以被赋值给任意其它类型的变量":["64.1"],"被标记为":["64.1"],"才是一个":["64.2"],"什么都没有":["64.2"],"的类型":["64.2"],"它甚至不包括空的类型":["64.2"],"严格来说":["64.2"],"类型不携带任何的类型信息":["64.2"],"因此会在联合类型中被直接移除":["64.2"],"比如我们看":["64.2"],"的类型兼容性":["64.2"],"declare":["64.2","66.2","67.7","76.2","76.3","78.5"],"v1":["64.2","76.2"],"v2":["64.2"],"x":["64.2","64.4","80.12","82.12","103.2"],"不能赋值给类型":["64.2"],"在编程语言的类型系统中":["64.2"],"类型被称为":["64.2"],"bottom":["64.2","64.8","69.10","91.9","107.50"],"是":["64.2","70.2","74.2","87.4","96.2","115.4"],"整个类型系统层级中最底层的类型":["64.2"],"还可以":["64.3"],"到":["64.3","69.5","88.5"],"来为所欲为":["64.3"],"跳过所有的类型检查":["64.3"],"str":["64.3","64.4","66.1","77.0","85.25","107.54"],"从":["64.4"],"tofixed":["64.5","66.2","66.4"],"此时":["64.5","86.27"],"中不一定存在":["64.5"],"调用结果中不一定存在":["64.5"],"且可能为":["64.5"],"any":["64.6","69.8","71.8","71.12","72.1","75.3","79.19","84.7","86.8","88.4","91.8"],"unknown":["64.6","65.1","69.8","71.4","86.9"],"表现在它们包含了所有可能的类型":["64.8"],"表现在它是一个虚无的":["64.8"],"不存在的类型":["64.8"],"那么加上此前学习的原始类型与字面量类型等":["64.8"],"按照类型的包含来进行划分":["64.8"],"我们大概能梳理出这么个类型层级关系":["64.8"],"最顶级的类型":["64.8"],"也提到这些内置类型实际上是最基础的":["65.0"],"积木":["65.0"],"那想要利用好这些":["65.0"],"possibledatatypes":["65.1"],"status":["65.1"],"抽离一个函数类型":["65.1"],"handler":["65.1","85.8","85.20","86.3"],"e":["65.1"],"event":["65.1","79.10"],"void":["65.1","73.3","76.3","79.3"],"clickhandler":["65.1"],"movehandler":["65.1"],"即可":["65.2"],"而代表着按位与的":["65.2"],"则不同":["65.2"],"你需要符合这里的所有类型":["65.2"],"才可以说实现了这个交叉类型":["65.2"],"即":["65.2","66.1","68.1","70.4","71.5","75.2","78.5","82.2"],"需要同时满足":["65.2"],"两个类型":["65.2"],"才行":["65.2"],"我们声明一个交叉类型":["65.2"],"namestruct":["65.2"],"索引签名类型":["65.3"],"索引类型查询":["65.3"],"proptype1":["65.4"],"proptype2":["65.4"],"然后再组合成联合类型":["65.5"],"这里并不会将数字类型的键名转换为字符串类型字面量":["65.5"],"而是仍然保持为数字类型字面量":["65.5"],"接下来":["65.6"],"我们来看个例子":["65.6"],"numberrecord":["65.6"],"type":["65.6","65.7","66.1","68.3","69.5","69.7","69.10","70.1","71.6","71.8","72.1","73.1","73.3","75.7","77.0","77.3","78.13","79.2","79.8","79.10","79.13","79.19","80.18","80.25","81.7","81.10","84.4","86.22","91.1","91.9","107.103","107.121"],"proptype":["65.6"],"这里":["65.6"],"我们使用":["65.6","66.3","87.0"],"stringify":["65.7","67.1"],"k":["65.7","67.1","85.4"],"keyof":["65.7","67.1","75.3","79.4"],"这个工具类型会接受一个对象类型":["65.7"],"假设我们只会这么用":["65.7"],"获得这个对象类型的键名组成字面量联合类型":["65.7"],"然后通过映射类型":["65.7"],"即这里的":["65.7"],"以下这张表格概括了它们的实现方式与常见搭配":["65.8"],"类型工具":["65.8"],"创建新类型的方式":["65.8"],"常见搭配":["65.8"],"类型别名":["65.8"],"将一组类型":["65.8"],"类型结构封装":["65.8"],"在大部分时候":["66.0"],"这些类型工具的作用是":["66.0"],"还新增了用于类型查询的":["66.1"],"query":["66.1"],"operator":["66.1"],"这个":["66.1"],"返回的是一个":["66.1"],"我们在":["66.2"],"类型一节中学到的也是如此":["66.2"],"在类型控制流分析下":["66.2"],"每流过一个":["66.2"],"后续联合类型的分支就少了一个":["66.2"],"因为这个类型已经在这个分支处理过了":["66.2"],"不会进入下一个分支":["66.2"],"strornumorbool":["66.2"],"一定是字符串":["66.2"],"charat":["66.2"],"一定是数字":["66.2"],"一定是布尔值":["66.2"],"baronly":["66.3"],"handle":["66.3"],"这里的":["66.3","70.2"],"属性们其实有着不同的意义":["66.3"],"来区分":["66.3"],"联合类型":["66.3","73.0","73.6","107.28"],"然后就可以在对应的分支代码块中正确访问到":["66.3"],"独有的类型":["66.3"],"如果用":["66.3"],"上面这段代码在运行时会抛出一个错误":["66.4"],"因为":["66.4","75.2"],"接收到的表达式执行结果为":["66.4"],"这其实也类似类型守卫的场景":["66.4"],"如果断言":["66.4"],"不成立":["66.4"],"比如在这里意味着值的类型不为":["66.4"],"那么在断言下方的代码就执行不到":["66.4"],"相当于":["66.4"],"dead":["66.4"],"属于类型语法的交叉类型":["66.5"],"索引类型":["66.5"],"的三个部分":["66.5"],"objectprop":["66.7"],"unionprop":["66.7"],"接口":["66.7"],"struct2":["66.7"],"错误扩展接口":["66.7"],"版本中都有或多或少的场景增强":["66.8"],"而这里说的增强":["66.8"],"其实就包括了":["66.8"],"对可辨识联合类型的分析能力":["66.8"],"比如下面这个例子在此前":["66.8"],"版本以前":["66.8"],"比较熟悉":["67.0"],"甚至开始爱不释手了":["67.0"],"但也意味着课程难度有所提升":["67.0"],"typearg":["67.1"],"类型别名中的泛型大多是用来进行工具类型封装":["67.1"],"比如我们在上一节的映射类型中学习的工具类型":["67.1"],"除了声明默认值以外":["67.2"],"泛型还能做到一样函数参数做不到的事":["67.2"],"泛型约束":["67.2"],"也就是说":["67.2","68.1","76.8","89.6"],"你可以要求传入这个工具类型的泛型必须符合某些条件":["67.2"],"否则你就拒绝进行后面的逻辑":["67.2"],"在函数中":["67.2"],"我们只能在逻辑中处理":["67.2"],"add":["67.2","80.1","80.2","83.2","93.2"],"source":["67.2","89.2","96.5","101.63"],"throw":["67.2","86.4"],"new":["67.2","78.9","83.2","84.7","89.2","101.11","107.37"],"error":["67.2","67.4","72.1","85.26","86.9"],"invalid":["67.2"],"arguments":["67.2","80.18"],"falsyresult":["67.3"],"extends":["67.3","68.3","69.2","69.5","69.6","69.7","71.6","71.8","71.12","75.7","75.8","77.0","77.3","79.4","79.12","87.4","87.8","91.2"],"passed":["67.3"],"result1":["67.3"],"这个接口描述了一个通用的响应类型结构":["67.4"],"预留出了实际响应数据的泛型坑位":["67.4"],"然后在你的请求函数中就可以传入特定的响应类型了":["67.4"],"iuserprofileres":["67.4"],"shouldbeobject":["67.5"],"虽然我们约束了入参的类型":["67.5"],"但返回值的类型并没有像我们预期的那样和入参关联起来":["67.5"],"上面三个调用结果的类型仍然是一个宽泛的联合类型":["67.5"],"难道要用重载一个个声明可能的关联关系":["67.5"],"天":["67.5"],"如果再多一些复杂的情况":["67.5"],"别说你愿不愿意补充每一种关联了":["67.5"],"同事看到这样的代码都会质疑你的水平":["67.5"],"我们就该请出泛型了":["67.5"],"内的方法还可以再声明自己独有的泛型参数":["67.6"],"我们直接来看完整的示例":["67.6"],"queue":["67.6"],"telementtype":["67.6"],"list":["67.6","103.11","111.9","111.10"],"内部的":["67.7"],"类型声明中同样是通过泛型实现":["67.7"],"promiseconstructor":["67.7"],"promiselike":["67.7","80.7"],"还有数组":["67.7"],"array":["67.7"],"函数参数":["67.8"],"感受到了泛型与类型别名一同使用时":["67.8"],"真的就像一个接收输入再输出结果的函数一样":["67.8"],"的代码":["68.0"],"cat":["68.0"],"eat":["68.0"],"比较两个类型并非通过类型的名称":["68.1"],"函数只能通过":["68.1"],"类型调用":["68.1"],"而是比较这两个类型上实际拥有的属性与方法":["68.1"],"这里实际上是比较":["68.1"],"类型上的属性是否都存在于":["68.1"],"类型上":["68.1"],"在我们最初的例子里":["68.1"],"类型上的方法是一致的":["68.1"],"所以它们虽然是两个名字不同的类型":["68.1"],"但仍然被视为结构一致":["68.1"],"这就是结构化类型系统的特性":["68.1"],"你可能听过结构类型的别称":["68.1"],"鸭子类型":["68.1"],"duck":["68.1"],"typing":["68.1"],"usd":["68.2"],"cny":["68.2"],"cnycount":["68.2"],"usdcount":["68.2"],"tagprotector":["68.3"],"nominal":["68.3"],"u":["68.3","71.6","75.3"],"在这里我们使用":["68.3"],"声明了一个具有":["68.3"],"属性的类":["68.3"],"使用它来携带额外的信息":["68.3"],"并和原本的类型合并到一起":["68.3"],"而标称类型系统是":["68.4"],"基于类型名来进行比较":["68.4"],"以及在":["68.4","87.5"],"总的来说就是":["68.6"],"访问限制":["68.6"],"赋值限制":["68.6"],"中即是原始类型":["68.6"],"对象类型":["68.6","73.0"],"函数类型":["68.6","80.9"],"说类型层级是最重要的基础概念也不为过":["69.0"],"类型层级一方面能帮助我们明确各种类型的层级与兼容性":["69.0"],"而兼容性问题往往就是许多类型错误产生的原因":["69.0"],"另一方面":["69.0"],"则说明":["69.1"],"的子类型":["69.1"],"否则":["69.1"],"说明不成立":["69.1"],"但注意":["69.1"],"不成立并不意味着":["69.1"],"的子类型了":["69.1"],"result2":["69.2"],"result8":["69.4"],"result9":["69.4"],"的类型层级":["69.5"],"result14":["69.5"],"result15":["69.5"],"result16":["69.5"],"result18":["69.5"],"类型自然会是":["69.6"],"类型的子类型":["69.6"],"result22":["69.6"],"result23":["69.6"],"但如果我们把条件类型的两端对调一下呢":["69.6"],"当然也包括字面量类型":["69.7"],"result33":["69.7"],"但你可能又想到了一些特别的部分":["69.7"],"result37":["69.9"],"result38":["69.9"],"向下也见到了":["69.10"],"因为你已经完全理解了它的判断逻辑":["70.0"],"比如这个例子":["70.1"],"literaltype":["70.1"],"other":["70.1","78.8"],"res1":["70.1"],"res2":["70.1"],"同三元表达式可以嵌套一样":["70.1"],"条件类型中也常见多层嵌套":["70.1"],"如":["70.1","70.2","78.6","80.8","80.9","80.15","80.20","80.26","80.35","80.37","85.6","89.4"],"inference":["70.2"],"的缩写":["70.2"],"意为推断":["70.2"],"就表示":["70.2"],"待推断的类型":["70.2"],"只能在条件类型中使用":["70.2"],"因为我们实际上仍然需要":["70.2"],"类型结构是一致的":["70.2"],"比如上例中类型信息需要是一个函数类型结构":["70.2"],"我们才能提取出它的返回值类型":["70.2"],"如果连函数类型都不是":["70.2"],"那我只会给你一个":["70.2"],"类型结构":["70.2"],"当然并不局限于函数类型结构":["70.2"],"还可以是数组":["70.2"],"swap":["70.2"],"a":["70.2","80.11","83.10","96.5","96.6","96.24","100.2","101.9","101.10","101.13","101.17","101.18","101.52","101.60","106.2"],"swapresult1":["70.2"],"符合元组结构":["70.2"],"首尾元素替换":["70.2"],"swapresult2":["70.2"],"不符合结构":["70.2"],"进行判断的联合类型被作为泛型参数传入给另一个独立的类型别名":["70.3"],"中直接对这两者进行判断":["70.3"],"记住第一个差异":["70.3"],"是否通过泛型参数传入":["70.3"],"我们再看一个例子":["70.3"],"naked":["70.3"],"y":["70.3"],"n":["70.3","89.1","96.16","101.58","103.6"],"wrapped":["70.3"],"res3":["70.3"],"res4":["70.3"],"现在我们都是通过泛型参数传入了":["70.3"],"但诡异的事情又发生了":["70.3"],"为什么第一个还是个联合类型":["70.3"],"第二个倒是好理解一些":["70.3"],"元组的成员有可能是数字类型":["70.3"],"显然不兼容于":["70.3"],"再仔细观察这两个例子你会发现":["70.3"],"它们唯一的差异是条件类型中的":["70.3"],"泛型参数是否被数组包裹":["70.3"],"了":["70.3","77.3","79.19"],"同时":["70.3"],"你会发现在":["70.3"],"的判断中":["70.3"],"其联合类型的两个分支":["70.3"],"恰好对应于分别使用":["70.3"],"去作为条件类型判断时的结果":["70.3"],"把上面的线索理一下":["70.3"],"其实我们就大致得到了条件类型分布式起作用的条件":["70.3"],"infer":["70.4","75.5","76.5","77.3","81.10"],"对于条件类型最核心的部分":["70.4"],"身化万千":["70.5"],"必然是不成立的":["70.5"],"而交叉类型":["70.5"],"也非常奇怪":["70.5"],"它意味着同时符合字面量类型":["70.5"],"和另一个类型":["70.5"],"在学习交叉类型时我们已经了解":["70.5"],"然而":["71.0","77.2"],"这是非常错误的想法":["71.0"],"工具类型学起来不难":["71.0"],"它的概念也不复杂":["71.0"],"可写":["71.1"],"我们将这一类统称为":["71.1"],"属性修饰工具类型":["71.1"],"对既有类型的裁剪":["71.1"],"拼接":["71.1"],"转换等":["71.1"],"比如使用对一个对象类型裁剪得到一个新的对象类型":["71.1"],"required":["71.2"],"readonly":["71.2"],"其中":["71.2","71.5","81.2","85.22","85.32","89.3"],"这一类属性修饰的工具类型":["71.3"],"不妨想想它们是否能满足我们的需要":["71.3"],"假设场景逐渐开始变得复杂":["71.3"],"可以是单个类型":["71.4"],"也可以是联合类型":["71.4"],"即为属性的类型":["71.4"],"键名均为字符串":["71.4"],"键值类型未知":["71.4"],"record1":["71.4"],"键值类型任意":["71.4"],"record2":["71.4"],"键名为字符串或数字":["71.4"],"record3":["71.4"],"是日常使用较多的形式":["71.4"],"互斥":["71.5"],"存在时不允许":["71.5"],"存在":["71.5"],"集合":["71.6"],"为集合":["71.6"],"的子集":["71.6"],"的补集":["71.6"],"完整的集合":["71.6"],"内置工具类型中提供了交集与差集的实现":["71.6"],"extract":["71.6","81.10"],"这里的具体实现其实就是条件类型的分布式特性":["71.6"],"即当":["71.6"],"都是联合类型":["71.6"],"视为一个集合":["71.6"],"时":["71.6","82.4","96.16"],"的成员会依次被拿出来进行":["71.6"],"如果现在我们要处理":["71.7"],"对象类型结构的集合运算":["71.7"],"functiontype":["71.8"],"args":["71.8","73.1","84.7"],"parameters":["71.8"],"p":["71.8","71.12","79.9","79.13","79.19","89.2","110.6","112.1","112.2","112.5","113.6","113.7"],"returntype":["71.8"],"和条件类型的搭配看起来会有奇效":["71.9"],"内置的工具类型进行了全面地讲解":["71.10"],"从它们的原理":["71.10"],"加上对提取字符串的条件类型":["71.12"],"等工具时自动地收窄类型":["72.0"],"可辨识联合类型":["72.0"],"等等":["72.0","78.6","87.2","121.3"],"lineno":["72.1"],"colno":["72.1"],"我们自己实现一个函数签名":["72.1"],"其实也是一样的效果":["72.1"],"customhandler":["72.1"],"也推导出了参数类型":["72.1"],"除了参数类型":["72.1"],"返回值类型同样会纳入管控":["72.1"],"handler2":["72.2"],"handler3":["72.2"],"handler4":["72.2"],"另一个方向":["72.3"],"的类型推导":["72.3"],"了解了它是基于位置进行类型匹配的":["72.3"],"foreach":["72.5"],"push":["72.5","96.19","96.23"],"一节中":["73.0"],"我们分析了":["73.0"],"类型系统自下而上的层级":["73.0"],"比较了原始类型":["73.0"],"dogfactory":["73.1"],"在本文中":["73.1"],"我们进一步将其简化为":["73.1"],"的表达形式":["73.1"],"对于函数类型比较":["73.1"],"实际上我们要比较的即是参数类型与返回值类型":["73.1"],"也只能是这俩位置的类型":["73.1"],"这三个类":["73.1"],"如果将它们分别可重复地放置在参数类型与返回值类型处":["73.1"],"相当于排列组合":["73.1"],"就可以得到以下这些函数签名类型":["73.1"],"这里的结果中不包括":["73.1"],"因为我们要用它作为基础来":["73.1"],"被":["73.1"],"假设我们对其进行返回值类型的函数签名类型包装":["73.2"],"则有":["73.2"],"也即是说":["73.2"],"在我需要狗狗的地方":["73.2"],"柯基都是可用的":["73.2"],"即不考虑参数类型的情况":["73.2"],"在包装为函数签名的返回值类型后":["73.2"],"其子类型层级关系保持一致":["73.2"],"如果换成参数类型的函数签名类型包装":["73.2"],"很自然的我们会产生一些疑惑":["73.3"],"如果启用了这个配置才是逆变检查":["73.3"],"那么原来是什么样的":["73.3"],"在实际场景中的逆变检查又是什么样的":["73.3"],"还是以我们的三个类为例":["73.3"],"首先是一个函数以及两个函数类型签名":["73.3"],"fn":["73.3","101.19"],"dog":["73.3"],"bark":["73.3"],"corgifunc":["73.3"],"corgi":["73.3"],"animalfunc":["73.3"],"animal":["73.3","73.7"],"我们通过赋值的方式来实现对函数类型的比较":["73.3"],"函数类型之间同样是能够比较的":["73.4"],"而对我们开头提出的":["73.4"],"如何对两个函数类型进行兼容性比较":["73.4"],"这一问题":["73.4"],"我想你也有了答案":["73.4"],"比较它们的参数类型是否是反向的父子类型关系":["73.4"],"返回值是否是正向的父子类型关系":["73.4"],"如果用本章学到的新知识来说":["73.4"],"其实就是判断":["73.4"],"以及兄弟类型":["73.6"],"同一基类的两个派生类":["73.6"],"先不考虑":["73.7"],"内部的实现":["73.7"],"只知道它同时只能放一个物种的动物":["73.7"],"能被作为":["73.7"],"的子类型吗":["73.7"],"以及类型编程":["74.0"],"对实际项目开发的帮助在哪里":["74.0"],"我真的需要精通它们吗":["74.0"],"这些工具类型看起来真的好烧脑":["74.0"],"你可能看到过基于":["74.1"],"类型实现的四则远算":["74.1"],"斐波那契数列":["74.1"],"象棋":["74.1"],"lisp":["74.1"],"编译器这一类令人叹为观止的操作":["74.1"],"这些就属于类型体操":["74.1"],"但请注意":["74.1"],"这个词并不是贬义的":["74.1"],"相反":["74.1"],"大部分类型体操的作者都是编程功底十分深厚的大牛":["74.1"],"他们发明这些体操的意图并不是为了炫技":["74.1"],"只是为了展示给萌新们新世界的大门":["74.1"],"我个人也非常佩服能写出如此高阶类型运算的大佬们":["74.1"],"这些体操虽然对实际项目开发的意义非常有限":["74.1"],"但却可以从另外一个角度让你认识到":["74.1"],"类型系统的图灵完备":["74.1"],"以及在高手手里所表现出来的精妙技巧":["74.1"],"如果你因为看不懂这些体操":["74.1"],"或者想不出更炫酷的体操而感到焦虑":["74.1"],"那就需要警醒一下了":["74.1"],"类型体操绝不代表你的":["74.1"],"antfu":["74.2","81.6"],"团队成员":["74.2"],"以及":["74.2","75.5","77.4","85.23","86.42","96.6"],"以及它们的扩展方向":["75.0"],"这一节":["75.0"],"我们会在这些基础上逐一实现这些扩展方向":["75.0"],"nested":["75.1"],"nestedfoo":["75.1"],"nestedbar":["75.1"],"nestedbarfoo":["75.1"],"的泛型坑位中传入一个类型":["75.1"],"然后再传入一个值":["75.1"],"就可以验证这个值是否符合泛型类型了":["75.1"],"类似的":["75.1","78.7"],"我们还可以实现其他进行递归属性修饰的工具类型":["75.1"],"展示如下":["75.1"],"deeprequired":["75.1"],"也可以记作":["75.1"],"deepimmutable":["75.1"],"属性名":["75.2"],"属性名字面量类型":["75.2"],"对于非函数类型的属性":["75.2"],"其值为":["75.2"],"我们加上":["75.2"],"这一索引类型查询":["75.2"],"操作符的组合":["75.2"],"whatwillweget":["75.2"],"我们神奇地获得了所有函数类型的属性名":["75.2"],"这又是如何实现的呢":["75.2"],"其实就是我们此前学习过的":["75.2"],"当索引类型查询中使用了一个联合类型时":["75.2"],"它会使用类似分布式条件类型的方式":["75.2"],"将这个联合类型的成员依次进行访问":["75.2"],"然后再最终组合起来":["75.2"],"上面的例子可以这么简化":["75.2"],"whatwillwegetequal1":["75.2"],"whatwillwegetequal2":["75.2"],"whatwillwegetequal3":["75.2"],"通过这一方式":["75.2"],"我们就能够获取到符合预期类型的属性名了":["75.2"],"如果希望抽象":["75.2"],"基于键值类型查找属性":["75.2"],"名这么个逻辑":["75.2"],"我们就需要对":["75.2"],"的逻辑进行封装":["75.2"],"将预期类型也作为泛型参数":["75.2"],"由外部传入":["75.2"],"expectedpropkeys":["75.2"],"valuetype":["75.2"],"expecttype":["75.2"],"报错":["75.2","80.41"],"不是函数类型属性":["75.2"],"为了避免可选属性对条件类型语句造成干扰":["75.2"],"补集":["75.3"],"complement":["75.3"],"我们对应地实现对象属性名的版本":["75.3"],"使用更精确的对象类型描述结构":["75.3"],"plainobjecttype":["75.3"],"record":["75.3","79.4"],"属性名并集":["75.3"],"objectkeysconcurrence":["75.3"],"属性名交集":["75.3"],"objectkeysintersection":["75.3"],"要提取最后一个参数类型则可以这样":["75.4"],"lastparameter":["75.4"],"将":["75.5"],"复杂类型降维到基础类型再逐个击破":["75.5"],"在嵌套的条件类型中基于":["75.5"],"多次修改类型结构":["75.5"],"来提取最终需要的类型":["75.5"],"最重要的是":["75.5","88.1"],"mutablekeys":["75.7"],"immutablekeys":["75.7"],"也是如此":["75.7","87.2"],"我们可以通过一个很巧妙的方式判断一个属性是否是必选的":["75.7"],"先看一个例子":["75.7"],"tmp1":["75.7"],"在这里":["75.8"],"我们稍作驻足":["76.0"],"放慢节奏":["76.0"],"来学习":["76.0"],"bigint":["76.1"],"greet1":["76.1"],"greet2":["76.1"],"greet3":["76.1"],"greet4":["76.1"],"greet5":["76.1"],"changelistener":["76.3"],"changed":["76.3"],"listener":["76.3"],"提示并约束为":["76.3"],"namechanged":["76.3"],"agechanged":["76.3"],"jobchanged":["76.3"],"在需要基于已有的对象类型进行字面量层面的变更时":["76.3"],"heavyname":["76.4"],"respectname":["76.4"],"上面的重映射部分":["76.4"],"我们成功将键名从":["76.4"],"修改成了":["76.4"],"modified":["76.4"],"的形式":["76.4"],"如果要修改成我们更习惯的小驼峰形式呢":["76.4"],"first":["76.5"],"last":["76.5"],"capitalize":["76.5"],"我们一共在两处使用了模板字符串类型":["76.5"],"首先是在约束部分":["76.5"],"我们希望传入的字符串字面量类型是":["76.5"],"tom":["76.5"],"hardy":["76.5"],"budu":["76.5"],"还包括了专用的工具类型等":["76.6"],"在实际应用中":["76.6"],"由于其灵活性与自动分发联合能力等能力":["76.6"],"我们可以用它来进行大量字面量类型的定义与约束":["76.6"],"另外":["76.6","94.8"],"模板字符串类型本身也和此前已存在类型工具":["76.6"],"我们也可以基于重映射来实现":["76.8"],"结构处理":["76.8"],"工具类型":["76.8"],"reversename":["77.0"],"前后声明了两个":["77.1"],"插槽":["77.1"],"但实际上并不消费":["77.1"],"而只是判断字符串是否可以被划分为":["77.1"],"要搜索的部分":["77.1"],"其他部分":["77.1"],"来验证一下实际效果":["77.1"],"includeres1":["77.1"],"includeres2":["77.1"],"includeres3":["77.1"],"includeres4":["77.1"],"includeres5":["77.1"],"replaceres2":["77.2"],"你应该遇到过需要全量替换的场景":["77.2"],"也就是":["77.2","82.1"],"replaceall":["77.2"],"那我们能否在类型层面也实现一个":["77.2"],"当然没问题":["77.2"],"只需要再请出我们的老朋友":["77.2"],"递归":["77.2"],"mmm":["77.2"],"replaceallres1":["77.2"],"www":["77.2"],"w":["77.2"],"m":["77.2"],"replaceallres2":["77.2"],"如果你更喜欢将这两个类型合并在一起":["77.2"],"再通过选项来控制是否进行全量替换":["77.2"],"其实也很简单":["77.2"],"在结构工具类型中我们就试过引入类型层面的选项控制":["77.2"],"这里也是类似":["77.2"],"shouldreplaceall":["77.2"],"在这里即是":["77.3"],"以外的后续部分都转为首字母大写":["77.3"],"至于怎么转":["77.3"],"当然是贴心内置的":["77.3"],"我们直接来看实现":["77.3"],"由于这部分会有大量的结果验证":["77.3"],"我们再次请出":["77.3"],"s":["77.3","83.2"],"head":["77.3"],"解决了":["77.3"],"稍微举一反三":["77.3"],"kebabcase":["77.3"],"中划线":["77.3"],"其实也解决了":["77.3"],"不就是换个分隔符的事":["77.3"],"kebabcase2camelcase":["77.3"],"的唯一区别就是模式匹配的分隔符":["77.3"],"身为封装工程师":["77.3"],"我们肯定要把分隔符的能力进行抽象":["77.3"],"支持任意的分隔符":["77.3"],"delimitercase2camelcase":["77.3"],"replace":["77.4"],"split":["77.4"],"转换等工具类型":["77.4"],"这些类型虽然在实际项目开发中使用场景有限":["77.4"],"实战篇主要包括了工程能力":["78.0"],"框架集成":["78.0"],"语法":["78.0","82.10","107.37","121.4"],"inline":["78.1"],"comments":["78.1"],"用于支持在某一处特定代码":["78.1"],"基本上所有的类型报错都可以通过这个指令来解决":["78.2"],"但由于它本质是上":["78.2"],"disable":["78.2"],"也就意味着如果下一行代码并没有问题":["78.2"],"那使用":["78.2"],"反而就是一个错误了":["78.2"],"呢":["78.3","88.2"],"这看起来是一个多余的指令":["78.3"],"因为默认情况下":["78.3"],"文件不是就会被检查吗":["78.3"],"实际上":["78.3","78.10","83.10"],"这两个指令还可以用在":["78.3"],"文件中":["78.3"],"要明白这一点":["78.3"],"首先我们要知道":["78.3"],"并不是只能检查":["78.3"],"我们可以直接访问这些声明":["78.4"],"otherprop":["78.4"],"但不能为这些声明变量赋值":["78.4"],"不允许在环境上下文中使用初始值":["78.4"],"在核心代码文件以外去提供对类型的进一步补全":["78.5"],"类型声明文件":["78.5"],"d":["78.5","78.7","79.2","79.15","84.1","85.29","86.25","87.3","92.0"],"结尾的文件":["78.5"],"它会自动地被":["78.5"],"加载到环境中":["78.5"],"实现对应部分代码的类型补全":["78.5"],"声明文件中并不包含实际的代码逻辑":["78.5"],"它做的事只有一件":["78.5"],"类型检查与推导提供额外的类型信息":["78.5"],"而使用的语法仍然是":["78.5"],"只不过现在我们要进一步学习其它打开方式了":["78.5"],"要详细学习声明文件与":["78.5"],"我们不妨先来看看如何解决上面的问题":["78.5"],"lodash":["78.6"],"来提供类型定义的包常见的有几种情况":["78.6"],"这样的库仍然有大量":["78.6"],"项目使用":["78.6"],"将类型定义内置在里面不一定是所有人都需要的":["78.6"],"反而会影响包的体积":["78.6"],"还有像":["78.6"],"这行代码来自于":["78.7"],"lib":["78.7","86.25"],"它定义了对浏览器文档对象模型的类型声明":["78.7"],"这就是":["78.7"],"提供的内置类型":["78.7"],"也是":["78.7"],"出厂自带":["78.7"],"的类型检查能力的依据":["78.7"],"还有内置的":["78.7"],"reference":["78.8"],"path":["78.8"],"node":["78.8","88.1"],"需要注意的是":["78.8","83.4"],"三斜线指令必须被放置在文件的顶部才能生效":["78.8"],"这里的三条指令作用其实都是声明当前文件依赖的外部类型声明":["78.8"],"只不过使用的方式不同":["78.8"],"分别使用了":["78.8"],"virtualcurrency":["78.9"],"bitcoinpaysdk":["78.9"],"ethpaysdk":["78.9"],"这里的代码是在":["78.9"],"文件中的":["78.9"],"此时它是具有实际逻辑意义的":["78.9"],"也不能和类型混作一谈":["78.9"],"而命名空间的使用类似于枚举":["78.9"],"唯一需要注意的是":["78.9"],"命名空间内部实际上就像是一个独立的代码文件":["78.9"],"因此其中的变量需要导出以后":["78.9"],"才能通过":["78.9"],"这样的形式访问":["78.9"],"虽然类型导入和值导入存在于同一条导入语句中":["78.10"],"在编译后的":["78.10"],"代码里还是只会有值导入存在":["78.10"],"同时在编译的过程中":["78.10"],"值与类型所在的内存空间也是分开的":["78.10"],"在这里我们只能通过名称来区分值和类型":["78.10"],"但为每一个类型都加一个":["78.10"],"后缀也太奇怪了":["78.10"],"我们可以更好地区分值导入和类型导入":["78.10"],"只需要通过":["78.10"],"语法即可":["78.10"],"类型声明":["78.11"],"命名空间":["78.11"],"三个部分":["78.11"],"类型声明相关的能力几乎是所有规模的工程都会使用到的":["78.11"],"你总会遇到没有提供类型定义的库吧":["78.11"],"通过大量的额外类型声明我们可以实现更复杂":["78.11"],"更准确的类型保护":["78.11"],"而既然有了类型标注":["78.13"],"那么自然也能享受到像":["78.13"],"文件中一样的类型提示了":["78.13"],"但这里我们需要使用更强大一些的":["78.13"],"能力":["78.13"],"中使用导入语句":["78.13"],"tsx":["79.0","79.1","79.16"],"文件本质上也是一个":["79.0"],"因此可以直接享受到":["79.0"],"的类型检查能力":["79.0"],"也因此":["79.0","86.27"],"模板即可":["79.1"],"最终的项目结构是这样的":["79.1"],"index":["79.1","85.8","85.10","85.11","85.13","85.20","86.27","96.23"],"package":["79.1"],"src":["79.1","85.10","85.20","86.39","87.7","95.2","107.67","107.82"],"app":["79.1","85.10","86.27","86.39","87.7","88.3","95.4","113.21"],"css":["79.1","97.6","97.21","100.4","110.3","110.7"],"而除了这一点":["79.2"],"当我们从":["79.2"],"中导出一个类型":["79.2"],"fc":["79.2"],"实际上这个类型也来自于":["79.2"],"接着是项目内的":["79.2"],"env":["79.2","87.3","88.3"],"声明文件":["79.2"],"我们会发现它只有短短的一行":["79.2"],"controller":["79.3"],"属性默认值":["79.3"],"defaultprops":["79.3"],"也可以通过参数默认值的形式非常自然地进行声明":["79.3"],"这么做看起来很朴素":["79.3"],"icellprops":["79.4"],"tdata":["79.4","88.4"],"field":["79.4"],"cell":["79.4"],"hooks":["79.5"],"此时类型为":["79.6"],"state2":["79.6"],"setstate2":["79.6"],"需要注意的是在显式传入泛型时":["79.6"],"如果像上面的例子一样没有提供初始值":["79.6"],"隐式推导":["79.7"],"显式提供":["79.7"],"两种":["79.7","80.29"],"container":["79.7","79.10"],"泛型推导为":["79.7"],"actions":["79.8"],"inc":["79.8"],"payload":["79.8"],"dec":["79.8"],"min":["79.8"],"state":["79.8","107.77","112.1","112.2"],"此时其类型":["79.9"],"会被推断为":["79.9"],"refobject":["79.9"],"的值类型则为":["79.9"],"mutablerefobject":["79.9"],"这是完全符合预期的":["79.9"],"因为我们并不会去修改挂载了":["79.9"],"引用的":["79.9"],"而确实会修改值引用的":["79.9"],"所以后者会是":["79.9"],"mutable":["79.9"],"然而实际上":["79.9"],"这一差异并不是通过判断是否被应用在了":["79.9"],"引用来实现的":["79.9"],"setv":["79.10"],"handlechange":["79.10"],"而是仅在组件库开发等场景时才会使用到":["79.11"],"ibuttonprops":["79.12"],"button":["79.12","100.2","107.100","114.11","114.12","115.5"],"size":["79.12","107.82"],"small":["79.12"],"large":["79.12"],"link":["79.12","93.10"],"propswithchildren":["79.13","79.19"],"functioncomponent":["79.13","79.19"],"我们其实已经基本了解了":["79.14"],"request":["79.15"],"tool":["79.15"],"typings":["79.15"],"我们来依次讲解下这些类型声明文件的作用":["79.15"],"被其他类型定义所使用的类型":["79.15"],"如简单的联合类型封装":["79.15"],"简单的结构工具类型等":["79.15"],"此时我推荐的方式是":["79.16"],"将这个类型定义在父组件中":["79.16"],"子组件使用仅类型导入去导入这个类型":["79.16"],"由于值空间与类型空间是隔离的":["79.16"],"因此我们并不需要担心循环引用":["79.16"],"结合使用的方式":["79.17"],"我们再来看一看":["79.19"],"的类型定义":["79.19"],"reactnode":["79.19"],"context":["79.19"],"reactelement":["79.19"],"的属性中是默认包含了":["79.19"],"检查与格式化后工工整整的代码":["80.0"],"那简直叫一个赏心悦目":["80.0"],"我认为它就是现代前端工程必备的一样工具":["80.0"],"无论是简单的寥寥几行配置":["80.0"],"还是精心挑选了最适合自己或者团队风格的规则集":["80.0"],"它都是不可缺少的一环":["80.0"],"安装以下依赖":["80.1"],"plugin":["80.1","93.3","94.1"],"parser":["80.1"],"save":["80.1","80.2","80.3"],"dev":["80.1","80.2","81.2"],"yarn":["80.1","80.2"],"pnpm":["80.1","80.2","94.1"],"这些":["80.2"],"涉及具体代码逻辑":["80.2"],"的规则":["80.2"],"而是专注于":["80.2"],"indent":["80.2"],"quote":["80.2"],"comma":["80.2"],"逗号":["80.2"],"printwidth":["80.2"],"每行允许的字符串长度":["80.2"],"等规则":["80.2"],"首先安装":["80.2"],"如果你想要让":["80.2"],"也参与格式化代码文件":["80.2"],"还需要安装":["80.2"],"config":["80.2","80.3"],"这一配置包禁用了部分":["80.2"],"中会与":["80.2"],"产生冲突的规则":["80.2"],"install":["80.2","107.7"],"创建":["80.2","121.6"],"配置文件":["80.2","86.41"],"prettierrc":["80.2"],"我们选择一小部分常用的":["80.2"],"exports":["80.2","87.2"],"单行最多":["80.2"],"字符":["80.2"],"一个":["80.2"],"tab":["80.2"],"缩进":["80.2"],"个空格":["80.2"],"tabwidth":["80.2"],"如何约束代码":["80.3"],"与配置等":["80.3"],"我也简单对这些规则做了分类":["80.3"],"基础版与进阶版":["80.3"],"基础版为约束程度较低的规则":["80.3"],"而进阶版则较为严格":["80.3"],"如果你想直接使用现成的配置":["80.3"],"我也将下面介绍的规则发布到了":["80.3"],"首先安装配置集":["80.3"],"ruleset":["80.3"],"两种方式声明数组类型":["80.6"],"此规则约束项目中对这两种数组类型声明的使用":["80.6"],"promise":["80.7","82.12","89.4"],"两种不同的语法进行类型断言":["80.8"],"在绝大部分场景下":["80.9"],"来声明对象类型":["80.9"],"应当用于声明联合类型":["80.9"],"工具类型等":["80.9"],"循环遍历数组时":["80.10"],"如果索引仅仅用来访问数组成员":["80.10"],"则应该替换为":["80.10"],"就像我们在类型声明那一节所了解的":["80.12"],"能够帮助你更好地组织你的项目头部的导入结构":["80.12"],"值导入与类型导入在":["80.12"],"此规则要求在类型断言仅起到去空值作用":["80.13"],"如将":["80.13"],"返回":["80.14"],"虽然":["80.15"],"是允许使用各种合法表达式作为枚举成员的":["80.15"],"但由于枚举的编译结果拥有自己的作用域":["80.15"],"因此可能导致错误的赋值":["80.15"],"imoutside":["80.15"],"对于常量断言":["80.16"],"指令的使用":["80.20"],"或者允许其在提供了说明的情况下被使用":["80.20"],"text":["80.20","85.9","85.10","86.27","86.39","87.3","87.7"],"assertion":["80.22","80.25"],"不允许额外的重复非空断言":["80.22"],"asserted":["80.23","80.24"],"nullish":["80.23","82.2"],"coalescing":["80.23","82.2"],"不允许与默认约束一致的泛型约束":["80.26"],"区别如下":["80.29"],"t1":["80.29"],"这些类型":["80.31"],"会让你寸步难行":["80.31"],"上不存在属性":["80.31"],"不允许定义空的接口":["80.32"],"可配置为允许单继承下的空接口":["80.32"],"此前我们已经了解过":["80.33"],"类型的弊端":["80.33"],"甚至":["80.33"],"函数的属性成员进行额外标注":["80.34"],"函数与类方法的返回值需要被显式指定":["80.35"],"而不是依赖类型推导":["80.35"],"不允许对布尔类型变量的":["80.37"],"比较":["80.37"],"一个字符串如":["80.38"],"qiongxin":["80.39"],"developer":["80.39"],"result":["80.39"],"可能为":["80.40"],"的值以及正则表达式":["80.40"],"或者你也可以允许任意的值":["80.40"],"但这样这条规则就形同虚设了":["80.40"],"在模板表达式中":["80.40"],"arr":["80.41","96.23","101.25","101.30"],"不能将":["80.41"],"而是使用":["80.42"],"来进行类型的导入":["80.42"],"下的":["80.43"],"eslint":["80.43","81.0","85.0"],"配置":["80.43","85.12","86.0"],"中的集成":["81.0"],"而在实际项目开发时":["81.0"],"我们在环境搭建一节中已经介绍过":["81.2"],"用于直接执行":["81.2"],"esno":["81.6"],"的作品":["81.6","81.8"],"核心能力同样是执行":["81.6"],"但底层是":["81.6"],"esbuild":["81.6"],"minimum":["81.7"],"tjs":["81.7"],"integer":["81.7","107.140"],"会生成以下的":["81.7"],"definitions":["81.7"],"http":["81.7","107.80"],"目前":["81.8"],"star":["81.8"],"最多下载量最高的工具类型库":["81.8"],"sindre":["81.8"],"sorhus":["81.8"],"而不同于":["81.9"],"the":["81.10","87.3","106.3"],"inferred":["81.10"],"我个人比较看好的一个库":["81.10"],"trpc":["81.10"],"blitz":["81.10"],"等前后端一体交互的框架中能同时提供类型保障和":["81.10"],"校验":["81.10"],"同时和":["81.10"],"prisma":["81.10","87.0"],"这一类库也有着很好地集成":["81.10"],"最重要的是社区生态非常丰富":["81.10"],"有许多自动生成的工具":["81.10"],"report":["81.11"],"检查你的项目中类型的覆盖率":["81.11"],"如果你希望项目的代码质量更高":["81.11"],"比如":["81.12"],"无法编译装饰器":["81.12"],"但可以使用插件":["81.12"],"对含有装饰器的文件回退到":["81.12"],"tsc":["81.12","86.27"],"编译":["81.12"],"swc":["81.12","86.30"],"也无需过多介绍":["81.12"],"工具库":["81.13"],"就像开头所说":["81.13"],"本节的内容会持续更新":["81.13"],"之间的关系":["82.0"],"我们来理清经常看到的":["82.0"],"es":["82.0"],"的竞争中落得下风":["82.1"],"为了避免从此":["82.1"],"web":["82.1"],"脚本的主导权从此落入微软手中":["82.1"],"年":["82.1","83.13"],"网景将":["82.1"],"的标准制定权交给了":["82.1"],"协会":["82.1"],"因此有了":["82.1"],"的语言规范":["82.1"],"并不是一门语言":["82.1"],"而是一门规范":["82.1"],"我们说的":["82.1"],"es5":["82.1","85.25","89.0"],"esnext":["82.1","85.23"],"等等概念":["82.1"],"实际上指的都是":["82.1"],"这门语言规范的新版本":["82.1"],"维护着数百条规范":["82.1"],"这些规范的领域差异非常大":["82.1"],"因此":["82.1"],"采用技术小组":["82.1"],"technical":["82.1"],"optional":["82.2"],"chainning":["82.2"],"空值合并":["82.2"],"逻辑赋值":["82.2"],"这样的错误":["82.3"],"我们通常会使用":["82.3"],"逻辑与":["82.3"],"语法来确保在某一层出现空值时及时短路掉访问":["82.3"],"inner":["82.3"],"somevalue":["82.4"],"fallbackvalue":["82.4"],"逻辑或会在":["82.4"],"左边被判断为":["82.4"],"还有除法运算":["82.5"],"就不演示了":["82.5"],"tc39":["82.6","83.13"],"以及大家都至少听说过的装饰器以外":["82.8"],"还有许多演进中的":["82.8"],"我们可以简单归类为语法糖":["82.8"],"中引入了两个新的":["82.9"],"原始":["82.9"],"数据类型":["82.9"],"分别对应到对象与数组":["82.9"],"差异仅仅是声明时多了个":["82.9"],"很难说这对":["82.10"],"开发者来说是否是刚需":["82.10"],"但它们确实能带给你另一种截然不同的编程范式":["82.10"],"这一提案的理念背景是函数式编程中的面向表达式":["82.10"],"oriented":["82.10"],"它长这个样子":["82.10"],"这一提案尝试引入原生的":["82.11"],"支持":["82.11","88.1"],"你可以简单理解为这是用于处理较复杂异步场景的神器":["82.11"],"如果不是工作中确实需要处理复杂的异步场景":["82.11"],"我个人并不推荐去深入学习":["82.11"],"double":["82.12"],"then":["82.12"],"我们能将以上代码改写为这样":["82.12"],"也成功进入到":["82.13"],"stage1":["82.13"],"这一提案的目的是引入和":["82.13"],"中一样":["82.13"],"会在编译时被擦除的类型标注":["82.13"],"其语法也和":["82.13"],"基本一致":["82.13"],"提案也已经成为":["83.0"],"中相当重要的一部分":["83.0"],"它就是装饰器":["83.0"],"装饰器语法在":["83.0"],"python":["83.0","88.1"],"java":["83.0","88.1"],"等语言中都能见到":["83.0"],"但在":["83.0"],"中的装饰器可以分为":["83.1"],"类装饰器":["83.1"],"method":["83.2"],"newstaticmethod":["83.2"],"等信息":["83.3"],"能拿到原本实现":["83.3"],"也就意味着":["83.3"],"我们可以在执行原本方法的同时":["83.3"],"插入一段新的逻辑":["83.3"],"比如计算这个方法的执行耗时":["83.3"],"computeprofiler":["83.3"],"fetch":["83.3"],"在你对":["83.4"],"进行赋值时触发":["83.4"],"访问符装饰器本质上仍然是方法装饰器":["83.4"],"它们使用的类型定义也相同":["83.4"],"访问符装饰器只能同时应用在一对":["83.4"],"的其中一个":["83.4"],"即要么装饰":["83.4"],"要么装饰":["83.4"],"这是因为":["83.4","89.0"],"不论你是装饰哪一个":["83.4"],"装饰器入参中的属性描述符都会包括":["83.4"],"但你仍然可以通过":["83.5"],"直接在类的原型上赋值":["83.5"],"来修改属性":["83.5"],"参数在函数参数中的索引值":["83.6"],"即第几个参数":["83.6"],"如果只是单独使用":["83.6"],"它的作用同样非常有限":["83.6"],"经过简化":["83.7"],"strict":["83.7","86.35"],"decorate":["83.7"],"decorators":["83.7"],"target":["83.7","84.2","85.25","96.5","101.63"],"desc":["83.7"],"paramindex":["83.7"],"decorator":["83.7"],"依次对装饰器的表达式求值":["83.8"],"得到装饰器的实现":["83.8"],"中实现即为":["83.8"],"中实现则需要进行一次求值":["83.8"],"这些装饰器的具体实现才会":["83.8"],"从下往上":["83.8"],"如这里是":["83.8"],"receiver":["83.9"],"success":["83.9"],"上注册元数据":["83.10"],"而提取则可以通过":["83.10"],"getmetadatakeys":["83.10"],"反射元数据正是我们实现属性装饰器中提到的":["83.10"],"委托":["83.10"],"能力的基础":["83.10"],"我们在属性装饰器中去注册一个元数据":["83.10"],"然后在真正实例化这个类时":["83.10"],"就可以拿到类原型上的元数据":["83.10"],"以此对实例化完毕的类再进行额外操作":["83.10"],"我先通过元数据说明":["83.10"],"这个属性需要获得变量":["83.10"],"在实例化时":["83.10"],"我们发现有这个元数据":["83.10"],"就会对应进行赋值操作":["83.10"],"正是考虑到这一点":["83.10"],"反射元数据中直接就内置了基于装饰器的调用方式":["83.10"],"我们了解了装饰器的基本概念":["83.11"],"包括":["83.11","85.15","86.4","87.2"],"在这期间提案内容":["83.13"],"也就是语法":["83.13"],"作用与运行时机制等":["83.13"],"已经迭代了四个版本":["83.13"],"第四个版本在":["83.13"],"月份的":["83.13"],"会议中终于如愿进入":["83.13"],"stage":["83.13"],"也就意味着这一版本的实现基本上就是未来最终落地的版本":["83.13"],"此前的版本都在":["83.13"],"方法中有一段代码是检查":["83.14"],"控制反转":["84.0"],"现在一共只有三个类":["84.1"],"倒还没问题":["84.1"],"如果随着开发这些类的数量与依赖关系复杂度暴涨":["84.1"],"依赖":["84.1"],"再加上每个类需要实例化的参数可能又有所不同":["84.1"],"此时再去手动维护这些依赖关系与实例化过程就是灾难了":["84.1"],"而控制反转模式则能够很好地解决这一问题":["84.1"],"它引入了一个容器的概念":["84.1"],"内部自动地维护了这些类的依赖关系":["84.1"],"当我们需要一个类的时候":["84.1"],"它会帮我们把这个类内部依赖的实例都填充好":["84.1"],"我们直接用就行":["84.1"],"methoddecoratorfactory":["84.2"],"methoddecorator":["84.2"],"descriptor":["84.2"],"在方法实现上注册":["84.2"],"请求方法":["84.2"],"的元数据":["84.2"],"reflect":["84.2","84.4"],"definemetadata":["84.2"],"这样一来":["84.2"],"依赖于驱动":["84.3"],"这个容器会帮我们完成":["84.3"],"注入到":["84.3"],"内的操作":["84.3"],"那这个容器如何知道有哪些类需要被提前实例化呢":["84.3"],"我们使用一个":["84.3"],"装饰器":["84.3"],"被其标记的":["84.3"],"会自动被容器收集":["84.3"],"然后在需要使用这些类实例的地方":["84.3"],"装饰器声明这里需要哪个实例":["84.3"],"容器就会自动地将这个属性注入进来":["84.3"],"这里有一个比较复杂的地方":["84.3"],"在存储一个类和注入一个类时":["84.3"],"我们需要有一个标识符":["84.3"],"才能实现一一对应的注入方式":["84.3"],"在上面的例子里我们的":["84.3"],"装饰器都是使用无参数调用的":["84.3"],"这样的话标识符从何而来":["84.3"],"你可能会想到使用内置的元数据信息":["84.3"],"的确是这样":["84.3"],"但是为了降低学习成本":["84.3"],"我们先来了解如何不使用元数据来实现这个":["84.3"],"也就是我们能够这么使用":["84.3"],"driverservice":["84.3"],"propertydecorator":["84.4"],"propertykey":["84.4"],"propertyregistry":["84.4"],"getmetadata":["84.4"],"design":["84.4"],"本节的代码并没有在类型上进行十分精确的处理":["84.4"],"这主要是为了避免增加额外的代码复杂度":["84.4"],"毕竟我们的主要目的是":["84.4"],"理解依赖注入":["84.4"],"而不是类型":["84.4"],"我们支持了在不传入标识符时":["84.4"],"作为默认的标识符":["84.4"],"再到反射":["84.5"],"反射元数据":["84.5"],"最后到控制反转与依赖注入":["84.5"],"onlyfoo":["84.7"],"只能在":["84.7"],"及其子类上应用":["84.7"],"此时就可以通过约束":["84.7"],"的类型实现":["84.7"],"classstruct":["84.7"],"restrictedclassdecorator":["84.7"],"tclass":["84.7"],"的结合使用以及装饰器等":["85.0"],"这些实践更像是上层建筑":["85.0"],"默认是在一个已经基本配置完环境的":["85.0"],"项目中进行的":["85.0"],"我们在装饰器一节中已经了解了此选项对实际编译代码的作用":["85.4"],"metadata":["85.4"],"转换":["85.5"],"也可以将其配置为":["85.5"],"jsxdev":["85.5"],"组件会被转换为对":["85.5"],"方法的调用与生成":["85.5"],"此方法来自于":["85.5"],"runtime":["85.5"],"helloworld":["85.5","107.65","107.67"],"hello":["85.5","85.25","86.22","101.13","107.54","110.6"],"world":["85.5"],"babel":["85.6","86.30"],"中也有":["85.6"],"targets":["85.6"],"的概念":["85.6"],"但这里的":["85.6"],"通常指的是预期运行的浏览器":["85.6"],"chrome":["85.6"],"然后基于":["85.6"],"browserlist":["85.6"],"获取浏览器信息":["85.6"],"基于":["85.6"],"caniuse":["85.6"],"compat":["85.6"],"table":["85.6"],"获取各个浏览器版本支持的特性":["85.6"],"最后再进行语法的降级":["85.6"],"如果没有特殊需要":["85.6"],"推荐将":["85.6"],"设置为":["85.6"],"包括从何处开始收集要构建的文件":["85.7"],"compileroptions":["85.8","85.12","85.14","86.38"],"如果你的文件数量较多":["85.8"],"或者分散在各个文件夹":["85.8"],"此时可以使用":["85.8"],"进行配置":["85.8"],"所在的路径来确定根目录的位置":["85.9"],"project":["85.9","85.10","85.13","86.28","87.7","89.2","107.4"],"out":["85.9","106.3"],"因为声明文件可能会和":["85.10"],"位于同一层级":["85.10"],"最长公共路径又是什么":["85.10"],"简单地说":["85.10"],"它就是某一个":["85.10"],"包含了所有被包括的":["85.10"],"文件的文件夹":["85.10"],"会找到这么一个文件夹":["85.10"],"默认将其作为":["85.10"],"utils":["85.10","85.16","86.27","89.8"],"helpers":["85.10"],"locale":["85.11"],"还是会隐式地推导":["85.11"],"此时它的值为":["85.11"],"路径":["85.12"],"这么做可以让你更方便地使用第三方库的类型":["85.12"],"但如果你希望只加载实际使用的类型定义包":["85.12"],"就可以通过":["85.12"],"jest":["85.12"],"其中存在基于相对路径":["85.13"],"require":["85.13","86.35"],"的导入":["85.13","89.4"],"则会依次按照以下顺序解析":["85.13"],"文件是否存在":["85.13"],"是否是一个文件夹":["85.13"],"此文件夹内部是否包含":["85.13"],"moduleresolution":["85.14"],"它同样影响对模块的解析策略":["85.14"],"但仅影响模块的后缀名部分":["85.14"],"如以下配置":["85.14"],"会将你代码中导入的文件也解析为程序的一部分":["85.15"],"允许你通过":["85.16"],"或类似的方式来简化导入路径":["85.16"],"并对导入内容获得完整的基于实际":["85.17"],"通常情况下会按照原本的目录结构存放":["85.20"],"core":["85.20","85.24"],"常量枚举会在编译时被抹除":["85.21"],"这两个选项主要控制最终是否将构建产物实际写入文件系统中":["85.22"],"nodenext":["85.23"],"等":["85.23","86.30","88.1","99.6"],"实际的值也可以是全小写的形式":["85.23"],"另外也支持":["85.23"],"amd":["85.23"],"这一功能是通过":["85.24"],"原":["85.24"],"polyfill":["85.24"],"实现的":["85.24"],"中这些辅助函数被统一封装在了":["85.24"],"tslib":["85.24"],"通过启用":["85.24"],"或更低":["85.25"],"循环会被降级为普通的基于索引的":["85.25"],"源代码":["85.25"],"remove":["85.26"],"即对仅类型导入进行抹除":["85.26"],"你也可以将其更改为":["85.26"],"preserve":["85.26"],"这样所有的导入语句都会被导入":["85.26"],"但是类型变量仍然会被抹除":["85.26"],"或者是":["85.26"],"在这种情况下首先所有导入语句仍然会被保留":["85.26"],"但会在值导入仅被用于类型时产生一个错误":["85.26"],"举例来说":["85.26"],"以下代码中的仅类型导入会在":["85.26"],"接受一个布尔值":["85.28"],"即是否产生声明文件":["85.28"],"控制写入声明文件的路径":["85.28"],"map":["85.29"],"这样你就可以从":["85.29"],"而不会包含":["85.30"],"有关":["85.31"],"我们就放在一起介绍了":["85.31"],"sourcemap":["85.31"],"inlinesourcemap":["85.31"],"有些类似于":["85.31"],"lf":["85.32"],"换行风格":["85.32"],"其实就是":["85.32"],"carriage":["85.32"],"其中主要的概念包括如何配置你的输入与输出":["85.33"],"以及如何启用特殊的语法等":["85.33"],"这也是导致":["86.1"],"且默认情况下为禁用或者给出警告":["86.2"],"commonjs":["86.3"],"通过判断当前环境下哪种规范可用就使用哪种规范":["86.3"],"示例如下":["86.3"],"源码":["86.3"],"编译结果":["86.3"],"global":["86.3"],"常见的":["86.4"],"语句":["86.4","86.13"],"语句会被标记为":["86.5"],"然后在别的地方你就可以用":["86.5"],"来引用这段语句":["86.5"],"如标记一个函数":["86.5"],"非严格模式下":["86.5"],"也包括实际的代码逻辑":["86.6"],"它们主要关注未被妥善处理的逻辑代码与无类型信息":["86.6"],"而推导为":["86.8"],"类型就意味着丧失了类型检查":["86.8"],"类型会被更改为":["86.9"],"连续执行指的是某一个":["86.11"],"中自己执行了专属逻辑后":["86.11"],"由于没有":["86.11"],"break":["86.11"],"语句导致继续向下执行":["86.11"],"不希望去覆盖基类已有的方法":["86.12"],"solid":["86.12"],"原则":["86.12"],"这样可以确保在任何需要基类的地方":["86.12"],"我们都可以放心地传入一个派生类":["86.12"],"函数缺少结束":["86.13"],"占据主导地位的今天":["86.14"],"我们通常只会在":["86.14"],"内部使用":["86.14"],"还是为":["86.14"],"allstringtypes":["86.15"],"nounusedparameters":["86.16"],"prefer":["86.18"],"dark":["86.18"],"light":["86.18","107.65"],"默认情况下":["86.18"],"属性的类型实际为":["86.18"],"也就是说你可以这么做":["86.18"],"中的严格模式吗":["86.19"],"这一配置就是它在":["86.19"],"开启":["86.20"],"来改变一个函数的":["86.21"],"指向":["86.21"],"绝大部分情况下即使改变了":["86.21"],"tolowercase":["86.22"],"stringornumberfunc":["86.22"],"时成立":["86.23"],"prop2":["86.24"],"prop3":["86.24"],"没有初始化表达式":["86.24"],"且未在构造函数中明确赋值":["86.24"],"会对加载的类型声明文件也进行检查":["86.25"],"包括内置的":["86.25"],"关于具体项目":["86.27"],"请参考我们仓库中的示例":["86.27"],"这一特性实际上也让":["86.27"],"不再只是一个编译器了":["86.27"],"它现在还可以是一个类似于":["86.27"],"lerna":["86.27"],"那样的":["86.27"],"script":["86.27","93.9","101.1"],"runner":["86.27"],"即在多个子项目之间去确定一条顺序正确的构建链路":["86.27"],"在使用":["86.27"],"的项目中":["86.27"],"需要使用":["86.27"],"build":["86.27"],"而非":["86.27"],"来进行构建":["86.27"],"会首先确定整个引用关系图":["86.27"],"然后检查上面作为子结点的项目是否是最新构建的":["86.27"],"最后才基于引用顺序去构建这些非最新的项目":["86.27"],"我们可以来实际体验一下":["86.27"],"假设要构建的项目结构是这样的":["86.27"],"内部的配置":["86.28"],"通常在这个过程中":["86.30"],"类型相关的检查会完全交由":["86.30"],"处理":["86.30"],"你才能在":["86.32"],"文件提供尽可能全面的类型检查":["86.33"],"reactcopy":["86.35"],"命名空间导入":["86.35"],"namespace":["86.35"],"这样的代码在默认情况下":["86.35"],"即没有启用":["86.35"],"会被编译为":["86.35"],"esmodule":["86.35"],"配置将启用增量构建":["86.37"],"在每次编译时首先":["86.37"],"modules":["86.38"],"文件夹的变化进行监听":["86.38"],"但只到文件夹级别":["86.38"],"时重新进行编译":["86.38"],"通常我们会搭配":["86.38"],"incremental":["86.38"],"选项":["86.38"],"你可以通过与":["86.38"],"用于了解构建缓慢的可能原因":["86.39"],"listfiles":["86.39"],"listemittedfiles":["86.39"],"会罗列所有被纳入本次编译过程的文件":["86.39"],"可以用于检查是否携带了非预期的文件":["86.39"],"则会罗列输出的文件":["86.39"],"你可以利用这些文件信息进行额外处理":["86.39"],"比如拷贝文件":["86.39"],"traceresolution":["86.39"],"输出一份跟踪模块解析策略与路径的信息":["86.39"],"比如这样":["86.39"],"resolving":["86.39"],"在这里即是一个已存在的":["86.41"],"其作用包括在":["86.41"],"monorepo":["86.41"],"我们了解了":["86.42"],"esm":["86.42"],"cjs":["86.42"],"之间调用的问题":["86.42"],"技术选型方面":["87.0"],"nestjs":["87.0"],"作为框架":["87.0"],"作为":["87.0","94.4"],"orm":["87.0","87.2","87.5"],"的环境":["87.1"],"因为这一步耗时比较久":["87.1"],"我们可以让它在一边安装":["87.1"],"先开始下面的学习":["87.1"],"在终端运行以下命令":["87.1"],"全家桶":["87.2"],"官方团队基本上已经把":["87.2"],"以上的能力都提供完毕":["87.2"],"的集成":["87.2"],"mongoose":["87.2"],"typeorm":["87.2","87.9"],"消息队列":["87.2"],"bull":["87.2"],"open":["87.2"],"swagger":["87.2"],"鉴权":["87.2"],"passport":["87.2"],"graphql":["87.2"],"apollo":["87.2"],"在大部分情况下":["87.2"],"这些能力以及附带的详细文档就能很好地满足你的需求":["87.2"],"当然":["87.2"],"没有事物是十全十美的":["87.2"],"我个人认为":["87.2"],"不友好的地方在于":["87.2"],"新手可能需要一些时间才能理解其模块作用域与依赖各种关系":["87.2"],"imports":["87.2"],"provides":["87.2"],"providers":["87.2","87.7"],"等概念确实不是很好理解":["87.2"],"既然说基础了":["87.2"],"那我们还是要介绍一下基本使用代码":["87.2"],"这段代码我们在装饰器一节中已经很熟悉了":["87.2"],"最特殊的一点":["87.3"],"它使用自己的":["87.3"],"sdl":["87.3"],"schema":["87.3","88.2"],"define":["87.3"],"language":["87.3"],"也可以说是":["87.3"],"dsl":["87.3"],"domain":["87.3"],"specified":["87.3"],"来声明一个实体":["87.3"],"your":["87.3"],"file":["87.3"],"learn":["87.3"],"more":["87.3"],"about":["87.3"],"it":["87.3"],"docs":["87.3"],"https":["87.3","95.2","107.13"],"pris":["87.3"],"ly":["87.3"],"generator":["87.3"],"client":["87.3","88.2"],"provider":["87.3"],"output":["87.3"],"datasource":["87.3"],"db":["87.3"],"postgresql":["87.3","88.1"],"url":["87.3"],"database":["87.3"],"article":["87.3"],"int":["87.3","88.4"],"default":["87.3","89.6","93.3"],"autoincrement":["87.3","88.4"],"title":["87.3","88.4"],"description":["87.3"],"implements":["87.4","107.44"],"await":["87.4","88.3"],"connect":["87.4"],"disconnect":["87.4"],"提供的应用级生命周期":["87.4"],"我们继承":["87.4"],"来实现这两个方法":["87.4"],"然后分别在启动与停止阶段与数据库连接":["87.4"],"断开连接":["87.4"],"在前面我们已经提到":["87.4"],"需要被实例化后才能使用":["87.4"],"的基础概念与使用方式":["87.5"],"这一方式下的目录结构是这样的":["87.7"],"controllers":["87.7"],"services":["87.7"],"main":["87.7","95.5","107.67","107.82"],"它们的差别又是什么":["87.8"],"先来看":["87.8"],"模式下的":["87.8"],"代码":["87.8","89.0"],"baseentity":["87.8"],"entity":["87.8"],"primarygeneratedcolumn":["87.8"],"column":["87.8"],"user":["87.8"],"id":["87.8","94.4","94.5","97.3","97.4","107.43","107.44"],"builder":["87.9"],"就是这另外一种使用方式":["87.9"],"它和":["87.9"],"一样":["87.9","89.9"],"通过编程语言书写":["87.9"],"但不同的是它并不包括实体类映射到数据库表的部分":["87.9"],"而只是负责":["87.9"],"以":["87.9"],"那我们就来接着了解一下":["88.0"],"cloud":["88.1"],"nx":["88.1"],"来进一步绑定用户":["88.1"],"这些服务基本对个人开发者免费":["88.1"],"只有需要进行团队协作或者高级功能时才会收费":["88.1"],"就是一个提供免费服务的云平台":["88.1"],"它主要以提供":["88.1"],"服务部署为主":["88.1"],"go":["88.1"],"等几乎所有主流语言":["88.1"],"选择它的主要原因有两方面":["88.1"],"一是我认为在类似的平台中它使用起来相对方便":["88.1"],"二是它面向个人开发者提供了一定免费额度的数据库":["88.1"],"唯一存在遗憾的地方是":["88.1"],"它需要科学上网才能正常访问":["88.1"],"推送到数据库":["88.2"],"创建对应的数据表":["88.2"],"同时这一命令也会再次执行":["88.2"],"generate":["88.2"],"命令来生成":["88.2"],"imagedb88d65589f9bb99":["88.2"],"通常来说":["88.2"],"数据库也会按照环境分为日常":["88.2"],"预发":["88.2"],"生产":["88.2"],"测试等多个版本":["88.2"],"但谁让我们只是在写":["88.2"],"demo":["88.2","101.58","107.80"],"上一节我们已经介绍了如何在":["88.2"],"bootstrap":["88.3"],"port":["88.3"],"process":["88.3"],"listen":["88.3"],"在启动这个项目时":["88.3"],"默认使用的是":["88.3"],"start":["88.3","101.28"],"命令":["88.3"],"而在我们的项目中这一命令其实是开发环境下的启动":["88.3"],"技术":["88.4"],"感想":["88.4"],"总结":["88.4","107.61"],"category":["88.4"],"这篇文章还没有介绍":["88.4"],"文章是否可见":["88.4"],"visible":["88.4"],"createdat":["88.4"],"datetime":["88.4"],"now":["88.4"],"updatedat":["88.4"],"service":["88.4"],"层":["88.4"],"我们在这里会从数据库取回数据然后进行返回":["88.4"],"但一般我们不会直接丢个数据回去":["88.4"],"而是会附带上状态码等信息一起返回":["88.4"],"这里我们实现一个简单的版本":["88.4"],"maybenull":["88.4"],"statuscode":["88.4"],"resolved":["88.4"],"rejected":["88.4"],"responsewrapper":["88.4"],"heroku":["88.5"],"平台上":["88.5"],"如果你此前未接触过":["88.5"],"nest":["88.5"],"loader":["89.0"],"的作用你应该也至少了解过一些":["89.0"],"其实它的核心功能就是":["89.0"],"语法降级":["89.0"],"是的":["89.0"],"在编译时会进行的类型擦除与语法降级中的那个语法降级":["89.0"],"的曾用名是":["89.0"],"6to5":["89.0"],"意为将":["89.0"],"代码转换为":["89.0"],"当时":["89.0"],"已经算是时代的弄潮儿了":["89.0"],"paramname":["89.1"],"创建参数类型结点":["89.1"],"paramtype":["89.1"],"createkeywordtypenode":["89.1"],"syntaxkind":["89.1","89.2"],"numberkeyword":["89.1"],"创建参数的声明":["89.1"],"parameter":["89.1"],"createparameterdeclaration":["89.1"],"创建表达式":["89.1"],"condition":["89.1"],"createbinaryexpression":["89.1"],"lessthanequalstoken":["89.1"],"createnumericliteral":["89.1"],"创建代码块":["89.1"],"ifbody":["89.1"],"createblock":["89.1"],"chalk":["89.2"],"实例化一个":["89.2"],"项目实例":["89.2"],"将某个路径的文件添加到这个项目内":["89.2"],"addsourcefileatpath":["89.2"],"dirname":["89.2"],"创建一个接口":["89.2"],"iuser":["89.2"],"interfacedec":["89.2"],"addinterface":["89.2"],"properties":["89.2"],"新增属性":["89.2"],"addproperties":["89.2"],"操作":["89.3"],"就需要自己手动一个个处理":["89.3"],"这些操作其实可以分为两大类":["89.3"],"readfile":["89.4"],"promises":["89.4"],"在这个例子中":["89.4"],"我们希望进行两种操作":["89.4"],"将来自于":["89.4"],"sync":["89.4"],"更换为来自":["89.4"],"检查是否存在对":["89.4"],"首先第一步":["89.4"],"一定是分析源代码的":["89.4"],"结构":["89.4"],"messagehandler":["89.5"],"其处理结果应当是这样的":["89.5"],"处理后的结果则是这样的":["89.6"],"我们需要添加具名导入":["89.6"],"以及修改默认导出表达式两个步骤":["89.6"],"首先分析":["89.6"],"istruct":["89.7"],"ijob":["89.7"],"istructpets":["89.7"],"具体实现其实并不复杂":["89.7"],"由于":["89.7","89.8"],"的限制":["89.7"],"我们无需处理函数之类的类型":["89.7"],"但也无法实现字面量类型与枚举这样精确的定义":["89.7"],"然而绝大部分情况下":["89.7"],"这是一个临时的兼容":["89.8"],"tempsolution":["89.8"],"工具方法":["89.8"],"viewer":["89.8"],"目前不支持":["89.8"],"的解析":["89.8"],"这里我们直接来整理一下实现思路":["89.8"],"检查所有函数的":["89.8"],"区域":["89.8"],"如果发现了":["89.8"],"对比其标注的过期时间与当前的时间":["89.8"],"如果过期":["89.8"],"抛出错误":["89.8","96.3"],"并指出":["89.8"],"标记的作者":["89.8"],"morph":["89.9"],"来对":["89.9"],"源码进行操作":["89.9"],"就像数据库的":["89.9"],"crud":["89.9"],"很相似":["89.11"],"都是检查代码是否符合规则":["89.11"],"并且":["89.11"],"也希望小册中的内容能够让你收获明显的成长":["90.0"],"这本小册是我的第一本小册":["90.0"],"肯定还存在许多不足之处":["90.0"],"也为后面的进阶预留了扩展空间":["90.1"],"内置类型工具部分":["90.1"],"我们对":["90.1"],"茫茫多的类型工具进行了逐个击破":["90.1"],"漫谈篇的内容不会包含任何新的":["90.2"],"知识点":["90.2","91.13"],"你只需要读过一遍就能理解并化为己用":["90.2"],"在此":["90.3"],"我想再次向他们致以最诚挚的谢意":["90.3"],"感谢掘金小编的一路跟随与耐心审校":["90.3"],"在这本小册中学习到的写作经验也是我的重要收获之一":["90.3"],"技能的考察也会逐渐上升到和":["91.0"],"在对象扩展情况下":["91.2"],"比如小册中提过的":["91.3"],"也即结构化类型系统进行类型兼容性的比较":["91.5"],"即对于两个属性完全一致的类型":["91.5"],"就认为它们属于同一种类型":["91.5"],"怎么能轻易止步":["91.6"],"如果想进一步升华回答":["91.6"],"还可以从以下方面进行扩展":["91.6"],"在实际开发中":["91.9"],"我们不可能确保对所有地方的类型都进行精确的描述":["91.9"],"但对于完成了整本小册阅读的你来说":["91.10"],"partial":["91.11"],"我不仅能写出这些基础实现":["91.12"],"还能写出其在实际应用场景中的增强版":["91.12"],"07":["93.0"],"plugins":["93.3"],"生成":["93.6"],"模块配置":["93.7"],"标签":["93.9","93.10","97.4"],"需要":["93.11"],"cdn":["93.11"],"加速的包名称":["93.11"],"名称的别名":["93.11"],"地址":["93.12"],"pordurl":["93.12"],"persistedstate":["94.1"],"中添加":["94.2"],"persist":["94.3"],"来开启数据持久化":["94.3"],"storage":["94.4","94.5","94.9","94.10"],"默认的":["94.4"],"用于引用":["94.5"],"中的数据":["94.5"],"必须具有":["94.6","94.8"],"getitem":["94.6"],"中哪些数据需要被持久化":["94.7"],"表示不持久化任何状态":["94.7"],"表示持久化整个":["94.7"],"该配置能够指定持久化时所使用的序列化方法":["94.8"],"以及恢复":["94.8"],"时的反序列化方法":["94.8"],"serialize":["94.8"],"该":["94.9","94.10"],"hook":["94.9","94.10"],"将在从":["94.9","94.10"],"中恢复数据之前触发":["94.9"],"并且它可以访问整个":["94.9","94.10"],"中恢复数据之后触发":["94.10"],"默认值":["94.11"],"svg":["95.2"],"图片的文件夹":["95.2"],"可以填写多个":["95.2"],"raw":["95.2"],"githubusercontent":["95.2"],"com":["95.2","107.13"],"组件":["95.3"],"直接返回":["96.2"],"getprototypeof":["96.2"],"自带的":["96.2"],"能够拿到参数的原型对象":["96.2"],"proto":["96.2"],"while":["96.2"],"循环往下寻找":["96.2"],"直到找到相同的原型对象":["96.2"],"nan":["96.3","96.6"],"如果是字符串":["96.3"],"如果字符串中只包含了数字":["96.3"],"则将其转换为十进制":["96.3"],"如果字符串中包含了有效的浮点格式":["96.3"],"将其转换为浮点数值":["96.3"],"将其转换为":["96.3"],"如果不是以上格式的字符串":["96.3"],"均返回":["96.3"],"如果是对象并且部署了":["96.3"],"synbol":["96.3"],"toprimitive":["96.3"],"那么调用此方法":["96.3"],"否则调用对象的":["96.3"],"0111":["96.3"],"对象的合并等多个用途":["96.5"],"其中一个用途就是可以进行浅拷贝":["96.5"],"的语法为":["96.5"],"对象中含有":["96.6"],"序列化的结果会变成":["96.6"],"无法拷贝对象的循环应用":["96.6"],"即对象成环":["96.6"],"基础版":["96.6"],"手写递归实现":["96.6"],"obj1":["96.6","101.52"],"deepclone":["96.6"],"cloneobj":["96.6"],"遍历":["96.6"],"使用这种方式我们可以更好地复用以前的开发代码":["96.7"],"二":["96.8"],"构造函数继承":["96.8"],"借助":["96.8"],"call":["96.8","101.49"],"getname":["96.8"],"child":["96.8","113.1","113.2","117.1","117.2"],"没问题":["96.8"],"会报错":["96.8"],"20240117094152565":["96.8"],"三":["96.8"],"组合继承":["96.8"],"前两中组合":["96.8"],"parent3":["96.8"],"根据构造函数的情况":["96.9"],"来确定是否可以接受参数的传递":["96.9"],"执行过程":["96.9"],"创建一个新对象":["96.9"],"将构造函数的作用域赋给新对象":["96.9"],"指向新对象":["96.9"],"执行构造函数中的代码":["96.9"],"为这个新对象添加属性":["96.9"],"返回新对象":["96.9"],"关键词执行之后总是会返回一个对象":["96.9"],"要么是实例对象":["96.9"],"要么是":["96.9"],"语句指定的对象":["96.9"],"的作用域":["96.10"],"闭包是指有权访问另外一个函数作用域中的变量的函数":["96.11"],"mdn":["96.11"],"当访问一个变量时":["96.12"],"在定时器":["96.13"],"时间监听":["96.13"],"对象中的方法":["96.14"],"parse":["96.14"],"传入的参数将按照顺序依次成为新数组的第":["96.16"],"至第":["96.16"],"项":["96.16"],"返回空数组":["96.16"],"len":["96.16"],"shift":["96.18","115.5"],"sort":["96.18"],"splice":["96.18","96.23","101.26"],"unshift":["96.18"],"以及两个":["96.18"],"length":["96.19","101.35"],"isarray":["96.19"],"concat":["96.19"],"说的更多地是通过":["96.21"],"o":["96.21"],"快速排序":["96.23"],"通过一趟排序":["96.23"],"将待排记录分割成独立的两部分":["96.23"],"其中一部分记录的关键字均比另一部分的关键字小":["96.23"],"则可以分别对这两部分记录继续进行排序":["96.23"],"以达到整个序列有序":["96.23"],"quicksort":["96.23","101.51"],"quick":["96.23"],"floor":["96.23"],"pivot":["96.23"],"left":["96.23"],"right":["96.23"],"comparefunction":["96.24"],"小于":["96.24"],"标准盒子模型":["97.1"],"ie":["97.1"],"盒子模型":["97.1"],"盒子模型的区别":["97.1"],"通配":["97.3","97.4"],"选择器":["97.3"],"类选择器":["97.3"],"标签选择器":["97.3"],"画一个三角形":["97.5"],"用边框画":["97.5"],"方式一":["97.6"],"width":["97.6"],"none":["97.7"],"此元素不会被显示":["97.7"],"此元素将显示为块元素":["97.7"],"的理解":["97.8"],"就是页面上一个隔离的独立容器":["97.8"],"容器里面的子元素不会影响到外面的元素":["97.8"],"overflow":["97.9"],"hidden":["97.9","97.15"],"方式二":["97.9"],"偶数":["97.10"],"让文字在浏览器上表现的更好看":["97.10"],"固定定位":["97.11"],"相对于浏览器窗口进行定位":["97.11"],"relative":["97.11"],"相对定位":["97.11"],"相对于自身定位":["97.11"],"不脱离文档流":["97.11"],"请写出结构及样式":["97.12"],"双飞翼布局":["97.12"],"是一个":["97.13"],"有什么优缺点":["97.14"],"区别":["97.15","97.16","97.19","99.3","101.53","121.7"],"实现透明效果":["97.16"],"中双冒号和单冒号有什么区别":["97.17"],"解释一下这两个伪元素的作用":["97.17"],"12px":["97.18"],"的文字":["97.18"],"placeholder":["97.20","107.114"],"语法结构":["97.21"],"media":["97.21"],"only":["97.21"],"screen":["97.21"],"and":["97.21"],"专题页面":["97.22"],"特别追求性能的项目":["97.22"],"不太适合响应式":["97.22"],"因为如果添加了很多的响应式":["97.22"],"会造成加载速度变慢":["97.22"],"pc":["97.22"],"span":["99.1","113.6","113.7"],"块级元素":["99.1"],"有什么区别":["99.2","99.4","103.3"],"区别一":["99.2","99.4","101.55","101.66"],"定义":["99.3"],"概括了网站信息":["99.3"],"可以告诉搜索引擎或者用户关于这个网站的内容主题是什么":["99.3"],"文章主题内容":["99.3"],"告诉蜘蛛我们的网站内容最主要是什么":["99.3"],"alt":["99.4"],"分别什么时候用":["99.5"],"无损压缩":["99.5"],"尺寸体积要比":["99.5"],"section":["99.6"],"键盘首字母自动大小写":["100.1"],"长按时不触发系统的菜单":["100.3"],"长按触发系统菜单":["100.4"],"android":["100.6"],"defer":["101.1"],"例如":["101.1","107.46","107.49","115.4"],"时先设计的":["101.3"],"原因":["101.3"],"最初设计":["101.3"],"代码执行流程":["101.5"],"同步执行完":["101.5"],"没有块级作用域":["101.6"],"作用域链":["101.6"],"本层作用域有没有此变量":["101.7"],"fun":["101.10"],"对象是通过":["101.11"],"你能写出哪些方法":["101.20"],"deletecount":["101.28"],"prototype":["101.34"],"addprefix":["101.34"],"创建了一个空的对象":["101.36"],"闭包是什么":["101.38"],"内部函数可以访问到外部函数的局部变量":["101.39"],"闭包可以解决的问题":["101.39"],"解决":["101.40"],"把闭包的函数设置为":["101.40"],"对象共享属性和共享方法":["101.41"],"谁有原型":["101.41"],"apply":["101.47","101.49"],"可以改变":["101.48"],"函数只给出了两种排序":["101.51"],"insertionsort":["101.51"],"数量小于":["101.51"],"arr2":["101.52"],"数据存放有效期":["101.53"],"仅在当前浏览器窗口关闭之前有效":["101.53"],"window":["101.54"],"addeventlistener":["101.54"],"const共同点":["101.55"],"都是可以声明变量的":["101.55"],"具有变量提升的机制":["101.55"],"没有变量提升性":["101.57"],"assign":["101.61"],"extend":["101.63"],"箭头函数中的":["101.64"],"是在箭头函数定义时就确定的":["101.64"],"有三种状态":["101.65"],"every":["101.67"],"篇":["103.0"],"关于生命周期":["103.1"],"还是":["103.2"],"中如何获取":["103.4"],"4一旦进入组件会执行哪些生命周期":["103.5"],"第二次或者第":["103.6"],"父组件引入子组件":["103.7","103.11"],"那么生命周期执行的顺序是":["103.7"],"alive":["103.8"],"会执行哪些生命周期":["103.8"],"如果使用了":["103.8"],"你在什么情况下用过哪些生命周期":["103.9"],"说一说生命周期的使用场景":["103.9"],"关于组件":["103.10"],"父传后代":["103.11"],"后代拿到了父的数据":["103.11"],"绑定数据":["103.11"],"关于原理":["103.14"],"微任务":["103.15"],"page":["106.0"],"powered":["106.1"],"by":["106.1"],"shikiji":["106.1"],"box":["106.2"],"tip":["106.2"],"warning":["106.2"],"studio":["107.2","107.3"],"studio基于":["107.2"],"intellij":["107.2"],"idea":["107.2"],"community":["107.2"],"社区版":["107.2"],"构建":["107.2"],"阅读各项条款":["107.3"],"点击":["107.3","107.4","107.7"],"agree":["107.3"],"表示同意":["107.3"],"初次启动会出现如下设置向导":["107.3"],"首先需要为":["107.3"],"选择项目模版":["107.4"],"preview":["107.6"],"预览":["107.6"],"安装步骤如下":["107.7"],"tools":["107.7"],"菜单下的":["107.7"],"device":["107.7"],"manager":["107.7"],"打开设备管理器":["107.7"],"os":["107.8"],"系统的手机":["107.8"],"系统版本最好为":["107.8"],"及以上":["107.8"],"系统版本可在":["107.8"],"关于手机":["107.8"],"中查看":["107.8"],"harmonyos":["107.9"],"应用的主要开发语言是":["107.9"],"arkts":["107.9","107.56","107.65","107.103"],"编辑器":["107.13"],"vscode是一款轻量级":["107.13"],"开源且功能丰富的集成开发环境":["107.13"],"ide":["107.13"],"支持多种编程语言":["107.13"],"具有强大的插件系统":["107.13"],"下载地址为":["107.13"],"visualstudio":["107.13"],"类型推断":["107.17","107.31"],"表示数字":["107.19"],"包括整数和浮点数":["107.19"],"数组":["107.22"],"数组类型定义由两部分组成":["107.22"],"是一种一系列由":["107.23"],"属性名称":["107.23"],"属性值":["107.23"],"getpersoninfo":["107.27"],"特殊类型":["107.28"],"一个函数可能用于处理不同类型的值":["107.28"],"这种情况可以使用联合类型":["107.28"],"例如以下案例中的":["107.28"],"匿名函数":["107.32"],"匿名函数的语法结构简洁":["107.32"],"特别适用于简单且仅需一次性使用的场景":["107.32"],"numbers":["107.32"],"概述":["107.34","107.48","107.52","107.73","107.130","107.133","107.139"],"类":["107.34"],"是面向对象编程语言中的一个重要概念":["107.34"],"类的定义":["107.36"],"定义类的语法如下图所示":["107.36"],"代码如下":["107.36"],"person":["107.36","107.43","107.44"],"对象创建":["107.37"],"创建对象的关键字为":["107.37"],"具体语法如下":["107.37"],"中的类中可以包含静态成员":["107.38"],"静态属性和静态方法":["107.38"],"静态成员隶属于类本身":["107.38"],"而不属于某个对象实例":["107.38"],"静态成员通用用于定义一些常量":["107.38"],"或者工具方法":["107.38"],"声明静态成员":["107.38"],"继承另一个类":["107.39"],"父类或基类":["107.39"],"的属性和方法":["107.39"],"子类可以直接使用父类的特性":["107.39"],"并根据需要添加新的特性或覆盖现有的特性":["107.39"],"这种机制赋予面向对象程序良好的扩展性":["107.39"],"下面通过一个例子演示继承的特性":["107.39"],"modifiers":["107.40"],"用于控制类成员":["107.40"],"方法等":["107.40"],"的可访问性":["107.40"],"提供了三种访问修饰符":["107.40"],"分别是private":["107.40"],"关键字定义":["107.43"],"通常情况下":["107.43"],"接口中只会包含属性和方法的声明":["107.43"],"而不包含具体的实现细节":["107.43"],"具体的细节由其实现类完成":["107.43"],"接口的实现类":["107.44"],"teacher":["107.44"],"如下":["107.44"],"totalamount":["107.45"],"pay":["107.45"],"alipay":["107.45"],"中的接口是一个非常灵活的概念":["107.46"],"除了用作类的规范之外":["107.46"],"也常用于直接描述对象的类型":["107.46"],"现有一个变量的定义如下":["107.46"],"season":["107.49"],"spring":["107.49"],"summer":["107.49"],"autumn":["107.49"],"winter":["107.49"],"枚举使用":["107.49"],"枚举的使用记住两个原则即可":["107.49"],"枚举值的访问":["107.49"],"像访问对象属性一样访问枚举值":["107.49"],"开始递增":["107.50"],"例如上述案例中的":["107.50","107.77"],"direction":["107.50"],"枚举中":["107.50"],"up":["107.50"],"的值为":["107.50"],"依次类推":["107.50"],"具体如下":["107.50"],"导出":["107.53"],"导出须使用":["107.53"],"语法如下":["107.53"],"moduleb":["107.54"],"除了上述导入导出的语法之外":["107.55"],"还有一种语法":["107.55"],"叫做":["107.55"],"这种语法相对简洁一些":["107.55"],"定义界面状态":["107.58"],"按照声明式":["107.58"],"ui":["107.58"],"的开发范式":["107.58"],"首先需要分析和定义页面的各种状态":["107.58"],"改变状态":["107.60"],"在明确了界面在不同状态下的显示效果后":["107.60"],"我们只需修改状态变量的值":["107.60"],"就能触发界面的更新":["107.60"],"在当前案例中":["107.60"],"组件化":["107.62"],"在鸿蒙开发中":["107.62"],"ets":["107.65","107.67","107.82"],"pages":["107.65","107.67","107.82"],"solution":["107.65","107.82"],"struct":["107.65","107.69"],"完整代码见":["107.67"],"demos":["107.67","107.82"],"entry":["107.67","107.82"],"delete":["107.67"],"deletebutton":["107.67"],"各部分语法说明如下":["107.69"],"是arkts新增的用于自定义组件或者自定义弹窗的关键字":["107.69"],"其声明的数据结构和ts中的类十分相似":["107.69"],"可包含属性和方法":["107.69"],"案例实操":["107.70"],"各参数的含义如下":["107.77"],"需要进行循环渲染的数据源":["107.77"],"必须为数组类型":["107.77"],"options":["107.77","107.103","107.121"],"苹果":["107.77"],"桃子":["107.77"],"香蕉":["107.77"],"橘子":["107.77"],"组件生成函数":["107.77"],"用于为":["107.77"],"数组中的每个元素创建对应的组件":["107.77"],"该函数可接收两个参数":["107.77"],"分别是":["107.77"],"本地图片":["107.80"],"images":["107.80"],"jpg":["107.80"],"使用这种方式引入本地图片":["107.80"],"需要将图片置于":["107.80"],"目录下":["107.80"],"并且需要为":["107.80"],"组件提供图片相对于":["107.80"],"目录的路径":["107.80"],"网络图片":["107.80"],"真机中运行的鸿蒙应用":["107.80"],"访问网络图片需要配置网络访问权限":["107.80"],"不过在预览器和模拟器中测试时不受限制":["107.80"],"权限配置相关的内容在后续章节会系统介绍":["107.80"],"两个方法可接收的参数类型均为":["107.82"],"resource":["107.82","107.87","107.89","107.91","107.123"],"相关案例见":["107.82"],"imagesize":["107.82"],"下面对三种参数类型逐一进行介绍":["107.82"],"objectfit":["107.83"],"方法来设置图片的显示效果":["107.83"],"该方法的参数类型为":["107.83","107.89"],"imagefit":["107.83"],"枚举类型":["107.83"],"可选的枚举值如下":["107.83"],"名称":["107.83"],"图片会模糊并出现锯齿":["107.84"],"如下图所示":["107.84"],"interpolation":["107.84"],"方法对图片进行插值":["107.84"],"下面分别对两个参数类型进行介绍":["107.87"],"我是一段文本":["107.87"],"方法进行设置":["107.89","107.91","107.92"],"下面逐一介绍":["107.89","107.90","107.91"],"类型的取值范围是":["107.90"],"该方法参数类型为":["107.91"],"color":["107.91","107.124"],"文本对齐":["107.92"],"文本对齐方向可通过":["107.92"],"textalign":["107.92"],"该方法的参数为枚举类型":["107.92"],"可使用":["107.93"],"maxlines":["107.93"],"方法控制文本的最大行数":["107.93"],"当内容超出最大行数时":["107.93"],"textoverflow":["107.93"],"两种方式下":["107.96"],"组件所需的参数有所不同":["107.96"],"下面分别介绍":["107.96"],"不包含子组件时":["107.96"],"组件所需的参数如下":["107.96"],"label":["107.96"],"边框圆角":["107.99"],"按钮的边框圆角大小可使用":["107.99"],"borderradius":["107.99"],"组件而言":["107.100"],"最为常用的就是点击事件":["107.100"],"toggletype":["107.103"],"ison":["107.103"],"swtich":["107.106"],"滑块颜色":["107.106"],"每当":["107.107"],"组件的状态发生变化":["107.107"],"就会触发":["107.107"],"事件":["107.107","107.117"],"textinput":["107.110"],"组件的参数定义如下":["107.110"],"输入框类型":["107.112"],"可通过":["107.112"],"文本样式":["107.115"],"每当输入的内容发生变化":["107.117"],"焦点事件包括":["107.118"],"获得焦点":["107.118"],"失去焦点":["107.118"],"两个事件":["107.118"],"当输入框获得焦点时":["107.118"],"total":["107.121"],"progresstype":["107.121"],"例如进度条的宽度":["107.123"],"该方法的参数类型定义如下":["107.123"],"strokewidth":["107.123"],"进度条颜色":["107.124"],"进度条的颜色可通过":["107.124"],"promptaction":["107.128"],"模块中的":["107.128"],"showtoast":["107.128"],"方法显示":["107.128"],"toast":["107.128"],"提示":["107.128"],"使用时需要先导入":["107.128"],"alertdialog":["107.130"],"actionsheet":["107.133"],"例如文本选择器":["107.136"],"日期选择器":["107.136"],"时间选择器等等":["107.136"],"各选择器效果如下":["107.136"],"details":["107.136"],"lake":["107.136"],"collapse":["107.136"],"当现有组件不满足要求时":["107.139"],"customdialogcontroller":["107.140"],"具体用法可参考相关案例或者官方文档":["107.140"],"br":["107.140"],"lesson":["109.1"],"blob":["109.1"],"chatlist":["109.1"],"单文件组件":["110.1"],"我们想在具有css作用域的":["110.5"],"可以把对应的":["110.7"],"提供了一个内置组件":["111.1"],"将以下元素渲染成":["111.2"],"teleport":["111.3"],"组件的":["111.5"],"渲染函数来实现一个组件":["111.12"],"请注意":["111.12"],"你需要实现一个树组件":["111.15"],"如果源是对象":["113.14"],"强制深度遍历":["113.14"],"以便在深层级变更时触发回调":["113.14"],"参考深层侦听器":["113.14"],"flush":["113.14"],"强制触发依赖于一个浅层":["113.18"],"你将使用":["113.20"],"组合式":["113.20"],"run":["113.25"],"customref":["113.29"],"提供了一个指令":["114.4"],"并跳过之后的更新":["114.6"],"在随后的重新渲染":["114.6"],"元素":["114.6"],"li":["114.14","114.15"],"让我们开始吧":["115.1"],"click":["115.2"],"click1":["115.2"],"在监听键盘事件时添加按键修饰符":["115.4"],"只有在":["115.4"],"被一同按下时也会触发":["115.5"],"更新":["116.0"],"响应式":["118.1"],"reactiveobj":["118.3"],"我们需要依赖于异步的返回结果做一些后续处理":["119.1"],"composition":["121.0"],"类型的":["121.1"],"拉开序幕的":["121.2"],"数据":["121.3"],"计算属性":["121.3"],"监视":["121.3"],"均配置在":["121.3"],"特点如下":["121.3"],"函数返回的对象中的内容":["121.3"],"定义响应式变量":["121.4"],"对象类型的响应式数据":["121.5","121.6"],"作用":["121.5"],"定义一个":["121.5"],"响应式对象":["121.5"],"对象类型数据":["121.7"],"创建的变量必须使用":["121.7"],"备注":["121.8"],"功能一致":["121.8"],"setup语法糖":["122.0"]},{"0":["0.20","0.68","58.20","58.68","61.4","62.12","69.8","80.10","80.11","82.1","83.7","86.11","97.16"],"1":["0.24","56.5","56.6","58.24","61.4","62.10","65.5","67.7","69.8","71.6","76.2","78.9","80.8","80.15","80.39","80.40","97.16","101.12","101.21","101.22","101.23","101.25","101.58","101.59","101.60","107.11","107.30","107.32","107.37","107.42","107.59","107.74","107.86","107.95","107.102","107.105","107.109","107.120","107.126"],"2":["0.84","0.90","31.0","44.0","56.6","58.84","58.90","61.4","65.5","67.7","69.8","71.6","76.2","80.39","83.13","96.24","97.8","99.6","101.3","101.7","101.11","101.16","101.23","101.25","101.30","101.36","107.113","107.129","107.131","107.134"],"3":["0.60","0.65","0.76","0.79","0.86","0.87","19.2","58.60","58.65","58.76","58.79","58.86","58.87","67.7","69.8","71.6","96.2","101.30","107.18","107.32"],"4":["0.82","57.1","58.82","69.8","71.6","76.2","78.10","101.30","107.24","107.25","107.26","107.29","107.66","107.71","107.72","107.75","107.116","107.135"],"5":["0.33","0.83","57.1","58.33","58.83","69.8","78.9","82.1","101.19","107.19","107.32","107.33","107.35","107.138"],"6":["0.83","16.0","58.83","69.8","78.10","85.24","107.41"],"7":["0.30","58.30","69.8","107.47"],"8":["69.8","107.51"],"10":["66.1","81.10","90.1","96.5","101.10","101.51","107.23"],"14":["90.1"],"15":["90.1"],"16":["0.35","58.35"],"17":["96.3"],"18":["62.8","65.2","67.5","78.3","101.43"],"20":["81.10","101.45","107.65"],"21":["0.65","58.65"],"26":["0.15","58.15","101.33"],"32":["96.16","101.33"],"33":["107.19"],"35":["101.33","105.0"],"37":["101.33"],"39":["101.33"],"54":["93.0"],"100":["9.0","68.3","107.19","107.77"],"111":["96.3"],"123":["96.2","101.18"],"150":["107.140"],"262":["56.1"],"308":["0.32","58.32"],"315":["0.32","58.32"],"400":["107.90"],"404":["46.0"],"599":["62.4","65.5","75.2","79.7"],"1000":["34.2"],"1234":["82.9"],"3000":["83.3"],"10001":["62.2"],"50000":["62.2"],"都区分大小写":["0.2","58.2"],"换句话说":["0.2","58.2"],"变量":["0.2","58.2"],"第一个字符必须是一个":["0.3","58.3"],"字母":["0.3","58.3"],"下划线":["0.3","58.3"],"包括单行注释和块注释":["0.4","58.4"],"单行注释以两个斜杠字符":["0.4","58.4"],"开头":["0.4","58.4"],"的一些不规范写法在这种模式下会被处理":["0.5","58.5"],"对于不安全的活动将抛出错误":["0.5","58.5"],"要对整个脚本使用严格模式":["0.5","58.5"],"在脚本的开头加上这一行":["0.5","58.5"],"var":["0.7","0.20","0.22","58.7","58.20","58.22","78.9","85.25","86.3","93.3","101.10","101.24","101.39","101.63"],"catch":["0.7","58.7"],"export":["0.7","58.7","75.2","81.10","85.24","85.26","86.35","87.2","94.7","111.13"],"new":["0.7","0.44","13.0","58.7","58.44","60.8","64.2","66.2","73.1","83.3","83.10","84.3","87.2","87.8","89.8","96.2"],"void":["0.7","58.7","63.6","63.9","69.7","72.1","72.3","75.4","83.7","83.10","86.22","107.43"],"描述了一组保留的关键字":["0.8","58.8"],"let":["0.10","0.12","0.34","0.66","58.10","58.12","58.34","58.66","67.5","69.1","78.3","80.10","82.10","82.13","101.61","101.62","107.16","107.27","107.37"],"const":["0.12","58.12","61.1","62.4","62.8","62.18","63.2","64.1","65.2","65.4","67.7","68.3","73.1","78.5","78.13","79.19","80.35","80.37","80.40","82.9","83.10","86.11","86.18","87.8","87.9","89.8"],"和":["0.12","0.27","0.86","3.1","15.0","58.12","58.27","58.86","75.2","88.5","94.6","94.8","96.18","101.55","107.3","107.49","107.54","107.82","107.124"],"是一个关键字":["0.13","58.13"],"后跟变量名":["0.13","58.13"],"is":["0.14","36.2","58.14","70.3","86.39"],"not":["0.14","58.14","59.1","86.39"],"defined":["0.14","58.14"],"这里":["0.14","58.14","83.2"],"变量是在函数内部使用":["0.14","58.14"],"定义的":["0.14","58.14"],"函数叫":["0.14","58.14"],"调用它会创建这个变量并给它赋值":["0.14","58.14"],"调用之后变量随即被销毁":["0.14","58.14"],"因此示例中的最后一行会导致错误":["0.14","58.14"],"undefined":["0.15","0.17","0.23","0.24","58.15","58.17","58.23","58.24","61.6","64.2","69.7","70.1","72.2","79.9","83.10","101.9","121.3"],"之所以不会报错":["0.15","58.15"],"是因为":["0.15","58.15"],"ecmascript":["0.15","0.31","0.43","58.15","58.31","58.43","78.7"],"name":["0.16","0.21","58.16","58.21","61.1","65.1","67.4","79.4","93.3","107.36","107.39","107.43","107.46","107.140","109.1"],"matt":["0.16","0.21","58.16","58.21"],"console":["0.16","0.17","0.33","58.16","58.17","58.33","60.4","63.9","83.8","85.25","86.8","96.2","96.6","101.8","101.17","101.50","101.57","107.53"],"log":["0.16","0.17","0.33","58.16","58.17","58.33","60.4","63.9","83.8","85.25","86.8","96.2","96.5","96.6","101.12","101.50","101.57","107.53"],"会被提升":["0.17","58.17"],"在全局作用域中声明的变量不会成为":["0.18","58.18"],"window":["0.18","58.18"],"对象的属性":["0.18","58.18"],"因为":["0.19","58.19","63.11","76.5","103.3"],"循环块内部":["0.20","58.20"],"js":["0.20","0.25","2.1","14.0","21.1","22.1","23.0","25.0","29.3","36.4","58.20","58.25","60.3","78.9","85.20","85.30","96.9","101.39","110.6"],"i":["0.20","58.20","80.10","87.2","87.3","94.1"],"也不允许重复声明":["0.21","58.21"],"nicholas":["0.21","58.21"],"syntaxerror":["0.21","58.21"],"原始数据类型":["0.23","58.23"],"会返回下列字符串之一":["0.24","58.24"],"表示值未定义":["0.24","58.24"],"值的变量跟未定义变量是有区别的":["0.25","58.25"],"message":["0.25","58.25"],"这个变量被声明了":["0.25","58.25"],"只是值为undefined":["0.25","58.25"],"的原因":["0.26","58.26"],"在定义一个将来要保存对象值的变量时":["0.26","58.26"],"建议使用":["0.26","58.26"],"来初始化":["0.26","58.26"],"不要使用其他值":["0.26","58.26"],"这样":["0.26","58.26","67.5","80.12"],"false":["0.27","0.73","58.27","58.73","63.5","64.1","77.2","80.2","93.8","94.11","107.65"],"这两个布尔值不同于数值":["0.27","58.27"],"因此":["0.27","58.27","75.1","78.2","88.3"],"boolean":["0.28","0.44","58.28","58.44","61.4","64.8","65.6","65.7","67.3","69.2","70.1","75.2","77.2","79.7","87.8","101.4","107.21","107.65","107.96"],"类型使用":["0.29","58.29"],"然后是相应的八进制数字":["0.30","58.30"],"如果字面量中包含的数字超出了应有的范围":["0.30","58.30"],"有效":["0.31","58.31"],"但不推荐":["0.31","58.31"],"因为存储浮点数值使用的内存空间是存储整数值的两倍":["0.31","58.31"],"所以":["0.31","58.31"],"总是想方设法把值转换为整数":["0.31","58.31"],"在小数点后面没有数字或者全是":["0.31","58.31"],"7e":["0.32","58.32"],"如果某个计算得出的值超出这个范围":["0.32","58.32"],"那么这个数值会被自动转为一个特殊的":["0.32","58.32"],"infinity":["0.32","0.77","58.32","58.77"],"无穷":["0.32","58.32"],"值":["0.32","58.32"],"任何无法表示的负数以":["0.32","58.32"],"num1":["0.34","0.66","58.34","58.66"],"hello":["0.34","34.2","58.34","60.4","107.53"],"world":["0.34","58.34"],"num2":["0.34","0.90","58.34","58.90"],"num3":["0.34","0.90","58.34","58.90"],"000011":["0.34","58.34"],"num4":["0.34","58.34"],"考虑到":["0.34","58.34"],"函数转换字符串时相对复杂且有点反常规":["0.34","58.34"],"通常在需要得到整数时可以优先使用":["0.34","58.34"],"函数":["0.34","58.34"],"函数更专注于字符串是否包函数值模式":["0.34","58.34"],"字符串最前面的空格会被忽略":["0.34","58.34"],"从第一个非空的字符串开始转换":["0.34","58.34"],"如果第一个字符不是数值字符":["0.34","58.34"],"加号或减号":["0.34","58.34"],"立即返回":["0.34","58.34"],"如果第一个字符是数值字符":["0.34","58.34"],"加号或者减号":["0.34","58.34"],"数据类型表示零或多个":["0.35","58.35"],"反斜杠":["0.36","58.36"],"单引号":["0.36","58.36"],"在字符串以单引号标记时使用":["0.36","58.36"],"例如":["0.36","58.36","93.11","107.19","107.22","107.23","107.89","107.91","107.99","107.139"],"he":["0.36","58.36"],"said":["0.36","58.36"],"hey":["0.36","58.36"],"他们的值就不能变了":["0.37","58.37"],"tostring":["0.38","58.38","96.2"],"一个是直接在后面加空串":["0.38","58.38"],"与使用单引号或双引号不同":["0.39","58.39"],"模板字面量保留换行字符":["0.39","58.39"],"句法表达式":["0.40","58.40"],"只不过求值后得到的":["0.40","58.40"],"是字符串":["0.40","58.40"],"而通过标签函数可以自定义插值行为":["0.41","58.41"],"标签函数":["0.41","58.41"],"字符":["0.42","58.42"],"是":["0.43","12.1","58.43","67.2","71.2","73.7","85.32","87.3","89.7","93.11"],"函数不能与":["0.44","58.44"],"关键字一起作为构造函数使用":["0.44","58.44"],"这样做是为了避免创建符号包装对象":["0.44","58.44"],"像使用":["0.44","58.44"],"foo":["0.45","58.45","62.10","63.3","63.8","64.2","65.4","65.5","65.6","65.7","78.3","78.5","80.2","80.15","80.31","80.35","82.13","83.4","83.6","85.14","85.26","86.35"],"创建新符号":["0.45","58.45"],"otherfooglobalsymbol":["0.45","58.45"],"重用已有符号":["0.45","58.45"],"这就包括了对象字面量属性和":["0.46","58.46"],"object":["0.46","56.4","58.46","64.8","71.4","76.3","76.4","76.8","85.4","86.3","96.1","101.52","107.34"],"这些内置符号都以":["0.47","58.47"],"工厂函数字符串属性的形式存在":["0.47","58.47"],"这些内置符号最重要的用途之一是重新定义它们":["0.47","58.47"],"从而改变原生结构的行为":["0.47","58.47"],"页":["0.59","58.59"],"用于判断当前对象实例":["0.60","58.60"],"不是原型":["0.60","58.60"],"上是否存在给定的属性":["0.60","58.60"],"要检查的属性名必须是字符串或者符号":["0.60","58.60"],"operator":["0.62","58.62"],"对于字符串":["0.63","58.63"],"如果是有效的数值形式":["0.63","58.63"],"则转换为数值再应用改变":["0.63","58.63"],"变量类型从字符串变成数值":["0.63","58.63"],"如果不是有效的数值形式":["0.63","58.63"],"则将变量值设置为":["0.63","58.63"],"一元加由一个加号":["0.64","58.64"],"表示":["0.64","58.64"],"依此类推":["0.65","58.65"],"负值以一种称为二补数":["0.65","58.65"],"或补码":["0.65","58.65"],"的二进制编码存储":["0.65","58.65"],"一个数值的二补数通过如下":["0.65","58.65"],"然后基于真值表中的规则":["0.67","58.67"],"对每一位执行相应的与操作":["0.67","58.67"],"第一个数值的位":["0.67","58.67"],"会按照指定的位数将数值的所有位向左移动":["0.69","58.69"],"会将数值的所有":["0.70","58.70"],"对于正数":["0.71","58.71"],"无符号右移与":["0.71","58.71"],"有符号右移结果相同":["0.71","58.71"],"则返回":["0.73","0.77","0.79","58.73","58.77","58.79"],"如果操作数是空字符串":["0.73","58.73"],"true":["0.73","58.73","61.4","66.2","69.2","70.1","75.2","77.2","80.1","80.2","87.8","89.1","101.58","107.60"],"逻辑与操作符可用于任何类型的操作数":["0.74","58.74"],"不限于布尔值":["0.74","58.74"],"如果有操作数不是布尔值":["0.74","58.74"],"与逻辑与类似":["0.75","58.75"],"如果有一个操作数不是布尔值":["0.75","58.75"],"或":["0.77","0.78","58.77","58.78","80.6","85.26"],"如果有任一操作数是":["0.77","0.78","58.77","58.78"],"nan":["0.77","0.78","0.79","58.77","58.78","58.79"],"除数是有限值":["0.79","58.79"],"如果被除数是有限值":["0.79","58.79"],"除数是":["0.79","58.79"],"现在有了自己的操作符":["0.80","58.80"],"不仅如此":["0.80","58.80"],"则执行数值比较":["0.84","58.84"],"如果操作数都是字符串":["0.84","58.84"],"则逐个比较字符串中对应字符的编码":["0.84","58.84"],"第二组是全等和不全等":["0.85","58.85"],"则尝试将字符串转换为数值":["0.86","58.86"],"再比较是否相等":["0.86","58.86"],"如果一个操作数是对象":["0.86","58.86"],"另一个操作数不是":["0.86","58.86"],"则调用对象的":["0.86","58.86"],"valueof":["0.86","58.86"],"方法取得其原始值":["0.86","58.86"],"再根据前面的规则进行比较":["0.86","58.86"],"比较规则":["0.86","58.86"],"null":["0.86","55.1","58.86","64.1","66.1","69.7","70.1","75.1","83.7","94.6","101.2","101.50"],"个等于号":["0.87","58.87"],"上面的代码执行了条件赋值操作":["0.88","58.88"],"即根据条件表达式":["0.88","58.88"],"复合赋值操作符":["0.89","58.89"],"乘后赋值":["0.89","58.89"],"的理解":["1.0"],"中":["1.1","19.0","60.8","82.1","87.3","107.8"],"过程靠":["1.1"],"来实现":["1.1","30.0"],"声明式代码更加简单":["1.1"],"不需要关注实现":["1.1"],"按照要求填代码就可以了":["1.1"],"给上原材料就出结果":["1.1"],"javascript":["1.1","56.3","59.0","61.0","63.10","78.3","78.7","78.11","78.13","89.0","101.1"],"分层管理":["1.2"],"image":["1.2","95.2","96.19"],"20240313103948553":["1.2"],"对于前端而言就是如何将数据同步到页面上":["1.2"],"也就是借鉴后端思想":["1.2"],"拼接一个完整的字符串":["1.3"],"innerhtml":["1.3"],"全部重新渲染":["1.3"],"浏览器":["1.4"],"时":["1.4","61.6","80.13"],"vue":["1.4","3.2","10.2","19.1","20.0","20.2","22.2","24.0","29.3","34.1","37.1","54.2","79.19","80.2","92.0","93.3","103.12","121.8"],"组件化":["1.5"],"实现高内聚":["1.5"],"spa":["2.0"],"页面":["2.1"],"并且提供一个挂载点":["2.1"],"最终打包后会在此页面中引入对应的资源":["2.1"],"页面的渲染全部是由":["2.1"],"动态进行渲染的":["2.1"],"多个完整的页面":["2.2"],"刷新方式":["2.2"],"局部刷新":["2.2"],"整页刷新":["2.2"],"seo":["2.2","99.3","99.6"],"generation":["2.3"],"ssg":["2.3"],"在构建时生成完整的":["2.3"],"md":["3.0","6.0","16.0"],"vnode":["3.1","36.3"],"vdom":["3.1"],"virtual":["3.1"],"中我们常常回味组件编写模板":["3.2"],"会记录第一次生成的":["3.3"],"oldvnode":["3.3"],"当响应式数据发生变化时":["3.3"],"组件化的核心组成":["4.0"],"模板":["4.0"],"属性":["4.0","39.0","61.6","63.11","66.7","75.1"],"数据是响应式的":["4.1"],"数据变化后执行":["4.1"],"进行":["5.0"],"diff":["5.0","86.37"],"检测差异":["5.0"],"对象内部通过":["6.1"],"definereactive":["6.1","6.3"],"方法":["6.1","9.0","15.0","83.4","83.7","83.9","84.3","107.45","107.69","121.1"],"来进行数据的劫持":["6.2"],"需要对属性进行重写添加":["6.2"],"getter":["6.2","13.0"],"及":["6.2"],"key":["6.3","31.1","39.0","101.63"],"in":["6.3","70.3","76.4","80.9","83.8","101.63","114.14","114.15"],"target":["6.3","63.10","86.38"],"value":["6.3","79.10","94.8","107.140"],"中如何检测数组变化":["7.0"],"defineproperty":["7.1"],"对数组的每一项进行拦截":["7.1"],"数组的缺点":["7.2"],"中如何进行依赖收集":["8.0"],"存放它所依赖的":["8.1"],"watcher":["8.1"],"当属性变化后会通知自己对应的":["8.1"],"中会通过":["8.2"],"map":["8.2","31.2","84.3"],"array":["9.0"],"调用我们重写的":["9.0"],"splcie":["9.0"],"这样可以更新视图":["9.0"],"isarray":["9.0","96.17"],"isvalidarrayindex":["9.0"],"length":["9.0","63.4","66.1","81.10"],"math":["9.0","79.8","101.50"],"max":["9.0","101.50"],"if和":["10.0"],"v":["10.1","10.3","29.1","30.0","55.2","86.3","114.5","114.8","114.9","114.17","114.18"],"if":["10.1","21.3","64.3","80.37","86.3","89.1","96.9","101.35","101.58","107.65"],"template":["10.2","31.0","113.1","113.2","113.21","115.1","117.1","117.2","121.8"],"如何选择":["10.3"],"渲染":["11.0"],"计算属性":["11.0"],"computed":["11.1","15.0","52.0"],"计算属性仅当用户取值时才会执行对应的方法":["11.1"],"则是监控值的变化":["11.2"],"源码剖析":["11.3"],"reactive":["12.0","12.1"],"vue3":["12.1"],"源码实现":["12.2"],"effect":["13.0"],"reactiveeffect":["13.0"],"scheduler":["13.0"],"编译为":["14.0"],"中可执行的":["14.0"],"watch":["15.0","52.0"],"method":["15.0"],"同时也初始化了":["15.0"],"provide":["15.0"],"inject":["15.0"],"vue2":["16.0","121.0"],"避免在同一个标签中使用":["17.0"],"如果遇到需要同事使用时可以考虑写成计算属性的方式":["17.0"],"html":["17.0","37.3","55.2","100.1","100.4"],"应当避免这种写法":["17.0"],"li":["17.0","101.40","111.16"],"实例已经创建完成之后被调用":["18.1"],"在这一步":["18.1"],"实例已经完成以下配置":["18.1"],"属性和方法等":["18.1"],"但是这里没有":["18.1"],"el":["18.1"],"beforemount":["18.2","103.2"],"组件挂载之前":["18.2"],"mounted":["18.2","103.9"],"组件挂在实例上去之后":["18.2"],"beforeupdate":["18.2"],"组件数据发生变化":["18.2"],"基于虚拟":["19.1"],"dom":["19.1","19.2","20.1","55.2","79.12","93.11"],"复用给新的虚拟节点":["19.2"],"比较儿子节点":["19.2"],"考虑老节点和新节点儿子的情况":["19.2"],"的虚拟":["20.1"],"算法":["20.1"],"在新旧":["20.1"],"nodes":["20.1"],"在":["20.2","22.1","57.1","60.4","60.5","60.8","61.1","61.5","71.4","78.7","78.9","80.2","91.8","107.8","107.52"],"patch":["20.2"],"use":["21.0","54.3","85.25"],"插件":["21.1","81.12","107.13"],"如果插件是一个对象":["21.1"],"添加全局指令":["21.2"],"全局过滤器":["21.2"],"indexof":["21.3"],"如果已经有插件":["21.3"],"直接返回":["21.3"],"return":["21.3","34.2","54.3","55.1","60.8","61.3","66.1","66.2","68.2","79.4","79.7","79.8","79.10","79.19","83.3","83.4","83.8","83.9","84.7","85.4","87.2","96.6","107.27"],"extend":["22.0","23.0"],"需要注意":["22.1"],"中它必须是函数":["22.1"],"所有的组件创建时都会调用":["22.2"],"function":["23.0","59.1","63.3","64.2","64.3","67.4","68.0","68.2","73.1","78.9","79.6","79.9","80.22","83.3","83.5","83.8","85.24","86.4","86.5","86.13","86.14","96.9","101.17","101.31","101.32","101.34","101.54","107.28","107.53"],"options":["23.0","55.1","107.96"],"sub":["23.0"],"会将data":["23.0"],"this":["24.0","52.0","63.8","63.9","67.6","83.4","86.24","87.2","107.44","107.65","107.77","121.3"],"但是性能高":["24.0"],"正常组件是一个类继承了":["24.0"],"filter":["25.0"],"once":["26.0"],"概念":["26.1"],"h1":["26.2","97.3","99.1"],"comment":["26.2"],"p":["26.2","55.2","79.4","80.9","89.6","89.8","97.3","99.1","110.2","113.3","113.4","113.9","113.10","113.12","113.13","113.16","113.17","118.2","119.2"],"组件":["26.2","103.8"],"my":["26.2"],"mixin的使用场景和原理":["27.0"],"mixin可以用来扩展组件":["27.1"],"将公共逻辑进行抽离":["27.1"],"在需要该逻辑时进行":["27.1"],"混入方式":["27.2"],"在vue中我们可以":["27.2"],"对象的合并处理":["27.3"],"props":["27.3","55.1","79.4","79.13","103.11"],"methods":["27.3","103.3"],"中的":["28.0","73.2","82.1","85.31","89.7"],"插槽设计来源于":["28.1"],"web":["28.1","96.13"],"什么时候使用它":["28.2"],"通过插槽可以让用户更好地对组件进行扩展和定制化":["28.2"],"内容":["28.3"],"编译后结果":["28.3"],"with":["28.3","106.1"],"attrs":["28.3"],"以及它的实现原理":["29.0"],"中双向绑定靠的是指令":["29.1"],"model":["29.1","30.0","56.4"],"内部会根据标签的不同解析出不同的语法":["29.2"],"并且这里有":["29.2"],"额外":["29.2"],"的语法糖":["29.3"],"可用于组件中的数据的双向绑定":["29.3"],"名字也可以修改为":["29.3"],"component":["29.3","111.9","111.10"],"base":["29.3","86.27"],"checkbox":["29.3"],"默认只能双向绑定一个属性":["30.0"],"这里就可以通过":["30.0"],"submenu":["31.0"],"slot":["31.0","36.3","79.19"],"title":["31.0","81.10","82.9"],"id":["31.1","82.9","107.36","107.39","107.40","107.136","116.1","116.2"],"child":["31.2","101.43","101.44","101.45","101.46","113.21"],"children":["31.2","79.12","85.5"],"components":["32.0","95.4"],"属性中增加组件本身":["32.0"],"实现组件的递归调用":["32.0"],"可以表示组件的具体名称":["32.0"],"trim":["33.0"],"number":["33.0","61.4","64.1","64.3","64.8","65.2","65.7","66.8","67.7","69.2","70.5","75.4","79.7","80.29","86.11","86.22","89.2","96.2","101.27","107.22","107.28","107.36","107.39","107.40","107.43","107.46"],"事件修饰符":["33.0"],"stop":["33.0"],"中异步组件的作用和原理":["34.0"],"允许你以一个工厂函数的方式定义你的组件":["34.1"],"div":["34.2","37.3","55.2","97.3","97.12","113.1","113.2","113.16","113.17","113.23","113.24","115.1","117.1","117.2","118.2","120.1","121.8"],"promise":["34.2","63.6","67.4","83.3","103.15"],"写法":["34.2"],"异步组件原理":["34.3"],"nexttick":["35.0"],"中视图更新是异步的":["35.1"],"使用":["35.1","60.6","67.5","78.3","78.8","80.2","80.16"],"alive":["36.0","36.1"],"keep":["36.1","103.6"],"在路由器中使用keep":["36.2"],"val":["36.3"],"prunecache":["36.3"],"matches":["36.3"],"render":["36.3"],"slots":["36.3"],"每次进入路由的时候":["36.4"],"都会执行":["36.4"],"除了内置指令之外":["37.1"],"inserted":["37.2"],"被绑定元素插入父节点时调用":["37.2"],"仅保证父节点存在":["37.2"],"但不一定已被插入文档中":["37.2"],"drop":["37.3"],"可视化拖拽编辑器":["37.3"],"点击事件处理":["37.3"],"click":["37.3","79.10","112.5","113.4","113.6","113.7","114.11","114.12","115.5"],"outside":["37.3"],"createelement":["38.0"],"发布订阅模式":["38.0"],"订阅者把自己想订阅的事件注册到调度中心":["38.0"],"当该事件触发的时候":["38.0"],"发布者发布该事件到调度中心":["38.0"],"缓存值的结果":["39.0"],"不频繁取值":["39.0"],"合理设置":["39.0"],"进行代码分割":["40.0"],"组件加载采用按需加载的方式":["40.0"],"静态资源缓存":["40.0"],"http":["40.0"],"缓存":["40.0"],"服务端和服务端之间进行通信是没有跨域问题的":["41.0"],"跨域的实现方案有很多种":["41.0"],"不过一般常用的就那么几中":["41.0"],"cors":["41.0"],"主要是封装哪方面的":["42.0"],"设置请求超时时间":["42.0"],"根据项目环境设置请求路径":["42.0"],"要做权限管理该怎么做":["43.0"],"每次发送请求时会携带":["43.1"],"后端会对":["43.1"],"进行验证":["43.1"],"守卫":["44.0"],"在重用的组件里调用":["44.0"],"beforerouteupdate":["44.0"],"abstract":["45.0"],"模式是在不支持浏览器":["45.0"],"api":["45.0","78.0","82.11","113.20"],"环境使用":["45.0"],"项目本地开发完后部署到服务器后报":["46.0"],"vuex":["47.0","47.1"],"是一个专门为":["47.1"],"commit":["47.2"],"mutation":["47.2","51.0"],"只有一份":["47.3"],"复杂的数据需要依赖于模块":["47.3"],"vuex3":["47.4"],"核心就是通过":["47.4"],"中数据的变化":["48.0"],"通过":["48.0"],"每次获取数据前检测":["49.0"],"数据是否存在":["49.0"],"可以获取数据后将结果提交给":["50.0"],"中则是修改":["50.0"],"state":["50.0","51.0","107.65"],"允许我们将":["51.0"],"分割成模块":["51.0"],"每个模块拥有自己的":["51.0"],"等属性":["52.0"],"用户编写复杂业务逻辑会出现反复横跳的问题":["52.0"],"中所有的属性都是通过":["52.0"],"中的模块之间耦合度低":["53.0"],"模块可以独立使用":["53.0"],"拆分模块":["53.0"],"中很多方法挂遭到了实例中导致没有使用也会被打包":["53.0"],"还有很多组件也是一样":["53.0"],"通过构建工具":["53.0"],"tree":["53.0"],"shaking":["53.0"],"项目中的错误如何处理的":["54.0"],"如果全局的":["54.1"],"config":["54.1","54.2"],"errorhandler":["54.1","54.2"],"res":["54.3","78.5","83.3"],"中模板编译优化":["55.0"],"cache":["55.1"],"setup":["55.1","121.2"],"data":["55.1","62.0","82.3","111.16"],"text":["55.1","85.11","87.2","89.2","101.1","103.5","107.110","107.136","109.1","114.6"],"生成的虚拟":["55.1"],"树层级的":["55.2"],"树的结构可能会发生变化":["55.3"],"不稳定结构有哪些呢":["55.3"],"createelementvnode":["55.4"],"openblock":["55.4","55.5"],"createelementblock":["55.4","55.5"],"createcommentvnode":["55.4"],"fragment":["55.5"],"远远不限于":["56.1"],"ecma":["56.1"],"描述":["56.3","107.83","107.92"],"的对象和方法":["56.5"],"domlevel2":["56.5"],"新增了以下模块":["56.5"],"视图":["56.5"],"描述追踪文档不同视图":["56.5"],"如应用":["56.5"],"不过人们通常会把任何特定于浏览器的扩展都归在":["56.6"],"的范畴内":["56.6"],"比如":["56.6","69.7","73.6","79.15","85.28","91.12"],"弹出新浏览器窗口的能力":["56.6"],"设置凭据标志":["57.1"],"意味着出站请求会包含凭据":["57.1"],"defer":["57.1"],"表示脚本可以延迟到文档完全被解析和显示之后再执行":["57.1"],"ie7":["57.1"],"及更早版本中":["57.1"],"对行内脚本也可以指定这个属性":["57.1"],"integrity":["57.1"],"允许比对接收到的资源和指定的加密签名已验证子资源完整性":["57.1"],"sri":["57.1"],"subresource":["57.1"],"的受访者甚至认为":["59.0"],"将超越":["59.0"],"成为前端开发的主要语言":["59.0"],"无论":["59.0"],"a":["59.1","66.8","67.2","70.3","77.2","80.15","86.11","91.5","101.8","101.59"],"等":["59.1","79.15","81.10","82.2"],"这些错误就是我们过度依赖灵活性的后果":["59.1"],"一旦它们被触发":["59.1"],"就会导致你的页面白屏":["59.1"],"卡死":["59.1"],"甚至崩溃":["59.1"],"要解决灵活性带来的隐患":["59.1"],"我们需要的是类型":["59.1"],"更准确地说":["59.1"],"是项目开发时的类型检查能力":["59.1"],"通过易上手且功能强大的类型系统":["59.1"],"为":["59.1"],"提供了强大的类型检查能力":["59.1"],"在类型的帮助下":["59.1"],"任何知识点都不能孤立地学习":["59.2"],"不然在实际开发时":["59.2"],"遇到一个复杂点的类型编程场景":["59.2"],"我们就束手无策了":["59.2"],"那么":["59.2","79.6","82.1","91.0"],"我们到底该怎么学习":["59.2"],"呢":["59.2","71.7"],"学习没有捷径":["59.2"],"最好的学习方法就是先建立起对事物的全面认知":["59.2"],"然后由浅入深地系统学习":["59.2"],"这里的":["59.2","62.0","78.5","83.7","86.35"],"全面":["59.2"],"如何理解":["59.2"],"我们首先要了解":["59.2"],"是由哪些部分组成的":["59.2"],"相对严谨来说":["59.2"],"由三个部分组成":["59.2"],"包括它是如何进行类型比较的":["59.3"],"以及整个类型世界的运行规则是怎样的":["59.3"],"这一步将帮助你从根源上理解":["59.3"],"的类型能力设计与底层运行规则":["59.3"],"掌握了类型工具与类型系统后":["59.3"],"我们才会学习类型能力最复杂的概念":["59.3"],"类型编程":["59.3","66.5"],"这部分我们会从内置工具类型讲解到内置工具类型进阶":["59.3"],"带你循序渐进地掌握类型编程中的":["59.3"],"你可以把它当作一本备忘手册":["59.4"],"时常回顾和翻阅":["59.4"],"比如说":["59.4"],"当你忘记了":["59.4"],"tiny":["59.6"],"book":["59.6"],"下的":["60.0"],"环境搭建":["60.0"],"插件以及配置项":["60.0"],"对于":["60.0","79.0"],"ts":["60.0","60.3","60.6","63.11","76.3","80.1","81.12","85.26","85.28","86.19","86.27","86.32","86.33","86.39","87.2","88.2","89.4","89.6","107.17"],"这一功能在日常开发中真得非常非常好用":["60.1"],"尤其是当项目里有数百个声明分散在各个文件中时":["60.1"],"move":["60.1"],"这一插件在重构以及像我们这样写":["60.1"],"demo":["60.1"],"的场景下很有帮助":["60.1"],"它可以让你通过编辑文件的路径":["60.1"],"直接修改项目的目录结构":["60.1"],"比如从":["60.1","77.2"],"home":["60.1","85.5"],"project":["60.1","86.42","87.2","89.4","89.6","89.8"],"learn":["60.1"],"interface":["60.1","61.5","65.7","69.5","107.45"],"修改成":["60.1"],"还有一些额外的":["60.2"],"能提升你学习效率的插件":["60.2"],"代码":["60.3","63.10"],"快速查看编译后的":["60.3"],"代码与声明文件":["60.3"],"还可以通过":["60.3"],"可以这么做":["60.4"],"tsc":["60.4","86.30"],"接着":["60.4"],"创建一个":["60.4"],"再使用":["60.4"],"执行":["60.4"],"如果一切正常":["60.4"],"此时你的终端能够正确地输出字符":["60.4"],"可以通过两种方式进行配置":["60.4"],"中新增":["60.4"],"字段":["60.4"],"或在执行":["60.4"],"fe":["60.5"],"只是想要进行类型比较":["60.5"],"的前提下":["60.5"],"其实并没有必要真的去声明两个变量":["60.5"],"即涉及了值空间的操作":["60.5"],"我们完全可以只在类型空间中":["60.5"],"你可以理解为":["60.5"],"用于存放":["60.5"],"类型信息的内存空间":["60.5"],"比较这些类型":["60.5"],"playground":["60.6","83.7","107.12"],"作为一个简易又强大的临时编辑器":["60.6"],"以及如何使用":["60.6"],"使用了":["60.8"],"pirates":["60.8"],"这个库来简化注册逻辑":["60.8"],"compiler":["60.8"],"addhook":["60.8"],"code":["60.8","87.3"],"exts":["60.8"],"tsx":["60.8"],"你会感到非常熟悉":["61.0"],"同样的":["61.0","72.2"],"这一章我们会从":["61.0"],"的既有概念开始学习":["61.0"],"bigint":["61.1","101.2"],"typescript":["61.1","63.8","66.8","70.4","73.2","75.5","76.0","76.8","79.6","79.14","80.10","80.22","80.32","80.33","80.40","80.42","83.4","83.11","85.17","85.23","86.4","87.9","88.2","91.8","92.0","93.7","93.9","93.10","94.3","94.5","94.7","94.9","94.10","107.9","107.10","107.12","107.31","107.128"],"中它们都有对应的类型注解":["61.1"],"linbudu":["61.1","61.4","62.4","64.1","64.3","65.2","65.5","67.3","67.7","75.2","79.19","80.34","85.6","89.2"],"类型都是":["61.2"],"有具体意义的类型":["61.2"],"也就是说":["61.2","87.7"],"它们作为类型时":["61.2"],"表示的是一个有意义的具体类型值":["61.2"],"这两者在没有开启":["61.2"],"strictnullchecks":["61.2"],"检查的情况下":["61.2"],"因此整体其实相当于":["61.3"],"事实上":["61.3"],"的原始类型标注中也有":["61.3"],"但与":["61.3"],"中不同的是":["61.3"],"用于描述一个内部没有":["61.3"],"语句":["61.3","89.1"],"或者没有显式":["61.3"],"一个值的函数的返回值":["61.3"],"在索引":["61.4"],"处没有元素":["61.4"],"除了同类型的元素以外":["61.4"],"元组内部也可以声明多个与其位置强绑定的":["61.4"],"不同类型的元素":["61.4"],"arr5":["61.4"],"在这种情况下":["61.4","76.1","85.12"],"对数组合法边界内的索引访问":["61.4"],"即":["61.4","61.5","63.2","69.9","78.2","78.11","84.2","84.4"],"将精确地获得对应位置上的类型":["61.4"],"同时元组也支持了在某一个位置上的可选成员":["61.4"],"arr6":["61.4"],"类似于数组类型":["61.5"],"中我们也需要特殊的类型标注来描述对象类型":["61.5"],"你可以理解为它代表了这个对象对外提供的接口结构":["61.5"],"首先我们使用":["61.5"],"中定义了":["61.6"],"但当你访问":["61.6"],"它的类型仍然会是":["61.6"],"因为毕竟这是我们自己定义的类型嘛":["61.6"],"假设新增一个可选的函数类型属性":["61.6"],"然后进行调用":["61.6"],"alias":["61.7"],"类型别名":["61.7"],"以":["61.8","62.10","85.6","89.4"],"为例":["61.8","78.13","85.6"],"它同样包括":["61.8"],"以及代表的":["61.8"],"拆箱类型":["61.8"],"unboxed":["61.8"],"但并不包括其他装箱类型对应的拆箱类型":["61.8"],"如":["61.8","67.2","69.5","70.3","71.4","80.18","80.23","80.25","80.40","82.2","82.5","86.27","88.3","89.11"],"与":["61.8","65.3","73.2","75.8","76.1","78.1","79.0","80.0","80.43","82.11","83.13","84.3","89.6","91.12"],"基本对象类型":["61.8"],"我们看以下的代码":["61.8"],"tmp9":["61.8"],"tmp10":["61.8"],"tmp11":["61.8"],"tmp12":["61.8"],"以下不成立":["61.8"],"因为不是字符串类型的拆箱类型":["61.8"],"所以你可以认为你就是在写":["61.9"],"更严格一些的":["61.9"],"一些全新的概念":["61.9"],"比如元组与":["61.9"],"readonly":["61.9","63.12","75.1"],"修饰等":["61.9"],"这一部分你可能不会很快适应":["61.9"],"这个特性":["61.11"],"中支持了":["61.11"],"这一类型声明":["61.11"],"它是":["61.11"],"类型的子类型":["61.11"],"每一个":["61.11"],"类型都是独一无二的":["61.11"],"status":["62.0","62.2"],"string":["62.0","63.8","64.1","64.8","65.2","66.8","67.3","67.7","69.4","71.12","75.2","75.4","79.4","80.29","80.34","82.13","83.4","83.5","83.6","87.2","87.8","89.2","94.6","94.8","107.20","107.28","107.36","107.39","107.43","107.46","107.110"],"any":["62.0","69.1","74.1","79.4","79.13","80.26","80.31","84.2","84.3","85.26","86.9","89.2"],"在大多数情况下":["62.0"],"success":["62.2","88.4"],"对象字面量类型":["62.4"],"它们可以直接作为类型标注":["62.4"],"str":["62.4","101.34"],"num":["62.4"],"函数类型并不存在字面量类型":["62.6"],"因此这里的":["62.6"],"就是一个合法的函数类型":["62.6"],"你可以在联合类型中进一步嵌套联合类型":["62.6"],"但这些嵌套的联合类型最终都会被展平到第一级中":["62.6"],"联合类型的常用场景之一是通过多个对象类型的联合":["62.6"],"来实现手动的互斥属性":["62.6"],"即这一属性如果有字段1":["62.6"],"那就没有字段2":["62.6"],"age":["62.8","65.1","65.2","66.7","89.2","107.36","107.43","107.46"],"这么做的好处非常明显":["62.10"],"首先":["62.10","70.3","82.1"],"你拥有了更好的类型提示":["62.10"],"其次":["62.10","70.3"],"这些常量被真正地":["62.10"],"约束在一个命名空间":["62.10"],"下":["62.10"],"上面的对象声明总是差点意思":["62.10"],"如果你没有声明枚举的值":["62.10"],"它会默认使用数字枚举":["62.10"],"并且从":["62.10"],"开始":["62.10"],"递增":["62.10"],"items":["62.10"],"bar":["62.10","80.23","82.13","84.7"],"baz":["62.10"],"foovalue":["62.12"],"它和普通枚举的差异主要在访问性与编译产物":["62.12"],"对于常量枚举":["62.12"],"以及枚举与其编译产物等等":["62.14"],"对于字面量类型":["62.14"],"我们可以使用它来提供更精确的类型标注":["62.14"],"声明的变量":["62.18"],"其类型会从值推导出最精确的字面量类型":["62.18"],"而对象类型则只会推导至符合其属性结构的接口":["62.18"],"不会使用字面量类型":["62.18"],"es6":["63.0","63.10"],"新特性的重要一部分":["63.0"],"我们终于可以和各种花式继承告别了":["63.0"],"这一节":["63.0","85.0"],"我们会介绍函数与":["63.0"],"的类型标注":["63.0"],"以及一些在":["63.0"],"的形式声明一个函数":["63.2"],"在表达式中进行类型声明的方式是这样的":["63.2"],"我们也可以像对变量进行类型标注那样":["63.2"],"对":["63.2"],"没有调用":["63.3"],"调用了":["63.3"],"直接为可选参数声明默认值":["63.4"],"foo2":["63.4"],"将以上的例子使用重载改写":["63.5"],"functiongenfunc":["63.6"],"iterable":["63.6"],"标准入门":["63.8"],"属性的类型标注类似于变量":["63.8"],"而构造函数":["63.8"],"存取器的类型编标注类似于函数":["63.8"],"prop":["63.8","64.3","78.3","80.2"],"constructor":["63.8","67.6","83.5","86.24","96.8","96.9","107.39","107.44"],"inputprop":["63.8"],"print":["63.9"],"addon":["63.9"],"and":["63.9"],"get":["63.9","84.1","87.2","88.2"],"我们可以查看编译到":["63.10"],"es5":["63.10","80.2"],"及以下":["63.10"],"的":["63.10","78.7","78.8","87.9","121.0"],"以上就原生支持静态成员了":["63.10"],"来进一步了解它们的区别":["63.10"],"printwithlove":["63.11"],"在这里":["63.11","66.2","72.1","87.3"],"将会给出错误":["63.11"],"尝试覆盖的方法并未在基类中声明":["63.11"],"通过这一关键字我们就能确保首先这个方法在基类中存在":["63.11"],"同时标识这个方法在派生类中被覆盖了":["63.11"],"除了基类与派生类以外":["63.11"],"还有一个比较重要的概念":["63.11"],"抽象类是对类结构与方法的抽象":["63.11"],"简单来说":["63.11"],"一个抽象类描述了一个类中应当有哪些成员":["63.11"],"方法等":["63.11"],"一个抽象方法描述了这一方法在实际实现中的结构":["63.11"],"我们知道类的方法和函数非常相似":["63.11"],"包括结构":["63.11"],"因此抽象方法其实描述的就是这个方法的":["63.11"],"入参类型":["63.11"],"返回值类型":["63.11"],"抽象类使用":["63.11"],"如访问性修饰符":["63.12"],"public":["63.12","63.15","86.24"],"private":["63.12","84.3","107.40"],"protected":["63.12","107.40"],"操作修饰符":["63.12"],"静态成员":["63.12"],"那这就很奇怪了":["63.14"],"我们要一个不能实例化的类有啥用":["63.14"],"摆设吗":["63.14"],"还真不是":["63.14"],"有些场景下私有构造函数确实有奇妙的用法":["63.14"],"比如像我一样把类作为":["63.14"],"utils":["63.14","88.4"],"wechat":["63.15"],"taobao":["63.15"],"tiktok":["63.15"],"class":["63.15","78.3","80.34","81.10","82.2","83.0","83.4","84.4","84.7","87.2","95.3","97.12","107.38","107.40"],"static":["63.15","84.3","107.38"],"handler":["63.15","78.5","83.6"],"type":["63.15","65.2","65.5","66.2","66.8","76.8","78.3","84.2","84.3","86.15","89.2","91.2","93.7","101.1","107.96","107.112","114.1","114.2"],"代码的第一步迁移":["64.0"],"而这一节":["64.0"],"我们要学习的则是":["64.0"],"如何使用":["64.0"],"类型的变量可以拥有任意类型的值":["64.1"],"anyvar":["64.1"],"site":["64.1"],"juejin":["64.1"],"标记为具体类型的变量也可以接受任何":["64.1"],"类型的值":["64.1"],"val1":["64.1"],"val2":["64.1"],"val3":["64.1"],"val4":["64.1"],"你可以在":["64.1"],"类型变量上任意地进行操作":["64.1"],"包括赋值":["64.1"],"访问":["64.1","88.1"],"方法调用等等":["64.1"],"此时可以认为类型推导与检查是被完全禁用的":["64.1"],"一样":["64.2","86.35"],"它是所有类型的子类型":["64.2"],"但只有":["64.2"],"类型的变量能够赋值给另一个":["64.2"],"类型变量":["64.2"],"通常我们不会显式地声明一个":["64.2"],"它主要被类型检查所使用":["64.2"],"但在某些情况下使用":["64.2"],"确实是符合逻辑的":["64.2"],"比如一个只负责抛出错误的函数":["64.2"],"justthrow":["64.2"],"throw":["64.2","66.2","96.9"],"error":["64.2","66.2","80.20","80.38"],"在类型流的分析中":["64.2"],"一旦一个返回值类型为":["64.2"],"的函数被调用":["64.2"],"那么下方的代码都会被视为无效的代码":["64.2"],"即无法执行到":["64.2"],"func":["64.3","66.1"],"也可以在联合类型中断言一个具体的分支":["64.3"],"union":["64.3","70.3"],"类型":["64.4","65.6","66.3","67.7","72.1","80.41","86.9","91.5","93.9","93.10","96.6","107.89","107.91"],"到":["64.4"],"y":["64.4","75.7","82.10"],"类型的断言可能是错误的":["64.4"],"blabla":["64.4"],"as":["64.4","68.3","76.4","80.2","82.13","85.5"],"我们就会收获两个类型报错":["64.5"],"如果不管三七二十一地坚持调用":["64.5"],"想要解决掉类型报错就可以使用非空断言":["64.5"],"其应用位置类似于可选链":["64.5"],"但不同的是":["64.5"],"非空断言的运行时仍然会保持调用链":["64.5"],"因此在运行时可能会报错":["64.5"],"包括它们的类型兼容性表现与使用场景":["64.6"],"而在另外一部分类型断言中":["64.6"],"我们了解了类型断言的基本使用":["64.6"],"以及结合内置类型":["64.6"],"特殊的":["64.8"],"它也包含了所有的类型":["64.8"],"但和":["64.8"],"比还是差了一层":["64.8"],"我们还需要一些实用的类型工具":["65.0"],"它们就像是锤子":["65.0"],"锯子和斧子":["65.0"],"有了它们的帮助":["65.0"],"我们甚至可以拼装出摩天大楼":["65.0"],"在实际的类型编程中":["65.0"],"draghandler":["65.1"],"声明一个对象类型":["65.1"],"就像接口那样":["65.1"],"objtype":["65.1"],"关于接口和类型别名的取舍":["65.1"],"请参考原始类型与对象类型一节":["65.1"],"看起来类型别名真的非常简单":["65.1"],"不就是声明了一个变量让类型声明更简洁和易于拆分吗":["65.1"],"如果真的只是把它作为类型别名":["65.1"],"用来进行特定类型的抽离封装":["65.1"],"那的确很简单":["65.1"],"然而":["65.1","72.2"],"类型别名还能作为工具类型":["65.1"],"工具类同样基于类型别名":["65.1"],"只是多了个泛型":["65.1"],"如果你还不了解泛型也无需担心":["65.1"],"现阶段我们只要了解它和类型别名相关的使用就可以了":["65.1"],"至于更复杂的泛型使用场景":["65.1"],"agestruct":["65.2"],"profilestruct":["65.2"],"profile":["65.2","107.80"],"很明显这里的":["65.2"],"对象需要同时符合这两个对象的结构":["65.2"],"索引类型访问":["65.3"],"在这个例子中我们声明的键的类型为":["65.4"],"这也意味着在实现这个类型结构的变量中":["65.4"],"只能声明字符串类型的键":["65.4"],"这个类型来访问":["65.6"],"由于其内部声明了数字类型的索引签名":["65.6"],"这里访问到的结果即是":["65.6"],"注意":["65.6","76.5","89.7","96.5","97.22","101.6"],"其访问方式与返回值均是类型":["65.6"],"更直观的例子是通过字面量类型来进行索引类型访问":["65.6"],"propa":["65.6"],"propb":["65.6"],"关键字":["65.7","76.5","86.12","91.2","107.38"],"将这个联合类型的每一个成员映射出来":["65.7"],"并将其键值类型设置为":["65.7"],"具体使用的表现是这样的":["65.7"],"prop1":["65.7","80.34"],"prop2":["65.7"],"prop3":["65.7"],"作为一个新的类型":["65.8"],"映射类型":["65.8","66.5"],"工具类型":["65.8","68.3"],"在类型别名的基础上":["65.8"],"基于泛型去动态创建新类型":["65.8"],"基本所有类型工具":["65.8"],"基于已有的类型去创建出新的类型":["66.0"],"即类型工具的重要作用之一":["66.0"],"而除了类型的创建以外":["66.0"],"nullvar":["66.1"],"undefinedvar":["66.1"],"input":["66.1","68.2","79.10","83.6","100.2","113.27","113.28","114.1","114.2","114.8","114.9","114.17","114.18","115.4"],"要是走到这里就说明有问题":["66.2"],"exhaustivecheck":["66.2"],"unknown":["66.2","80.33","91.8"],"我们实际上通过":["66.2"],"条件中的表达式进行了类型保护":["66.2"],"即告知了流过这里的分析程序每个":["66.2"],"语句代码块中变量会是何类型":["66.2"],"这即是编程语言的类型能力中最重要的一部分":["66.2"],"与实际逻辑紧密关联的类型":["66.2"],"我们从逻辑中进行类型地推导":["66.2"],"再反过来让类型为逻辑保驾护航":["66.2"],"前面我们说到":["66.2"],"类型控制流分析就像一条河流一样流过":["66.2"],"那":["66.2","85.11"],"条件中的表达式要是现在被提取出来了怎么办":["66.2"],"isstring":["66.2"],"就会发现在分支代码块中":["66.3"],"仍然是初始的联合类型":["66.3"],"上不存在属性":["66.3"],"never":["66.3","66.4","70.1","75.1","80.41"],"这里需要注意的是":["66.3"],"都满足":["66.3"],"这个条件":["66.3"],"如果断言通过了":["66.4"],"不管你最开始是什么类型":["66.4"],"断言后的代码中就":["66.4"],"一定是符合断言的类型":["66.4"],"比如在这里就是":["66.4"],"但断言守卫和类型守卫最大的不同点在于":["66.4"],"在判断条件不通过时":["66.4"],"断言守卫需要抛出一个错误":["66.4"],"类型守卫只需要剔除掉预期的类型":["66.4"],"这里的抛出错误可能让你想到了":["66.4"],"但实际情况要更复杂一些":["66.4"],"断言守卫并不会始终都抛出错误":["66.4"],"所以它的返回值类型并不能简单地使用":["66.4"],"类型守卫等等":["66.5"],"对这些工具的学习能够更好的帮助你更好的理解":["66.5"],"这个概念":["66.5","86.35"],"的类型不兼容":["66.7"],"不能将类型":["66.7","72.1","86.22"],"分配给类型":["66.7","72.1","86.22"],"代码中会报错":["66.8"],"args":["66.8","84.2","84.3","96.9"],"b":["66.8","67.2","77.2","80.15","101.52"],"知识变得更加复杂了":["67.0"],"不过":["67.0"],"你也不必担心":["67.0"],"我会和你一起将思维调整到类型的频道":["67.0"],"clone":["67.1"],"会将一个对象类型的所有属性类型置为":["67.1"],"而":["67.1","67.5","71.2","83.0","83.7","83.13","88.3","91.2"],"则会进行类型的完全复制":["67.1"],"我们可以提前看一个":["67.1"],"的内置工具类型实现":["67.1"],"而在泛型中":["67.2"],"我们可以使用":["67.2"],"extends":["67.2","70.4","76.3","76.8","80.1","80.2","80.26","88.4","89.2","101.43","107.39"],"关键字来约束传入的泛型参数必须符合要求":["67.2"],"关于":["67.2"],"意味着":["67.2"],"的子类型":["67.2","73.3"],"这里我们暂时只需要了解非常简单的判断逻辑":["67.2"],"比":["67.2","99.3","101.51"],"的类型更精确":["67.2"],"或者说更复杂":["67.2"],"具体来说":["67.2"],"可以分为以下几类":["67.2"],"更精确":["67.2"],"字面量类型是对应原始类型的子类型":["67.2"],"rejected":["67.3"],"result2":["67.3"],"homepage":["67.4"],"avatar":["67.4"],"fetchuserprofile":["67.4"],"我们为函数声明了一个泛型参数":["67.5"],"并将参数的类型与返回值类型指向这个泛型参数":["67.5"],"在这个函数接收到参数时":["67.5"],"会自动地被填充为这个参数的类型":["67.5"],"这也就意味着你不再需要预先确定参数的可能类型了":["67.5"],"在返回值与参数类型关联的情况下":["67.5"],"也可以通过泛型参数来进行运算":["67.5"],"在基于参数类型进行填充泛型时":["67.5"],"其类型信息会被推断到尽可能精确的程度":["67.5"],"如这里会":["67.5"],"推导到字面量类型而不是基础类型":["67.5"],"这是因为在直接传入一个值时":["67.5"],"这个值是不会再被修改的":["67.5"],"因此可以推导到最精确的程度":["67.5"],"而如果你使用一个变量作为参数":["67.5"],"那么只会使用这个变量标注的类型":["67.5"],"在没有标注时":["67.5"],"会使用推导出的类型":["67.5"],"author":["67.5","89.2"],"声明":["67.5"],"被推导为":["67.5"],"authorage":["67.5"],"initial":["67.6"],"入队一个队列泛型子类型的元素":["67.6"],"enqueue":["67.6"],"ttype":["67.6"],"当中":["67.7"],"其泛型参数代表数组的元素类型":["67.7"],"几乎贯穿所有的数组方法":["67.7"],"arr":["67.7","80.40","101.21","101.22","101.23","101.24"],"的参数不能赋给类型":["67.7"],"的参数":["67.7"],"push":["67.7"],"这样来看是不是泛型就好理解多了":["67.8"],"但还没完":["67.8"],"我们紧接着了解了泛型的本质":["67.8"],"dog":["68.0"],"feedcat":["68.0"],"这个名字来源于":["68.1"],"鸭子测试":["68.1"],"test":["68.1"],"其核心理念是":["68.1"],"如果你看到一只鸟走起来像鸭子":["68.1"],"游泳像鸭子":["68.1"],"叫得也像鸭子":["68.1"],"那么这只鸟就是鸭子":["68.1"],"也就说":["68.1"],"鸭子类型中两个类型的关系是通过对象中的属性方法来判断的":["68.1"],"比如最开始的":["68.1"],"类型和":["68.1"],"类型被视为同一个类型":["68.1"],"而为":["68.1"],"类型添加独特的方法之后就不再能被视为一个类型":["68.1"],"但如果为":["68.1"],"类型添加一个独特方法呢":["68.1"],"addcny":["68.2"],"source":["68.2","69.1","89.7","89.8"],"就得到了":["68.3"],"有了":["68.3"],"这个工具类型":["68.3"],"我们可以尝试来改进下上面的例子了":["68.3"],"cnycount":["68.3"],"如何通过":["68.4"],"为类型附加信息":["68.4"],"的方式":["68.4"],"从":["68.4","79.9"],"类型层面":["68.4"],"或者":["68.4","69.4","75.2"],"字面量类型等基础类型":["68.6"],"以及类型别名":["68.6"],"联合类型等经过类型编程后得到的类型":["68.6"],"一组为变量":["68.6"],"函数等结构分配":["68.6"],"实施类型的规则":["68.6"],"通过显式地指定或类型推导来分配类型":["68.6"],"同时类型系统也定义了如何判断类型之间的兼容性":["68.6"],"类型层级也是我们后续学习条件类型必不可少的前置知识":["69.0"],"我也建议你能同时学习这两篇内容":["69.0"],"遇到不理解":["69.0"],"不熟悉的地方可以多看几遍":["69.0"],"类型层级实际上指的是":["69.0"],"还有一种备选的":["69.1"],"通过赋值来进行兼容性检查的方式":["69.1"],"其大致使用方式是这样的":["69.1"],"declare":["69.1","72.1","80.37","85.10","86.18"],"anytype":["69.1"],"result3":["69.2"],"在这一层面上":["69.4"],"并不需要联合类型的":["69.4"],"所有成员均为字面量类型":["69.4"],"字面量类型来自于同一基础类型":["69.4"],"这样的前提":["69.4"],"只需要这个类型存在于联合类型中":["69.4"],"对于原始类型":["69.4"],"联合类型的比较其实也是一致的":["69.4"],"result10":["69.4"],"这里看着像是混进来一个很奇怪的东西":["69.5"],"不是":["69.5"],"的字面量类型吗":["69.5"],"为什么能在这里比较":["69.5"],"并且":["69.5"],"还是它的子类型":["69.5"],"这时请回忆我们在结构化类型系统中一节学习到的概念":["69.5"],"假设我们把":["69.5"],"看作一个普通的对象":["69.5"],"上面存在一些方法":["69.5"],"replace":["69.5"],"replaceall":["69.5","82.2","85.6"],"startswith":["69.5"],"endswith":["69.5"],"includes":["69.5","86.8"],"这个时候":["69.5"],"是不是能看做":["69.5"],"继承了":["69.5"],"这个空对象":["69.5"],"result24":["69.6"],"result25":["69.6"],"你会发现":["69.6"],"竟然调过来":["69.6"],"值竟然变成了":["69.6"],"我们再多试几个看看":["69.6"],"result26":["69.6"],"result34":["69.7"],"其返回的结果为":["69.8"],"result39":["69.9"],"实际上":["69.9","73.2","78.9"],"对于联合类型地类型层级比较":["69.9"],"我们只需要比较":["69.9"],"一个联合类型是否可被视为另一个联合类型的子集":["69.9"],"这个联合类型中所有成员在另一个联合类型中都能找到":["69.9"],"数组和元组":["69.9"],"数组和元组是一个比较特殊的部分":["69.9"],"我们直接来看例子":["69.9"],"而在构造过程中":["69.10"],"除了父子类型":["69.10"],"那我们直接开始这一节的学习吧":["70.0"],"res3":["70.1"],"而在函数中":["70.1"],"条件类型与泛型的搭配同样很常见":["70.1"],"考考你":["70.1"],"以下这个函数":["70.1"],"我们应该如何标注它的返回值类型":["70.1"],"没有发生替换":["70.2"],"仍是":["70.2"],"由于我们声明的结构是一个仅有两个元素的元组":["70.2"],"因此三个元素的元组就被认为是不符合类型结构了":["70.2"],"但我们可以使用":["70.2"],"rest":["70.2","85.24"],"操作符来处理任意长度的情况":["70.2"],"提取首尾两个":["70.2"],"extractstartandend":["70.2"],"start":["70.2","101.27"],"end":["70.2","101.27"],"调换首尾两个":["70.2"],"swapstartandend":["70.2"],"left":["70.2","107.50"],"调换开头两个":["70.2"],"swapfirsttwo":["70.2"],"start1":["70.2"],"start2":["70.2"],"你的类型参数需要是一个联合类型":["70.3"],"类型参数需要通过泛型参数的方式传入":["70.3"],"而不能直接在外部进行判断":["70.3"],"最后":["70.3"],"条件类型中的泛型参数不能被包裹":["70.3"],"而条件类型分布式特性会产生的效果也很明显了":["70.3"],"即将这个联合类型拆开来":["70.3"],"每个分支分别进行一次条件类型判断":["70.3"],"再将最后的结果合并起来":["70.3"],"如果再严谨一些":["70.3"],"其实我们就得到了官方的解释":["70.3"],"对于属于裸类型参数的检查类型":["70.3"],"条件类型会在实例化时期自动分发到联合类型上":["70.3"],"types":["70.3","79.3","81.8","86.25"],"which":["70.3"],"the":["70.3"],"checked":["70.3"],"parameter":["70.3"],"are":["70.3"],"called":["70.3"],"automatically":["70.3"],"distributed":["70.3"],"over":["70.3"],"during":["70.3"],"instantiation":["70.3"],"这里的自动分发":["70.3"],"我们可以这么理解":["70.3"],"所代表的类型兼容性":["70.4"],"由于在上一节我们已经了解了整个":["70.4"],"类型系统的类型层级":["70.4"],"这样的字面量类型":["70.5"],"只有传入其本身":["70.5"],"对应的原始类型":["70.5"],"包含其本身的联合类型":["70.5"],"才能得到一个有意义的值":["70.5"],"并且这个值一定只可能是它本身":["70.5"],"tmp1":["70.5"],"tmp2":["70.5","75.7"],"tmp3":["70.5"],"这是因为交叉类型":["70.5"],"就像短板效应一样":["70.5"],"很多同学觉得难":["71.0"],"是因为还没完全熟悉所有类型工具":["71.0"],"对类型系统还懵懵懂懂的情况下":["71.0"],"就直接一头扎进各种复杂的类型编程源码中去":["71.0"],"其实只要我们熟悉了类型工具的使用":["71.0"],"将联合类型结构转换到交叉类型结构":["71.1"],"结构工具类型":["71.1"],"对集合":["71.1"],"即联合类型":["71.1"],"的处理":["71.1"],"即交集":["71.1"],"可以认为是一对工具类型":["71.2"],"它们的功能是相反的":["71.2"],"而在实现上":["71.2"],"它们的唯一差异是在索引类型签名处的可选修饰符":["71.2"],"即标记属性为可选":["71.2"],"则是":["71.2"],"相当于在原本属性上如果有":["71.2"],"这个标记":["71.2"],"则移除它":["71.2"],"如果你觉得不好记":["71.2"],"其实":["71.2","121.6"],"也可以使用":["71.2"],"来显式的表示添加可选标记":["71.2"],"比如以下这些情况":["71.3"],"现在的属性修饰是浅层的":["71.3"],"如果我想将":["71.3"],"嵌套在里面的对象类型":["71.3"],"通常我们使用这两者来代替":["71.4"],"在一些工具类库源码中其实还存在类似的结构声明工具类型":["71.4"],"dictionary":["71.4"],"index":["71.4","85.26","85.28","95.4","114.14","114.15"],"numericdictionary":["71.4"],"字典":["71.4"],"结构只需要一个作为属性类型的泛型参数即可":["71.4"],"而对于结构处理工具类型":["71.4"],"中主要是":["71.4"],"pick":["71.4","75.3","91.11"],"omit":["71.4"],"两位选手":["71.4"],"绑定":["71.5"],"存在时":["71.5"],"也必须存在":["71.5"],"不存在时":["71.5"],"也不允许存在":["71.5"],"此时应该如何实现":["71.5"],"另外":["71.5","75.1"],"你可能发现":["71.5"],"会约束第二个参数的联合类型来自于对象属性":["71.5"],"t1":["71.6"],"t2":["71.6","80.29"],"的计算":["71.6"],"然后将最终的结果再合并成联合类型":["71.6"],"比如对于交集":["71.6"],"其运行逻辑是这样的":["71.6"],"aextractb":["71.6"],"在处理对象类型结构运算时":["71.7"],"r":["71.8","75.4","107.87"],"根据":["71.8"],"的位置不同":["71.8"],"我们就能够获取到不同位置的类型":["71.8"],"在函数这里则是参数类型与返回值类型":["71.8"],"我们还可以更进一步":["71.8"],"比如只匹配第一个参数类型":["71.8"],"firstparameter":["71.8"],"比如在哪些场景":["71.9"],"比如随着条件类型的嵌套每个分支会提取不同位置的":["71.9"],"使用的类型操作":["71.10"],"使用场景":["71.10"],"到对它们进行扩展的可能方向":["71.10"],"这些类型推导其实有一个共同点":["72.0"],"它们的推导依赖开发者的输入":["72.0"],"比如变量声明":["72.0"],"函数逻辑":["72.0"],"类型保护都需要开发者的输入":["72.0"],"struct":["72.1"],"当然":["72.1","76.1","77.2"],"不仅是箭头函数":["72.1"],"函数表达式也是一样的效果":["72.1"],"这里就不做展开了":["72.1"],"参数的类型基于其上下文类型中的参数类型位置来进行匹配":["72.1"],"对应到":["72.1","79.19"],"所以是":["72.1"],"你会发现这个时候":["72.2"],"我们的函数实现返回值类型变成了五花八门的样子":["72.2"],"而且还都不会报错":["72.2"],"这也是一条世界底层的规则":["72.2"],"上下文类型对于":["72.2"],"返回值类型的函数":["72.2"],"并不会真的要求它啥都不能返回":["72.2"],"虽然这些函数实现可以返回任意类型的值":["72.2"],"但":["72.2","79.3","86.35","121.8"],"对于调用结果的类型":["72.2"],"仍然是":["72.2"],"以及上下文类型中":["72.3"],"类型返回值的特殊情况":["72.3"],"的函数中":["72.5"],"我们会消费":["72.5"],"的每一个成员":["72.5"],"但我们有时也会遇到并不实际消费数组成员的情况":["72.5"],"内置类型等的层级关系":["73.0"],"但是":["73.0"],"如果你使用过":["73.0"],"很容易就会想到":["73.0"],"我们好像漏了一点什么":["73.0"],"函数类型有类型层级吗":["73.0"],"如果有":["73.0"],"直接比较完整的函数类型并不符合我们的思维直觉":["73.1"],"因此我们需要引入一个辅助函数":["73.1"],"它接收一个":["73.1"],"类型的参数":["73.1"],"transformdogandbark":["73.1"],"在我需要条件满足是动物时":["73.2"],"狗狗都是可用的":["73.2"],"即不考虑返回值类型的情况":["73.2"],"在包装为函数签名的参数类型后":["73.2"],"其子类型层级关系发生了逆转":["73.2"],"这就是":["73.2"],"协变":["73.2"],"covariance":["73.2"],"func1":["73.3"],"func2":["73.3"],"还记得吗":["73.3"],"如果赋值成立":["73.3"],"说明":["73.3","97.10"],"的类型是":["73.3"],"这两个赋值实际上等价于":["73.3"],"t":["73.3","76.3","76.8","79.9","80.9","80.26","84.3","89.2","101.28"],"结合上面所学":["73.3"],"我们很明显能够发现第二种应当是不成立的":["73.3"],"参数类型是否遵循类型逆变":["73.4"],"返回值类型是否遵循类型协变":["73.4"],"我们可以通过":["73.4","78.5"],"eslint":["73.4","78.1"],"的规则以及":["73.4"],"strictfunctiontypes":["73.4"],"配置":["73.4","85.0","85.24","85.31"],"对于隐式的父子类型其可以仍然沿用显式的父子类型协变与逆变判断":["73.6"],"但对于兄弟类型":["73.6"],"对于这一类型的比较":["73.7"],"我们可以直接用实际场景来代入":["73.7"],"假设我需要一笼动物":["73.7"],"但并不会对它们进行除了读以外的操作":["73.7"],"那么你给我一笼狗我也是没问题的":["73.7"],"但你不能给我一笼植物":["73.7"],"也就意味着":["73.7"],"此时":["73.7","75.1","75.7","84.1","85.6"],"list":["73.7","114.14","114.15"],"并且它们并不能让我的网页运行得更快":["74.0"],"让我的":["74.0"],"node":["74.0","78.0","86.39","87.2"],"服务并发更高":["74.0"],"让我的网页":["74.0"],"水平":["74.1"],"我看到过很多因为掌握了各种类型体操表演引以为豪的同学":["74.1"],"其中有相当一部分人在实际业务开发中":["74.1"],"仍然是各种":["74.1"],"与复制粘贴":["74.1"],"这就是非常严重的本末倒置":["74.1"],"你学习":["74.1"],"是为了帅气的体操还是为了更高质量的代码呢":["74.1"],"如果你掌握了所有的类型体操":["74.1"],"你就能写好所有的业务代码吗":["74.1"],"答案显然是否定的":["74.1"],"类型体操就像是五年高考三年模拟":["74.1"],"只要你愿意花时间":["74.1"],"对着答案总是能看明白的":["74.1"],"但你看完就能保证做出数学压轴题的最后一小问吗":["74.1"],"类型体操绝不应当被作为":["74.1"],"水平的度量衡":["74.1"],"在绝大多数情况下":["74.1"],"我们对于":["74.1"],"相关的技巧":["74.1"],"vite":["74.2","93.2","95.1"],"vitest":["74.2"],"nuxt":["74.2"],"等知名开源项目的团队成员或作者":["74.2"],"的作品":["74.2","81.10"],"需要说明的是":["75.0","87.0"],"本节中的工具类型会更加复杂和烧脑一些":["75.0"],"你需要确保已经完全掌握了这一节前的绝大部分知识再来学习本节内容":["75.0"],"如果在学习过程中发现有知识点的缺失":["75.0"],"deepreadonly":["75.1"],"deepmutable":["75.1"],"在内置工具类型一节的结构工具类型中":["75.1"],"存在一个从联合类型中剔除":["75.1"],"的工具类型":["75.1"],"nonnullable":["75.1"],"在对象结构中我们也常声明类型为":["75.1"],"的形式":["75.1"],"代表了":["75.1"],"这里有值":["75.1"],"但可能是空值":["75.1"],"我们也可以将其等价为一种属性修饰":["75.1"],"nullable":["75.1"],"前面则是":["75.1"],"optional":["75.1","80.24"],"我们也可以像访问性修饰工具类型那样":["75.1"],"实现一个":["75.1"],"deepnonnullable":["75.1"],"这里我们使用":["75.2"],"移除了所有可选标记":["75.2"],"既然我们现在可以拿到对应类型的属性名":["75.2"],"那么把这些属性交给":["75.2"],"不就可以得到由这些属性组成的子结构了":["75.2"],"omitbyvaluetype":["75.2"],"也是类似的":["75.2"],"我们只需要一个和":["75.2"],"作用相反的工具类型即可":["75.2"],"比如来个":["75.2"],"filteredpropkeys":["75.2"],"只需要调换条件类型语句结果的两端即可":["75.2"],"如果你想把":["75.2"],"合并在一起":["75.2"],"其实也很简单":["75.2"],"只是需要引入第三个泛型参数来控制返回结果":["75.2"],"属性名差集":["75.3"],"objectkeysdifference":["75.3"],"属性名补集":["75.3"],"objectkeyscomplement":["75.3"],"对于交集":["75.3"],"我们可以直接使用属性名的集合来实现对象层面的版本":["75.3"],"objectintersection":["75.3"],"q":["75.4"],"funcfoo":["75.4"],"funcbar":["75.4"],"这些思路不仅仅会用在这一节的工具类型实现里":["75.5"],"当你以后面对更复杂的场景需要从头写一个工具类型时":["75.5"],"也完全可以使用":["75.5"],"不会再无从下手了":["75.5"],"至此":["75.5"],"我们就完成了对":["75.5"],"基本类型能力的学习":["75.5"],"n":["75.7"],"在类型层级一节中我们已经了解":["75.7"],"这两个函数结构实际上起辅助作用":["75.8"],"内部的条件类型并不会真的进行运算":["75.8"],"我们实际上是借助这一辅助结构判断类型":["75.8"],"的全等性":["75.8"],"这一全等性就包括了":["75.8"],"修饰符与可选性等":["75.8"],"我们基于其实现":["75.8"],"的一个特殊存在":["76.0"],"模板字符串类型":["76.0"],"此前我们已经学习了泛型相关的概念":["76.0"],"greet6":["76.1"],"0x1fffffffffffff":["76.1"],"9007199254740991":["76.1"],"目前有效的类型只有":["76.1"],"这几个":["76.1"],"正如上面的例子所示":["76.1"],"这些类型在最终的字符串结果中都会被转换为字符串字面量类型":["76.1"],"即使是":["76.1"],"你也可以直接为插槽传入一个类型而非类型别名":["76.1"],"类型并不会变成":["76.1"],"而是保持原样":["76.1"],"v2":["76.2"],"我们现在能够放心地将这部分类型约束也交给模板字符串类型了":["76.3"],"而除了索引类型":["76.3"],"模板字符串类型也和映射类型有着奇妙的化学反应":["76.3"],"为了与映射类型实现更好的协作":["76.3"],"在引入模板字符串类型时支持了一个叫做":["76.3"],"重映射":["76.3"],"remapping":["76.3"],"的新语法":["76.3"],"基于模板字符串类型与重映射":["76.3"],"我们可以实现一个此前无法想象的新功能":["76.3"],"在映射键名时基于原键名做修改":["76.3"],"我们可以使用映射类型很容易复制一个接口":["76.3"],"copy":["76.3"],"此时我们就可以使用上":["76.4"],"工具类型了":["76.4"],"copywithrename":["76.4"],"k":["76.4"],"keyof":["76.4","80.9"],"modifiedname":["76.4"],"modifiedage":["76.4"],"这样的形式":["76.5"],"这里的空格也需要严格遵循":["76.5"],"它也是一个字面量类型的一部分":["76.5"],"对于符合这样约束的类型":["76.5"],"我们使用":["76.5"],"模板插槽":["76.5"],"提取了其空格旁的两个部分":["76.5"],"即名与姓":["76.5"],"然后在条件类型中":["76.5"],"我们将":["76.5"],"提取出来的值":["76.5"],"如映射类型与索引类型":["76.6"],"有着奇妙的组合效果":["76.6"],"而基于模板字符串类型与模式匹配":["76.6"],"我们还可以进行非常多有趣的操作":["76.6"],"在下一节我们就会来介绍一些基于模板字符串的工具类型":["76.6"],"包括类型层面的":["76.6"],"first":["77.0"],"last":["77.0"],"capitalize":["77.0"],"我们发现对于空字符串":["77.1"],"需要进行特殊的处理":["77.1"],"也应当是成立的":["77.1"],"就像实际字符串中进行判断一样":["77.1"],"我们希望尽可能贴近原本字符串方法的表现":["77.1"],"因此我们需要新增额外处理":["77.1"],"除了":["77.2","85.33","96.3"],"在字符串类型值中还有一个常用的方法":["77.2"],"它会将字符串按照确定的分隔符拆分成一个数组":["77.2"],"lin":["77.2","83.4"],"bu":["77.2","83.4"],"du":["77.2","83.4"],"按照":["77.2"],"拆分为":["77.2"],"在类型层面":["77.2"],"我们也可以实现":["77.2"],"毕竟":["77.2"],"分隔符":["77.2"],"这个词就在强烈暗示你":["77.2"],"它":["77.2"],"一定是符合某种结构的字面量类型":["77.2"],"比如最简单的":["77.2"],"假设我们所有的字符串都是":["77.2"],"c":["77.2","101.14"],"这个结构":["77.2"],"那就可以这么拆分":["77.2"],"body":["77.2","97.12","100.4","111.2"],"splitres1":["77.2"],"真实情况肯定不会这么简单":["77.2"],"来验证一下效果":["77.3"],"到这里":["77.3","77.4"],"我们支持了一个能够通过传入分隔符解决任意":["77.3"],"转":["77.3"],"看起来可以功成身退了":["77.3"],"但这里还存在非常大的优化空间":["77.3"],"比如我们还能让它自动处理分隔符":["77.3"],"通常的变量命名只会使用":["77.3"],"作为分隔符":["77.3"],"加上字面量中可能存在的空格":["77.3"],"也就是我们希望自动处理":["77.3"],"这三个分隔符":["77.3"],"你可能会想当然地写出这样的代码":["77.3"],"worddelimiter":["77.3"],"delimitercase2camelcaseauto":["77.3"],"如果你真觉得这能够工作":["77.3"],"我的建议是再回到上一部分重新来过":["77.3"],"对于这种连续的":["77.3"],"插槽":["77.3"],"其匹配策略是尽可能为前面的每个插槽匹配一个字符":["77.3"],"但却带来了访问性修饰与结构处理等类型编程范式以外的新类型编程体系":["77.4"],"同时":["77.4"],"我们借着模板字符串类型的灵活性":["77.4"],"再次复习了模式匹配的应用场景":["77.4"],"让你对它的应用有了更深刻的了解":["77.4"],"我们的类型能力核心篇章就告一段落了":["77.4"],"解析以及":["78.0"],"开发这五个部分":["78.0"],"在这一节":["78.0"],"使用特殊的配置来覆盖掉全局配置":["78.1"],"最常见的即是":["78.1"],"随后又引入了一个更严格版本的":["78.2"],"它只有在":["78.2"],"下一行代码真的存在错误时":["78.2"],"才能被使用":["78.2"],"否则它会给出一个错误":["78.2"],"文件它也可以通过类型推导与":["78.3"],"jsdoc":["78.3","89.2"],"的方式进行不完全的类型检查":["78.3"],"myage":["78.3"],"标注变量类型":["78.3"],"myname":["78.3"],"在上面的代码中":["78.3"],"声明了初始值的":["78.3"],"result":["78.4","80.41","96.23"],"returntype":["78.4"],"typeof":["78.4","84.7","85.4","86.3","89.7","96.9","101.9"],"这些类型声明就像我们在":["78.4"],"中的类型标注一样":["78.4"],"会存放着特定的类型信息":["78.4"],"同时由于它们并不具有实际逻辑":["78.4"],"我们可以很方便地使用类型声明来进行类型兼容性的比较":["78.4"],"首先是无类型定义的":["78.5"],"module":["78.5","79.15","80.1","86.3","87.4"],"的方式来提供其类型":["78.5"],"import":["78.5","78.13","79.15","79.16","85.15","87.9","88.2","89.7","89.8","92.0","94.2","94.3","94.5","94.7","94.9","94.10","107.54","107.128"],"from":["78.5","79.16","82.13","87.2","87.9","88.2","89.8","94.2","94.5","94.7","94.9","94.10","107.54","107.128"],"pkg":["78.5","86.41"],"是一个没有类型定义的":["78.5"],"实际并不存在":["78.5"],"我们来看如何为它添加类型提示":["78.5"],"这种不是用纯":["78.6"],"书写的库":["78.6"],"需要自己来手写类型声明":["78.6"],"是用":["78.6"],"flow":["78.6","82.12"],"写的":["78.6"],"这是一门同样为":["78.6"],"添加类型的语言":["78.6"],"或者说语法":["78.6"],"举例来说":["78.6","85.24"],"只要你安装了":["78.6"],"es2021":["78.7"],"这种文件定义了对":["78.7"],"每个版本的类型声明新增或改动等等":["78.7"],"我们要做的":["78.7"],"实际上就是在内置类型声明的基础之上":["78.7"],"再新增一部分属性":["78.7"],"而别忘了":["78.7"],"中当你访问全局变量时":["78.7"],"是可以直接忽略":["78.7"],"这三个不同属性":["78.8"],"我们来依次解析":["78.8"],"指令":["78.8","86.33","114.16"],"其":["78.8"],"属性的值为一个相对路径":["78.8"],"指向你项目内的其他声明文件":["78.8"],"而在编译时":["78.8"],"会沿着":["78.8"],"如果你开始学习前端的时间较早":["78.9"],"一定会觉得命名空间的编译产物很眼熟":["78.9"],"它就像是上古时期里使用的伪模块化方案":["78.9"],"命名空间的作用也正是实现简单的模块化功能":["78.9"],"中引入它时":["78.9"],"版本":["78.9"],"前端的模块化方案还处于混沌时期":["78.9"],"命名空间的内部还可以再嵌套命名空间":["78.9"],"比如在虚拟货币中再新增区块链货币一类":["78.9"],"这样会造成导入语句数量激增":["78.10"],"如果你想同时保持较少的导入语句数量又想区分值和类型导入":["78.10"],"也可以使用同一导入语句内的方式":["78.10"],"需要":["78.10"],"版本以后才支持":["78.10"],"以及为上古时期的":["78.11"],"npm":["78.11","81.6","87.2","87.3"],"包提供类型定义":["78.11"],"definitelytyped":["78.11"],"但类型指令却相反":["78.11"],"以拥有海量配置项的":["78.13"],"webpack":["78.13","81.12","85.31"],"configuration":["78.13"],"中使用":["79.0","87.3","88.2","89.11","110.3"],"并没有非常复杂的地方":["79.0"],"我们主要关注三个方面":["79.0"],"组件声明":["79.0"],"泛型坑位":["79.0"],"内置类型定义":["79.0"],"favicon":["79.1"],"svg":["79.1","95.1"],"logo":["79.1"],"main":["79.1","85.13","95.2"],"env":["79.1","85.10"],"d":["79.1","85.6"],"reference":["79.2"],"client":["79.2","93.11"],"三斜线指令的作用我们在前面一节了解过":["79.2"],"现在我们就看看":["79.2"],"中都包含了什么":["79.2"],"lib":["79.2"],"path":["79.2","89.4","89.6","89.7","89.8","93.3"],"importmeta":["79.2"],"css":["79.2","97.9","97.20","100.6"],"cssmoduleclasses":["79.2"],"仍然能把返回值类型推导出来":["79.3"],"以上函数的类型可以被正确地推导为":["79.3"],"jsx":["79.3","80.2"],"element":["79.3","107.80","107.87"],"但这样只能说明它是一个函数":["79.3"],"并不能从类型层面上标明它是一个":["79.3"],"也无法约束它必须返回一个合法的组件":["79.3"],"我们可以加上显式的类型标注来确保它返回一个有效组件":["79.3"],"是一个命名空间":["79.3"],"来自于":["79.3"],"idatastruct":["79.4"],"我们一个个来看":["79.5"],"的类型实际上会是":["79.6"],"这是因为在":["79.6"],"声明中对是否提供初始值的两种情况做了区分重载":["79.6"],"提供了默认值":["79.6"],"handler1":["79.7"],"case":["79.8"],"也不需要做到如此智能":["79.9"],"的类型定义可以看出":["79.9"],"对于初始值为":["79.9"],"其类型均会被推导为":["79.9"],"initialvalue":["79.9"],"htmlinputelement":["79.10"],"handleclick":["79.10"],"htmlbuttonelement":["79.10"],"onchange":["79.10","107.107"],"button":["79.10","107.77","107.99","111.6","112.5","116.1","116.2"],"onclick":["79.10","107.77","107.100"],"这里我们也做简单地介绍":["79.11"],"除了对原生":["79.12"],"元素使用以外":["79.12"],"这一用法在使用组件库时也有奇效":["79.12"],"比如组件库只导出了这个组件而没有导出这个组件的属性类型定义":["79.12"],"而我们又需要基于这个组件进行定制封装":["79.12"],"此时就可以使用":["79.12"],"去提取它的属性类型":["79.12"],"context":["79.13"],"项目中使用":["79.14"],"与业务逻辑对应的类型定义":["79.15"],"user":["79.15","87.9","100.5"],"推荐的方式是在中大型项目中尽可能按照业务模型来进行细粒度的拆分":["79.15"],"请求相关的类型定义":["79.15"],"推荐的方式是定义响应结构体":["79.15"],"然后使用":["79.15"],"中的业务逻辑类型定义进行填充":["79.15"],"childa":["79.16"],"childb":["79.16"],"包括了项目的基础配置":["79.17"],"组件声明方式及其优劣":["79.17"],"hooks":["79.17"],"这一属性的":["79.19"],"中则是插槽":["79.19"],"的概念":["79.19","86.35"],"但并不是所有时候我们的组件都会包含一个":["79.19"],"containerwithoutchildren":["79.19"],"containerwithchildren":["79.19"],"如果你为":["79.19"],"也传入了":["79.19"],"虽然不会报错":["79.19"],"但这个":["79.19"],"实际上并不会渲染出来":["79.19"],"如果想让代码尽可能精准":["79.19"],"实际上我们应该区分这两种情况":["79.19"],"的作用其实可以划分为两个部分":["80.0"],"风格统一":["80.0"],"代码优化":["80.0"],"风格统一不必多说":["80.0"],"单双引号":["80.0"],"缩进":["80.0"],"逗号等编码风格的统一十分有必要":["80.0"],"看到一会单引号一会双引号的代码":["80.0"],"然后更改你的":["80.1"],"exports":["80.1","80.12","86.3","87.4"],"root":["80.1","86.41"],"plugins":["80.1"],"其他已有的配置":["80.1"],"recommended":["80.1"],"由于部分":["80.1"],"的规则和":["80.1"],"每一行结尾需要有分号":["80.2"],"semi":["80.2"],"使用单引号":["80.2"],"singlequote":["80.2"],"在对象属性中":["80.2"],"仅在必要时才使用引号":["80.2"],"quoteprops":["80.2"],"needed":["80.2"],"中使用双引号":["80.2"],"jsxsinglequote":["80.2"],"风格的尾缀逗号":["80.2"],"即数组和对象的最后一项成员后也需要逗号":["80.2"],"trailingcomma":["80.2"],"大括号内首尾需要空格":["80.2"],"bracketspacing":["80.2"],"标签":["80.2"],"以及":["80.2","84.3","85.12"],"模板等":["80.2"],"的反尖括号":["80.2"],"需要换行":["80.2"],"bracketsameline":["80.2"],"箭头函数仅有一个参数时也需要括号":["80.2"],"arg":["80.2","80.29"],"crlf":["80.2"],"作为换行符":["80.2"],"endofline":["80.2"],"关于更多配置":["80.2"],"参见":["80.2"],"同时为了避免和":["80.2"],"冲突":["80.2"],"我们还需要通过":["80.2"],"禁用掉部分":["80.2"],"规则":["80.2","80.12"],"修改":["80.2"],"plugin":["80.2","81.12","93.2","95.1"],"react":["80.2","85.12","91.0","93.11"],"dev":["80.3","85.5","85.10","87.3"],"yarn":["80.3"],"add":["80.3"],"pnpm":["80.3"],"然后在":["80.3"],"包括仅使用":["80.6"],"调用":["80.7","89.7"],"ifoo":["80.9"],"partial":["80.9"],"literalbool":["80.9"],"这是因为":["80.11","86.35"],"逻辑或":["80.11"],"会将":["80.11"],"中使用不同的空间来存放":["80.12"],"因此无须担心循环依赖":["80.12"],"所以你可以":["80.12"],"父组件导入子组件":["80.12"],"子组件导入定义在父组件中的类型":["80.12"],"类似的":["80.12"],"我们也可以通过":["80.12"],"类型断言为":["80.13"],"将其替换为非空断言":["80.13"],"outer":["80.15"],"不允许与默认值一致的泛型参数":["80.18"],"expect":["80.20"],"这里的类型太复杂":["80.20"],"日后补上":["80.20"],"而不是":["80.21"],"ignore":["80.21"],"在类型声明与类型指令一节我们已经了解到":["80.21"],"x":["80.22","80.32","82.10","82.13"],"不允许非空断言与空值合并同时使用":["80.23"],"chain":["80.24"],"不允许与实际值一致的类型断言":["80.25"],"fooany":["80.26"],"所以用了":["80.31"],"你大概率在下面还需要类型断言回去或者变":["80.31"],"同时别忘了":["80.31"],"专门引入了":["80.33"],"类型来尝试堵上一些口子":["80.33"],"然而即使这样":["80.33"],"通过显式指定返回值类型":["80.35"],"somecondition":["80.37"],"err":["80.38"],"只能抛出":["80.38"],"或基于":["80.38"],"break":["80.39"],"非字符串与数字以外的值很容易带来潜在的问题":["80.40"],"类型的值赋值给":["80.41"],"prev":["80.41","96.19","96.23"],"正如我们上一节所了解的那样":["80.42"],"不推荐使用":["80.42"],"以及为了实现更好约束引入的":["80.43"],"prettier":["80.43"],"git":["80.43"],"我们还会接触许多与":["81.0"],"相关的工具":["81.0"],"如果按照作用场景来进行划分":["81.0"],"这些工具大致可以划分为开发":["81.0"],"基于":["81.2"],"然后在成功时执行编译产物":["81.4"],"而非":["81.6"],"因此速度上会明显更快":["81.6"],"typed":["81.6"],"install":["81.6"],"我们知道有些":["81.6"],"包的类型定义是单独的":["81.6"],"org":["81.7"],"draft":["81.7"],"07":["81.7"],"properties":["81.7"],"description":["81.7"],"同时也是个人认为最接地气的一个工具类型库":["81.8"],"utility":["81.8"],"包含的类型较少":["81.8"],"但这个库是我类型编程的启蒙课":["81.8"],"我们此前对":["81.8"],"tsd":["81.9"],"json":["81.10","85.13","85.16","86.38","86.41","87.7","88.3","94.4"],"to":["81.10","83.9"],"nest":["81.10","87.7"],"dto":["81.10"],"validator":["81.10"],"typestack":["81.10"],"基于装饰器来进行校验":["81.10"],"我们会在后面的装饰器一节了解如何基于装饰器进行校验":["81.10"],"post":["81.10"],"contains":["81.10"],"可以使用这个工具来检查类型的覆盖程度":["81.11"],"从我个人使用经验来看":["81.11"],"大概":["81.11"],"的目的是替代":["81.12"],"babel":["81.12","83.13"],"因此它是可以直接支持装饰器等特性的":["81.12"],"fork":["81.12"],"checker":["81.12"],"如果你还使用过其它让你赞不绝口的工具库":["81.13"],"欢迎在评论区或答疑群提交给我":["81.13"],"下一节":["81.13"],"tc39":["82.0"],"等等概念到底是个啥":["82.0"],"然后":["82.0"],"committee":["82.1"],"也称为技术委员会":["82.1"],"的方式来管理这个规范":["82.1"],"对应的技术小组即是":["82.1"],"目前":["82.1"],"委员会的绝大部分成员来自于浏览器引擎厂商":["82.1"],"互联网巨头公司等等":["82.1"],"并且定期召开会议来讨论各个提案的进展":["82.1"],"提案又是什么":["82.1"],"中的新语法并不是委员会成员坐下来开个简单的会就决定引入到":["82.1"],"一个新语法必须先从草稿":["82.1"],"也就是从提案开始":["82.1"],"你可以把新语法想象成一条新法律":["82.1"],"得要有人首先提出这条法律能解决目前的某一问题":["82.1"],"然后法律专家":["82.1"],"法院":["82.1"],"国家都要通过":["82.1"],"它才能最终被写到法律条文中":["82.1"],"一个提案被纳入规范要经历":["82.1"],"个阶段":["82.1"],"stage":["82.1"],"strawman":["82.1"],"任何":["82.1"],"logical":["82.2"],"assignment":["82.2"],"这一类语法":["82.2"],"装饰器":["82.2"],"我们会用两节专门来讲解":["82.2"],"一些新增的方法":["82.2"],"innerproperty":["82.3"],"这种写法虽然丑陋":["82.3"],"但它确实能在一定程度上避免对空值的读取":["82.3"],"但也只是一定程度上":["82.3"],"为什么这么说":["82.3"],"上面的代码看起来很安全":["82.3"],"但在某一步访问出现空值时":["82.3"],"它返回的是上一步的值":["82.3"],"执行右边的逻辑":["82.4"],"在这里即是赋值行为":["82.4"],"看起来一切好像都很美好":["82.4"],"但别忘了":["82.4"],"由于":["82.4"],"中无处不在的隐式转换":["82.4"],"如果":["82.4","91.0"],"复合赋值其实就是先执行操作":["82.5"],"再将操作结果赋值给左边的变量":["82.5"],"就是执行":["82.5"],"然后将结果赋值给":["82.5"],"而逻辑赋值也是一样":["82.5"],"等概念之间的联系与实际意义":["82.6"],"认识了三位对你来说或许是首次见面的新朋友":["82.6"],"可选链":["82.6"],"新的内置方法":["82.8"],"新的":["82.8"],"api等":["82.8"],"在了解完本篇的核心内容以后":["82.8"],"我们不妨来瞅几个有意思的提案":["82.8"],"proposal":["82.9"],"contents":["82.9"],"tmp":["82.10"],"f":["82.10","86.5"],"相关的概念":["82.11"],"简单了解即可":["82.11"],"原因则是如果你没有实战场景":["82.11"],"那么基本上对于":["82.11"],"的海量":["82.11"],"其中":["82.12","85.8","107.93","107.124"],"表示上一个操作单元返回的值":["82.12"],"类似于":["82.12"],"pipe":["82.12"],"提案引入了两个":["82.12"],"中并没有被大量使用":["83.0"],"一方面是因为":["83.0"],"装饰器其实还不能被称为":["83.0"],"的一部分":["83.0"],"另一方面则是它对应用场景有着一定要求":["83.0"],"比如只能使用在":["83.0"],"上":["83.0"],"方法装饰器":["83.1"],"访问符装饰器":["83.1"],"newinstanceproperty":["83.2"],"newstaticproperty":["83.2"],"我们通过":["83.2"],"内置的":["83.2"],"类型定义来进行类型标注":["83.2"],"由于类装饰器只有一个参数":["83.2"],"我们也不想使用过多的类型代码":["83.2"],"这里我就直接":["83.2"],"了":["83.2"],"我们的函数返回了一个":["83.2"],"因此这个装饰器就是一个":["83.2"],"decorator":["83.2"],"resolve":["83.3","89.8"],"reject":["83.3"],"settimeout":["83.3"],"methoddecorator":["83.3","83.8"],"与setter":["83.4"],"hijacksetter":["83.4"],"modifynickname":["83.5"],"nickname":["83.5"],"checkparam":["83.6"],"prototype":["83.7","96.2","96.9","101.16","101.18","101.41"],"完整的代码见":["83.7"],"其实就是通过实际入参来判断当前到底执行的是哪种装饰器":["83.7"],"然后执行对应的装饰逻辑":["83.7"],"而观察这个方法调用时的入参":["83.7"],"我们会再次观察到这些装饰器的不同入参":["83.7"],"方法与属性装饰器是类的原型对象":["83.7"],"的顺序":["83.8"],"从这个角度来看":["83.8"],"甚至有点像洋葱模型":["83.8"],"on":["83.9","112.1","112.2"],"将修改这个对象的":["83.9"],"但我们可以通过":["83.9"],"方法获得原本的默认实现":["83.9"],"不会被修改":["83.9"],"先执行完默认实现逻辑再添加自己的额外逻辑":["83.9"],"上的这些方法会一一对应到":["83.9"],"装饰器会基于应用的位置进行实际的逻辑调用":["83.10"],"如在类上装饰时以类作为":["83.10"],"进行注册":["83.10"],"而在静态成员与实例成员中分别使用构造函数":["83.10"],"构造函数原型":["83.10"],"看起来我们现在拥有了实现委托的基本能力":["83.10"],"但实际上这还不够":["83.10"],"所有的元数据都需要我们提前定义好":["83.10"],"如果我们希望直接用一些已有的信息作为元数据呢":["83.10"],"比如下面这个例子":["83.10"],"userservice":["83.10"],"injectmodel":["83.10"],"usermodel":["83.10"],"我希望将":["83.10"],"属性的类型":["83.10"],"作为一个元数据信息注入":["83.10"],"同时我不会为":["83.10"],"装饰器提供任何信息":["83.10"],"那我们就束手无策了吗":["83.10"],"还记得我们在介绍反射概念时说的":["83.10"],"反射允许程序去检视自身":["83.10"],"而属性类型作为程序的一部分":["83.10"],"也应当是能被反射收集的":["83.10"],"为了实现这一目的":["83.10"],"反射元数据提案中还内置了基于类型的元数据":["83.10"],"你可以通过":["83.10"],"中的五种装饰器":["83.11"],"就胎死腹中":["83.13"],"中的装饰器则是基于第一版的提案实现的":["83.13"],"虽然语法都还是":["83.13"],"但这两个版本的装饰器实际上差异非常之大":["83.13"],"如果你有兴趣了解新版装饰器的具体语义":["83.13"],"可以阅读我此前发表的":["83.13"],"方法是否存在":["83.14"],"这一方法其实也来自于":["83.14"],"metadata":["83.14"],"依赖注入":["84.0","113.20"],"container":["84.1","97.12"],"我们的实例":["84.1"],"已经完成了对":["84.1"],"的依赖填充":["84.1"],"也完成了":["84.1"],"也就是说所有复杂的依赖关系都被处理完毕了":["84.1"],"这一模式就叫做":["84.1"],"控制反转":["84.1"],"我们此前手动维护关系的模式则成为":["84.1"],"控制正转":["84.1"],"举个例子":["84.1"],"当我们想要处对象时":["84.1"],"会上":["84.1"],"soul":["84.1"],"其实就是注册了":["84.2"],"这样的两对元数据":["84.2"],"分别标识了请求方法与请求路径":["84.2"],"需要注意的是":["84.2"],"我们是在方法体上去注册的":["84.2"],"这样在最终处理时":["84.2"],"可以":["84.2"],"通过这个类的原型拿到方法体":["84.2"],"继而获得注册的元数据":["84.2"],"controller":["84.2","87.2","88.2"],"中就简单一些了":["84.2"],"我们只需要拿到它的请求路径信息":["84.2"],"然后拼接在这个类中所有请求方法的请求路径前即可":["84.2"],"classdecorator":["84.2"],"在最后信息组装时":["84.2"],"我们需要做这么几步":["84.2"],"获取根路径":["84.2"],"装饰器的入参":["84.2"],"获取这个类实例的原型对象":["84.2"],"在原型对象上基于方法名获得方法体":["84.2"],"继而拿到定义的请求路径":["84.2"],"请求实现":["84.2"],"来看实际代码":["84.2"],"asyncfunc":["84.2"],"这样的话就就简单多了":["84.3"],"我们只需要基于字符串来存储":["84.3"],"查找":["84.3"],"注入一个类就好了":["84.3"],"首先我们创建一个容器":["84.3"],"很明显":["84.3"],"它需要一个":["84.3"],"来以字符串":["84.3"],"类的方式存储这些信息":["84.3"],"set":["84.3"],"classstruct":["84.3"],"services":["84.3"],"这里的元数据是一个完整的类":["84.4"],"driver":["84.4"],"对应的":["84.4"],"为了支持使用":["84.4"],"作为标识符进行查找":["84.4"],"装饰器中我们需要确保也使用":["84.4"],"作为标识符来存储一份":["84.4"],"不论是否传入":["84.4"],"都使用":["84.4"],"作为":["84.4"],"注册一份":["84.4"],"以及简单的":["84.5"],"ioc":["84.5","87.4"],"路由与":["84.5"],"onlybar":["84.7"],"来实际使用一下":["84.7"],"装饰器函数返回类型":["84.7"],"不可分配到类型":["84.7"],"我们深入下层基础":["85.0"],"来了解":["85.0"],"工程中最基础的一部分":["85.0"],"tsconfig":["85.0","86.28","87.7"],"reflect":["85.4"],"jsxfilename":["85.5"],"runner":["85.5","107.13"],"work":["85.5"],"一个对常用语法支持较为全面的版本":["85.6"],"更改":["85.6"],"配置也会同时影响你的":["85.6"],"配置默认值":["85.6"],"而它决定了你是否能使用某些来自于更新版本的":["85.6"],"语法":["85.6","89.0"],"如果你直接在项目中使用":["85.6"],"dd":["85.6"],"如果你的":["85.6"],"配置中不包含":["85.6"],"如何解析别名路径等等":["85.7"],"在这里可以传入文件夹或者":["85.8"],"这样的":["85.8"],"glob":["85.8"],"pattern":["85.8"],"也可以传入完整的文件路径":["85.8"],"配置方式参考":["85.8"],"generated":["85.8"],"internal":["85.8"],"src":["85.9","85.28","87.2","101.1","121.7"],"core":["85.9","86.27"],"在这个结构下":["85.9"],"在这个例子中":["85.10"],"会被推断为":["85.10"],"prod":["85.10","88.3"],"中所有文件夹最近的公共父文件夹":["85.11"],"在这里即是":["85.11"],"你肯定会想":["85.11"],"还有什么用":["85.11"],"实际上它主要用于实现":["85.11"],"多个虚拟目录的合并解析":["85.11"],"还是以上面的例子为例":["85.11"],"假设我们的目录结构是现在这样的":["85.11"],"locales":["85.11"],"只有":["85.12"],"会被加载":["85.12"],"即使其他":["85.12"],"package":["85.13","87.7"],"且其中使用":["85.13"],"属性描述了这个文件夹的入口文件":["85.13"],"假设":["85.13"],"指向":["85.13","101.15","101.48"],"dist":["85.13","85.20"],"那这里会尝试寻找":["85.13"],"文件":["85.13","85.30","87.3","88.2","97.13"],"ios":["85.14"],"native":["85.14"],"此配置在解析文件时":["85.14"],"会首先尝试查找":["85.14"],"导入和三斜线指令的导入":["85.15"],"你可以通过禁用这一配置来阻止这个解析过程":["85.15"],"它的配置方式是这样的":["85.16"],"compileroptions":["85.16"],"baseurl":["85.16"],"内容的类型推导":["85.17"],"repo":["85.17"],"对其成员的引用会直接使用原本的值来替换":["85.21"],"开启时将不会写入":["85.22"],"但仍然会执行构建过程":["85.22"],"因此也就包括了类型检查":["85.22"],"umd":["85.23"],"system":["85.23"],"等模块标准":["85.23"],"会随着版本更新新增可用的":["85.23"],"选项":["85.23"],"这些辅助函数就将从":["85.24"],"中导出而不是在源码中定义":["85.24"],"能够有效地帮助减少构建产物体系":["85.24"],"es":["85.24"],"中引入的":["85.24"],"操作符":["85.24"],"在降低情况下会编译为这样的产物":["85.24"],"s":["85.25","86.8"],"降级":["85.25"],"strict":["85.25"],"时保留":["85.26"],"footype":["85.26"],"init":["85.26","87.3"],"默认情况下声明文件会和构建代码文件在一个位置":["85.28"],"直接映射回原本的":["85.29"],"文件了":["85.29"],"devtool":["85.31"],"控制是生成":["85.31"],"line":["85.32","106.1"],"feed":["85.32"],"windows":["85.32"],"dos":["85.32"],"系统下的换行符":["85.32"],"相当于":["85.32"],"这些配置通常通常不会频繁发生变化":["85.33"],"包括源码相关":["86.0"],"解析相关":["86.0"],"项目下限与上限差异巨大的主要原因":["86.1"],"检查全开与全关下的":["86.1"],"因此需要显式通过配置来允许这些有害语法":["86.2"],"factory":["86.3"],"尝试使用":["86.3"],"语句以及":["86.4"],"process":["86.4"],"exit":["86.4"],"后的代码":["86.4"],"l":["86.5"],"如果在一个代码块中使用":["86.5"],"效果和对象字面量非常相似":["86.5"],"手动标注与自动推导均无":["86.6"],"的部分":["86.6"],"fn":["86.8","101.17","113.25"],"否则是":["86.9"],"这样可以在类型层面确保在":["86.9"],"在真的需要覆盖基类方法时":["86.12"],"推荐的方式是使用":["86.12"],"override":["86.12"],"标明此方法覆盖了基类中的方法":["86.12"],"返回类型不包括":["86.13"],"handle":["86.13"],"color":["86.13","107.77"],"留了一席之地":["86.14"],"比如函数与":["86.14"],"的方法中":["86.14"],"实际上第一个参数是":["86.14"],"proptype1":["86.15"],"unknownprop":["86.15"],"proptype2":["86.15"],"是否允许存在":["86.16"],"theme":["86.18"],"中的体现":["86.19"],"会默认将这些规则全部启用":["86.20"],"包括":["86.20","96.3"],"函数的入参也应当是不变的":["86.21"],"这条配置会确保在使用":["86.21"],"方法时":["86.21"],"ns":["86.22"],"在某些可能产生":["86.23"],"类型的方法中":["86.23"],"如果关闭了":["86.23"],"检查":["86.23"],"就意味着很可能下面会遇到一个":["86.23"],"cannot":["86.23"],"prop4":["86.24"],"系列与":["86.25"],"下的声明文件":["86.25"],"在某些时候":["86.25"],"这些声明文件可能存在冲突":["86.25"],"这四个项目的引用关系是这样的":["86.27"],"这四个项目可以使用完全独立的":["86.27"],"references":["86.28","86.42"],"的被引用子项目":["86.28"],"因为这些构建器只能执行语法降级与打包":["86.30"],"由于这些构建器通常是独立地处理每个文件":["86.30"],"这也就意味着如果存在如类型导入":["86.30"],"namespace":["86.30"],"等特殊语法时":["86.30"],"它们无法像":["86.30"],"我们在类型指令一节学习过":["86.33"],"check":["86.33"],"可以看到":["86.35","89.6"],"默认导入的调用被转换为了":["86.35"],"而具名导入和命名空间则不变":["86.35"],"三种导入语句都被转换为了":["86.35"],"默认将":["86.35"],"也视为":["86.35"],"对于具名导入":["86.35"],"可以直接将":["86.35"],"等价":["86.35"],"但是由于":["86.35"],"中并没有这个":["86.35"],"默认导出":["86.35","107.55"],"只能将":["86.35"],"中的默认导出":["86.35"],"强行等价于":["86.35"],"如上面的编译结果中的":["86.35"],"就是一个属性名":["86.35"],"是一个概念":["86.35"],"下存在着类似":["86.35"],"命名空间导出":["86.35"],"出发生变更的文件":["86.37"],"同级的":["86.38"],"watchoptions":["86.38"],"来配置监听行为":["86.38"],"es2020":["86.38"],"moduleresolution":["86.38"],"resolution":["86.39"],"kind":["86.39"],"specified":["86.39"],"using":["86.39"],"nodejs":["86.39","88.5","107.3"],"loading":["86.39"],"modules":["86.39","93.3"],"folder":["86.39"],"file":["86.39"],"does":["86.39"],"下统一各个子项目的基础配置":["86.41"],"packages":["86.41"],"是如何解决的":["86.42"],"在工程部分":["86.42"],"这一工程领域的重磅特性":["86.42"],"以及如何通过":["86.42"],"isolatedmodules":["86.42"],"heroku":["87.0","88.0"],"作为部署平台与数据库提供商":["87.0"],"我们要开发的":["87.0"],"并不会十分完善":["87.0"],"bash":["87.1","87.2","87.3"],"适用于":["87.1"],"mac":["87.1"],"需要安装":["87.1"],"common":["87.2","88.2","88.4"],"cats":["87.2"],"catscontroller":["87.2"],"findall":["87.2"],"action":["87.2"],"returns":["87.2"],"all":["87.2"],"本质上":["87.2"],"也就是一个":["87.2"],"因此完全没必要在初次接触时就做深入了解":["87.2"],"等我们用到的时候再学":["87.2"],"才不会被劝退":["87.2"],"我们先新建好项目":["87.2"],"cli":["87.2","87.7"],"g":["87.2","87.3"],"application":["87.2"],"初始的目录结构是这样的":["87.2"],"app":["87.2"],"这篇文章还没有介绍":["87.3"],"content":["87.3"],"如在上面的例子中":["87.3"],"我们在":["87.3"],"自己定义的语法来进行描述":["87.3"],"可以在":["87.3"],"vs":["87.3"],"中安装扩展来获得语法高亮":["87.3"],"imaged37616c085b20456":["87.3"],"png":["87.3","95.2"],"而不论是用编程语言还是":["87.3"],"来描述数据库实体":["87.3"],"都需要有转换到":["87.3"],"的这一步":["87.3"],"在传统":["87.3"],"中这一步实时进行":["87.3"],"在你调用":["87.3"],"find":["87.3","87.8"],"时动态地进行转换":["87.3"],"而在":["87.3"],"这一步则要特殊一些":["87.3"],"我们在实践中熟悉":["87.3"],"首先在项目内初始化":["87.3"],"npx":["87.3"],"它会为你创建":["87.3"],"我们还需要安装对应的依赖":["87.3"],"save":["87.3","87.8"],"我们这里的":["87.4"],"也是":["87.4"],"但是如果某一处代码需要使用它":["87.4"],"容器在交给它这个类时就会进行实例化过程":["87.4"],"然后新建":["87.4"],"global":["87.4"],"providers":["87.4"],"default":["87.4","111.13"],"prismamodule":["87.4"],"通过这种方式":["87.4"],"中集成":["87.5"],"的方法":["87.5"],"相比于其它同类型框架":["87.5"],"它们都有着决定性的优势":["87.5"],"所有的":["87.7"],"文件都在":["87.7"],"isactive":["87.8"],"不渡":["87.8"],"await":["87.8"],"newusers":["87.8"],"typeorm中":["87.8"],"模式为例":["87.9"],"getconnection":["87.9"],"好了":["88.1"],"基本信息介绍完了":["88.1"],"接下来我们正式开始体验吧":["88.1"],"最开始当然是注册环节":["88.1"],"主页":["88.1"],"按照要求填写信息":["88.1"],"img":["88.1","89.5","89.6","107.2","107.67","107.80","121.7"],"在登录时":["88.1"],"如果提示需要":["88.1"],"multi":["88.1"],"factor":["88.1"],"auth":["88.1"],"可以选择先跳过":["88.1"],"完成登录后":["88.1"],"它会将你重定向到应用管理页面":["88.1"],"点击右上角的新建":["88.1"],"选择创建一个新应用":["88.1"],"应用名需要是独一无二的":["88.1"],"创建成功后":["88.1"],"我们会来到应用界面":["88.1"],"以我们已经创建完毕的页面为例":["88.1"],"nestjs":["88.2"],"也完成了相关配置":["88.2"],"现在我们可以真正连接到数据库试用一下了":["88.2"],"创建":["88.2","89.1"],"seed":["88.2"],"在其中添加对":["88.2"],"service":["88.2"],"的实际调用":["88.2"],"run":["88.3"],"才是基于构建后代码的启动":["88.3"],"我们需要告诉":["88.3"],"使用这一":["88.3"],"script":["88.3"],"启动":["88.3"],"通常云平台们都支持了项目内的配置文件":["88.3"],"vercel":["88.3"],"netlify":["88.3"],"toml":["88.3"],"的配置文件则要特殊一些":["88.3"],"它的名字叫":["88.3"],"procfile":["88.3"],"failed":["88.4"],"从简起见":["88.4"],"我们不想每次使用这个类时都标记状态":["88.4"],"因为我们总共就两种状态":["88.4"],"所以可以提前准备好成功与失败的响应修饰":["88.4"],"resolvedresponse":["88.4"],"super":["88.4"],"rejectedresponse":["88.4"],"成功时使用":["88.4"],"数据为空或出现异常时使用":["88.4"],"你也可以进行更进一步的拆分":["88.4"],"如让参数校验失败":["88.4"],"数据为空":["88.4"],"鉴权失败等等都有专用的":["88.4"],"从创建开始":["88.4"],"我们直接调用注入好的":["88.4"],"即可":["88.4","107.3","107.4","107.7"],"injectable":["88.4"],"prismaservice":["88.4"],"responseunion":["88.4"],"response":["88.4"],"wrapper":["88.4"],"articlecreateinput":["88.4"],"articleupdateinput":["88.4"],"prisma":["88.5"],"那最大的收获其实是学习了目前功能最全面的":["88.5"],"框架":["88.5"],"很多浏览器还无法完全支持其中的特性":["89.0"],"这就需要":["89.0"],"将其转换为能够在更低版本的浏览器上运行的代码":["89.0"],"而它现在的这个名字":["89.0"],"意为巴别塔":["89.0"],"是圣经中记载的一座通天之塔":["89.0"],"当时的人们只有一种语言":["89.0"],"彼此之间精诚合作":["89.0"],"尝试联合起来建立起通往天堂的高塔":["89.0"],"而上帝为了阻止这一行动":["89.0"],"让人类之间使用不同的语言":["89.0"],"彼此之间无法沟通":["89.0"],"而计划最终自然失败":["89.0"],"使用这一名字":["89.0"],"正是为了更好地宣告自己的使命":["89.0"],"让所有各不相同的":["89.0"],"最终都能转换为能在相同环境下直接运行的代码":["89.0"],"可你是否了解":["89.0"],"创建代码块内的返回语句":["89.1"],"createreturnstatement":["89.1"],"decrementedarg":["89.1"],"minustoken":["89.1"],"recurse":["89.1"],"asterisktoken":["89.1"],"创建函数调用表达式":["89.1"],"createcallexpression":["89.1"],"statements":["89.1"],"添加":["89.2"],"注释":["89.2"],"addjsdoc":["89.2"],"tags":["89.2"],"tagname":["89.2"],"添加泛型":["89.2"],"record":["89.2"],"addtypeparameter":["89.2"],"constraint":["89.2"],"获取接口名称":["89.2"],"getname":["89.2"],"删除这个接口声明":["89.2"],"remove":["89.2"],"创建一条导入":["89.2"],"readfile":["89.2"],"指的是完全不进行新增":["89.3"],"更新":["89.3"],"删除操作":["89.3"],"只是通过":["89.3"],"预设的条件检查源码是否符合要求":["89.3"],"比如不允许调用某个方法":["89.3"],"不允许默认导出":["89.3"],"要求某个导入必须存在":["89.3"],"都属于":["89.3"],"整理一下思路":["89.4"],"将":["89.4"],"更改为":["89.4"],"将来自":["89.4"],"结尾的导入进行更改":["89.4"],"检查是否存在以":["89.4"],"为导入名的导入声明":["89.4"],"直接看具体实现":["89.4"],"syntaxkind":["89.4","89.6","89.8"],"sourcefile":["89.4","89.6","89.8"],"importdeclaration":["89.4"],"morph":["89.4","89.6","89.8"],"uniq":["89.4"],"performancemark":["89.5"],"这里我们使用抽象类来区分目标":["89.5"],"即只有实现了某一抽象类的":["89.5"],"才需要进行处理":["89.5"],"首先分析":["89.5"],"结构":["89.5","89.6","107.69"],"整理一下实现思路":["89.5"],"拿到所有实现了":["89.5"],"我们需要处理的两处分别为":["89.6"],"namedimports":["89.6"],"exportassignment":["89.6"],"接下来就简单了":["89.6"],"中的值类型其实还是字符串":["89.7"],"数字":["89.7"],"布尔值以及对象与数组这五位":["89.7"],"我们来整理一下思路":["89.7"],"遍历":["89.7"],"对于原始类型元素":["89.7"],"直接使用":["89.7"],"不是类型查询操作符":["89.7"],"的值作为类型":["89.7"],"interfacedeclaration":["89.7"],"addproperty":["89.7"],"方法新增属性":["89.7"],"对于对象类型":["89.7"],"遍历此对象类型":["89.7"],"将此对象类型生成的接口也调用":["89.7"],"addinterface":["89.7"],"方法添加到源码中":["89.7"],"并将其名称调用":["89.7"],"添加到顶层的对象中":["89.7"],"对于数组类型":["89.7"],"如果其中是原始类型":["89.7"],"提取所有原始类型值的类型":["89.7"],"合并为联合类型":["89.7"],"如果其中是对象类型":["89.7"],"则遍历其中的对象类型":["89.7"],"类似上一步":["89.7"],"来看完整的代码":["89.7"],"直接来看实现":["89.8"],"chalk":["89.8"],"functiondeclaration":["89.8"],"addsourcefileatpath":["89.8"],"dirname":["89.8"],"对源码的常见操作其实也可以被归类为检查":["89.9"],"变更":["89.9"],"新增这么几类":["89.9"],"对没有系统学习过编译原理的同学":["89.9"],"其实更推荐使用":["89.9"],"来简化这些":["89.9"],"也是通过":["89.11"],"来进行检查":["89.11"],"explorer":["89.11"],"比如错别字":["90.0"],"示例代码的呈现以及内容的组织方面等等":["90.0"],"明确了这些类型工具各自的作用与使用场景":["90.1"],"同时为类型编程的学习打好了基础":["90.1"],"类型系统部分":["90.1"],"作为这本小册区分于市面上所有其他":["90.1"],"不需要打开编辑器":["90.2"],"不需要准备笔记本":["90.2"],"不需要特别安静的学习环境":["90.2"],"目前已经确定的漫谈篇内容包括":["90.2"],"漫谈":["90.2"],"感谢":["90.3"],"寻找海蓝":["90.3"],"某兔":["90.3"],"技能一样的地位":["91.0"],"异同点":["91.1"],"使用交叉类型":["91.2"],"同名的":["91.2"],"来定义对象类型":["91.3"],"使用类型别名来处理函数签名":["91.3"],"联合类型":["91.3"],"工具类型等等":["91.3"],"类型系统的基本工作原理":["91.4"],"而对于":["91.5"],"结构化类型系统到标称类型系统":["91.6"],"你可以表达你不仅了解结构化类型系统":["91.6"],"还了解与其可以作为对比的标称类型系统":["91.6"],"这一部分主要考察你对内置":["91.7"],"因此就需要":["91.9"],"来表示一个包含任意类型的类型":["91.9"],"而在类型编程中":["91.9"],"如果对两个不存在交集的类型强行进行交集运算":["91.9"],"也需要一个类型表示这个不存在的类型":["91.9"],"肯定不是难事":["91.10"],"require":["91.11"],"deeppartial":["91.12"],"至于它们为什么会高频出现":["91.13"],"其实也是有原因的":["91.13"],"加入以下内容":["92.0"],"lastedittime":["93.0","105.0"],"cdn":["93.2"],"wangeditor":["93.3"],"editor":["93.3"],"router":["93.4"],"cnd":["93.6"],"文件路径的模板":["93.6"],"url":["93.6"],"默认值":["93.8"],"unpkg":["93.12"],"com":["93.12","121.7"],"createpinia":["94.2"],"stringify":["94.4"],"parse":["94.4"],"definestore":["94.5","94.7","94.9","94.10"],"pinia":["94.5","94.7"],"setitem":["94.6"],"statetree":["94.8"],"deserialize":["94.8"],"这可用于在恢复数据之前强制地执行特定的操作":["94.9"],"这可用于在恢复数据之后强制地执行特定的操作":["94.10"],"当设置为":["94.11"],"xuchp":["95.2"],"typora":["95.2"],"pics":["95.2"],"images":["95.2"],"20240204101235373":["95.2"],"svgicon":["95.4"],"中引入":["95.5"],"symbol":["96.1","101.2"],"bigint引用数据类型":["96.1"],"找到相同的原型对象":["96.2"],"返回":["96.2"],"验证一下自己实现的":["96.2"],"是否":["96.2"],"ok":["96.2"],"1a":["96.3"],"0x11":["96.3"],"方法的强制转换规则":["96.3"],"转换出来是":["96.3"],"其他均为":["96.3"],"是对象就再次调用该函数递归":["96.6"],"else":["96.6"],"基本类型的话直接复制值":["96.6"],"obj2":["96.6","101.13","101.52"],"这个深拷贝函数不能复制不可枚举的属性以及":["96.6"],"这种方法只是针对普通的引用类型的值做递归复制":["96.6"],"对象的属性里面成环":["96.6"],"即循环引用没有解决":["96.6"],"改进版":["96.6"],"改进后递归实现":["96.6"],"针对能够遍历对象对象的不可枚举属性以及":["96.6"],"缩短开发的周期":["96.7"],"child3":["96.8"],"第二次调用parent3":["96.8"],"第一次调用parent3":["96.8"],"手动挂上构造器":["96.8"],"指向自己的构造函数":["96.8"],"s3":["96.8"],"s4":["96.8"],"互不影响":["96.8"],"正常输出":["96.8"],"被调用后大致做了哪几件事情":["96.9"],"让实例可以访问到私有属性":["96.9"],"让实例可以访问构造函数原型":["96.9"],"所在原型链上的属性":["96.9"],"构造函数返回的最后结果是引用数据类型":["96.9"],"的实现":["96.9"],"ctor":["96.9"],"指变量能够被访问到的范围":["96.10"],"一个函数和对其周围状态的引用捆绑在一起":["96.11"],"或者说函数被引用包围":["96.11"],"代码解释器会首先在当前的作用域查找":["96.12"],"ajax":["96.13"],"请求":["96.13"],"方法用来解析":["96.14"],"字符串":["96.14"],"构造有字符串描述的":["96.14"],"不是数值时":["96.16"],"处理同上":["96.16"],"返回一个只包含":["96.16"],"元素一项的数组":["96.16"],"为数值时":["96.16"],"最大不能超过":["96.16"],"位无符号整型":["96.16"],"即需要小于":["96.16"],"新增的方法":["96.18"],"copywithin":["96.18"],"fill不改变自身的方法":["96.18"],"concat":["96.18","96.23"],"20240117153246144":["96.19"],"利用":["96.19"],"reduce":["96.19"],"函数迭代":["96.19"],"从上面普通的递归函数中可以看出":["96.19"],"其实就是对数组的每一项进行处理":["96.19"],"其实也可以用":["96.19"],"来实现数组的拼接":["96.19"],"从而简化第一种方法的代码":["96.19"],"nlogn":["96.21"],"插入排序":["96.23"],"插入排序算法描述的是一种简单直观的排序方法":["96.23"],"它的工作原理是通过构建有序序列":["96.23"],"对于未排序数据":["96.23"],"在已排序序列中从后向前扫描":["96.23"],"找到相应的值并插入":["96.23"],"从而达到排序的效果":["96.23"],"insertsort":["96.23"],"current":["96.23"],"while":["96.23"],"会被排列在":["96.24"],"之前":["96.24"],"等于":["96.24"],"margin":["97.1"],"border":["97.1","97.5","97.6"],"padding":["97.1"],"的区别":["97.2","101.67"],"相邻选择器":["97.3"],"后代":["97.3"],"权重计算":["97.4"],"第一":["97.4"],"style":["97.4"],"300px":["97.6"],"height":["97.6"],"5px":["97.6"],"solid":["97.6"],"ccc":["97.6"],"display":["97.6"],"此元素前后会带有换行符":["97.7"],"inline":["97.7"],"默认":["97.7"],"此元素会被显示为内联元素":["97.7"],"了解":["97.8"],"创建一个盒子":["97.9"],"添加样式":["97.9"],"absolute":["97.11"],"绝对定位":["97.11"],"相对于第一个有":["97.11"],"的父元素定位":["97.11"],"脱离文档流":["97.11"],"用来重置":["97.13"],"样式":["97.13","107.114"],"把多个小图标合并成一张大图片":["97.14"],"又称精灵图":["97.14"],"取值范围":["97.16"],"之间":["97.16"],"区别":["97.17"],"一个冒号":["97.17"],"是伪类":["97.17"],"chorme":["97.18"],"浏览器默认字体大小是":["97.18"],"相对于":["97.19"],"font":["97.19"],"size":["97.19"],"的颜色值能改变吗":["97.20"],"width":["97.21","107.77","107.140"],"1000px":["97.21"],"可以排除不支持媒体查询的浏览器":["97.21"],"设备类型":["97.21"],"移动端应该做什么样的布局方案":["97.22"],"访问量还可以或者比较大":["97.22"],"例如淘宝网":["97.22"],"端是一套":["97.22"],"会加入一点点响应式":["97.22"],"移动端是一套":["97.22"],"footer":["99.1"],"header":["99.1"],"section":["99.1"],"现有":["99.2"],"后有":["99.2"],"是显示在网页标题上":["99.3"],"显示在网页内容上":["99.3"],"更加的重要":["99.3"],"的了解":["99.3"],"鼠标移入到图片显示的值":["99.4"],"jpeg":["99.5"],"的大":["99.5"],"适合做小图标":["99.5"],"易读性和维护性更好":["99.6"],"textarea":["100.2"],"select":["100.5"],"用户选中文字":["100.6"],"的时候借鉴了":["101.3"],"java":["101.3"],"语言":["101.3"],"都会隐式转换":["101.4"],"事件循环":["101.5"],"同步执行完了":["101.5"],"才会执行事件循环的内容":["101.5"],"进入事件循环":["101.5"],"内部可以访问外部的变量":["101.6"],"但是外部不能访问内部的变量":["101.6"],"如果内部有":["101.6"],"注意变量提升":["101.7"],"操作符构建出来的":["101.11"],"所以对象之间不相等":["101.11"],"除了引用外":["101.11"],"geta":["101.18"],"obj":["101.19"],"test1":["101.19"],"是否会改变原数组":["101.26"],"unique":["101.31","101.32"],"char":["101.35"],"charat":["101.35"],"将空对象的原型指向于构造函数的原型":["101.36"],"闭包是一个函数加上到创建函数的作用域的连接":["101.38"],"lis":["101.39","101.40"],"document":["101.39","101.40"],"getelementsbytagname":["101.40"],"for":["101.40","101.63","103.13"],"函数拥有":["101.41"],"对象拥有":["101.41"],"call":["101.46","101.64"],"bind":["101.47","101.49"],"可以立即执行":["101.49"],"不会立即执行":["101.49"],"的数组使用":["101.51"],"assign":["101.52"],"深拷贝":["101.52"],"浏览器关了就没了":["101.53"],"始终有效":["101.53"],"窗口或者浏览器关闭了也一直存在":["101.53"],"所以是持久化存储":["101.53"],"resize":["101.54"],"setremunit":["101.54"],"没有变量提升的机制":["101.55"],"区别二":["101.55"],"obj1":["101.61","101.62"],"而且是不能修改的":["101.64"],"apply":["101.64"],"pending":["101.65"],"返回的内容不同":["101.66"],"系统自带有8个":["103.2"],"beforecreated":["103.2","103.7"],"如果请求是在":["103.3"],"中封装好的":["103.3"],"只要写异步代码":["103.4"],"获取":["103.4"],"次进入组件会执行哪些生命周期":["103.6"],"如果当前组件加入了":["103.6"],"父":["103.7"],"当前的组件会额外新增":["103.8"],"单组件请求":["103.9"],"str1":["103.11"],"子组件通过":["103.11"],"单向绑定":["103.12"],"的优先级":["103.13"],"then":["103.15"],"demonstrates":["106.0"],"some":["106.0"],"additional":["106.1"],"features":["106.1"],"like":["106.1"],"danger":["106.2"],"documentation":["106.3"],"鸿蒙应用开发快速体验":["107.0"],"准备开发环境":["107.1"],"为鸿蒙应用提供了一站式开发环境":["107.2"],"集成了开发":["107.2"],"运行":["107.2"],"调试以及发布应用的各项功能":["107.2"],"以下是具体的安装步骤":["107.2"],"获取deveco":["107.2"],"studio安装包":["107.2"],"官方下载地址为":["107.2"],"ohpm":["107.3"],"选择合适的安装路径":["107.3"],"完成后点击":["107.3"],"next":["107.3"],"注":["107.3"],"用于为鸿蒙应用的自动化构建工具提供运行环境":["107.3"],"此处选择第一个":["107.4"],"empty":["107.4"],"ability":["107.4"],"运行项目":["107.5"],"previewer":["107.6"],"预览用于查看应用的":["107.6"],"ui":["107.6","107.61","107.69","107.73"],"安装模拟器":["107.7"],"后":["107.7"],"会首先下载模拟器相关的":["107.7"],"sdk":["107.7"],"下载完成后点击":["107.7"],"finish":["107.7"],"打开手机的开发者模式":["107.8"],"连续多次点击系统版本号":["107.8"],"直至出现":["107.8"],"您正处在开发者模式":["107.8"],"的提示信息":["107.8"],"开启":["107.8"],"usb":["107.8"],"调试":["107.8"],"它由":["107.9"],"简称":["107.9","107.34","121.4"],"线上":["107.12"],"runner是一款在vscode中使用的插件":["107.13"],"它提供了简便的代码执行功能":["107.13"],"使开发者能够快速运行和调试代码片段":["107.13"],"常量声明":["107.16"],"用于声明变量":["107.16"],"如果一个变量或常量的声明包含了初始值":["107.17"],"表示字符串":["107.20"],"表示布尔值":["107.21"],"元素类型":["107.22"],"表示数字数组":["107.22"],"组成的数据结构":["107.23"],"姓名":["107.23"],"张三":["107.23"],"年龄":["107.23"],"性别":["107.23"],"未知":["107.27"],"p1":["107.27"],"printnumberorstring":["107.28"],"特殊类型":["107.30"],"若函数没有返回值":["107.30"],"函数的返回值类型可根据函数内容推断出来":["107.31"],"因此可以省略不写":["107.31"],"面向对象编程":["107.34"],"oriented":["107.34"],"programming":["107.34"],"person":["107.37","107.39","107.40","107.46"],"zhangsan":["107.37"],"定义静态成员需要使用":["107.38"],"constants":["107.38"],"count":["107.38","113.6","113.7","113.12","113.13"],"student":["107.39"],"classnumber":["107.39"],"protected和public":["107.40"],"概述":["107.42","107.76","107.102"],"introduce":["107.43"],"接口实现":["107.43"],"接口的实现需要用到":["107.43"],"很容易预想到":["107.45"],"这个系统将来可能需要支持其他的支付方式":["107.45"],"为了方便代码支持新的支付方式":["107.45"],"我们可以对代码进行如下改造":["107.45"],"首先定义一个支付策略的接口":["107.45"],"接口中声明一个":["107.45"],"用来规范实现类必须实现支付逻辑":["107.45"],"paymentstrategy":["107.45"],"amount":["107.45"],"gender":["107.46"],"枚举":["107.48"],"enumeration":["107.48"],"是编程语言中常见的一种数据类型":["107.48"],"枚举值的类型":["107.49"],"枚举值的类型为":["107.49"],"的名称":["107.49"],"等值的类型都是":["107.49"],"right":["107.50"],"除了使用默认的数字作为属性的值":["107.50"],"模块化是指将复杂的程序拆解为多个独立的文件单元":["107.52"],"每个文件被称为一个模块":["107.52"],"同时引入":["107.54"],"modulea":["107.54"],"的内容":["107.54"],"如下":["107.54","107.80","107.128"],"显然就会出命名冲突":["107.54"],"默认导出允许一个模块指定一个":["107.55"],"最多一个":["107.55"],"默认的导出项":["107.55"],"语法如下":["107.55","121.8"],"快速入门":["107.56"],"声明式":["107.57"],"并声明相应的状态变量用于表示不同的状态":["107.58"],"当前案例中":["107.58"],"界面共有两个状态":["107.58"],"分别是":["107.58","107.82"],"若我们将":["107.60"],"ison":["107.60","107.65"],"的值改为":["107.60"],"那么界面上就会显示":["107.60"],"以上就是声明式":["107.61"],"组件是构成界面的最小单元":["107.62"],"我们所看到的界面":["107.62"],"都是由众多组件组合而成的":["107.62"],"lightpage":["107.65"],"build":["107.65","107.69"],"column":["107.65"],"space":["107.65"],"声明组件的完整语法如下图所示":["107.67"],"各部分语法说明如下":["107.67"],"组件参数":["107.67"],"如果组件的定义包含参数":["107.67"],"可在组件名称后面的":["107.67"],"中配置相应参数":["107.67"],"方法用于声明自定义组件的":["107.69"],"组件属性":["107.69"],"组件属性可用作自定义组件的参数":["107.69"],"现在需要对前文的开":["107.70"],"关灯的案例做出如下改造":["107.70"],"由于两个按钮的结构十分相似":["107.70"],"条件渲染可根据应用的不同状态渲染不同的":["107.73"],"界面":["107.73"],"例如前文的开":["107.73"],"循环渲染可使用":["107.76"],"foreach":["107.76"],"数组中的数据项":["107.77"],"可选":["107.77"],"数组中的数据项的索引":["107.77"],"backgroundcolor":["107.77","107.124"],"green":["107.77","107.91"],"answer":["107.77"],"key生成函数":["107.77"],"图片":["107.78"],"类型的参数用于引入":["107.80"],"resources":["107.80","107.87"],"目录下的图片":["107.80"],"resources目录用于统一存放应用所需的各种资源":["107.80"],"包括图片":["107.80"],"音频":["107.80"],"视频":["107.80"],"文本等等":["107.80"],"下面简要介绍":["107.80"],"目录的用法":["107.80"],"首先需要了解":["107.80"],"的目录结构":["107.80"],"用于存放资源的子目录有":["107.80"],"和rawfile":["107.80"],"下面分别介绍":["107.80"],"类型的参数可为百分比":["107.82"],"或者为具体尺寸":["107.82"],"100px":["107.82","107.89"],"具体尺寸的单位":["107.82"],"常用的有两个":["107.82"],"px":["107.82"],"vp":["107.82"],"下面逐个介绍":["107.82"],"前置知识":["107.82"],"屏幕参数":["107.82"],"pixel":["107.82"],"物理像素":["107.82"],"以像素个数来定义图像尺寸":["107.82"],"这种方式的弊端是":["107.82"],"在不同像素密度的屏幕上":["107.82"],"none":["107.83"],"保持原有尺寸显示":["107.83"],"不做任何缩放":["107.83"],"超出显示区域的部分不显示":["107.83"],"使图片显示得更清晰":["107.84"],"该方法的参数为":["107.84","107.112"],"imageinterpolation":["107.84"],"枚举类型":["107.84"],"可选的值有":["107.84"],"名称":["107.84","107.92"],"文本":["107.85"],"类型的参数用于引用":["107.87"],"目录中定义的字符串":["107.87"],"同样需要使用":["107.87"],"类型的参数可用于指定字体大小的具体单位":["107.89"],"字体大小的单位支持":["107.89"],"取值间隔为":["107.90"],"默认为":["107.90"],"取值越大":["107.90"],"字体越粗":["107.90"],"为枚举类型":["107.91"],"其中包含了多种常用颜色":["107.91"],"可选的枚举值如下":["107.92"],"方法处理超出部分":["107.93"],"该方法的参数类型为":["107.93"],"overflow":["107.93"],"按钮":["107.94"],"buttontype":["107.96"],"stateeffect":["107.96"],"为按钮上显示的文字内容":["107.96"],"背景颜色":["107.98"],"按钮的颜色可使用":["107.98"],"方法进行设置":["107.99","107.124"],"arkts":["107.99"],"可以通过":["107.100"],"方法为按钮绑定点击事件":["107.100"],"该方法的参数为一个回调函数":["107.100"],"当按钮被点击时":["107.100"],"切换按钮":["107.101"],"属性用于设置":["107.103"],"组件的类型":["107.103"],"可通过":["107.103","107.114"],"选中状态背景色":["107.105"],"可使用设置":["107.106"],"switchpointcolor":["107.106"],"方法设置switch类型的":["107.106"],"toggle":["107.106"],"开发者可通过":["107.107"],"方法为":["107.107"],"组件绑定change事件":["107.107"],"该方法参数为一个回调函数":["107.107"],"文本输入":["107.108"],"placeholder":["107.110"],"resource":["107.110"],"方法设置输入框的类型":["107.112"],"placeholderfont":["107.114"],"输入文本的样式可通过":["107.115"],"fontsize":["107.115"],"fontweight":["107.115"],"就会触发":["107.117"],"会触发":["107.118"],"focus":["107.118"],"事件":["107.118"],"失去焦点时":["107.118"],"blur":["107.118"],"进度条":["107.119"],"属性用于设置当前进度值":["107.121"],"属性用于设置总值":["107.121"],"scalecount":["107.123"],"scalewidth":["107.123"],"属性用于设置进度条的宽度":["107.123"],"弹窗":["107.125"],"弹窗是移动应用中常见的一种用户界面元素":["107.125"],"模块":["107.128"],"警告对话框":["107.130"],"用于向用户发出警告或确认操作的提示":["107.130"],"确保用户在敏感操作前进行确认":["107.130"],"操作列表弹窗":["107.133"],"用于提供一组选项给用户选择":["107.133"],"用户从中选择后":["107.133"],"可执行相应的操作":["107.133"],"summary":["107.136"],"ucbbb1a17":["107.136"],"strong":["107.136"],"span":["107.136","113.3","113.4","114.5"],"ne":["107.136"],"textpickerdialog":["107.136"],"使用说明":["107.137"],"具体用法可参考相关案例或者官方文档":["107.137"],"各选择器的官方文档地址如下":["107.137"],"可考虑自定义弹窗":["107.139"],"自定义弹窗允许开发者自定义弹窗内容和样式":["107.139"],"chat":["109.1"],"单文件组件设置全局css样式":["110.5"],"该怎么设置呢":["110.5"],"转化为全局作用域":["110.7"],"local":["110.7"],"将其插槽内容渲染到另一个dom":["111.1"],"成为该dom的一部分":["111.1"],"的子元素":["111.2"],"将内容渲染到":["111.3"],"使它只接收":["111.5"],"primary":["111.5"],"ghost":["111.5"],"你应该确保参数被正确传递":["111.12"],"事件被正常触发和插槽内容正常渲染":["111.12"],"让我们开始吧":["111.12","111.15"],"mouse":["112.9","112.10"],"position":["112.9","112.10"],"update":["113.6","113.7"],"调整回调函数的刷新时机":["113.14"],"参考回调的刷新时机及":["113.14"],"watcheffect":["113.14"],"默认情况下":["113.14"],"用户创建的侦听器回调":["113.14"],"ref":["113.18","121.5"],"track":["113.29"],"trigger":["113.29"],"以便只渲染一次元素和组件":["114.4"],"并且跳过以后的更新":["114.4"],"组件及其所有子项将被当作静态内容并跳过渲染":["114.6"],"这可以用来优化更新时的性能":["114.6"],"debounce":["114.11","114.12"],"item":["114.14","114.15"],"click2":["115.2"],"enter":["115.4"],"时调用":["115.4"],"vm":["115.4"],"submit":["115.4"],"keyup":["115.4"],"onclick1":["115.5"],"xx":["118.1"],"raw":["118.1","121.7"],"来完成它":["118.1"],"根据一个":["118.3"],"until":["119.1"],"数据":["121.1"],"计算属性等":["121.1"],"可直接在模板中使用":["121.3"],"中访问":["121.3"],"函数会在":["121.3"],"beforecreate":["121.3"],"之前调用":["121.3"],"初始值":["121.4"],"返回值":["121.4"],"一个":["121.4"],"refimpl":["121.4"],"的实例对象":["121.4"],"基本类型不要用它":["121.5"],"要用":["121.5"],"可以使用":["121.7"],"volar":["121.7"],"插件自动添加":["121.7"],"https":["121.7"],"githubusercontent":["121.7"],"可以批量转换":["121.8"]},{"0":["0.73","0.79","0.82","0.83","58.73","58.79","58.82","58.83","64.1","71.6","76.1","81.10","82.4","85.5","85.25","89.8","101.3","101.31","101.40","107.91"],"1":["0.27","0.33","0.65","0.67","0.74","0.75","14.0","58.27","58.33","58.65","58.67","58.74","58.75","64.1","64.2","67.2","70.1","75.2","76.1","76.6","82.1","85.24","85.25","86.11","97.11","101.24","101.35","107.15","107.25","107.38","107.64","113.4","113.6","113.7"],"2":["0.22","0.24","1.1","56.5","58.22","58.24","62.10","64.1","67.2","75.2","76.6","80.8","80.40","82.1","97.14","101.12","101.21","101.22","101.24","103.8","107.2","115.2"],"3":["0.24","0.63","0.84","0.90","1.1","9.0","56.5","58.24","58.63","58.84","58.90","66.4","67.2","75.2","80.39","80.40","96.5","96.24","97.22","101.3","101.5","101.6","101.11","101.16","101.23","101.25","101.36","101.41","107.29"],"4":["0.60","0.79","1.1","58.60","58.79","59.3","67.2","71.0","76.6","83.13","85.23","101.60","107.50"],"5":["0.20","0.82","1.1","58.20","58.82","71.6","78.4","82.12","85.23","101.30"],"6":["0.43","0.82","57.1","58.43","58.82"],"7":["0.83","58.83","66.4"],"8":["103.8"],"9":["85.5","107.19"],"10":["0.34","58.34","107.27","107.46"],"11":["93.0"],"12":["96.3"],"13":["96.3"],"14":["121.3"],"15":["107.27","121.3"],"16":["75.5","90.1"],"18":["0.65","58.65","107.36"],"23":["121.3"],"24":["61.1"],"25":["0.66","58.66"],"26":["0.16","58.16"],"30":["121.3"],"32":["0.70","58.70","85.5"],"33":["95.2"],"42":["86.8"],"87":["121.7"],"90":["78.3"],"95":["81.11"],"100":["62.10","82.13"],"123":["101.14"],"200":["114.11","114.12"],"499":["62.10"],"599":["62.10","64.3","67.2","71.12","72.2","77.2","86.4"],"600":["62.10"],"857":["101.33"],"1000":["97.4","101.33"],"1001":["101.33"],"1234":["0.34","58.34"],"1920":["97.22"],"2024":["121.3"],"test":["0.2","58.2","107.31"],"和变量":["0.2","58.2"],"或美元符号":["0.3","58.3"],"剩下的其他字符可以是":["0.3","58.3"],"如":["0.4","0.65","57.1","58.4","58.65","59.1","60.8","61.3","61.6","63.0","76.1","78.1","79.9","79.10","80.24","80.38","83.9","85.12","87.5","87.8"],"js":["0.4","0.5","0.13","0.18","0.26","0.39","0.80","3.1","30.0","47.1","51.0","54.2","58.4","58.5","58.13","58.18","58.26","58.39","58.80","80.1","85.28","85.31","106.1"],"use":["0.5","58.5"],"strict":["0.5","58.5"],"虽然看起来像个没有赋值给任何变量的字符串":["0.5","58.5"],"class":["0.7","58.7","88.2","107.43","121.8"],"extends":["0.7","58.7","67.6","80.3","84.2","86.27"],"return":["0.7","9.0","55.4","58.7","63.9","64.2","67.5","68.3","70.1","78.4","80.41","82.13","83.5","83.10","84.3","88.4","89.1","89.4","89.8","101.34"],"while":["0.7","58.7","96.19"],"这些关键字有特殊用途":["0.8","58.8"],"package":["0.10","58.10","87.2","107.3"],"其中":["0.12","58.12","63.6","107.89"],"在":["0.12","58.12","64.3","73.3","77.3","80.26","83.2","83.13","86.27","87.2","87.3","99.4","103.3"],"即标识符":["0.13","58.13"],"不过":["0.14","58.14"],"在函数内定义变量时省去":["0.14","58.14"],"操作符":["0.14","58.14"],"可以创建一个全局变量":["0.14","58.14"],"没有":["0.14","24.0","58.14"],"会被挂载到":["0.14","58.14"],"运行时把它看成等价于如下代码":["0.15","58.15"],"age":["0.16","0.17","0.25","58.16","58.17","58.25","61.1","61.5","79.4","107.40"],"matt":["0.17","58.17"],"不会被提升":["0.17","58.17"],"声明的变量则会":["0.18","58.18"],"name":["0.18","58.18","61.5","63.11","64.2","67.2","69.2","80.40","83.10","86.14","87.3","93.9","93.10","101.44","101.46","107.23","107.37","107.40","111.13","121.8"],"let":["0.19","1.1","54.3","58.19","62.18","81.10","86.22","96.9","101.54","107.19","107.49","121.5"],"settimeout":["0.20","58.20"],"console":["0.20","0.25","0.45","58.20","58.25","58.45","63.8","64.2","80.10","83.6","86.4","86.11","101.13","101.18","101.23","101.25","101.58","107.27","107.28","107.31","107.32","107.37","107.44","107.55"],"log":["0.20","0.25","0.45","58.20","58.25","58.45","63.8","64.2","83.6","86.4","86.11","101.8","101.17","101.18","101.58","107.27","107.28","107.32","107.37","107.44"],"声明的作用域也是块":["0.21","58.21"],"if":["0.21","0.26","10.3","36.3","37.3","39.0","55.2","58.21","58.26","64.2","70.3","82.3","82.10","86.13","111.16"],"true":["0.21","0.45","55.1","58.21","58.45","60.8","62.4","80.3","80.9","80.37","86.8","94.11","107.21"],"null":["0.23","58.23","64.8","67.5","79.13","80.11","88.4"],"boolean":["0.24","29.3","58.24","64.2","66.7","67.4","75.4","78.4","78.5","82.13","107.107"],"表示值为布尔值":["0.24","58.24"],"uncaught":["0.25","58.25"],"只要检查这个变量的值是不是":["0.26","58.26"],"就可以知道这个变量是否在后面被重新赋予了一个对象的引用":["0.26","58.26"],"比如":["0.26","0.47","58.26","58.47","61.2","62.14","73.0"],"car":["0.26","58.26"],"不等于":["0.27","58.27"],"string":["0.28","0.44","58.28","58.44","61.2","61.5","63.11","64.2","66.4","69.6","69.9","71.2","71.8","73.0","79.2","80.12","85.4","85.6","86.13","86.14","89.4","96.2","103.11","107.22","107.40","107.128"],"非空字符串":["0.28","58.28"],"空字符串":["0.28","58.28"],"ieee":["0.29","58.29"],"就回忽略前缀的":["0.30","58.30"],"后面的数字被当做十进制":["0.30","58.30"],"的情况下":["0.31","58.31","73.3"],"就会变成整数":["0.31","58.31"],"floatnum1":["0.31","58.31"],"小数点后面没有数字":["0.31","58.31"],"当成整数":["0.31","58.31"],"负无穷大":["0.32","58.32"],"表示":["0.32","0.87","58.32","58.87"],"任何无法表示的正数以":["0.32","58.32"],"注意":["0.32","58.32","63.11","88.3","101.7"],"一旦得到":["0.32","58.32"],"就不能再进一步用于任何计算":["0.32","58.32"],"因为":["0.32","58.32","66.2","76.2","96.6","101.49"],"独特属性":["0.33","58.33"],"任何涉及":["0.33","58.33"],"的操作始终返回":["0.33","58.33"],"在连续多步计算时这可能是个问题":["0.33","58.33"],"则继续依次检测每一个字符":["0.34","58.34"],"直到字符串末尾":["0.34","58.34"],"或碰到非数值字符":["0.34","58.34"],"假设字符串中第一个字符是数值字符":["0.34","58.34"],"函数也能识别不同的整数格式":["0.34","58.34"],"十进制":["0.34","58.34"],"八进制":["0.34","58.34"],"十六进制":["0.34","58.34"],"换句话说":["0.34","58.34"],"如果字符串以":["0.34","58.34"],"0x":["0.34","58.34"],"开头":["0.34","58.34","80.9"],"就会被解释为十六进制":["0.34","58.34"],"且紧跟着数值字符":["0.34","58.34"],"在非严格模式下会被某些实现解释为八进制":["0.34","58.34"],"1234blue":["0.34","58.34"],"0xa":["0.34","58.34"],"解释为十六进制":["0.34","58.34"],"位":["0.35","58.35"],"unicode":["0.35","58.35"],"要修改某个变量中的字符串值":["0.37","58.37"],"数值调用":["0.38","58.38"],"可以夸行定义字符串":["0.39","58.39"],"模板字面量在定义时立即求值并转换为字符串实例":["0.40","58.40"],"任何插入的变量也会从它们最接近的作用域中取值":["0.40","58.40"],"字符串插值通过在":["0.40","58.40"],"中使用一个":["0.40","58.40"],"会接收被插值记号分隔后的模板和对每个表达式求值的结果":["0.41","58.41"],"标签函数本身是一个常规函数":["0.41","58.41"],"而不是被转":["0.42","58.42"],"换后的字符表示":["0.42","58.42"],"或":["0.44","58.44","64.5","66.3","121.4"],"number":["0.44","58.44","61.5","64.2","69.4","69.9","70.2","71.8","76.4","79.4","79.15","80.22","81.10","82.13","83.10","85.24","107.38"],"那样":["0.44","58.44"],"它们都支持构造函数且可用于初始化包含原":["0.44","58.44"],"始值的包装对象":["0.44","58.44"],"全局注册表中的符号必须使用字符串键来创建":["0.45","58.45"],"因此作为参数传给":["0.45","58.45"],"defineproperty":["0.46","6.3","15.0","58.46","83.9","96.5"],"我们知道":["0.47","58.47"],"for":["0.47","26.2","58.47","70.3","89.8","101.31","101.32","101.39","106.3"],"of":["0.47","58.47","70.3","86.23","96.16","106.0"],"循环会在相关对象上使用":["0.47","58.47"],"ispropertyof":["0.60","58.60"],"用于判断当前对象是否为另一个对象的原型":["0.60","58.60"],"propertyisenumerable":["0.60","58.60"],"一元操作符是":["0.62","58.62"],"nan":["0.63","0.86","58.63","58.86"],"变量类型从字符串变为数值":["0.63","58.63"],"对于布尔值":["0.63","58.63"],"如果是":["0.63","0.77","0.78","58.63","58.77","58.78"],"false":["0.63","58.63","61.1","61.6","62.6","67.7","75.2","80.9","80.11","85.5","85.17","89.1"],"则转换成":["0.63","58.63"],"放在变量前头":["0.64","58.64"],"对数值没有任何影响":["0.64","58.64"],"个步骤计算":["0.65","58.65"],"得到":["0.65","58.65"],"确定绝对值的二进制表示":["0.65","58.65"],"对于":["0.65","58.65","60.1","61.9","65.4"],"二进制00000000000000000000000000011001":["0.66","58.66"],"第二个数值的位":["0.67","58.67"],"结果":["0.67","58.67"],"按位异或":["0.68","58.68"],"对于负数":["0.71","58.71"],"有时候差异会非常大":["0.71","58.71"],"与有符号右移不同":["0.71","58.71"],"如果操作数是非空字符串":["0.73","58.73"],"如果操作数是数值":["0.73","58.73"],"则逻辑与并不一定会返回布尔值":["0.74","58.74"],"而是遵循如下规则":["0.74","58.74"],"如果第一个操作数是对象":["0.74","0.75","58.74","58.75"],"则返回第二个操作数":["0.74","58.74"],"如果第二个操作数是对象":["0.74","58.74"],"则只有第一个操作数求值为":["0.74","58.74"],"那么逻辑或操作符也不一定返回布尔值":["0.75","58.75"],"它遵循如":["0.75","58.75"],"下规则":["0.75","58.75"],"则返回第一个操作数":["0.75","58.75"],"个乘性操作符":["0.76","58.76"],"乘以":["0.77","58.77"],"除以":["0.78","58.78"],"如果被除数是":["0.79","58.79"],"指数操作符也有自己的指数赋值操作符":["0.80","58.80"],"该操作符执行指数运算和结果的赋值操作":["0.80","58.80"],"如果有任一操作数是数值":["0.84","58.84"],"则将另一个操作数转换为数值":["0.84","58.84"],"执行数值比较":["0.84","58.84"],"它们在比较之前不执行转换":["0.85","58.85"],"undefined":["0.86","58.86","61.4","64.8","67.7","71.2","84.3","86.3","86.35","101.8","101.57"],"相等":["0.86","58.86"],"不能转换为其他类型的值在进行比较":["0.86","58.86"],"如果有任一操作数是":["0.86","58.86"],"则相等操作符返回":["0.86","58.86"],"不相等操作符返回":["0.86","58.86"],"的值决定将哪个值赋给变量":["0.88","58.88"],"如果":["0.88","58.88","66.2"],"除后赋值":["0.89","58.89"],"也可以使用逗号操作符来辅助":["0.90","58.90"],"赋值":["0.90","58.90"],"官方":["1.0"],"vue是一套用于构架用户界面的":["1.0"],"命令式编程":["1.1"],"numbers":["1.1"],"backbone":["1.2"],"underscore":["1.2"],"jquery":["1.2"],"对于前端而言":["1.2"],"数据变化无法同步到视图中":["1.2"],"添加虚拟":["1.3"],"后":["1.3","83.13","88.1"],"的渲染核心就是调用渲染":["1.4"],"render":["1.4","3.2","3.3","18.1","55.4","55.5","111.13"],"方法将虚拟":["1.4"],"低耦合":["1.5"],"的理解":["2.0","35.0"],"切换页面时通过监听路由变化":["2.1"],"渲染对应的页面client":["2.1"],"side":["2.1"],"rendering":["2.1"],"客户端渲染":["2.1"],"csr":["2.1"],"mpa":["2.1"],"搜索引擎优化":["2.2"],"无法实现":["2.2"],"容易实现":["2.2"],"页面切换":["2.2"],"速度快":["2.2"],"html":["2.3","79.9","97.5","101.1","114.6"],"页面":["2.3"],"就是在打包的时候":["2.3"],"就是用":["3.1"],"对象来描述真实":["3.1"],"是对真实":["3.1"],"template":["3.2","15.0","22.1","29.3","111.1","111.12","115.4"],"这个模板会被编译器编译为渲染函数":["3.2"],"将会引起组件刷新":["3.3"],"此时就会生成新的":["3.3"],"事件":["4.0","56.5","101.5"],"插槽":["4.0"],"或者":["4.1","96.3"],"内部设计原因导致":["5.0"],"设计的是每个组件一个":["5.0"],"使用":["6.1","107.8"],"object":["6.1","9.0","69.2","75.8","81.7","83.9","83.10","84.2","96.8","96.9","101.2"],"setter":["6.2"],"性能差":["6.2"],"当新增属性和删除属性时无法边控变化":["6.2"],"需要通过":["6.2"],"get":["6.3","63.8","63.11","83.9","83.10","113.29"],"记录渲染":["6.3"],"watcher":["6.3","38.0"],"set":["6.3","63.9"],"newvalue":["6.3"],"让记录的":["6.3"],"重新执行一下即可":["6.3"],"而是选择重写数组":["7.1"],"push":["7.1","67.6","70.3"],"数组的索引和长度变化是无法监控的":["7.2"],"去更新":["8.1"],"默认在初始化时会调用":["8.1"],"结构将属性和":["8.2"],"effect":["8.2"],"映射起来":["8.2"],"splice":["9.0"],"如果是对象本身的属性":["9.0"],"则直接添加即可":["9.0"],"in":["9.0","17.0","75.8","76.3","76.8","80.1","107.67"],"prototype":["9.0","84.2","101.44"],"如果条件不成立不会渲染当前指令所在节点的":["10.1"],"dom":["10.1","35.1","55.1","103.9"],"explorer":["10.2"],"vuejs":["10.2"],"用户":["11.0"],"computed属性是具备缓存的":["11.1"],"当值发生变化时调用对应的回调函数":["11.2"],"经常用于监控某个值的变化":["11.2"],"区别":["12.0"],"数据响应式中非常重要的两个概念":["12.1"],"用于处理对象类型的数据响应":["12.1"],"run":["13.0","80.2"],"函数":["13.0","101.48","107.24"],"app":["13.0","79.4"],"innerhtml":["13.0"],"state":["13.0","94.4","113.16","113.17"],"将":["14.0"],"模板转换成":["14.0"],"内部会对数据进行劫持":["15.0"],"对象采用":["15.0"],"数组采用方法重写":["15.0"],"再看一下用户是否传入了":["15.0"],"el":["15.0"],"属性和":["15.0"],"新增的一个":["16.0"],"api":["16.0","53.0","60.4","78.6","107.67"],"i":["17.0","77.2","77.3","80.9","85.25","89.4","101.31","101.32","101.40","107.44"],"arr":["17.0","80.10","85.24"],"一般也不咋用":["18.1"],"beforemount再挂载之前被调用":["18.1"],"相关的":["18.1"],"函数首次被调用":["18.1"],"mounted":["18.1"],"被新创建的":["18.1"],"更新之前":["18.2"],"updated":["18.2","103.2"],"组件数据更新之后":["18.2"],"beforedestroy":["18.2","103.2"],"beforeunmount":["18.2"],"组件实例销毁之前":["18.2"],"destroyed":["18.2"],"unmounted":["18.2"],"diff":["19.0"],"做更新":["19.1"],"老的没儿子":["19.2"],"现在有儿子":["19.2"],"直接插入新的儿子":["19.2"],"老的有儿子":["19.2"],"新的没儿子":["19.2"],"中":["20.0","65.4","73.3","75.3","77.3","83.2","83.9","87.4","88.3","103.13","107.52"],"对比时辨识":["20.1"],"vnode":["20.1","37.2"],"如果不使用":["20.1"],"过程中通过":["20.2"],"是干什么的":["21.0"],"必须提供":["21.1"],"install":["21.1"],"方法":["21.1","87.8","94.8","96.6"],"全局组件":["21.2"],"通过全局混入来添加一些组件选项":["21.2"],"additional":["21.3"],"parameters":["21.3"],"args":["21.3"],"toarray":["21.3"],"arguments":["21.3"],"除了第一项":["21.3"],"方法的作用":["22.0"],"var":["22.1","63.10","85.24","86.35","93.11","101.16","101.57"],"profile":["22.1"],"p":["22.1","60.4","67.1","75.8","89.4","89.5","89.7","113.1","113.2","113.23","113.24","117.1","117.2"],"firstname":["22.1"],"extend":["22.2","60.1"],"方法进行创建":["22.2"],"存起来":["23.0"],"this":["23.0","59.1","81.10","85.5","85.24","86.35","101.17","107.39"],"constructor":["23.0","84.2","84.3","88.2","107.36","107.40"],"函数式组件就是普通的函数":["24.0"],"new":["24.0","47.4","63.15","68.0","79.8","81.10","84.4","88.4","89.4","89.5","89.6","89.7","107.7"],"function":["25.0","55.4","55.5","63.10","66.4","68.3","70.1","72.5","80.18","80.34","82.13","83.4","83.6","83.10","84.3","86.21","86.35","89.4","101.33","107.31","107.32","107.55","113.25"],"value":["25.0","30.0","63.9","75.2","84.3","94.6","96.5"],"返回处理后的值":["25.0"],"filterb":["25.0"],"的使用场景有哪些":["26.0"],"是":["26.1","36.1","55.1","75.3","79.13"],"compoent":["26.2"],"指令":["26.2"],"混入":["27.1"],"采用策略模式针对不同的属性进行合并":["27.1"],"如果混入的数据和本身组件中的数据冲突":["27.1"],"局部混入":["27.2"],"inject":["27.3"],"computed同名时会被替换":["27.3"],"slot":["28.0","31.2"],"components":["28.1"],"规范草案":["28.1"],"可以通过具名插槽指定渲染的位置":["28.2"],"v":["28.3","39.0","55.1","55.3","77.1","110.3","113.27","113.28"],"作用域插槽":["28.3"],"可以绑定一个动态值到视图上":["29.1"],"同时修改视图能改变数据对应的值":["29.1"],"的处理逻辑":["29.2"],"例如":["29.2","103.4","107.17","107.20","107.48","107.50","107.87","107.100","107.106"],"checked":["29.3"],"event":["29.3"],"change":["29.3"],"props":["29.3","55.4","55.5"],"修饰符绑定多个属性":["30.0"],"my":["30.0"],"编写递归组件":["31.1"],"在组件中调用自己":["31.1"],"submenu":["31.1"],"elsubmenu":["31.2"],"div":["31.2","97.9"],"title":["31.2","81.7","111.16"],"方便调试和查找对应组件":["32.0"],"children":["32.0","55.1"],"filter":["32.0","84.2","89.8"],"item":["32.0","84.2"],"prevent":["33.0"],"self":["33.0"],"once":["33.0","114.5"],"这个工厂函数会异步解析你的组件定义":["34.1"],"import":["34.2","79.3","89.5","93.2","94.8","95.2","95.5"],"webpackchunkname":["34.2"],"b4":["34.2"],"默认渲染异步占位符节点":["34.3"],"方法可以保证用户定义的逻辑在更新之后执行":["35.1"],"可用于获取更新后的":["35.1"],"平时在哪里使用":["36.0"],"vue":["36.1","47.1","47.4","53.0","55.4","55.5","93.4","111.12","111.15","113.14","118.1","118.3","121.3"],"router":["36.2","92.0"],"view":["36.2"],"getfirstcomponentchild":["36.3"],"获得第一个组组件":["36.3"],"componentoptions":["36.3"],"check":["36.3","80.2"],"pattern":["36.3","80.2"],"getcomponentname":["36.3"],"获取组件名":["36.3"],"看是否需要缓存":["36.3"],"不需要缓存则直接返回":["36.3"],"not":["36.3"],"included":["36.3"],"to":["36.4","60.8","81.7","88.1","111.2"],"from":["36.4","55.4","55.5","79.3","79.15","85.26","89.5","89.7","94.3","94.8"],"next":["36.4","96.19","107.7"],"同时":["37.1","59.1","62.12","72.1","88.5"],"update":["37.2","113.3","113.4"],"所在组件的":["37.2"],"更新时调用":["37.2"],"hide":["37.3"],"input":["37.3","64.2","68.3","70.3","83.4","83.10","97.20","100.1","106.1"],"type":["37.3","55.1","61.4","64.1","67.4","71.5","74.1","79.15","83.10","85.4","88.4","91.7","103.11","107.99"],"text":["37.3","81.10","100.6","114.1","114.2"],"focus":["37.3","114.8","114.9"],"show":["37.3","39.0","107.67"],"有调度中心统一调度订阅者注册到调度中心的处理代码":["38.0"],"观察者模式":["38.0"],"和":["38.0","39.0","62.18","64.8","65.2","65.4","65.6","75.1","79.10","81.2","96.24","97.11","101.50","107.58","107.80","107.114"],"dep":["38.0"],"强制缓存":["40.0"],"对比缓存":["40.0"],"localstorage":["40.0"],"实现缓存资源":["40.0"],"cross":["41.0"],"origin":["41.0"],"resource":["41.0"],"sharing":["41.0"],"设置拦截请求":["42.0"],"自动添加":["42.0"],"如果控制到按钮级别的权限怎么做":["43.0"],"当页面刷新时我们可以使用token":["43.1"],"来获得用户权限":["43.1"],"访问权限":["43.1"],"根据用户是否登录判断能否访问一个页面":["43.1"],"通过路由守卫实现判断用户是否有此权限":["43.1"],"在路由配置里调用":["44.0"],"beforeenter":["44.0"],"解析异步路由组件":["44.0"],"在被激活的组件里调用":["44.0"],"不依赖于浏览器历史":["45.0"],"模式":["45.0"],"是什么原因呢":["46.0"],"的个人理解":["47.0"],"修改状态":["47.2"],"状态是一个树状结构":["47.3"],"最终会将模块的状态挂载到根模块上":["47.3"],"模块和状态的名字冲突":["47.3"],"watch":["48.0"],"监控":["48.0"],"不存在则发请求重新拉去数据":["49.0"],"存储到":["49.0"],"中可以多次进行":["50.0"],"commit":["50.0"],"action":["51.0"],"getter":["51.0"],"甚至是嵌套子模块":["51.0"],"const":["51.0","61.11","63.5","64.2","70.3","76.1","78.4","78.7","79.2","80.13","80.25","82.12","83.3","85.24","88.4","89.4","89.5","89.7","94.5","94.7","94.9","94.10","96.6","107.16","107.53"],"modulea":["51.0"],"访问":["52.0"],"存在指向明确问题":["52.0"],"中很多未使用的方法或者属性依旧会被打包":["52.0"],"并且所有全局":["52.0"],"机制实现按需引入":["53.0"],"减少用户打包后的体积":["53.0"],"重写":["53.0"],"允许自定义渲染器":["53.0"],"扩展能力强":["53.0"],"不会发生以前的事情":["53.0"],"改写":["53.0"],"被定义":["54.1"],"所有的错误仍会发送给它":["54.1"],"因此这些错误仍然会向单一的分析服务的地方进行汇报":["54.1"],"配置函数":["54.2"],"data":["54.3","55.4","62.2","79.15","87.4","121.1"],"err":["54.3","78.7"],"json":["55.1","86.28","87.2"],"isvnode":["55.1"],"key":["55.1","79.2","84.3","107.77","114.14","114.15"],"symbol":["55.1","96.5"],"nu1l":["55.1"],"flag":["55.2"],"span":["55.2"],"a":["55.2","63.9","69.1","73.2","96.9","101.62","107.19","107.28","107.44","107.53","115.5"],"export":["55.4","55.5","70.3","75.8","77.3","79.2","79.15","79.16","80.12","88.2","89.4","89.8","94.3","94.5","94.9","94.10","107.55"],"ctx":["55.4","55.5"],"cache":["55.4","55.5","80.2"],"setup":["55.4"],"options":["55.4","107.128"],"todisplaystring":["55.5"],"所定义的那样":["56.1"],"完整的":["56.1"],"包含以下几个部分":["56.1"],"包含如下几个部分":["56.3"],"语法":["56.3","82.1","101.48","121.5"],"是一个应用编程接口":["56.4"],"css":["56.5"],"样式前后的文档":["56.5"],"的接口":["56.5"],"描述事件及事件处理的接口":["56.5"],"移动":["56.6"],"缩放和关闭浏览器窗口的能力":["56.6"],"对象":["56.6"],"提供关于浏览器的详尽信息":["56.6"],"如果接收到的资源的签名与这个属性指定的签名不匹配":["57.1"],"则页面会报错":["57.1"],"脚本不会执行":["57.1"],"这个属性可以用于确保内容分发网络":["57.1"],"cdn":["57.1"],"content":["57.1","97.1","97.6"],"delivery":["57.1"],"network":["57.1"],"不会提供恶意内容":["57.1"],"language":["57.1"],"废弃":["57.1"],"最初用于表示代码块中的脚本语言":["57.1"],"javascript":["57.1","63.0","63.4","65.4","76.0","80.3","82.8","84.1","86.33","96.14"],"javascript1":["57.1"],"是否会超越":["59.0"],"可以肯定的是":["59.0"],"我们无需实际运行代码":["59.1"],"就能通过类型的流转观察到变量的值是如何改变的":["59.1"],"类型的标记也能帮助我们确保每一处访问":["59.1"],"赋值与操作的类型是符合预期的":["59.1"],"有效减少我们需要承受的心智负担":["59.1"],"由于类型的引入":["59.1"],"的确限制了":["59.1"],"的灵活性":["59.1"],"但也增强了项目代码的健壮性":["59.1"],"并且对于其他同属于灵活性的代表特性":["59.1"],"原型链":["59.1"],"闭包以及函数等":["59.1"],"丝毫没有限制":["59.1"],"类型":["59.2","61.2","66.2","68.1","76.1","77.3","78.5","78.10","93.6","96.3","107.23","107.137"],"语法与工程":["59.2"],"我们可以从这三个部分入手":["59.2"],"来建立起一个全面":["59.2"],"系统的学习路径":["59.2"],"首先是":["59.2"],"类型能力":["59.2"],"它是最核心的部分":["59.2"],"也是学习成本最高的部分":["59.2"],"它为":["59.2"],"中的变量":["59.2"],"函数等概念提供了类型的标注":["59.2"],"同时内置了一批类型工具":["59.2"],"基于这些类型工具我们就能实现更复杂的类型描述":["59.2"],"将类型关联起来":["59.2"],"你可以从最简单的类型开始":["59.2"],"每学到一个新的类型能力就添加上去":["59.2"],"思考它和已掌握部分的交相融合":["59.2"],"大范式":["59.3"],"通过这一路线":["59.3"],"你将建立起全面的":["59.3"],"类型能力知识体系":["59.3"],"懂得如何结合使用各种类型工具来进行类型编程":["59.3"],"如何独立解决各种类型报错":["59.3"],"以及最重要的能力":["59.3"],"never":["59.4","65.2","69.1","77.3","79.15","80.39"],"类型的具体意义":["59.4"],"tsconfig":["59.4","79.1","87.2"],"这个仓库里":["59.6"],"文件的执行":["60.0"],"我们会介绍":["60.0"],"node":["60.0","60.6","79.1","107.13"],"notes":["60.1"],"这个插件会自动帮你把文件目录更改到对应的样子":["60.1"],"并且更新其他文件中对这一文件的导入语句":["60.1"],"usage":["60.1"],"gif":["60.1"],"当然":["60.1","63.4","64.1","69.8","75.1","79.1"],"内置的":["60.1"],"你可以依据自己的喜好进行添加":["60.2"],"以下的插件列表将会不定期进行更新":["60.2"],"shift":["60.3"],"enter":["60.3"],"来执行":["60.3"],"文件":["60.3","85.31"],"可以说":["60.3"],"时作为命令行的参数":["60.4"],"这里我们主要介绍通过命令行进行常用配置的方式":["60.4"],"project":["60.4","60.8","89.5","89.7"],"指定你的":["60.4"],"文件位置":["60.4"],"默认情况下":["60.4","107.52"],"会查找项目下的":["60.4"],"如果你的配置文件是":["60.4"],"script":["60.4"],"base":["60.4","86.41","107.87"],"这种":["60.4"],"就需要使用这一参数来进行配置了":["60.4"],"t":["60.4","65.1","71.5","84.2","84.4","101.27"],"transpileonly":["60.4"],"禁用掉执行过程中的类型检查过程":["60.4"],"这能让你的文件执行速度更快":["60.4"],"且不会被类型报错卡住":["60.4"],"这一选项的实质是使用了":["60.4"],"compiler":["60.4"],"只需要使用":["60.5"],"declare":["60.5","78.6","79.2","92.0"],"关键字":["60.5","107.43"],"与":["60.6","61.3","62.0","63.0","64.0","68.2","73.6","75.1","75.3","80.21","82.12","83.2","84.1","85.28","107.89"],"matcher":["60.8","86.23"],"nodejs":["60.8"],"中的":["60.8","80.39"],"逻辑执行大概是这样的":["60.8"],"resolution":["60.8"],"基于入参拼接出":["60.8"],"文件的绝对路径":["60.8"],"当路径中不包含后缀名时":["60.8"],"会按照":["60.8"],"的模块解析策略来进行处理":["60.8"],"utils":["60.8","78.10","85.8","107.38"],"会解析到":["60.8"],"path":["60.8","78.9","89.5","95.2"],"详细讲解":["61.0"],"typescript":["61.0","63.0","71.5","77.4","80.2","80.13","80.18","85.5","86.9","86.21","89.11","93.6","94.8","95.2","95.5","107.13","107.52"],"所有原始类型":["61.0"],"数组以及对象的类型标注":["61.0"],"让你能快速对":["61.0"],"male":["61.1"],"undef":["61.1"],"会":["61.2"],"被视作其他类型的子类型":["61.2"],"类型会被认为包含了":["61.2"],"func1":["61.3"],"func2":["61.3"],"func3":["61.3"],"在这里":["61.3","83.2"],"的返回值类型都会被隐式推导为":["61.3"],"只有显式返回了":["61.3"],"下面这么写也可以":["61.4"],"对于标记为可选的成员":["61.4"],"strictnullcheckes":["61.4"],"配置下会被视为一个":["61.4"],"的类型":["61.4","78.5"],"此时元组的长度属性也会发生变化":["61.4"],"比如上面的元组":["61.4"],"其长度的类型为":["61.4"],"tuplelength":["61.4"],"typeof":["61.4","64.2"],"length":["61.4","78.4","80.10","85.25","89.8"],"声明一个结构":["61.5"],"然后使用这个结构来作为一个对象的类型标注即可":["61.5"],"idescription":["61.5"],"此时将会产生一个类型报错":["61.6"],"不能调用可能是未定义的方法":["61.6"],"但可选属性标记不会影响你对这个属性进行赋值":["61.6"],"即使你对可选属性进行了赋值":["61.6"],"仍然会使用":["61.6"],"接口的描述为准":["61.6"],"进行类型检查":["61.6"],"来代替接口结构描述对象":["61.7"],"而我更推荐的方式是":["61.7"],"tmp13":["61.8"],"x":["61.8","70.1","76.1"],"tmp14":["61.8"],"tmp15":["61.8"],"tmp16":["61.8"],"在任何情况下":["61.8"],"你都不应该使用这些装箱类型":["61.8"],"的引入就是为了解决对":["61.8"],"类型的错误使用":["61.8"],"它代表":["61.8"],"所有非原始类型的类型":["61.8"],"即数组":["61.8"],"对象与函数类型这些":["61.8"],"tmp17":["61.8"],"tmp18":["61.8"],"需要稍微转换一下思维方式":["61.9"],"我建议你可以从现在开始":["61.9"],"有意识地在日常开发中去多多使用它们":["61.9"],"另外":["61.9","83.13","86.6","86.42","88.1"],"这一修饰符":["61.9"],"uniquesymbolfoo":["61.11"],"linbudu":["61.11","66.2","67.2","69.6","71.12","80.40","86.8"],"类型不兼容":["61.11"],"uniquesymbolbar":["61.11"],"实际值会来自于一组确定值的集合":["62.0"],"failure":["62.2"],"any":["62.2","64.0","69.0","70.1","78.7","83.3","83.4","83.5","84.4","86.14"],"bool":["62.4"],"为什么说字面量类型比原始类型更精确":["62.4"],"我们可以看这么个例子":["62.4"],"报错":["62.4","72.1","78.2"],"不能将类型":["62.4","69.1"],"user":["62.6","87.2"],"vip":["62.6"],"expires":["62.6"],"promotion":["62.6"],"如果要实现一个对象字面量类型":["62.8"],"在这个例子中":["62.10"],"的值依次是":["62.10"],"如果你只为某一个成员指定了枚举值":["62.10"],"那么之前未赋值成员仍然会使用从":["62.10"],"递增的方式":["62.10"],"之后的成员则会开始从枚举值递增":["62.10"],"在数字型枚举中":["62.10"],"你可以使用延迟求值的枚举值":["62.10"],"比如函数":["62.10"],"returnnum":["62.10"],"你":["62.12"],"只能通过枚举成员访问枚举值":["62.12"],"而不能通过值访问成员":["62.12"],"在编译产物中并不会存在一个额外的辅助对象":["62.12"],"你可以将如用户类型与请求状态码这一类属性的类型":["62.14"],"要解答这个现象":["62.18"],"需要你回想":["62.18"],"中独有或相比":["63.0"],"更加完全的概念":["63.0"],"重载":["63.0"],"这个变量进行类型声明":["63.2"],"这里的":["63.2","68.0","88.4"],"看起来很眼熟":["63.2"],"对吧":["63.2"],"但没有返回值":["63.3"],"bar":["63.3","80.22","82.10","83.8"],"原因和我们在原始类型与对象类型一节中讲到的":["63.3"],"需要注意的是":["63.4","64.8","70.3","71.2","75.1","79.10","85.15","86.22","87.2"],"可选参数必须位于必选参数之后":["63.4"],"毕竟在":["63.4"],"中函数的入参是按照位置":["63.4"],"形参":["63.4"],"而不是按照参数名":["63.4"],"名参":["63.4"],"进行传递":["63.4"],"我们也可以直接将可选参数与默认值合并":["63.4"],"res1":["63.5","75.2"],"res2":["63.5"],"asyncgenfunc":["63.6"],"asynciterable":["63.6"],"函数与异步":["63.6"],"print":["63.8"],"addon":["63.8"],"void":["63.8","65.7","66.8","71.8","78.7","84.3","85.5","94.6","107.30","107.44","107.45"],"and":["63.8"],"propa":["63.8","63.9"],"我们通常不会为构造函数添加修饰符":["63.9"],"abstract":["63.11","63.12","63.15"],"关键字声明":["63.11"],"absfoo":["63.11"],"absprop":["63.11"],"absgetter":["63.11"],"absmethod":["63.11"],"抽象类中的成员也需要使用":["63.11"],"关键字才能被视为抽象类成员":["63.11"],"如这里的抽象方法":["63.11"],"我们可以实现":["63.11"],"implements":["63.11","107.43"],"一个抽象类":["63.11"],"foo":["63.11","71.2","71.4","76.4","80.12","80.13","80.22","80.32","82.10","86.4","86.14"],"static":["63.12","84.1","84.4"],"抽象类":["63.12"],"以及":["63.12","83.1","89.0","96.21"],"override":["63.12"],"等在":["63.12"],"方法时":["63.14"],"此时":["63.14","86.25"],"类内部全部都是静态成员":["63.14"],"我们也并不希望真的有人去实例化这个类":["63.14"],"此时就可以使用私有构造函数来阻止它被错误地实例化":["63.14"],"throw":["63.15","79.8"],"error":["63.15","79.8","80.2","88.4"],"invalid":["63.15"],"当然不":["63.15"],"基于开放封闭原则":["63.15"],"我们应当将登录的基础逻辑抽离出来":["63.15"],"不同的登录方式通过扩展这个基础类来实现自己的特殊逻辑":["63.15"],"提供的内置类型在类型世界里获得更好的编程体验":["64.0"],"首先是内置的可用于标注的类型":["64.0"],"包括":["64.0","79.9","89.0"],"unknown":["64.0","64.4","70.5","84.3"],"baz":["64.1"],"prop1":["64.1"],"类型的主要意义":["64.1"],"其实就是为了表示一个":["64.1"],"无拘无束的":["64.1"],"它能兼容所有类型":["64.1"],"也能够被所有类型兼容":["64.1"],"这一作用其实也意味着类型世界给你开了一个外挂":["64.1"],"无论什么时候":["64.1"],"你都可以使用":["64.1"],"类型跳过类型检查":["64.1"],"运行时出了问题就需要你自己负责了":["64.1"],"的本质是类型系统中的顶级类型":["64.1"],"即":["64.1","64.2","66.5","67.2","71.6","78.10","79.19","85.10","85.13","86.21","86.35","87.2"],"top":["64.1","91.7","91.8"],"这是许多类型语言中的重要概念":["64.1"],"我们会在类型层级部分讲解":["64.1"],"类型的万能性也导致我们经常滥用它":["64.1"],"比如类型不兼容了就":["64.1"],"一下":["64.1"],"类型不想写了也":["64.1"],"不确定可能会是啥类型还是":["64.1"],"此时的":["64.1"],"就变成了令人诟病的":["64.1"],"anyscript":["64.1"],"为了避免这一情况":["64.1"],"我们要记住以下使用小":["64.1"],"等同于":["64.2"],"语句后的代码":["64.2"],"dead":["64.2"],"code":["64.2","79.15"],"我们也可以显式利用它来进行类型检查":["64.2"],"即上面在联合类型中":["64.2"],"类型神秘消失的原因":["64.2"],"假设":["64.2","85.10"],"我们需要对一个联合类型的每个类型分支进行不同处理":["64.2"],"strornumorbool":["64.2"],"str":["64.2","101.57","107.38"],"else":["64.2","70.3","82.10","86.3","101.35"],"includes":["64.3","67.7"],"tofixed":["64.3"],"但是类型断言的正确使用方式是":["64.3"],"类型分析不正确或不符合预期时":["64.3"],"将其断言为此处的正确类型":["64.3"],"handler":["64.4","72.5","78.4"],"此时它会提醒你先断言到":["64.4"],"再断言到预期类型":["64.4"],"就像这样":["64.4"],"而可选链则会在某一个部分收到":["64.5"],"时直接短路掉":["64.5"],"不会再发生后面的调用":["64.5"],"非空断言的常见场景还有":["64.5"],"document":["64.5"],"queryselector":["64.5"],"array":["64.5","70.2","96.1"],"find":["64.5","67.7"],"方法等":["64.5","87.8"],"element":["64.5"],"id":["64.5","120.1"],"的使用场景":["64.6"],"在下一节":["64.6"],"我们会开始对":["64.6"],"这些装箱类型":["64.8"],"原始类型与对象类型":["64.8"],"字面量类型":["64.8","69.4"],"即更精确的原始类型与对象类型嘛":["64.8"],"并不是字面量类型的子类型":["64.8"],"最底层的":["64.8"],"实际上这个层级链并不完全":["64.8"],"因为还有联合类型":["64.8"],"为了满足各种需求下的类型定义":["65.0"],"我们通常会结合使用这些类型工具":["65.0"],"因此":["65.0","65.4","79.19","86.35"],"我们一定要清楚这些类型工具各自的使用方法和功能":["65.0"],"所以":["65.0"],"接下来我们会用两节课的时间来聊聊这些类型工具":["65.0"],"我们后面会详细了解":["65.1"],"在类型别名中":["65.1"],"类型别名可以这么声明自己能够接受泛型":["65.1"],"我称之为泛型坑位":["65.1"],"一旦接受了泛型":["65.1"],"我们就叫它工具类型":["65.1"],"factory":["65.1","79.13","83.2","84.1"],"虽然现在类型别名摇身一变成了工具类型":["65.1"],"但它的基本功能仍然是创建类型":["65.1"],"只不过工具类型能够接受泛型参数":["65.1"],"实现":["65.1"],"更灵活的类型创建功能":["65.1"],"从这个角度看":["65.1"],"工具类型就像一个函数一样":["65.1"],"泛型是入参":["65.1"],"内部逻辑基于入参进行某些操作":["65.1"],"再返回一个新的类型":["65.1"],"比如在上面这个工具类型中":["65.1"],"我们就简单接受了一个泛型":["65.1"],"然后把它作为联合类型的一个成员":["65.1"],"返回了这个联合类型":["65.1"],"从另外一个角度来看":["65.2"],"其实就是一个新的":["65.2"],"同时包含":["65.2"],"两个接口所有属性的类型":["65.2"],"这里是对于对象类型的合并":["65.2"],"那对于原始类型呢":["65.2"],"strandnum":["65.2"],"我们可以看到":["65.2"],"它竟然变成":["65.2"],"了":["65.2","87.4"],"目前很多社区的学习教程并没有这一点进行说明":["65.3"],"实际上这三者都是独立的类型工具":["65.3"],"但由于":["65.4"],"obj":["65.4","80.40","96.9"],"prop":["65.4","85.4"],"形式的访问会将":["65.4"],"数字索引访问转换为字符串索引访问":["65.4"],"也就是说":["65.4","77.3","96.11"],"的效果是一致的":["65.4"],"fookeys":["65.5"],"如果觉得不太好理解":["65.5"],"propatype":["65.6"],"propbtype":["65.6"],"看起来这里就是普通的值访问":["65.6"],"但实际上这里的":["65.6"],"都是":["65.6"],"字符串字面量类型":["65.6"],"prop4":["65.7"],"stringifiedfoo":["65.7"],"等价于":["65.7"],"创建一组类型集合":["65.8"],"满足其中一个类型即满足这个联合类型":["65.8"],"交叉类型":["65.8"],"类型的安全保":["66.0"],"障同样属于类型工具的能力之一":["66.0"],"上不存在属性":["66.2"],"replace":["66.2"],"linbudu599":["66.2"],"奇怪的事情发生了":["66.2"],"我们只是把逻辑提取到了外面而已":["66.2"],"返回了":["66.2"],"肯定也是":["66.2"],"类型啊":["66.2"],"想象类型控制流分析这条河流":["66.2"],"刚流进":["66.2"],"就戛然而止了":["66.2"],"这个函数在另外一个地方":["66.2"],"因此在":["66.3","68.2"],"分支中":["66.3"],"都会被保留":["66.3"],"那在":["66.3"],"分支中就只剩下":["66.3"],"这个时候肯定有人想问":["66.3"],"为什么":["66.3"],"不能用来区分":["66.3"],"答案很明显":["66.3"],"因为它同时存在两个类型中不具有辨识度":["66.3"],"而":["66.3","70.2","73.7","77.3","80.11","83.2","85.8","85.22","85.32","86.12","86.27","87.8","89.3","107.16"],"是各个类型独有的属性":["66.3"],"因此可以作为":["66.3"],"可辨识属性":["66.3"],"discriminant":["66.3"],"property":["66.3","73.3","86.23"],"tagged":["66.3"],"又因为存在这样具有区分能力的辨识属性":["66.3"],"可以称为":["66.3"],"可辨识联合类型":["66.3"],"discriminated":["66.3"],"unions":["66.3"],"为此":["66.4"],"版本专门引入了":["66.4"],"asserts":["66.4"],"关键字来进行断言场景下的类型守卫":["66.4"],"比如前面":["66.4"],"方法的签名可以是这样的":["66.4"],"condition":["66.4","75.2"],"msg":["66.4"],"原来对类型也是有这么多花样的":["66.5"],"原来类型编程真是对类型进行编程":["66.5"],"在类型守卫部分":["66.5"],"类似的":["66.7","67.2","74.1","78.13","80.2","84.7"],"如果你直接声明多个同名接口":["66.7"],"虽然接口会进行合并":["66.7"],"func":["66.8","86.22","89.8"],"去认识这些类型世界的新朋友们":["67.0"],"如果说":["67.0"],"是一门对类型进行编程的语言":["67.0"],"partial":["67.1"],"工具类型":["67.1"],"会将传入的对象类型复制一份":["67.1"],"但会额外添加一个":["67.1"],"还记得这代表什么吗":["67.1"],"可选":["67.1"],"也就是说现在我们获得了一个属性均为可选的山寨版":["67.1"],"成立":["67.2","73.7"],"联合类型子集均为联合类型的子类型":["67.2"],"更复杂":["67.2"],"因为在":["67.2"],"的基础上增加了额外的类型":["67.2"],"这个例子表明":["67.3"],"多泛型参数其实就像接受更多参数的函数":["67.3"],"其内部的运行逻辑":["67.3"],"类型操作":["67.3"],"会更加抽象":["67.3"],"表现在参数":["67.3"],"泛型参数":["67.3"],"需要进行的逻辑运算":["67.3"],"statussucceed":["67.4"],"handleoperation":["67.4"],"而泛型嵌套的场景也非常常用":["67.4"],"填充为字面量类型":["67.5"],"填充为基础类型":["67.5"],"你也可以将鼠标悬浮在表达式上":["67.5"],"来查看填充的泛型信息":["67.5"],"img":["67.5","71.4","78.13","89.11","107.65","107.70","107.76","107.96","107.103","107.106","107.130","107.133","107.139"],"再看一个例子":["67.5"],"swap":["67.5"],"u":["67.5","77.2"],"start":["67.5","83.3","107.92"],"end":["67.5"],"swapped1":["67.5"],"swapped2":["67.5"],"swapped3":["67.5"],"在这里返回值类型对泛型参数进行了一些操作":["67.5"],"而同样你可以看到其调用信息符合预期":["67.5"],"函数中的泛型同样存在约束与默认值":["67.5"],"ele":["67.6"],"第一种":["67.7","77.2"],"reduce":["67.7"],"prev":["67.7"],"curr":["67.7","80.41"],"idx":["67.7","80.41"],"基于调用时类型推导来自动填充类型参数":["67.8"],"从而让多个位置上的类型存在约束或关联":["67.8"],"函数明明需要的是一只猫":["68.0"],"bark":["68.1"],"这个时候为什么却没有类型报错了":["68.1"],"结构化类型系统认为":["68.1"],"类型完全实现了":["68.1"],"至于额外的方法":["68.1"],"可以认为是":["68.1"],"类型继承":["68.1"],"类型后添加的新方法":["68.1"],"即此时":["68.1"],"在结构化类型系统中":["68.2"],"分别代表美元单位与人民币单位":["68.2"],"被认为是两个完全一致的类型":["68.2"],"usdcount":["68.3"],"addcny":["68.3"],"source":["68.3","83.10","89.1","89.4","89.6"],"报错了":["68.3"],"这一实现方式本质上只在类型层面做了数据的处理":["68.3"],"在运行时无法进行进一步的限制":["68.3"],"我们还可以从逻辑层面入手进一步确保安全性":["68.3"],"逻辑层面":["68.4"],"出发去模拟标称类型系统":["68.4"],"如果你在实际上的业务代码中遇到过单位转换这种类型问题":["68.4"],"不妨考虑使用这种方式":["68.4"],"来进一步提升项目中类型的安全性":["68.4"],"我想":["68.4"],"中即是结构化类型系统":["68.6"],"确保":["68.6"],"类型遵循类型系统下的类型兼容性":["68.6"],"对于静态类型语言":["68.6"],"编译时":["68.6"],"进行":["68.6"],"中所有类型的兼容关系":["69.0"],"从最上面一层的":["69.0"],"nevertype":["69.1"],"分配给类型":["69.1"],"对于变量":["69.1"],"变量":["69.1"],"result4":["69.2"],"结论":["69.4"],"包含此字面量类型的联合类型":["69.4"],"原始类型":["69.4"],"包含此原始类型的联合类型":["69.4"],"而如果一个联合类型由同一个基础类型的类型字面量组成":["69.4"],"那这个时候情况又有点不一样了":["69.4"],"既然你的所有类型成员都是字符串字面量类型":["69.4"],"那你岂不就是我":["69.4"],"类型的小弟":["69.4"],"然后自己实现了这些方法":["69.5"],"当然可以":["69.5"],"在结构化类型系统的比较下":["69.5"],"会被认为是":["69.5"],"的子类型":["69.5","75.3","76.1"],"这里从":["69.5"],"看起来构建了一个类型链":["69.5"],"但实际上":["69.5"],"并不成立":["69.5"],"tmp":["69.5","80.23"],"由于结构化类型系统这一特性的存在":["69.5"],"我们能得到一些看起来矛盾的结论":["69.5"],"result27":["69.6"],"result28":["69.6"],"result29":["69.6"],"result35":["69.7"],"result36":["69.7"],"也就意味着所有条件均成立":["69.8"],"结合上面的结构化类型系统与类型系统设定":["69.8"],"我们还可以构造出一条更长的类型层级链":["69.8"],"verbosetypechain":["69.8"],"budulin":["69.8"],"result40":["69.9"],"result41":["69.9"],"result42":["69.9"],"我们还了解了":["69.10"],"联合类型的子类型判定":["69.10"],"基于结构化类型系统的子类型判定":["69.10"],"基于类型系统基本规则":["69.10"],"本节代码见":["70.0"],"universaladd":["70.1"],"bigint":["70.1"],"y":["70.1","75.2","82.13"],"as":["70.1","76.8","84.2","84.3"],"当我们调用这个函数时":["70.1"],"由于两个参数都引用了泛型参数":["70.1"],"因此泛型会被填充为一个联合类型":["70.1"],"填充为":["70.1"],"是的":["70.2"],"甚至可以和":["70.2"],"操作符一样同时提取一组不定长的类型":["70.2"],"的用法是否也让你直呼神奇":["70.2"],"上面的输入输出仍然都是数组":["70.2"],"而实际上我们完全可以进行结构层面的转换":["70.2"],"比如从数组到联合类型":["70.2"],"arrayitemtype":["70.2"],"elementtype":["70.2"],"arrayitemtyperesult1":["70.2"],"arrayitemtyperesult2":["70.2"],"arrayitemtyperesult3":["70.2"],"原理即是这里的":["70.2"],"实际上等价于":["70.2"],"除了数组":["70.2"],"结构也可以是接口":["70.2"],"提取对象的属性类型":["70.2"],"proptype":["70.2"],"写成伪代码其实就是这样的":["70.3"],"res":["70.3","88.4","96.9"],"而这里的裸类型参数":["70.3"],"其实指的就是泛型参数是否完全裸露":["70.3"],"我们上面使用数组包裹泛型参数只是其中一种方式":["70.3"],"比如还可以这么做":["70.3"],"nodistribute":["70.3"],"我们并不是只会通过裸露泛型参数":["70.3"],"因此在实际学习时其实基本没有什么压力":["70.4"],"毕竟你已经参透了它最基础的运行规则":["70.4"],"而对于":["70.4","70.5"],"其最终计算的类型是由最短的那根木板":["70.5"],"也就是最精确的那个类型决定的":["70.5"],"这样看":["70.5"],"无论如何":["70.5"],"都不会成立":["70.5"],"但作为代表任意类型的":["70.5"],"它的存在就像是开天辟地的基本规则一样":["70.5"],"如果交叉类型的其中一个成员是":["70.5"],"那短板效应就失效了":["70.5"],"此时最终类型必然是":["70.5"],"tmp4":["70.5"],"并不能享受到这个待遇":["70.5"],"了解类型系统的概念":["71.0"],"再结合小册中对类型编程":["71.0"],"大范式进行的分类解析":["71.0"],"再复杂的类型编程也会被你所掌握的":["71.0"],"并集":["71.1"],"差集":["71.1"],"补集":["71.1"],"集合工具类型":["71.1"],"基于":["71.1"],"可选标记不等于修改此属性类型为":["71.2"],"原类型":["71.2"],"如以下的接口结构":["71.2"],"interface":["71.2","73.4","79.15","79.16","84.2"],"optional":["71.2"],"如果你声明一个对象去实现这个接口":["71.2"],"它仍然会要求你提供":["71.2"],"属性":["71.2","79.9","85.6"],"也进行修饰":["71.3"],"需要怎么改进":["71.3"],"现在的属性修饰是全量的":["71.3"],"exclude":["71.4","71.5"],"首先来看":["71.4"],"它接受两个泛型参数":["71.4"],"即是我们会进行结构处理的原类型":["71.4"],"一般是对象类型":["71.4"],"则被约束为":["71.4"],"类型的键名联合类型":["71.4"],"由于泛型约束是立即填充推导的":["71.4"],"即你为第一个泛型参数传入":["71.4"],"类型以后":["71.4"],"的约束条件会立刻被填充":["71.4"],"因此在你输入":["71.4"],"时会获得代码提示":["71.4"],"并不这么要求":["71.5"],"官方团队的考量是":["71.5"],"可能存在这么一种情况":["71.5"],"omit1":["71.5"],"k":["71.5","76.3","76.8","77.3","86.35"],"keyof":["71.5","75.8","76.8"],"而差集":["71.6"],"也是类似":["71.6"],"但需要注意的是":["71.6"],"差集存在相对的概念":["71.6"],"的差集与":["71.6"],"的差集并不一定相同":["71.6"],"而交集则一定相同":["71.6"],"为了便于理解":["71.6"],"我们也将差集展开":["71.6"],"seta":["71.6"],"setb":["71.6"],"aexcludeb":["71.6"],"bexcludea":["71.6"],"可能存在不同的需求":["71.7"],"比如合并时":["71.7"],"arg":["71.8","72.5"],"funcfoo":["71.8"],"funcbar":["71.8"],"在学习完毕本节内容以后":["71.10"],"你可能会发现某些工具类型很好地解决了曾困扰你的问题":["71.10"],"试用一下":["71.12"],"tmp1":["71.12"],"tmp2":["71.12"],"实际上":["72.0","76.4","80.43"],"中还存在着另一种类型推导":["72.0"],"它默默无闻却又无处不在":["72.0"],"它就是这一节的主角":["72.0"],"这就是上下文类型的核心理念":["72.1"],"基于位置的类型推导":["72.1"],"相对于我们上面提到的基于开发者输入进行的类型推导":["72.1"],"上下文类型更像是":["72.1"],"反方向的类型推导":["72.1"],"也就是":["72.1","85.10"],"基于已定义的类型来规范开发者的使用":["72.1"],"在上下文类型中":["72.1"],"我们实现的表达式可以只使用更少的参数":["72.1"],"而不能使用更多":["72.1"],"这还是因为上下文类型基于位置的匹配":["72.1"],"一旦参数个数超过定义的数量":["72.1"],"那就没法进行匹配了":["72.1"],"正常":["72.1"],"result1":["72.2"],"result2":["72.2"],"result3":["72.2"],"这一节比较轻松对吧":["72.3"],"那在下一节":["72.3"],"我们会学习一个稍微复杂点的概念":["72.3"],"otherfactory":["72.5"],"这个时候":["72.5"],"我们实际上就是在":["72.5"],"再看一个更明显的例子":["72.5"],"它的类型层级又是怎么样的":["73.0"],"下面这几个函数类型之间的兼容性如何":["73.0"],"foofunc":["73.0"],"对于函数参数":["73.1"],"实际上类似于我们在类型系统层级时讲到的":["73.1"],"如果一个值能够被赋值给某个类型的变量":["73.1"],"那么可以认为这个值的类型为此变量类型的子类型":["73.1"],"如一个简单接受":["73.1"],"类型参数的函数":["73.1"],"makedogbark":["73.1"],"它在调用时只可能接受":["73.1"],"类型或":["73.1"],"类型的子类型":["73.1"],"而不能接受":["73.1"],"类型的父类型":["73.1"],"没问题":["73.1"],"不行":["73.1"],"逆变":["73.2"],"contravariance":["73.2"],"在函数签名类型中的表现形式":["73.2"],"这两个单词最初来自于几何学领域中":["73.2"],"随着某一个量的变化":["73.2"],"随之变化一致的即称为协变":["73.2"],"而变化相反的即称为逆变":["73.2"],"用":["73.2"],"的思路进行转换":["73.2"],"即如果有":["73.2"],"b":["73.2","91.5","101.9","101.60"],"协变意味着":["73.2"],"wrapper":["73.2","73.7"],"但在禁用了":["73.3"],"并不会抛出错误":["73.3"],"这是因为":["73.3"],"在默认情况下":["73.3"],"对函数参数的检查采用":["73.3"],"双变":["73.3"],"bivariant":["73.3"],"即逆变与协变都被认为是可接受的":["73.3"],"eslint":["73.3","89.3"],"有这么一条规则":["73.3"],"method":["73.3","73.4"],"signature":["73.3","73.4"],"style":["73.3","95.2"],"它的意图是约束在接口中声明方法时":["73.3"],"需要使用":["73.3"],"而非":["73.3"],"形式":["73.3"],"来为":["73.4"],"内的函数声明启用严格的检查模式":["73.4"],"如果你的项目内已经配置了":["73.4"],"不妨添加上":["73.4"],"dog":["73.6","78.9"],"cat":["73.6"],"readonly":["73.7","79.2","88.2"],"即在不可变的":["73.7"],"pv":["74.0"],"uv":["74.0"],"数据更喜人":["74.0"],"我为什么需要了解它们":["74.0"],"都应该秉持着从实用性出发的角度来看待":["74.1"],"还有盯着":["74.1"],"源码读":["74.1"],"类型编程还没入门就去刷":["74.1"],"challenges":["74.1"],"等等误区":["74.1"],"当你发现学习进度慢得感人":["74.1"],"掉发进度快得吓人":["74.1"],"真的不会怀疑人生吗":["74.1"],"我个人更偏向于实用主义":["74.1"],"就像这本小册一直到现在":["74.1"],"以及接下来的内容都是接地气的":["74.1"],"不存在你学了却无处可用的知识":["74.1"],"这也是我认为在学习一门编程语言":["74.1"],"工具":["74.1","88.5"],"框架时最应该先考虑的事情":["74.1"],"一门技术":["74.1"],"要么应当能够在当下或者可预见的未来给予你帮助":["74.1"],"要么能够扩宽你的技术视野和知识边界":["74.1"],"类型体操并不完全算":["74.1"],"而类型体操对于新人来说除了徒增焦虑并没有任何意义":["74.1"],"现在我们可以来回答下开始的问题了":["74.1"],"其中搜集了许多类型编程的题目":["74.2"],"并且贴心地按照难易程度分为了":["74.2"],"easy":["74.2"],"medium":["74.2"],"hard":["74.2"],"可以先回到前面的章节复习":["75.0"],"巩固":["75.0"],"再学不迟":["75.0"],"来递归剔除所有属性的":["75.1"],"就像":["75.1"],"的关系一样":["75.1"],"也有自己的另一半":["75.1"],"deepnullable":["75.1"],"conditional":["75.2"],"resolved":["75.2"],"rejected":["75.2"],"valuetypefilter":["75.2"],"positive":["75.2"],"看起来好像很完美":["75.2"],"但这里基于条件类型的比较是否让你想到了某个特殊情况":["75.2"],"即在联合类型的情况下":["75.2"],"通过泛型参数传入":["75.2"],"会被视为是合法的":["75.2"],"这是由于分布式条件类型的存在":["75.2"],"而有时我们希望对联合类型的比较是全等的比较":["75.2"],"还记得我们说怎么禁用分布式条件类型吗":["75.2"],"让它不满足裸类型参数这一条即可":["75.2"],"wrapped":["75.2"],"n":["75.2","77.2","77.3","85.24","85.32"],"在这里我们也只需要简单进行改动即可":["75.2"],"strictconditional":["75.2"],"看起来好像没问题":["75.2"],"但这里其实不够完美":["75.2"],"比如下面这种情况":["75.2"],"objectdifference":["75.3"],"objectcomplement":["75.3"],"需要注意的是在":["75.3"],"意味着":["75.3"],"但在属性组成的集合类型中却相反":["75.3"],"的属性联合类型是":["75.3"],"的属性联合类型的子类型":["75.3"],"funcbaz":["75.4"],"arg1":["75.4"],"arg2":["75.4"],"foolastparameter":["75.4"],"barlastparameter":["75.4"],"bazlastparameter":["75.4"],"一路走来甚是不易":["75.5"],"我们用了":["75.5"],"节":["75.5"],"总计约":["75.5"],"7w":["75.5"],"字的内容":["75.5"],"来完成对":["75.5"],"会使用基于结构化类型的比较":["75.7"],"也就意味着由于":["75.7"],"可以视为继承自":["75.7"],"是不满足条件的":["75.7"],"但是":["75.7"],"如果这里的":["75.7"],"q":["75.8"],"知道它的表现就像":["76.0"],"中的函数参数一样":["76.0"],"这也意味着它并没有实际意义":["76.1"],"此时就是一个无法改变的模板字符串类型":["76.1"],"但所有":["76.1"],"开头的字面量类型都会被视为":["76.1"],"很明显":["76.1","86.35"],"模板字符串类型的主要目的即是增强字符串字面量类型的灵活性":["76.1"],"进一步增强类型和逻辑代码的关联":["76.1"],"通过模板字符串类型你可以这样声明你的版本号":["76.1"],"version":["76.1","93.12"],"v1":["76.1"],"如果反过来":["76.2"],"很显然是不成立的":["76.2"],"然而":["76.3","79.14"],"如果我们想要在复制时小小的修改下键名要怎么做":["76.3"],"比如从":["76.3"],"到":["76.3","76.6"],"modified":["76.3"],"修改键值类型我们都很熟练了":["76.3"],"但要修改键名":["76.3"],"我们就需要本节的新朋友搭把手才可以":["76.3"],"我们直接看如何基于重映射来修改键名":["76.3"],"copiedfoo":["76.4"],"这是":["76.4"],"中首次引入了":["76.4"],"能直接改变类型本身含义":["76.4"],"的工具类型":["76.4"],"你肯定对它们的内部实现非常有兴趣":["76.4"],"然而当你跳转到源码定义时却会发现它们的定义是这样的":["76.4"],"s":["76.4","79.6"],"intrinsic":["76.4"],"再次使用模板插槽注入到了新的字符串类型中":["76.5"],"来实际使用一下":["76.5"],"reversedtomhardy":["76.5"],"reversedlinbudu":["76.5"],"split":["76.6","77.3"],"从":["76.6","77.0","85.13"],"我们在上一节说到":["77.0"],"对模板字符串类型中使用模式匹配时":["77.0"],"本质上就是在一个字符串字面量类型结构做处理":["77.0"],"因此我们可以复刻一个字符串类型的值拥有的大部分方法":["77.0"],"trim":["77.0"],"当字符串":["77.1"],"为空字符串时":["77.1"],"我们判断":["77.1"],"是否是空字符串来直接决定返回结果":["77.1"],"因为很明显":["77.1"],"是不成立的":["77.1"],"不为空字符串时":["77.1"],"我们才会真的进行":["77.1"],"的判断":["77.1"],"均为空字符串的情况下":["77.1"],"我们直接返回":["77.1"],"否则我们才进行模式匹配":["77.1"],"而提到模板字符串类型中的空字符串":["77.1"],"我们会想到":["77.1"],"三兄弟":["77.1","79.9"],"去除起始部分空格的":["77.1"],"trimstart":["77.1"],"去除结尾部分空格的":["77.1"],"trimend":["77.1"],"以及开头结尾空格一起去的":["77.1"],"基于模式匹配的思路我们还是很容易进行对应的类型实现":["77.1"],"分隔符与字符串长度都是不确定的":["77.2"],"但有着模式匹配与递归":["77.2"],"没什么能难得倒我们":["77.2"],"管你多长的字符串":["77.2"],"我直接一个递归":["77.2"],"delimiter":["77.2"],"fe":["77.2"],"splitres2":["77.2"],"l":["77.2","77.3"],"d":["77.2","85.20","86.39","93.2","95.1"],"splitres3":["77.2"],"这里有两种情况需要注意":["77.2"],"存在多处分割时":["77.2"],"类型进行到最后一次":["77.2"],"即无法再分割时":["77.2"],"需要直接将最后一部分给返回":["77.2"],"第二种":["77.2"],"对于空字符串作为分隔符":["77.2"],"其表现为将字符串字面量按字母进行拆分":["77.2"],"这同样与":["77.2"],"方法的实际表现一致":["77.2"],"在实际情况中":["77.2"],"我们的字符串可能包含了多种可能的分隔符":["77.2"],"即这里的":["77.2"],"可以是一个联合类型":["77.2"],"在这种情况下":["77.2"],"模板字符串中的模式匹配也能够生效":["77.2"],"它会使用这里的多个分隔符依次进行判断":["77.2"],"并在判断到其中一种就立刻成立":["77.2"],"然后将所有剩下的部分都交给最后一个插槽":["77.3"],"在上面会匹配为":["77.3"],"budu":["77.3"],"因此要实现一个自动分割的版本":["77.3"],"我们还需要一些额外的工作":["77.3"],"但思路仍然是一致的":["77.3"],"按照分隔符拆分":["77.3"],"对除首个字符串以外的字符单元进行首字母大写处理以及组装":["77.3"],"我们通过可确定的分隔符直接使用递归模式匹配拆分":["77.3"],"如果分隔符并不确定的情况下我们应该怎么做":["77.3"],"我们在上面讲到的":["77.3"],"其实就能很好地满足我们的需要":["77.3"],"delimiters":["77.3"],"splitres4":["77.3"],"我们可以使用":["77.3","96.6"],"将字符串拆分成数组":["77.3"],"然后在数组中去处理第一项以外的其他成员":["77.3"],"camelcasestringarray":["77.3"],"这个类型":["77.3"],"我们希望它能够将":["77.3"],"转化为":["77.3"],"也就是说这个数组可以分为两个部分":["77.3"],"无需处理的第一项和全部首字母大写的其余项":["77.3"],"words":["77.3"],"first":["77.3"],"capitalizestringarray":["77.3"],"在这数十节的内容里":["77.4"],"我们从内置类型基础开始":["77.4"],"一步步跨过了内置类型工具":["77.4"],"类型系统":["77.4"],"类型编程与模板字符串类型四座大山":["77.4"],"现在你可以自信地说自己已经把":["77.4"],"我们主要介绍":["78.0"],"的工程能力基础":["78.0"],"包括类型指令":["78.0"],"类型声明":["78.0","78.7"],"prettier":["78.1","80.1","80.3"],"提供的禁用检查能力":["78.1"],"错误使用此指令":["78.2"],"都能被推导出其类型":["78.3"],"而无初始值的":["78.3"],"也可以通过":["78.3"],"标注的方式来显式地标注类型":["78.3"],"但我们知道":["78.3"],"是弱类型语言":["78.3"],"表现之一即是变量可以":["78.3"],"被赋值为与初始值类型不一致的值":["78.3"],"比如上面的例子进一步改写":["78.3"],"与初始值类型不同":["78.3"],"工具类型的声明与测试等等":["78.4"],"除了手动书写这些声明文件":["78.4"],"更常见的情况是你的":["78.4"],"代码在编译后生成声明文件":["78.4"],"源代码":["78.4"],"现在我们的":["78.5"],"就具有了":["78.5"],"会为默认导入":["78.5"],"添加一个具有":["78.5"],"虽然这里的":["78.5"],"根本不存在":["78.5"],"我们也可以在":["78.5"],"中使用默认导出":["78.5"],"会自动将其加载到环境中":["78.6"],"实际上所有":["78.6"],"下的包都会自动被加载":["78.6"],"并作为":["78.6"],"模块内部":["78.6"],"的声明":["78.6"],"但这些类型定义并不一定都是通过":["78.6"],"module":["78.6","78.13","79.2","80.3","86.27","87.2","92.0","107.53"],"我们下面介绍的命名空间":["78.6"],"namespace":["78.6"],"其实也可以实现一样的能力":["78.6"],"onerror":["78.7"],"反过来":["78.7"],"在类型声明中":["78.7"],"如果我们直接声明一个变量":["78.7"],"那就相当于将它声明在了全局空间中":["78.7"],"errorreporter":["78.7"],"实际使用":["78.7"],"而如果我们就是想将它显式的添加到已有的":["78.7"],"指定的路径不断深入寻找":["78.8"],"最深的那个没有其他依赖的声明文件会被最先加载":["78.8"],"中的示例":["78.8"],"fs":["78.8","89.2","89.7"],"此时嵌套的命名空间也需要被导出":["78.9"],"blockchaincurrency":["78.9"],"类似于类型声明中的同名接口合并":["78.9"],"命名空间也可以进行合并":["78.9"],"但需要通过三斜线指令来声明导入":["78.9"],"animal":["78.9"],"protectedanimals":["78.9"],"reference":["78.9"],"这实际上是我个人编码习惯的一部分":["78.10"],"对导入语句块的规范整理":["78.10"],"在大型项目中一个文件顶部有几十条导入语句是非常常见的":["78.10"],"它们可能来自第三方库":["78.10"],"ui库":["78.10"],"项目内工具方法":["78.10"],"样式文件":["78.10"],"项目内工具方法可能又分成":["78.10"],"constants":["78.10"],"hooks":["78.10","80.43"],"config":["78.10","78.13","79.1"],"等等":["78.10","83.9","107.80"],"如果将这些所有类型的导入都混乱地堆放在一起":["78.10"],"它绝对不应该被滥用":["78.11"],"无论是相当于后门的":["78.11"],"ts":["78.11","80.26","81.8","85.6","85.14","86.42","89.5","89.7","107.9"],"ignore":["78.11"],"还是稍显安全的":["78.11"],"expect":["78.11","85.12"],"exports":["78.13","80.3"],"此时你会发现已经拥有了如臂使指的类型提示":["78.13"],"也可以直接进行导出":["78.13"],"的工程规范":["79.0"],"我们也会简要介绍":["79.0"],"组件声明指的是我们声明一个":["79.0"],"组件的方式":["79.0"],"如何结合":["79.0"],"来进行组件属性":["79.0"],"返回元素的有效性检查":["79.0"],"你也可以使用":["79.1"],"classes":["79.2"],"default":["79.2","79.8","103.11","107.55"],"scss":["79.2"],"除了这种方式":["79.3"],"中还提供了":["79.3"],"fc":["79.3"],"这一类型来支持更精确的类型声明":["79.3"],"initialstate":["79.6"],"dispatch":["79.6","79.8"],"setstateaction":["79.6"],"没有提供默认值":["79.6"],"显式提供为":["79.7"],"compare":["79.7"],"handler2":["79.7"],"unexpected":["79.8"],"received":["79.8"],"counter":["79.8","116.1","116.2"],"这一类型来自于":["79.9"],"内置":["79.9"],"在使用":["79.9"],"来引用":["79.9"],"元素时":["79.9"],"你应当使用尽可能精确的元素类型":["79.9"],"htmlinputelement":["79.9"],"htmliframeelement":["79.9"],"等":["79.9","79.13","101.1"],"而不是":["79.9","80.16"],"htmlelement":["79.9"],"这样宽泛的定义":["79.9"],"因为这些精确元素定义的内部封装了更加具体的类型定义":["79.9"],"事件入参等":["79.9"],"可能很多同学并不熟悉":["79.9"],"可以参考":["79.9"],"这篇文章来了解具体使用":["79.9"],"简单地说":["79.9"],"这个":["79.9","86.14"],"me":["79.10","115.2"],"上还具有一个泛型坑位":["79.10"],"用于指定发生此事件的元素类型":["79.10"],"我们可以在这里进一步传入":["79.10"],"这样更精确的元素类型获得更严格的类型检查":["79.10"],"除了使用":["79.10"],"作为参数类型":["79.10"],"还提供了整个函数的类型签名":["79.10"],"changeeventhandler":["79.10"],"ui":["79.12","97.10","97.22","107.57"],"lib":["79.12","85.33"],"display":["79.12"],"createelement":["79.13"],"cloneelement":["79.13"],"方法的返回值类型":["79.13"],"的注意事项":["79.14"],"status":["79.15"],"irequeststruct":["79.15"],"tdata":["79.15"],"childc":["79.16"],"被多个子组件消费的类型":["79.16"],"ispecialdatastruct":["79.16"],"中的泛型坑位以及内置类型等等":["79.17"],"这些概念其实本质上还是来自于":["79.17"],"即组件是否会接受":["79.19"],"并消费":["79.19"],"而在":["79.19"],"中并没有进行区分":["79.19"],"中又提供了":["79.19"],"vfc":["79.19"],"voidfunctioncomponent":["79.19"],"它和":["79.19"],"的区别就在于属性中不包含":["79.19"],"很难不怀疑作者的代码水平":["80.0"],"而代码优化则就是一个比较宽泛的概念了":["80.0"],"它可以指":["80.0"],"让你的代码更简洁":["80.0"],"比如不允许未使用的变量":["80.0"],"也可以指":["80.0"],"让你的代码更严谨":["80.0"],"比如不允许未声明的全局变量":["80.0"],"很多人可能存在一个误区":["80.0"],"即认为":["80.0"],"中基础的规则有冲突":["80.1"],"我们需要修改配置文件的规则":["80.1"],"最终的基本示例如下":["80.1"],"react":["80.1"],"rules":["80.1"],"jsx":["80.1"],"recommended":["80.2","80.3"],"新增这一行":["80.2"],"创建忽略文件":["80.2"],"prettierignore":["80.2"],"init":["80.2"],"build":["80.2"],"dist":["80.2","85.10","85.28","86.27"],"out":["80.2","83.8"],"如果你不希望":["80.2"],"检查代码文件的话":["80.2"],"tsx":["80.2","86.39","89.6"],"同时更新":["80.2"],"scripts":["80.2"],"src":["80.2","85.16"],"on":["80.2"],"unmatched":["80.2"],"ext":["80.2"],"fix":["80.2"],"write":["80.2"],"配置中启用":["80.3"],"root":["80.3"],"plugin":["80.3"],"基础规则":["80.3"],"严格规则":["80.3"],"其中一种":["80.6"],"或者对于原始类型与类型别名使用":["80.6"],"对于联合类型":["80.6"],"对象类型":["80.6"],"也就是实现了":["80.7"],"接口":["80.7","107.41","107.42"],"常量断言":["80.8"],"原因主要有这么几点":["80.9"],"配合":["80.9"],"naming":["80.9"],"convention":["80.9"],"规则":["80.9"],"检查接口是否按照规范命名":["80.9"],"我们要求接口的名称需要以大写字母":["80.9"],"视为":["80.11"],"而导致错误地应用默认值":["80.11"],"则只会在":["80.11"],"来约束只能使用":["80.12"],"导出类型":["80.12"],"一个简单的":["80.12"],"的函数必须被标记为":["80.14"],"c":["80.15","97.12"],"这里":["80.15"],"还是":["80.15"],"nocheck":["80.20"],"未完成迁移的文件":["80.20"],"此规则推荐与":["80.20"],"prefer":["80.20"],"非空断言可以用于移除掉一个类型中的":["80.23"],"不允许非空断言与可选链同时使用":["80.24"],"仍然是出于简化代码的考虑":["80.26"],"此规则将声明方式进行约束":["80.29"],"推荐使用第二种的":["80.29"],"作为万物起源的特性":["80.31"],"的使用在大部分情况下都是错误的":["80.31"],"别忘了它实际上表示所有非原始类型的类型":["80.31"],"对于未知的对象类型":["80.31"],"应使用":["80.31"],"很多场景下考虑到成本":["80.33"],"我们还是会使用":["80.33"],"因此实际上这条规则只被设置为":["80.33"],"warn":["80.33"],"我们可以直观区分函数的功能":["80.35"],"如是否携带副作用":["80.35"],"以及是否有返回值等":["80.35"],"同时显式指定的函数返回值类型也能在一定程度上提升":["80.35"],"首先":["80.37","86.27","89.11"],"记住我们是在写":["80.37"],"派生类的实例":["80.38"],"联合类型变量中每一条类型分支可能都需要特殊的处理逻辑":["80.39"],"此规则可以避免你新增了一个类型分支却没有为它分配对应的处理逻辑":["80.39"],"在内置类型一节":["80.39"],"我们还了解了通过":["80.39"],"类型来实现编译时的检验":["80.39"],"虽然我们知道":["80.41"],"types":["80.42","81.6","83.10"],"vite":["80.42"],"它们就是你开始提升自己代码质量的第一步":["80.43"],"校验":["81.0"],"构建":["81.0"],"类型四类":["81.0"],"在这一节我们将介绍一批":["81.0"],"类似于":["81.2","81.11","85.30"],"nodemon":["81.2"],"包":["81.6"],"但我们并没办法分辨一个包需不需要额外的类型定义":["81.6"],"有时安装了才发现没有还要再安装一次类型也挺烦躁的":["81.6"],"的功能就是在安装包时自动去判断这个包是否有额外的类型定义包":["81.6"],"并为你自动地进行安装":["81.6"],"和上面那位反过来":["81.7"],"生成":["81.7"],"代码":["81.7","86.42","107.13"],"example":["81.7"],"functionkeys":["81.8"],"requiredkeys":["81.8"],"等工具类型的实现就来自于这个库":["81.8"],"essentials":["81.8"],"仅在类型层面":["81.9"],"hello":["81.10","82.13","107.44","107.55","110.2"],"isint":["81.10"],"min":["81.10","97.21"],"max":["81.10","101.35"],"rating":["81.10"],"isemail":["81.10"],"email":["81.10"],"错误":["81.10"],"左右就是一个比较平衡的程度了":["81.11"],"使用额外的子进程来进行":["81.12"],"的类型检查":["81.12"],"需要禁用掉":["81.12"],"loader":["81.12"],"自带的类型检查":["81.12"],"我们会来了解一个对你来说可能熟悉又陌生的名词":["81.13"],"ecmascript":["81.13"],"包括它到底代表了什么":["81.13"],"一起看看":["82.0"],"都提前实现了哪些":["82.0"],"的成员都可以提交":["82.1"],"proposal":["82.1"],"进入此阶段就意味着这一提案被认为是":["82.1"],"正式":["82.1"],"的了":["82.1"],"需要对此提案的场景与api进行详尽描述":["82.1"],"要想进入":["82.1"],"需要一位":["82.1"],"成员作为负责人":["82.1"],"champion":["82.1"],"对这个提案具体的":["82.1"],"语义和现有语法的冲突风险":["82.1"],"都进行详细讨论分析":["82.1"],"draft":["82.1"],"要进入":["82.1"],"需要完成":["82.1"],"包含提案所有内容的标准文本的初稿":["82.1"],"理论上来说":["82.1"],"这一阶段的提案":["82.1"],"如果能最终被纳入规范":["82.1"],"这之后的阶段中就不会被大改了":["82.1"],"只接受增量修改":["82.1"],"因为如果要大改":["82.1"],"往往需要废弃掉整个提案":["82.1"],"让":["82.1"],"相关":["82.2"],"如基于":["82.2"],"的私有成员标注等":["82.2"],"这篇文章中我们并不关注新增的方法以及":["82.2"],"相关语法":["82.2"],"因为它们真的就是看一下文档的事":["82.2"],"对于这些新增的方法":["82.2"],"中可以通过在":["82.2"],"而在属性的读取过程中":["82.3"],"我们通常希望的是如果某一环节短路了":["82.3"],"那返回一个":["82.3"],"给我就好":["82.3"],"否则":["82.3"],"如果下面还存在对":["82.3"],"进行真值假值判断":["82.3"],"左边是":["82.4"],"都会被视为":["82.4"],"虽然是":["82.4"],"但它也是个值":["82.4"],"类比一下":["82.5"],"逻辑赋值就是":["82.5"],"先执行逻辑操作":["82.5"],"然后将结果赋值给左边的变量":["82.5"],"这一语法其实在实际开发中有奇效":["82.5"],"空值合并以及短路赋值":["82.6"],"从现在开始":["82.6"],"你可以在接下来的项目开发中不断提醒自己去使用它们":["82.6"],"看看未来的":["82.8"],"可能会是什么样的":["82.8"],"以下介绍的提案状态均以本文写作时":["82.8"],"keywords":["82.9"],"ecma":["82.9"],"tc39":["82.9"],"measures":["82.9"],"g":["82.10"],"h":["82.10"],"async":["82.10","88.2","88.4"],"只能抓瞎":["82.11"],"或者学完之后很快就忘干净了":["82.11"],"就像我一样":["82.11"],"回到这个提案":["82.11"],"它引入了部分":["82.11"],"中的核心概念":["82.11"],"除":["82.11"],"对象上的系列方法":["82.12"],"pipeasync":["82.12"],"flowasync":["82.12"],"接受一个输入值与一系列的一元函数":["82.12"],"并从第一个一元函数开始":["82.12"],"将上一次的调用结果传给下一个一元函数作为参数":["82.12"],"会在原地执行这些一元函数":["82.12"],"equals":["82.13"],"并不是":["83.0"],"中大量使用的语法":["83.0"],"至于为什么说装饰器还不是":["83.0"],"我们会在扩展阅读中介绍更多":["83.0"],"这一节我们只关注":["83.0"],"中的装饰器":["83.0"],"从基础语法到不同种类的装饰器":["83.0"],"属性装饰器":["83.1"],"在实际执行时需要以":["83.2"],"deco":["83.2"],"的形式调用":["83.2"],"方法中":["83.2","84.1"],"我们分别在":["83.2"],"上添加了方法与属性":["83.2"],"还记得":["83.2"],"es6":["83.2"],"的本质仍然是基于原型的吗":["83.2"],"上的属性实际上是":["83.2"],"静态成员":["83.2"],"也就是其实例上不会获得的方法":["83.2"],"date":["83.3","96.1","121.3"],"target":["83.3","83.4","83.5","83.8","84.3","86.27"],"methodidentifier":["83.3","83.4"],"descriptor":["83.3","83.4","83.8"],"typedpropertydescriptor":["83.3"],"originalmethodimpl":["83.3"],"val":["83.4"],"methoddecorator":["83.4"],"propertydecorator":["83.5","84.3"],"propertyidentifier":["83.5"],"parameterdecorator":["83.6"],"类装饰器才能获得这个类本身作为入参":["83.7"],"而属性装饰器应用时":["83.7"],"这个属性还未被初始化":["83.7"],"属性需要实例化才会有值":["83.7"],"这也是为什么它无法像方法装饰器那样获取到值":["83.7"],"可以看到":["83.7","89.2"],"上面的装饰器顺序依次是":["83.7"],"实例上的属性":["83.7"],"方法参数":["83.7"],"然后是":["83.7","85.14"],"静态的属性":["83.7"],"最后是":["83.7"],"类以及类构造函数参数":["83.7"],"而从这一编译结果中":["83.7"],"我们还能观察到不同类型装饰器的":["83.7"],"首先是实例上的属性":["83.7"],"然后是静态的属性":["83.7"],"最后是类以及类构造函数参数":["83.7"],"而装饰器的":["83.7"],"应用顺序":["83.7"],"则略有不同":["83.7"],"方法参数装饰器会先于方法装饰器应用":["83.7"],"关于执行顺序与应用顺序":["83.7"],"执行是":["83.7"],"装饰器求值得到最终装饰器表达式":["83.7"],"propertykey":["83.8","84.3"],"或者说":["83.9"],"中只有":["83.9"],"上方法的对应实现":["83.9"],"deleteproperty":["83.9"],"apply":["83.9"],"has":["83.9"],"这些方法其实也可以在别的对象上找到":["83.9"],"design":["83.10","85.4"],"paramtypes":["83.10"],"returntype":["83.10"],"这三个内置的元数据":["83.10"],"获取到类与类成员的类型":["83.10"],"参数类型":["83.10"],"返回值类型":["83.10"],"definetype":["83.10"],"defineparamtypes":["83.10"],"definereturntype":["83.10"],"add":["83.10","87.2"],"returntypes":["83.10"],"以及这些装饰器的入参":["83.11"],"使用场景":["83.11","107.49"],"月":["83.13"],"会议报告":["83.13"],"来了解更多":["83.13"],"装饰器进入":["83.13"],"或已经有可用的编译支持":["83.13"],"见":["83.14"],"l115":["83.14"],"这一方法的作用就是":["83.14"],"等概念":["84.0"],"这样的交友平台一个一个找":["84.1"],"择偶条件是由我自己决定的":["84.1"],"这就叫":["84.1"],"现在我觉得这样太麻烦了":["84.1"],"直接把自己的介绍":["84.1"],"择偶条件上传到世纪佳缘":["84.1"],"如果有人认为我不错":["84.1"],"就会主动向我发起聊天":["84.1"],"而这就是":["84.1"],"控制反转的实现方式主要有两种":["84.1"],"依赖查找":["84.1"],"依赖注入":["84.1"],"它们的本质其实均是":["84.1"],"将依赖关系的维护与创建独立出来":["84.1"],"其中依赖查找在":["84.1"],"中并不多见":["84.1"],"它其实就是将实例化的过程放到了另外一个新的":["84.1"],"produce":["84.1"],"promise":["84.2","88.4"],"icollected":["84.2"],"requestmethod":["84.2"],"requesthandler":["84.2"],"routerfactory":["84.2"],"ins":["84.2"],"getprototypeof":["84.2"],"rootpath":["84.2"],"getmetadata":["84.2"],"methods":["84.2"],"ownkeys":["84.2","96.6"],"collected":["84.2"],"map":["84.2","84.4","89.4"],"m":["84.2","86.35"],"public":["84.3","84.4","107.40"],"我们使用私有构造函数来避免这个类被错误地实例化":["84.3"],"毕竟它其实只是用来将这些逻辑收拢到一起":["84.3"],"然后就像我们前面说的":["84.3"],"装饰器需要进行存储与注入工作":["84.3"],"classdecorator":["84.3"],"倒简单":["84.3"],"但":["84.3"],"然后就没了":["84.4"],"我们并不需要修改":["84.4"],"的逻辑":["84.4"],"只需要调整类型即可":["84.4"],"servicekey":["84.4"],"private":["84.4","88.2","88.4"],"services":["84.4","88.2"],"容器实现":["84.5"],"这些概念可以帮助你在使用基于装饰器的工具库时":["84.5"],"更加熟悉其底层的原理":["84.5"],"derivedfoo":["84.7"],"我们还可以实现约束方法装饰器只能在同步或异步函数上调用":["84.7"],"asyncfunc":["84.7"],"为什么选择现在才讲配置呢":["85.0"],"因为在前面的工程实践中":["85.0"],"我们并不需要自己去修改":["85.0"],"脚手架已经帮我们处理好了":["85.0"],"有了实践经验":["85.0"],"decorate":["85.4"],"来自于":["85.4"],"配置":["85.4","85.23","86.30","86.42"],"website":["85.5"],"index":["85.5"],"filename":["85.5"],"linenumber":["85.5"],"columnnumber":["85.5"],"除了":["85.5"],"以外":["85.5"],"其它":["85.5"],"相关配置使用较少":["85.5"],"我们简单了解即可":["85.5"],"影响负责最终处理转换完毕":["85.5"],"组件的方法":["85.5"],"默认即为":["85.5"],"上面的代码就会给出一个错误提示":["85.6"],"在类型":["85.6"],"上不存在":["85.6"],"是否需要更改目标库":["85.6"],"请尝试将":["85.6"],"编译器选项更改为":["85.6"],"或更高版本":["85.6"],"正如我们在类型声明一节中了解的":["85.6"],"会自动加载内置的":["85.6"],"等声明文件":["85.6"],"而加载哪些文件则和":["85.6"],"配置有关":["85.6"],"表示匹配":["85.8"],"src下所有的合法文件":["85.8"],"而无视目录层级":["85.8"],"则只会匹配":["85.8"],"下的文件":["85.8"],"不会匹配":["85.8"],"这里的合法文件指的是":["85.8"],"在不包括文件扩展名":["85.8"],"如果配置为":["85.9"],"根目录就会被确定为":["85.9"],"你也可以通过这一配置":["85.9"],"所在的目录":["85.10"],"构建产物的目录结构会受到这一配置的影响":["85.10"],"outdir":["85.10","86.27"],"被配置为":["85.10"],"在上面的第一种情况下":["85.10"],"最终的产物会被全部放置在":["85.10"],"目录下":["85.10"],"保持它们在":["85.10"],"内的目录结构":["85.10"],"generated":["85.11"],"messages":["85.11"],"main":["85.11","87.2","121.7"],"mapper":["85.11"],"info":["85.11"],"包没有被包含":["85.12"],"它们也仍然能拥有完整的类型":["85.12"],"但其中的全局声明":["85.12"],"process":["85.12"],"describe":["85.12"],"等全局变量":["85.12"],"将不会被包含":["85.12"],"同时也无法再享受到基于类型的提示":["85.12"],"如果你甚至希望改变加载":["85.12"],"否则的话":["85.13"],"说明这个文件不是一个模块或者没有定义模块入口":["85.13"],"我们走默认的":["85.13"],"而对于绝对路径":["85.13"],"其只会在":["85.13"],"modules":["85.13","88.4"],"中寻找":["85.13"],"虽然导入过程被禁用了":["85.15"],"dry":["85.17"],"debug":["85.17"],"这一配置项可以改变此行为":["85.21"],"语法检查与实际构建过程":["85.22"],"如在":["85.23"],"版本新增了":["85.23"],"es2022":["85.23"],"fn":["85.24"],"arr2":["85.24"],"read":["85.24","86.23"],"o":["85.24","86.35"],"这样":["85.26","87.4"],"文件中的":["85.26"],"也就是副作用":["85.26"],"仍然能够得到执行":["85.26"],"会构建出":["85.28"],"在使用第三方库时":["85.29"],"如果你点击一个来自第三方库的变量":["85.29"],"会发现跳转的是其声明文件":["85.29"],"如果这些库提供了":["85.29"],"noemit":["85.30"],"这样独立的":["85.31"],"还是直接将其附加在生成的":["85.31"],"r":["85.32"],"则是":["85.32"],"可能会需要动态调整":["85.33"],"产物相关等几个部分":["86.0"],"简直就是两门不同的语言":["86.1"],"它们的名称均为":["86.2"],"require":["86.3"],"为了区分":["86.5"],"与对象字面量":["86.5"],"这条规则禁止了声明但没有被实际使用的":["86.5"],"部分代码逻辑检查实际上":["86.6"],"语句中对":["86.9"],"进行更妥当的处理":["86.9"],"zero":["86.11"],"one":["86.11"],"这一配置的作用":["86.12"],"就是避免你在不使用":["86.12"],"blue":["86.13"],"black":["86.13"],"参数实际上就是函数执行时指向的":["86.14"],"索引类型签名的确可以帮助你快速生成一个随意使用的接口结构":["86.15"],"但在某些时候也会带来危险":["86.15"],"比如你忘记了检查这个属性是不是真的存在":["86.15"],"声明但未使用的变量和函数参数":["86.16"],"将这个属性设置为":["86.18"],"配置会使得":["86.19"],"alwaysstrict":["86.20"],"useunknownincatchvariables":["86.20"],"其第二个入参":["86.21"],"将用于调用原函数的入参":["86.21"],"需要与原函数入参类型保持一致":["86.21"],"对于接口中的函数类型":["86.22"],"只有通过":["86.22"],"xxx":["86.23"],"的错误":["86.23"],"这条配置有时候也不完全合理":["86.24"],"如我们将初始化逻辑放在一个单独函数中":["86.24"],"比如两个不同来源的声明文件使用不同的类型声明了一个全局变量":["86.25"],"你就可以使用":["86.25"],"跳过对这些类型声明文件的检查":["86.25"],"的":["86.27","96.6","96.16","107.45"],"为":["86.27","107.3"],"es5":["86.27"],"则可以是":["86.27"],"esnext":["86.27"],"那么检查配置":["86.27"],"功能配置等自然也可以不同":["86.27"],"中定义引用关系":["86.27"],"baseurl":["86.27"],"include":["86.27","88.4"],"中必须为启用状态":["86.28"],"它通过一系列额外的配置项":["86.28"],"那样去全面分析这些关系后再进行处理":["86.30"],"此时我们可以启用":["86.30"],"它会确保每个文件都能被视为一个独立模块":["86.30"],"因此也就能够被这些构建器处理":["86.30"],"启用":["86.30"],"文件中去导入":["86.32"],"这一配置就相当于为所有":["86.33"],"文件标注了":["86.33"],"可以等价于":["86.35"],"对于默认导出的情况":["86.35"],"由于":["86.35","88.3"],"中并没有使用":["86.35"],"提供":["86.35"],"模拟":["86.35"],"一个默认导出":["86.35"],"只可能是":["86.35"],"为了解决这种情况":["86.35"],"中支持通过":["86.35"],"配置来在":["86.35"],"导入":["86.35"],"这种情况时引入额外的辅助函数":["86.35"],"进一步对兼容性进行支持":["86.35"],"如上面的代码在开启配置后的构建产物会是这样的":["86.35"],"createbinding":["86.35"],"create":["86.35","88.2","88.4","96.6","96.8","96.9"],"k2":["86.35"],"setmoduledefault":["86.35"],"仅对这些文件进行构建":["86.37"],"如何监听文件":["86.38"],"watchfile":["86.38"],"usefsevents":["86.38"],"如何监听目录":["86.38"],"watchdirectory":["86.38"],"fallbackpolling":["86.38"],"dynamicpriority":["86.38"],"synchronouswatchdirectory":["86.38"],"exist":["86.39"],"来使其它编译器也能妥善处理":["86.42"],"这两节的内容其实并不包含所有":["86.42"],"一方面":["87.0"],"过多的":["87.0"],"crud":["87.0","87.8"],"代码并没有教学意义":["87.0"],"另一方面":["87.0"],"如果要完整开发一个生产可用的":["87.0"],"homebrew":["87.1"],"brew":["87.1"],"tap":["87.1","100.2"],"service":["87.2"],"我们来简单介绍一下重要文件的功能":["87.2"],"更好地了解":["87.2"],"的开发风格":["87.2"],"路由的定义文件":["87.2"],"我们在这里去定义":["87.2"],"list":["87.2"],"post":["87.2"],"这样的请求处理逻辑":["87.2"],"应用中我们一般不会在":["87.2"],"中去处理业务逻辑":["87.2"],"通常只会处理请求入参的校验":["87.2"],"请求响应的包装":["87.2"],"具体的业务逻辑来自于":["87.2"],"cli":["87.3"],"则是其运行时所需的依赖":["87.3"],"文件中定义了我们的数据库地址":["87.3"],"支持基本上所有的主流数据库":["87.3"],"后面我们会使用免费的":["87.3"],"heroku":["87.3"],"数据库":["87.3"],"现在保持不动即可":["87.3"],"我们先将最终的":["87.3"],"部分填入":["87.3"],"然后来解释其中的语法":["87.3"],"tag":["87.3"],"cuid":["87.3"],"category":["87.3"],"相关的所有能力都被归纳在这个模块中":["87.4"],"后续你还可以继续添加如":["87.4"],"middleware":["87.4"],"的功能":["87.4"],"接着别忘了将":["87.4"],"也添加到":["87.4"],"appmodule":["87.4","87.7"],"imports":["87.4"],"其他地方的":["87.4"],"就可以使用":["87.4"],"的全家桶套餐":["87.5"],"文件夹下":["87.7"],"这一方式适用于项目规模较小的情况":["87.7"],"此时无需进行精细的模块化拆分":["87.7"],"我们只会有一个":["87.7"],"而按逻辑进行拆分的目录结构可能是这样的":["87.7"],"模式下需要让实体类继承":["87.8"],"类":["87.8","107.33"],"然后实体类上就具有了各种操作方法":["87.8"],"remove":["87.8"],"模式最早由":["87.8"],"martin":["87.8"],"fowle在":["87.8"],"企业级应用架构模式":["87.8"],"一书中命名":["87.8"],"即直接在对象上支持相关的":["87.8"],"下的代码则是这样的":["87.8"],"await":["87.9","88.4"],"createquerybuilder":["87.9"],"select":["87.9"],"where":["87.9"],"的打开方式":["88.0"],"点击":["88.1","107.67"],"deploy":["88.1"],"我们需要把应用和":["88.1"],"github":["88.1"],"仓库关联起来":["88.1"],"这样就能在每次提交时自动重新部署了":["88.1"],"首先选择":["88.1"],"connect":["88.1"],"授权完毕后选择你对应的仓库":["88.1"],"配置完毕后你会看到这样的界面":["88.1"],"enable":["88.1"],"automatic":["88.1"],"deploys":["88.1"],"我们的应用就会随着每次":["88.1"],"提交而重新部署":["88.1"],"我们此前的环境配置其实就是安装了":["88.1"],"articleservice":["88.2","88.4"],"article":["88.2"],"seedcontroller":["88.2"],"没有文件扩展名":["88.3"],"写入内容到":["88.3"],"procile":["88.3"],"ini":["88.3"],"web":["88.3"],"还有最后一步":["88.3"],"prisma":["88.3"],"需要有一步":["88.3"],"generate":["88.3"],"代码内才能访问到":["88.3"],"client":["88.3"],"createinput":["88.4"],"try":["88.4"],"catch":["88.4"],"配置意为我们希望":["88.4"],"在查询时连带返回所有文章的标签与分类信息":["88.4"],"我们直接使用":["88.4"],"生成的":["88.4"],"作为类型":["88.4"],"但这里你会发现出现了一个类型报错":["88.4"],"如果没有引用":["88.4"],"则无法命名":["88.4"],"的推断类型":["88.4"],"这很可能不可移植":["88.4"],"需要类型注释":["88.4"],"这是因为我们消费的":["88.4"],"类型来自于":["88.4"],"无法直接使用这个类型为":["88.4"],"方法完成类型推导":["88.4"],"同时我们又多了":["88.4"],"这一层":["88.4"],"为了解决这一问题":["88.4"],"我们声明一个通用的响应类型":["88.4"],"然后作为返回值类型使用":["88.4"],"以及下一代":["88.5"],"orm":["88.5"],"的基本使用":["88.5"],"的工作流程":["89.0"],"从功能角度":["89.0"],"的源码大致可以分为这么几个部分":["89.0"],"核心部分":["89.0"],"parser":["89.0","89.11"],"transformer":["89.0"],"generator":["89.0"],"它们主要负责对源码的解析":["89.0"],"转换以及生成等工作":["89.0"],"一份源码首先会被":["89.0"],"通过词法分析与语法分析":["89.0"],"转换为":["89.0"],"ast":["89.0","89.9"],"也就是抽象语法树的形式":["89.0"],"然后由":["89.0"],"createifstatement":["89.1"],"创建函数声明":["89.1"],"createfunctiondeclaration":["89.1"],"createtoken":["89.1"],"exportkeyword":["89.1"],"函数返回值类型":["89.1"],"函数体":["89.1"],"创建一个虚拟的源文件":["89.1"],"resultfile":["89.1"],"createsourcefile":["89.1"],"scripttarget":["89.1"],"latest":["89.1","93.3"],"scriptkind":["89.1"],"rmsync":["89.2","89.7"],"importdec":["89.2"],"addimportdeclaration":["89.2"],"namedimports":["89.2"],"modulespecifier":["89.2"],"新增具名导入":["89.2"],"appendfile":["89.2"],"addnamedimport":["89.2"],"设置默认导入":["89.2"],"setdefaultimport":["89.2"],"删除默认导入":["89.2"],"removedefaultimport":["89.2"],"删除命名空间导入":["89.2"],"removenamespaceimport":["89.2"],"删除这条导入声明":["89.2"],"提供了一系列直观的封装方法":["89.2"],"只要调用这些方法就可以完成对":["89.2"],"的各种操作":["89.2"],"包括新增":["89.2"],"更新":["89.2"],"的范畴":["89.3"],"关于":["89.3"],"的区别":["89.3","97.11","101.47"],"请参考扩展阅读部分":["89.3"],"lodash":["89.4","89.7"],"addsourcefileatpath":["89.4","89.6"],"resolve":["89.4","89.6","89.7"],"dirname":["89.4","89.6","89.7"],"获取所有导入声明中的模块名":["89.4"],"getimportmodulespecifiers":["89.4"],"getimportdeclarations":["89.4"],"getmodulespecifiervalue":["89.4"],"抽象类的":["89.5"],"声明":["89.5","107.14"],"为这些声明内部的":["89.5"],"方法添加":["89.5"],"装饰器":["89.5","107.69"],"完整实现如下":["89.5"],"classdeclaration":["89.5"],"morph":["89.5","89.7"],"获取默认导出":["89.6"],"exportdefaultassignment":["89.6"],"getfirstchildbykind":["89.6","89.8"],"syntaxlist":["89.6","89.8"],"extra":["89.7"],"capitalize":["89.7"],"uniq":["89.7"],"filepath":["89.7"],"ensurefilesync":["89.7"],"收集所有的函数声明":["89.8"],"getallfunctiondeclarations":["89.8"],"functiondeclarationlist":["89.8"],"getchildrenofkind":["89.8"],"收集所有存在":["89.8"],"的函数声明":["89.8"],"filteredfuncdeclarations":["89.8"],"getjsdocs":["89.8"],"操作":["89.9"],"原因上面我们也已经了解到了":["89.9"],"通过更符合直觉的":["89.9"],"封装掉了很多底层的操作":["89.9"],"然而二者的差异实际上非常大":["89.11"],"lint":["89.11"],"幸运的是我拥有许多耐心细致的读者帮我":["90.0"],"捉虫":["90.0"],"我也会在发现这些问题时第一时间改正":["90.0"],"教程的特色":["90.1"],"我们了解了结构化类型系统":["90.1"],"类型层级":["90.1"],"协变与逆变等类型系统的核心概念":["90.1"],"有必要再次重申":["90.1"],"类型系统不仅能帮助你更好地理解复杂类型编程的底层原理":["90.1"],"也能够让你获得独立解决各种类型问题的能力":["90.1"],"类型编程部分":["90.1"],"面试中的":["90.2"],"技能水平检验":["90.2"],"王文璐":["90.3"],"神光":["90.3"],"等前辈的无私创作分享":["90.3"],"在我学习":["90.3"],"在面试中出现":["91.0"],"它又会变成什么样子":["91.0"],"这可能是最经典的一道":["91.1"],"会自动合并":["91.2"],"并且在合并时会要求兼容原接口的结构":["91.2"],"这同样也代表了你对这两个工具的理解":["91.3"],"就是描述对象对外暴露的接口":["91.3"],"以及使用的深入程度":["91.4"],"包括存在意义与比较方式":["91.6"],"以及如何在":["91.6"],"类型层级中属于最顶层的":["91.8"],"这就是":["91.9"],"的存在意义":["91.9"],"这一部分就不做过多叙述了":["91.10"],"omit":["91.11"],"markaspartial":["91.12"],"pickbytype":["91.12"],"相比其它部分知识":["91.13"],"这些考点难度适中":["91.13"],"https":["93.3","107.2"],"jsdelivr":["93.3"],"net":["93.3"],"npm":["93.3","94.1"],"antd":["93.4"],"getmodulefunc":["93.7"],"produrl":["93.7"],"vite2":["93.8"],"vite3":["93.8"],"的别名":["93.11"],"全局分配给模块的变量":["93.11"],"pinia":["94.2","94.3","94.8","94.9","94.10"],"piniapluginpersistedstate":["94.2"],"进行序列化":["94.4"],"反序列化":["94.4"],"整个":["94.4"],"默认将被持久化":["94.4"],"如何你不想使用默认的配置":["94.4"],"usestore":["94.5","94.7","94.9","94.10"],"store":["94.7","94.9","94.10"],"save":["94.7"],"definestore":["94.8"],"时":["94.11","107.77"],"icons":["95.1"],"alt":["95.2"],"zoom":["95.2"],"svgclass":["95.3"],"aria":["95.3"],"hidden":["95.3"],"svg":["95.4"],"component":["95.4","107.69"],"regexp":["96.1"],"call":["96.2","101.45"],"同上结果":["96.2"],"加上call也ok":["96.2"],"的隐式转换规则":["96.3"],"如果类型相同":["96.3"],"无需进行转换":["96.3"],"如果一个操作值是":["96.3"],"那么另一个操作符必须是":["96.3"],"才会返回":["96.3"],"否则都返回":["96.3"],"如果其中有一个是":["96.3"],"那么返回":["96.3"],"两个操作值如果都为":["96.3"],"那么就会将字符串转换为":["96.3"],"它不会拷贝对象的继承属性":["96.5"],"它不会拷贝对象的不可枚举属性":["96.5"],"可以拷贝":["96.5"],"类型的属性":["96.5"],"obj1":["96.5"],"sym":["96.5"],"innumerable":["96.5"],"不可枚举属性":["96.5"],"reflect":["96.6"],"当参数是":["96.6"],"则直接生成一个新的实例返回":["96.6"],"利用":["96.6"],"getownpropertydescriptors":["96.6"],"方法可以获得对象的所有属性":["96.6"],"以及对应的特性":["96.6"],"顺便结合":["96.6"],"方法创建一个新对象":["96.6"],"并继承传入源对象的原型链":["96.6"],"weakmap":["96.6"],"类型作为":["96.6"],"hash":["96.6"],"表":["96.6"],"是弱引用类型":["96.6"],"可以有效防止内存泄漏":["96.6"],"作为检测循环引用很有帮助":["96.6"],"如果存在循环":["96.6"],"则引用直接返回":["96.6"],"存储的值":["96.6"],"iscomplexdatatype":["96.6"],"提升开发效率":["96.7"],"20240117094228124":["96.8"],"四":["96.8"],"原型式继承":["96.8"],"一是用作新对象原型的对象":["96.8"],"二是为新对象定义额外属性的对象":["96.8"],"可选参数":["96.8"],"parent4":["96.8"],"friends":["96.8"],"p1":["96.8"],"p2":["96.8","107.27"],"p3":["96.8"],"person4":["96.8"],"tom":["96.8"],"jerry":["96.8"],"person5":["96.8"],"lucy":["96.8"],"must":["96.9"],"be":["96.9","109.1"],"proto":["96.9","101.41"],"这样的组合就是闭包":["96.11"],"如果没找到":["96.12"],"workers":["96.13"],"或者任何异步中":["96.13"],"只要使用了回调函数":["96.13"],"值或对象":["96.14"],"第一个参数是需要解析处理的":["96.14"],"次方":["96.16"],"最大为":["96.16"],"math":["96.16"],"pow":["96.16"],"否则将抛出":["96.16"],"rangeerror":["96.16"],"用于将参数依次转化为数组中的一项":["96.16"],"然后返回这个新数组":["96.16"],"用来判断一个变量是否为数组类型":["96.17"],"join":["96.18"],"slice":["96.18"],"tostring":["96.18"],"tolocalstring":["96.18"],"indexof":["96.18"],"lastindexof":["96.18"],"扩展运算符实现":["96.19"],"选择排序":["96.23"],"选择排序是一种简单直观的排序方法":["96.23"],"首先将最小的元素存放在序列的起始位置":["96.23"],"再从剩余未排序元素中继续寻找最小元素":["96.23"],"然后放到已排序的序列后面":["96.23"],"以此类推":["96.23"],"直到所有元素均排序完毕":["96.23"],"selectsort":["96.23"],"minindex":["96.23"],"的相对位置不变":["96.24"],"是每一行文字的高":["97.2"],"子元素":["97.3"],"ul":["97.3"],"li":["97.3","101.39"],"子元素选择器":["97.3"],"权重值":["97.4"],"第二":["97.4"],"flex":["97.6"],"justify":["97.6"],"center":["97.6","107.92"],"align":["97.6"],"items":["97.6"],"元素前后没有换行符":["97.7"],"行内块元素":["97.7"],"的原则":["97.8"],"一个元素具有":["97.8"],"那么内部元素再怎么弄":["97.8"],"都不会影响到外面的元素":["97.8"],"clear":["97.9"],"both":["97.9"],"给前端设计图一般都是偶数":["97.10"],"normalize":["97.13"],"为了增强跨浏览器渲染的一致性":["97.13"],"优缺点":["97.14"],"占用位置区别":["97.15"],"是不占位置的":["97.15"],"虽然隐藏了":["97.15"],"但是占用位置":["97.15"],"表示完全透明":["97.16"],"表示不透明":["97.16"],"两个冒号":["97.17"],"是伪元素":["97.17"],"是为了做区分":["97.17"],"16px":["97.18"],"每个浏览器默认字体大小不一定一样":["97.18"],"是针对于父元素的":["97.19"],"height":["97.21","107.65","107.140"],"会使用自适应的布局方式":["97.22"],"的设计图":["97.22"],"笔记本电脑":["97.22"],"h6":["99.1"],"空元素":["99.1"],"br":["99.1"],"hr":["99.1"],"元素之间的转换问题":["99.1"],"所以在兼容性上":["99.2"],"场景":["99.3"],"网站的":["99.3"],"logo":["99.3"],"都是用":["99.3"],"标签包裹的":["99.3"],"图片无法加载时显示的值":["99.4"],"区别二":["99.4"],"采用压缩算法":["99.5"],"有一点失真":["99.5"],"成分会更好":["99.6"],"蜘蛛抓取更好":["99.6"],"webkit":["100.2"],"touch":["100.4"],"none":["100.5","107.84"],"textarea":["100.6"],"全部解析完成":["101.1"],"引用类型":["101.2","101.11"],"字符串和其他类型相加":["101.2"],"会被隐式转化成":["101.3"],"很不容易发现错误":["101.3"],"现有":["101.3"],"通过":["101.4"],"valueof":["101.4"],"请求":["101.5"],"定时器":["101.5"],"优先查找内部":["101.6"],"如果内部没有就查找外部的":["101.6"],"注意声明变量是用":["101.6"],"对象注意":["101.11"],"world":["101.13"],"原型考题":["101.15"],"test2":["101.19"],"newarr":["101.31","101.32"],"闭包":["101.38"],"getelementsbytagname":["101.39"],"对象查找属性或者方法的顺序":["101.41"],"super":["101.43","107.39"],"张三":["101.44","101.46","107.46"],"返回的是一个函数":["101.49"],"bind":["101.50","101.64"],"btn":["101.50"],"h1s":["101.50"],"大的数组则使用":["101.51"],"之前的版本是":["101.51"],"插入排序和快排":["101.51"],"是复制真正的值":["101.52"],"不同引用":["101.52"],"只在设置的":["101.53"],"过期时间之前有效":["101.53"],"即时窗口或者浏览器关闭":["101.53"],"也不会失效":["101.53"],"fontsize":["101.54"],"可以多次声明同一个变量":["101.55"],"箭头函数的":["101.64"],"进行中":["101.65"],"返回的是数组":["101.66"],"如果有一项匹配":["101.67"],"beforeupdate":["103.2"],"destoryed":["103.2"],"调用的时候":["103.3"],"阶段是拿不到":["103.3"],"是在异步中获取的":["103.4"],"就可以了":["103.4"],"beforecreated":["103.5"],"alive":["103.6"],"只会执行一个生命周期":["103.6"],"created":["103.7"],"beforemount":["103.7"],"个生命周期":["103.8"],"系统":["103.8"],"同步可以获取":["103.9"],"如果子组件请求后父组件请求":["103.9"],"来接收":["103.11"],"双向绑定":["103.12"],"vue2":["103.13"],"setimmediate":["103.15"],"mutationobserver":["103.15"],"宏任务":["103.15"],"the":["106.0"],"md":["106.1"],"dangerous":["106.2"],"details":["106.2"],"developer":["107.2"],"com":["107.2"],"consumer":["107.2"],"cn":["107.2","107.80"],"openharmony":["107.3"],"manager":["107.3"],"是鸿蒙生态第三方库的包管理工具":["107.3"],"支持共享包的发布":["107.3"],"安装和依赖管理":["107.3"],"harmonyos":["107.3","107.82"],"sdk":["107.3"],"配置项目":["107.4"],"可能需要调整的配置项如下":["107.4"],"其余保持默认即可":["107.4"],"配置完成后":["107.4"],"finish":["107.4"],"deveco":["107.5"],"界面效果":["107.6"],"方便随时调整界面":["107.6"],"选择模拟的安装目录":["107.7"],"完成后点击":["107.7"],"emulator":["107.7"],"选择设备类型":["107.7"],"phone":["107.7","107.80"],"系统与更新":["107.8"],"开发人员选项":["107.8"],"打开":["107.8"],"开关":["107.8","107.103"],"数据线将手机和电脑相连":["107.8"],"扩展而来":["107.9"],"在继承":["107.9"],"快速入门":["107.10"],"运行环境说明":["107.11"],"提供了一个线上的":["107.12"],"node是一个":["107.13"],"它允许我们直接运行":["107.13"],"node的安装和运行依赖于node":["107.13"],"js环境":["107.13"],"因此在安装ts":["107.13"],"便可以根据初始值进行类型推断":["107.17"],"此时我们就可以不显式指定其类型":["107.17"],"常用数据类型":["107.18"],"你好":["107.20"],"可选值为":["107.21"],"表示字符串数组":["107.22"],"数组类型的变量可由数组字面量":["107.22"],"男":["107.23","107.27","107.46"],"对象类型的声明需要包含所有属性的":["107.23"],"名称":["107.23","107.93"],"及":["107.23"],"zhagnsan":["107.27"],"lisi":["107.27"],"则可以使用":["107.30"],"foreach":["107.32"],"oop":["107.34"],"是一种编程范式":["107.34"],"其核心理念在于将程序中的数据与操作数据的方法有机地组织成对象":["107.34"],"从而使程序结构更加模块化和易于理解":["107.34"],"对象属性的访问":["107.37"],"tolowercase":["107.38"],"实现类中":["107.43"],"需要包含接口属性的赋值逻辑":["107.43"],"以及接口方法的实现逻辑":["107.43"],"student":["107.43","107.44"],"introduce":["107.44"],"am":["107.44"],"然后分别创建一个":["107.44"],"然后在订单类中增加一个":["107.45"],"的属性":["107.45"],"并且在订单类中的":["107.45"],"方法中调用":["107.45"],"可以看到变量的值为一个一般对象":["107.46"],"枚举":["107.47"],"其主要功能是定义一组有限的选项":["107.48"],"方向":["107.48"],"现需要编写一个函数":["107.49"],"move":["107.49"],"其功能是根据输入的方向":["107.49"],"上":["107.49"],"下":["107.49"],"左":["107.49"],"我们还能手动为每个属性赋值":["107.50"],"enum":["107.50"],"模块化":["107.51"],"有多种方式可以用来解决命名冲突":["107.54"],"下面逐一介绍":["107.54"],"导入重命名":["107.54"],"语法如下":["107.54"],"在继承了typescript语法的基础上":["107.56"],"开灯":["107.58","107.60"],"关灯":["107.58","107.60"],"状态":["107.58"],"所以我们可以使用一个":["107.58"],"描述界面显示效果":["107.59"],"的图片":["107.60"],"否则就会显示":["107.60"],"开发范式的大致流程":["107.61"],"下面为大家总结一下声明式":["107.61"],"所以编写界面其实就是组合组件的过程":["107.62"],"arkts":["107.62","107.100","107.107"],"提供了很多的内置组件":["107.62"],"入门案例":["107.63"],"image":["107.65"],"images":["107.65","121.7"],"png":["107.65"],"语法说明":["107.66","107.74"],"各组件支持的参数":["107.67"],"可查看":["107.67"],"文档":["107.67"],"查看方式如下":["107.67"],"首先将鼠标在相应组件悬停":["107.67"],"自定义组件":["107.68"],"除去系统预置的组件外":["107.68"],"使得自定义组件更为通用":["107.69"],"compnent":["107.69"],"装饰器用于装饰":["107.69"],"关键字声明的数据结构":["107.69"],"所以可考虑自定义一个按钮组件":["107.70"],"然后进行复用":["107.70"],"关灯案例":["107.73"],"以及以下的播放":["107.73"],"暂停案例":["107.73"],"条件渲染的语法如下":["107.74"],"语句基于一个数组来快速渲染一个组件列表":["107.76"],"例如以下案例中的选项列表就可通过循环渲染实现":["107.76"],"数组中的每个数据项生成唯一的key":["107.77"],"的作用":["107.77"],"在数组发生变化":["107.77"],"修改数组元素或者向数组增加或删除元素":["107.77"],"需要重新渲染组件列表":["107.77"],"在重新渲染时":["107.77"],"它会尽量复用原来的组件对象":["107.77"],"而不是为每个元素都重新创建组件对象":["107.77"],"key的作用就是辅助":["107.77"],"完成组件对象的复用":["107.77"],"具体逻辑如下":["107.77"],"在进行初次渲染时":["107.77"],"会使用keygenerator为数组中的每个元素生成一个唯一的key":["107.77"],"并将key作为组件对象的标识":["107.77"],"当数组发生变化导致":["107.77"],"需要重新渲染时":["107.77"],"概述":["107.79","107.86","107.95","107.109","107.120","107.127"],"可存在多种版本":["107.80"],"用于适配不同的环境":["107.80"],"例如语言环境":["107.80"],"zh":["107.80"],"cn和en":["107.80"],"us":["107.80"],"系统主题":["107.80"],"dark和light":["107.80"],"设备类型":["107.80"],"tablet":["107.80"],"我们可以为上述每种环境各自准备一套资源文件":["107.80"],"每种环境对应":["107.80"],"下的一个目录":["107.80"],"例如上述的":["107.80"],"en":["107.80"],"我们在使用resources下的资源时":["107.80"],"无需指定具体的环境版本":["107.80"],"系统会根据设备所处的环境自动选择匹配的版本":["107.80"],"例如当设备系统语言为中文时":["107.80"],"则会使用zh":["107.80"],"常用属性":["107.81","107.88","107.97","107.104","107.111","107.122"],"相同的像素个数对应的物理尺寸是不同的":["107.82"],"这样一来就会导致我们的应用在不同设备上显示的尺寸可能不同":["107.82"],"如下图所示":["107.82"],"virtual":["107.82"],"为了保证一致的观感":["107.82"],"我们可以使用虚拟像素作为单位":["107.82"],"虚拟像素是一种可根据屏幕像素密度灵活缩放的单位":["107.82"],"1vp相当于像素密度为160ppi的屏幕上的1px":["107.82"],"会根据如下公式将虚拟像素换算为对应的物理像素":["107.82"],"根据上述公式":["107.82"],"不难看出":["107.82"],"使用虚拟像素作为单位时":["107.82"],"同一尺寸":["107.82"],"在像素密度低的屏幕上":["107.82"],"单个像素的物理尺寸大":["107.82"],"contain":["107.83"],"保持宽高比进行缩小或者放大":["107.83"],"使得显示区域刚好包含整个图片":["107.83"],"cover":["107.83"],"使得图片刚好完全覆盖显示区域":["107.83"],"描述":["107.84","107.93"],"不使用图片插值":["107.84"],"high":["107.84"],"引用":["107.87"],"目录中有一个":["107.87"],"px":["107.89"],"fp":["107.89"],"font":["107.89"],"pixel":["107.89"],"为枚举类型":["107.90","107.93"],"可选枚举值如下":["107.90"],"名称描述":["107.90"],"lighter":["107.90"],"字体较细":["107.90"],"normal":["107.90","107.99"],"字体粗细正常":["107.90"],"类型的参数可用于设置":["107.91"],"rgb":["107.91"],"格式的颜色":["107.91"],"具体写法可以为":["107.91"],"首部对齐":["107.92"],"居中对齐":["107.92"],"可用枚举值有":["107.93"],"clip":["107.93"],"为按钮形状":["107.96"],"该属性的类型":["107.96"],"可选的枚举值有":["107.96","107.112"],"名称描述效果":["107.96","107.103","107.121"],"capsule":["107.96"],"胶囊形状":["107.96"],"backgroundcolor":["107.98"],"方法进行设置":["107.98"],"圆角按钮":["107.99"],"buttontype":["107.99"],"就会触发该回调函数":["107.100"],"toggle":["107.102"],"枚举类型进行设置":["107.103","107.121"],"可选的枚举值如下":["107.103","107.121"],"switch":["107.103"],"可使用":["107.105"],"selectedcolor":["107.105"],"组件中的圆形滑块颜色":["107.106"],"具体定义如下":["107.107"],"callback":["107.107"],"ison":["107.107"],"属性用于设置无输入时的提示文本":["107.110"],"效果如下":["107.110","107.123"],"inputtype":["107.112"],"枚举类型":["107.112"],"光标样式":["107.113"],"placeholdercolor":["107.114"],"方法设置":["107.114"],"fontcolor":["107.115"],"等通用属性方法进行设置":["107.115"],"相关案例见":["107.115","107.130","107.133","107.139"],"常用事件":["107.116"],"开发者可使用":["107.117","107.118"],"onchange":["107.117"],"方法为":["107.117","107.118"],"textinput":["107.117"],"onfocus":["107.118"],"onblur":["107.118"],"属性用于设置进度条类型":["107.121"],"可通过":["107.121"],"linear":["107.121","107.123"],"默认值为":["107.123"],"4vp":["107.123"],"该属性可用于":["107.123"],"ring":["107.123"],"scalering":["107.123"],"三种类型":["107.123"],"用于设置前景色":["107.124"],"用于设置背景色":["107.124"],"常用于显示一些重要的信息":["107.125"],"消息提示":["107.126"],"toast":["107.127"],"方法的参数定义如下":["107.128"],"message":["107.128"],"警告对话框":["107.129"],"具体效果如下":["107.130","107.133"],"使用说明":["107.131","107.134"],"操作列表弹框":["107.132"],"选择器弹窗":["107.135"],"文本滑动选择器弹窗":["107.136"],"文档地址":["107.137"],"自定义弹窗":["107.138"],"demos":["107.139"],"数据的组织":["109.1"],"查询":["109.1"],"让我们开始吧":["110.5","115.4"],"可以将对应的":["110.7"],"teleport":["111.2"],"body":["111.3"],"dashed":["111.5"],"link":["111.5"],"mybutton":["111.13"],"treecomponent":["111.16"],"off":["112.1","112.2"],"inc":["112.5"],"加":["112.5"],"is":["112.9","112.10"],"click":["113.3","115.1","119.2"],"count":["113.3","113.4","113.9","113.10"],"都会在":["113.14"],"组件更新":["113.14"],"之前":["113.14"],"被调用":["113.14"],"的副作用":["113.18"],"来完成它":["113.20"],"以下是你要实现的内容":["113.20","118.1"],"更新元素的文本内容":["114.6"],"onclick":["114.11","114.12"],"oh":["114.17","114.18"],"click1":["115.1"],"在这个挑战中":["115.4"],"我们将尝试它":["115.4"],"添加按键修饰符让有且只有":["115.5"],"reactivestate":["118.2"],"函数在这种场景下非常有用":["119.1"],"设计是":["121.0"],"是分散在":["121.1"],"领先":["121.3"],"所有钩子执行的":["121.3"],"01":["121.3"],"lastedittime":["121.3"],"ref对象":["121.4"],"对象的":["121.4"],"否则报错":["121.5"],"接收的数据可以是":["121.6"],"基本类型":["121.6"],"xuchp":["121.7"],"typora":["121.7"],"pics":["121.7"],"e8":["121.7"],"aa":["121.7"],"e5":["121.7"],"8a":["121.7"],"person":["121.8"],"h2":["121.8"],"姓名":["121.8"]},{"0":["0.27","0.28","0.63","0.67","0.71","0.77","0.78","1.1","55.4","58.27","58.28","58.63","58.67","58.71","58.77","58.78","76.2","83.10","85.4","101.32","101.39","107.2"],"1":["56.1","64.5","71.2","83.7","85.5","87.9","88.2","96.16","97.7","101.18","107.28","107.44","107.53","107.72","113.3"],"2":["14.0","64.5","80.1","83.7","86.11","88.2","97.11","97.17","101.8","101.49","101.53","101.64"],"3":["0.80","58.80","59.2","64.5","80.8","80.26","82.1","96.13","96.16","97.8","97.21","99.6","101.12","101.21","101.22","101.24","101.27","107.2"],"4":["0.24","0.63","0.84","0.86","9.0","19.2","56.5","56.6","58.24","58.63","58.84","58.86","59.2","61.4","75.5","82.1","85.5","101.6","101.16","106.1"],"5":["0.34","0.79","56.6","58.34","58.79","80.34","101.16"],"7":["0.82","57.1","58.82"],"8":["0.83","58.83"],"9":["0.83","58.83","80.26"],"10":["0.31","58.31","107.99"],"11":["81.10"],"12":["82.9"],"15":["0.34","58.34"],"16":["0.34","58.34"],"17":["121.3"],"18":["78.4","79.19"],"19":["90.1"],"22":["0.34","58.34"],"28":["121.3"],"29":["82.8"],"36":["105.0"],"38":["93.0"],"42":["82.9"],"67":["82.9"],"70":["0.34","58.34"],"85":["121.7"],"100":["76.2"],"111":["101.9"],"120":["107.123"],"123":["96.3"],"128":["107.91"],"175":["0.34","58.34"],"300":["107.65"],"456":["101.14"],"501":["107.2"],"599":["61.5","64.5","79.8","86.23"],"754":["0.29","58.29"],"1111":["101.59"],"1280":["97.22"],"2015":["83.13"],"2022":["82.8"],"10000":["62.0","67.2"],"10001":["62.0","67.2"],"10002":["67.2"],"50000":["62.0"],"是两个不同的变量":["0.2","58.2"],"类似地":["0.2","58.2"],"美元符号或数字":["0.3","58.3"],"单行注释":["0.4","58.4"],"块注释以一个斜杠和一个星号":["0.4","58.4"],"但它其实是一个预处理指令":["0.5","58.5"],"任何支持的":["0.5","58.5"],"引擎看到它都会切换到严格模式":["0.5","58.5"],"选择这种语法形式的目的是不破坏":["0.5","58.5"],"const":["0.7","0.22","9.0","34.2","55.1","58.7","58.22","61.2","61.5","65.7","66.8","71.2","79.16","80.10","80.22","80.39","83.2","83.4","83.8","87.4","94.3","94.8"],"finally":["0.7","58.7"],"super":["0.7","58.7","77.2"],"with":["0.7","30.0","58.7","81.6"],"try":["0.7","58.7"],"比如表示控制语句的开始和结束":["0.8","58.8"],"或者执行特定的操作":["0.8","58.8"],"protected":["0.10","58.10"],"private":["0.10","58.10","68.3","87.2","87.4"],"的所有版本中都可以使用":["0.12","58.12"],"而":["0.12","58.12","60.8","62.10","63.3","63.10","66.4","75.1","79.3","79.13","80.2","85.20","91.3","91.8"],"message":["0.13","58.13"],"window":["0.14","58.14","93.11","101.6"],"上":["0.14","58.14","79.9","89.0","107.48"],"变成全局变量":["0.14","58.14"],"去掉之前的":["0.14","58.14"],"操作符后":["0.14","58.14"],"这个就是所谓的提升":["0.15","58.15"],"hoist":["0.15","58.15"],"referenceerror":["0.16","0.17","0.25","58.16","58.17","58.25"],"uncaught":["0.17","58.17"],"cannot":["0.17","58.17","74.1"],"access":["0.17","58.17"],"matt":["0.18","58.18"],"console":["0.18","0.21","58.18","58.21","62.6","72.5","83.5","84.4","85.26","89.1","101.9","101.10","101.14","101.19","101.21","101.22","101.24","101.34","107.38","107.100"],"log":["0.18","0.21","58.18","58.21","62.6","72.5","80.10","83.5","89.1","101.9","101.10","101.13","101.19","101.23","101.25","107.31","107.38","107.55","107.100"],"是块级作用域":["0.19","58.19"],"所以不可能检查前面是否声明过同名变量":["0.19","58.19"],"声明的限制只适用于它指向的变量的引用":["0.21","58.21"],"换句话说":["0.21","0.65","58.21","58.65"],"如果":["0.21","58.21"],"优先":["0.22","58.22"],"boolean":["0.23","58.23","61.5","65.1","66.1","67.1","68.1","79.15","80.34","80.39","87.3","89.7","96.2","107.58"],"number":["0.23","0.24","0.28","58.23","58.24","58.28","73.3","78.2","78.4","80.34","80.39","86.5","89.1","107.23","107.128"],"string":["0.24","58.24","62.4","72.5","73.3","75.8","79.19","80.31","80.39","81.7","84.1","86.21","93.6","93.7","93.9","93.10","107.23","107.38"],"表示值为字符串":["0.24","58.24"],"表示值为数值":["0.24","58.24"],"is":["0.25","0.44","58.25","58.44","66.2","81.10"],"not":["0.25","58.25","94.7"],"defined":["0.25","58.25"],"对未声明的变量":["0.25","58.25"],"只能执行一个有用的操作":["0.25","58.25"],"就是对它调用":["0.25","58.25"],"是一个对象的引用":["0.26","58.26"],"undefined":["0.26","58.26","74.1","80.11","80.22","80.23","82.4","84.4","96.2"],"值是由":["0.26","58.26"],"派生而来的":["0.26","58.26"],"注意":["0.27","58.27","82.9","85.14","107.32"],"布尔值字面量":["0.27","58.27"],"非零数值":["0.28","58.28"],"包括无穷值":["0.28","58.28"],"格式表示正式和浮点数":["0.29","58.29"],"十六进制":["0.30","58.30"],"要创建十六进制字面量":["0.30","58.30"],"必须让真正的数值前缀":["0.30","58.30"],"处理":["0.31","58.31","76.0"],"floatnum2":["0.31","58.31"],"小数点后面是零":["0.31","58.31"],"没有可用于计算的数值表示形式":["0.32","58.32"],"要确定一个值是不是有限大":["0.32","58.32"],"介于":["0.32","58.32"],"javascript":["0.32","58.32","61.6","63.12","87.3"],"能表示的最小值和最大值之间":["0.32","58.32"],"可以使用":["0.32","16.0","58.32","85.12","88.4"],"isinfinite":["0.32","58.32"],"函数":["0.32","0.33","3.2","8.1","8.2","58.32","58.33","67.0","67.5","96.14"],"js":["0.32","0.40","37.3","58.32","58.40","80.9","83.10","85.8","85.10","85.26","86.32","101.7","101.51","107.13","121.4"],"不等于包括":["0.33","58.33"],"在内的任何值":["0.33","58.33"],"提供了":["0.33","58.33"],"isnan":["0.33","58.33"],"该函数接受一个参数":["0.33","58.33"],"可以是任意数据类型":["0.33","58.33"],"然后判断这个参数是否":["0.33","58.33"],"把一个值传给":["0.33","58.33"],"num5":["0.34","58.34"],"解释为十进制":["0.34","58.34"],"num6":["0.34","58.34"],"函数还有第二个参数":["0.34","58.34"],"用于指定底数":["0.34","58.34"],"进制数":["0.34","58.34"],"默认是":["0.34","58.34"],"通过第二个参数":["0.34","58.34"],"可以极大扩展转换后获得的结果类型":["0.34","58.34"],"af":["0.34","58.34"],"字符序列":["0.35","58.35"],"字符串可以使用双引号":["0.35","58.35"],"xnn":["0.36","58.36"],"以十六进制编码":["0.36","58.36"],"nn":["0.36","58.36"],"表示的字符":["0.36","58.36"],"其中":["0.36","58.36","86.15","107.114"],"必须先销毁原始的字符串":["0.37","58.37"],"let":["0.39","0.40","0.80","23.0","58.39","58.40","58.80","72.1","101.18","101.43","101.44","101.45","101.58","107.17","107.20","107.21","107.44"],"str":["0.39","58.39","62.10","107.53"],"表达式实现":["0.40","58.40"],"通过前缀到模板字面量来应用自定义行为":["0.41","58.41"],"如下例所示":["0.41","58.41"],"为此":["0.42","58.42"],"可以使用默认的":["0.42","58.42"],"新增的数据类型":["0.43","58.43"],"符号是原始值":["0.43","58.43"],"mysymbol":["0.44","58.44"],"typeerror":["0.44","58.44"],"的任何值都会被转化成字符串":["0.45","58.45"],"还可以使用":["0.45","58.45"],"keyfor":["0.45","58.45"],"来查询全局注册表":["0.45","58.45"],"这个方法接收符号":["0.45","58.45"],"返回该全局符号对应的字":["0.45","58.45"],"符串键":["0.45","58.45"],"如果查询的不是全局符号":["0.45","58.45"],"iterator":["0.47","58.47"],"属性":["0.47","55.1","58.47","83.7"],"那么就可以通过在自定义对象上重新定义":["0.47","58.47"],"用于判断给定属性是否可用":["0.60","58.60"],"for":["0.60","1.1","58.60","61.11","65.7","89.7"],"in":["0.60","26.2","58.60","70.2","79.2","80.3","81.7","82.10","101.35","106.0"],"语句枚举":["0.60","58.60"],"属性名必须是字符串":["0.60","58.60"],"ecmascript":["0.62","58.62","59.2","59.3","63.12"],"再应用改变":["0.63","58.63"],"变量类型从布尔值变成数值":["0.63","58.63"],"true":["0.63","0.87","55.5","58.63","58.87","65.1","68.1","70.3","86.27","86.38","87.3","89.7","95.3","107.58","107.107"],"一元减由一个减号":["0.64","58.64"],"先确定":["0.65","58.65"],"的二进制表示":["0.65","58.65"],"找到数值的一补数":["0.65","58.65"],"或反码":["0.65","58.65"],"num2":["0.66","58.66"],"按位异或用脱字符":["0.68","58.68"],"下面是按位异或的真值表":["0.68","58.68"],"位都向右移":["0.70","58.70"],"同时保留符号":["0.70","58.70"],"无符号右移会给空位补":["0.71","58.71"],"而不管符号位是":["0.71","58.71"],"什么":["0.71","58.71"],"如果操作数是非":["0.73","58.73"],"数值":["0.73","58.73"],"包括":["0.73","50.0","58.73"],"才会返回该对象":["0.74","58.74"],"如果两个操作数都是对象":["0.74","0.75","0.86","58.74","58.75","58.86"],"如果有一个操作数是":["0.74","58.74"],"null":["0.74","28.3","55.4","55.5","58.74","75.4","80.37","82.4","83.10","86.18","96.9"],"如果第一个操作数求值为":["0.75","58.75"],"则返回第二个操作数":["0.75","58.75"],"乘法":["0.76","58.76"],"乘以非":["0.77","58.77"],"除数不是":["0.79","58.79"],"squared":["0.80","58.80"],"如果有任一操作数是对象":["0.84","58.84"],"则调用其":["0.84","58.84"],"valueof":["0.84","58.84"],"方法":["0.84","58.84","60.4","85.6","87.2","88.4"],"记住":["0.86","58.86"],"即使两个操作数都是":["0.86","58.86"],"相等操作符也是返回":["0.86","58.86"],"因为按照规则":["0.86","58.86"],"不等于":["0.86","58.86"],"则比较他们是不是同一个对象":["0.86","58.86"],"如果两个操作数都指向同一个对象":["0.86","58.86"],"只有两个操作数在不转换的前提下相等才返回":["0.87","58.87"],"是":["0.88","58.88","70.1","79.3"],"则赋值":["0.88","58.88"],"取模后赋值":["0.89","58.89"],"加后赋值":["0.89","58.89"],"在赋值时使用逗号操作符分隔值":["0.90","58.90"],"最终会返回表达式中最后一个值":["0.90","58.90"],"渐进式框架":["1.0"],"total":["1.1"],"i":["1.1","26.2","79.1","101.39","107.39"],"需要将逻辑聚拢在":["1.2"],"controller":["1.2","79.9"],"层":["1.2"],"映射关系的简化":["1.2"],"可以比较新旧虚拟节点":["1.3"],"找到变化再进行更新":["1.3"],"虚拟":["1.3"],"dom":["1.4","18.1","24.0","113.14"],"渲染成真实":["1.4"],"单向数据流":["1.5"],"组件化开发能大幅提高应用开发效率":["1.5"],"multi":["2.1"],"多页引用":["2.1"],"多个":["2.1"],"用户体验良好":["2.2"],"切换加载资源":["2.2"],"速度慢":["2.2"],"用户体验差":["2.2"],"维护成本":["2.2"],"先将页面放到浏览器中运行一下":["2.3"],"将":["2.3","66.4"],"保存起来":["2.3"],"的抽象":["3.1"],"由于直接操作dom":["3.1"],"性能低但是":["3.1"],"在接下来的挂载过程中会调用":["3.2"],"newvnode":["3.3"],"使用":["3.3","41.0","80.42","85.22"],"和":["3.3","43.1","59.0","78.10","80.2","80.11","81.13","85.13","96.19","101.53"],"生命周期":["4.0"],"组件化好处":["4.0"],"高聚合":["4.0"],"组件要合理的划分":["4.1"],"如果不拆分组件":["4.1"],"watcher":["5.0"],"渲染":["5.0"],"没有采用一个属性对应一个":["5.0"],"defineproperty":["6.1","53.0"],"将属性进行劫持":["6.1"],"set":["6.2","63.8"],"delete":["6.2"],"实现":["6.2"],"数组不采用":["6.2"],"shift":["7.1","60.1","115.4"],"pop":["7.1"],"splice":["7.1"],"render":["8.1","8.2","15.0"],"此时会触发属性依赖收集":["8.1"],"默认在初始化时会调用":["8.2"],"如果是":["9.0"],"实例":["9.0","47.4"],"或者根数据":["9.0"],"data":["9.0","55.5","79.6","79.16","106.1"],"时":["9.0","69.6","70.3"],"报错":["9.0","67.7","101.59"],"更新":["9.0"],"无意义":["9.0"],"ob":["9.0"],"isvue":["9.0"],"show的怎么理解":["10.0"],"元素":["10.1","18.1","79.13"],"org":["10.2"],"可以阻断内部代码是否执行":["10.3"],"如果条件不成立不会执行内部逻辑":["10.3"],"vue3":["11.0"],"中有三种":["11.0"],"依赖的值不发生变化":["11.1"],"对其取值时计算属性方法不会重新执行":["11.1"],"进行一些操作":["11.2"],"异步要注意静态问题":["11.2"],"底层采用的是":["12.1"],"new":["12.1","66.4","68.3","71.8","80.38","86.4","86.9","96.6","101.44","101.46","107.44"],"proxy":["12.1"],"name":["13.0","23.0","64.3","64.8","70.2","71.4","78.4","82.13","84.3","101.43","101.45","107.4","107.87"],"数据变化后":["13.0"],"会调用":["13.0"],"schduler":["13.0"],"内部都会再次触发":["13.0"],"ast":["14.0"],"语法树":["14.0"],"parsehtml":["14.0"],"或者":["15.0","80.31","82.5","95.1","107.91"],"优先级更高":["15.0"],"如果用户写的是":["15.0"],"会做模板编译":["15.0"],"三部曲":["15.0"],"用于讲一个数据变成响应式的":["16.0"],"在父子组件通信时":["16.0"],"exists":["17.0"],"在":["17.0","59.2","62.18","63.11","69.6","78.5","79.4","83.7","85.23"],"vue2":["17.0","38.0","93.4"],"vm":["18.1","36.4"],"el替换":["18.1"],"并挂载到实例上去之后调用该钩子":["18.1"],"可以用于获取":["18.1"],"beforeupdate":["18.1"],"数据更新时调用":["18.1"],"发生在虚拟":["18.1"],"组件实例销毁之后":["18.2"],"activated":["18.2","36.4","103.6","103.8","103.9"],"keep":["18.2"],"alive":["18.2"],"缓存的组件激活时调用":["18.2"],"deactivated":["18.2","103.8"],"算法原理":["19.0"],"的核心就比较两个虚拟节点的差异":["19.1"],"直接删除页面节点":["19.2"],"老的儿子是文本":["19.2"],"新的文字是文本":["19.2"],"直接更新文本节点即可":["19.2"],"key":["20.0","55.4","70.2","84.1","89.7","101.11","101.35"],"会使用一种最大限度减少动态元素并且尽可能地尝试就地修改":["20.1"],"复用相同类型元素的算法":["20.1"],"当":["20.1","83.13","107.107"],"正在更新使用":["20.1"],"可以判断两个虚拟节点是否是相同节点":["20.2"],"可以复用老节点":["20.2"],"如果插件是一个函数":["21.1"],"它会被作为":["21.1"],"添加":["21.2"],"vue":["21.2","26.1","34.2","37.3","52.0","113.20"],"其他的参数整合成数组":["21.3"],"unshift":["21.3"],"typeof":["21.3","80.39","83.10"],"install":["21.3","87.1"],"lastname":["22.1","81.7"],"aka":["22.1"],"alias":["22.1"],"function":["22.1","78.6","89.7","96.1","101.30","101.40","101.52"],"return":["22.1","23.0","36.3","55.5","63.8","63.10","63.11","66.3","67.6","68.1","72.1","79.16","83.6","86.21","86.35","87.4","101.18","101.63","107.38","107.39","111.13"],"有了此方法我们可以用于手动挂载组件":["22.2"],"后端存储的字符串模板我们可以通过":["22.2"],"child":["23.0","113.20"],"xxxx":["23.0","30.0","32.0"],"的过程":["24.0","65.5","83.7"],"最终就是将返回的虚拟":["24.0"],"变成真实":["24.0"],"常见场景":["25.0"],"单位转换":["25.0"],"千分符":["25.0"],"文本格式化":["25.0"],"时间格式化等操作":["25.0"],"的内置指令":["26.1"],"li":["26.2"],"list":["26.2","86.23","97.7","106.3"],"会采用":["27.1"],"就近原则":["27.1"],"以组件的数据为准":["27.1"],"跟":["27.2"],"data会被合并":["27.3"],"生命周期和watch方法会被合并成队列":["27.3"],"components":["27.3"],"是怎样实现的":["28.0"],"利用":["28.1"],"slot":["28.1","31.1"],"常用的组件例如":["28.2"],"弹窗组件":["28.2"],"article":["28.3","87.4"],"编译后的结果":["28.3"],"default":["28.3","78.5","106.1","111.5"],"能修改的视图就是表单组件":["29.1"],"经常会听到一句话":["29.1"],"文本框会被解析成":["29.2"],"value":["29.2","63.8","68.3","70.2","84.4","89.7","96.3","107.87","113.29","114.17","121.4"],"input":["29.2","67.3","72.1","73.0","89.7"],"type":["29.3","57.1","73.2","80.42","91.3","91.8","100.1"],"bind":["29.3","37.3","110.3"],"on":["29.3","114.11","114.12"],"emit":["29.3","60.4"],"编译后结果是":["30.0"],"this":["30.0","83.10","88.2","96.16","101.34","107.36","107.40","111.13"],"if":["31.1","54.3","55.3","62.6","66.4","66.8","80.39","81.10","82.5","83.10","88.4","89.4","89.7","89.8","101.31","101.32","107.74"],"children":["31.1","111.16"],"options":["32.0","55.5"],"capture":["33.0"],"passive":["33.0"],"native":["33.0"],"推荐的做法是将异步组件和":["34.1"],"webpack":["34.1"],"对象写法":["34.2"],"asynccomponernt":["34.2"],"需要加载的组件":["34.2"],"应该是一个":["34.2"],"组件加载完毕后调用":["34.3"],"多次调用":["35.1"],"会被合并":["35.1"],"中的内置组件":["36.1"],"能在组件切换过程中会缓存组件的实例":["36.1"],"也可以通过meta属性指定哪些页面需要缓存":["36.2"],"哪些不要":["36.2"],"div":["36.2","97.5","118.1"],"id":["36.2","87.9","101.50","103.9"],"excluded":["36.3"],"same":["36.3"],"constructor":["36.3","68.3","87.2","96.6","107.43"],"may":["36.3"],"get":["36.3","71.4","84.4"],"getdata":["36.4"],"获取数据":["36.4"],"也允许用户注册自定义指令来对":["37.1"],"但是可能发生在其子":["37.2"],"更新之前":["37.2"],"指令的值可能发生了改变":["37.2"],"isshow":["37.3"],"显示面板":["37.3"],"directive":["37.3"],"clickoutside":["37.3"],"el":["37.3"],"的关系":["38.0"],"代理模式":["38.0"],"代理模式给某一个对象提供一个代理对象":["38.0"],"并有代理对象控制对原对象的引用":["38.0"],"装饰模式":["38.0"],"的选取":["39.0"],"控制组件力粒度":["39.0"],"采用组件级更新":["39.0"],"采用函数式组件":["39.0"],"图片资源的压缩":["40.0"],"雪碧图":["40.0"],"对小图片进行":["40.0"],"base64":["40.0"],"减少":["40.0"],"跨域资源共享":["41.0"],"有服务端设置":["41.0"],"允许指定的客户端访问服务器":["41.0"],"构建工具中设置反向代理":["41.0"],"token":["42.0","88.1","89.2"],"设置响应拦截":["42.0"],"对响应的状态码或者数据进行格式化":["42.0"],"页面权限":["43.1"],"前端配置的路由分为两部分":["43.1"],"通用路由配置":["43.1"],"需要权限的路由配置":["43.1"],"在权限路由中增加访问权限":["43.1"],"beforerouteenter":["44.0"],"beforeresolve":["44.0"],"popstate":["45.0"],"hashchange":["45.0"],"兼容性好但是不够美观":["45.0"],"服务端无法获取":["45.0"],"history":["46.0"],"模式刷新时会向服务器发起请求":["46.0"],"应用程序开发的":["47.1"],"状态管理模式":["47.1"],"dispatch":["47.2"],"action":["47.2"],"数据不够扁平化":["47.3"],"调用的时候过长":["47.3"],"更改状态":["47.3"],"mutation":["47.3"],"创建了一个":["47.4"],"中状态变化":["48.0"],"中":["49.0","61.4","63.11","66.2","69.7","73.7","79.12","84.3","85.13","97.12"],"采用":["49.0"],"操作":["50.0"],"中也可以调用":["50.0"],"mutations":["51.0"],"actions":["51.0"],"getters":["51.0"],"moduleb":["51.0"],"api":["52.0","56.4","79.0"],"都在":["52.0"],"对象上公开":["52.0"],"对":["52.0"],"tree":["52.0"],"源码改造渲染方式":["53.0"],"扩展更方便":["53.0"],"的时候使用":["53.0"],"来进行数据的劫持":["53.0"],"需要对属性进行重写添加":["53.0"],"getter":["53.0"],"及":["53.0"],"父组件":["54.1"],"子组件":["54.1","107.67"],"err":["54.2"],"dynamicchildren":["55.1"],"patchflag":["55.1"],"此时生成的虚拟节点多出一个dynamicchildren":["55.1"],"这个就是":["55.1"],"block":["55.1","77.2","106.2"],"作用":["55.1","97.17"],"可以收集所有后代动态节点":["55.1"],"这样后续更新时可以直接跳过静态节点":["55.1"],"实现靶向更新":["55.1"],"typescript":["55.1","80.0","83.14","85.13","86.5","86.12","90.3","94.4","94.6","107.17","107.30","107.69","107.74","107.118"],"else":["55.2","86.13","107.65"],"setup":["55.5"],"核心":["56.1"],"有":["56.1"],"类型":["56.3","57.1","69.0","71.2","71.4","84.7","86.23"],"语句":["56.3"],"用于在":["56.4"],"样式":["56.5"],"描述处理元素":["56.5"],"样式的接口":["56.5"],"遍历和范围":["56.5"],"location":["56.6"],"提供浏览器加载页面的详尽信息":["56.6"],"screen":["56.6"],"或":["57.1","82.4","83.7","89.9","115.4"],"vbscript":["57.1"],"大多数浏览器都会忽略这个值":["57.1"],"不应该再使用它":["57.1"],"表示包含要指向的代码的外部文件":["57.1"],"代替":["57.1","82.4"],"表示代码中脚本语言的内容类型":["57.1"],"也成":["57.1"],"mime":["57.1"],"按照惯例":["57.1"],"已被开发人员普遍接受":["59.0"],"es6":["59.0","63.2"],"语法以及前端框架一起":["59.0"],"被视为前端开发领域的基础工具":["59.0"],"但是":["59.0","59.1"],"想要获得类型的帮助":["59.1"],"我们需要额外的类型代码":["59.1"],"这会影响开发效率吗":["59.1"],"会有影响":["59.1"],"但更多是正向的":["59.1"],"首先":["59.1","60.1","73.1","80.29","87.3"],"要实现类型的精确标注":["59.1"],"我们并不一定需要大量的类型代码":["59.1"],"就像你给变量":["59.1"],"新增一些属性得到变量":["59.1"],"b":["59.1","66.3","69.1","75.1","75.2","76.5","80.34","97.16","101.62","107.19"],"你会完全重新声明这两个变量的值吗":["59.1"],"不会":["59.1"],"在类型层面也是一样":["59.1"],"变量":["59.1"],"的类型会基于变量":["59.1"],"以此一步步掌握整个类型系统":["59.2"],"接着是":["59.2"],"语法部分":["59.2"],"提前支持了一些已经到达":["59.2"],"stage":["59.2"],"阶段":["59.2"],"或是比较重要的":["59.2"],"tc39":["59.2"],"提案":["59.2"],"比如使用最多的可选链":["59.2"],"空值合并":["59.2","83.13"],"装饰器等":["59.2"],"这些语法都已经或即将成为":["59.2"],"next":["59.2","78.1"],"的新成员":["59.2"],"理解类型世界的基本规则与运行规律":["59.3"],"迈过了类型这座大山以后":["59.3"],"我们将面对新朋友":["59.3"],"语法":["59.3","82.0","82.3","85.23"],"它们比类型部分轻松友好多了":["59.3"],"与":["59.3","76.5","77.4","80.23","84.4","91.2"],"的某一个配置具体作用":["59.4"],"当你忘记了某一类工具类型的实现原理":["59.4"],"你都可以回来在小册中找到答案":["59.4"],"最后":["59.4","82.0"],"基于":["59.6","77.2","81.12"],"dev":["60.0","60.6"],"等工具":["60.0"],"帮助你快速验证":["60.0"],"代码的执行结果":["60.0"],"而如果你只想快速开始学习":["60.0"],"支持":["60.1"],"我们也可以通过一些配置项获得更好的开发体验":["60.1"],"你需要通过":["60.1"],"ctrl":["60.1"],"command":["60.1"],"p":["60.1","110.5"],"打开命令面板":["60.1"],"找到":["60.1"],"打开工作区设置":["60.1"],"这一项":["60.1"],"open":["60.1"],"setting":["60.1"],"然后":["60.1","71.4","107.77"],"在打开的设置中输入":["60.1"],"errorlens":["60.2"],"这一插件能够把你的":["60.2"],"如果不需要":["60.3"],"vs":["60.3"],"code":["60.3"],"更强大的提示能力与一些特殊插件":["60.3"],"主题等":["60.3"],"demo":["60.3"],"学习使用":["60.3"],"中的":["60.4","63.2","121.1"],"transpilemodule":["60.4"],"我们会在后面的章节详细讲解":["60.4"],"swc":["60.4"],"的基础上":["60.4"],"还会使用":["60.4"],"来进行文件的编译":["60.4"],"进一步提升执行速度":["60.4"],"如果你不仅是想要执行":["60.4"],"还想顺便查看下产物":["60.4"],"可以使用这一选项来把编译产物输出到":["60.4"],"文件夹下":["60.4"],"需要同时与":["60.4"],"compilerhost":["60.4"],"选项一同使用":["60.4"],"除了直接使用":["60.4"],"以外":["60.4","86.42"],"你也可以通过":["60.4"],"require":["60.4"],"hook":["60.4","79.9"],"的形式来执行":["60.4"],"你可以理解为在开始时的例子":["60.5"],"我们使用一个值空间存放这个变量具体的属性":["60.5"],"一个类型空间存放这个变量的类型":["60.5"],"而通过":["60.5"],"来快速执行你的":["60.6"],"文件":["60.6","85.8","85.29","107.87"],"在最后":["60.6"],"modules":["60.8"],"src":["60.8","101.51","107.70","107.76","107.115","107.130","107.133","107.139","121.3"],"index":["60.8","83.6","93.3","111.9","111.10"],"以及内置模块等":["60.8"],"需要注意的是在浏览器中":["60.8"],"需要带上完整的后缀名":["60.8"],"浏览器并不能查找服务器的文件":["60.8"],"但一般":["60.8"],"bundler":["60.8"],"会帮你处理好":["60.8"],"基于绝对路径":["60.8"],"的功能":["61.0"],"语法有一个基础认知":["61.0"],"这一章会包含几乎所有与原始类型":["61.0"],"对象类型":["61.0","121.6"],"数组等强相关的知识点":["61.0"],"nul":["61.1"],"obj":["61.1","64.3"],"object":["61.1","65.5","65.7","69.4","89.7","96.3","101.23"],"tmp1":["61.2"],"tmp2":["61.2"],"值的":["61.3"],"其返回值类型才被推导为了":["61.3"],"但在实际的代码执行中":["61.3"],"的返回值均是":["61.3"],"虽然":["61.3"],"的返回值类型会被推导为":["61.3"],"但是你仍然可以使用":["61.3"],"类型进行标注":["61.3"],"因为在类型层面":["61.3"],"也就是说":["61.4","84.3"],"这个元组的长度可能为":["61.4"],"关于类型别名":["61.4"],"类型查询":["61.4"],"以及联合类型":["61.4"],"我们会在后面讲到":["61.4"],"这里你只需要简单了解即可":["61.4"],"你可能会觉得":["61.4"],"元组的可读性实际上并不好":["61.4"],"比如对于":["61.4"],"来说":["61.4"],"你并不能直接知道这三个元素都代表什么":["61.4"],"还不如使用对象的形式":["61.4"],"而在":["61.4"],"有了具名元组":["61.4"],"male":["61.5"],"obj1":["61.5"],"linbudu":["61.5","62.10","63.11","63.14","86.23"],"你可以使用类型断言":["61.6"],"非空断言或可选链解决":["61.6"],"别急":["61.6","83.9"],"我们在后面会讲到":["61.6"],"除了标记一个属性为可选以外":["61.6"],"你还可以标记这个属性为只读":["61.6"],"readonly":["61.6","87.2"],"很多同学对这一关键字比较陌生":["61.6"],"因为以往":["61.6"],"中并没有这一类概念":["61.6"],"它的作用是":["61.6"],"防止对象的属性被再次赋值":["61.6"],"用来描述":["61.7"],"对象":["61.7","62.12","107.44"],"类的结构":["61.7"],"tmp19":["61.8"],"tmp20":["61.8"],"不成立":["61.8"],"值为原始类型":["61.8"],"tmp21":["61.8"],"tmp22":["61.8"],"tmp23":["61.8"],"tmp24":["61.8"],"最后是":["61.8"],"一个奇奇怪怪的空对象":["61.8"],"如果你了解过字面量类型":["61.8"],"可以认为":["61.8"],"就是一个对象字面量类型":["61.8"],"对应到字符串字面量类型这样":["61.8"],"否则":["61.8"],"你可以认为使用":["61.8"],"开发者可能需要一定的时间来理解和习惯":["61.9"],"但它在工程层面确实是非常推荐的一种实践":["61.9"],"可以使用只读标记来避免数组和对象被错误修改":["61.9"],"当然":["61.9","65.1","65.6","74.2","78.13","89.9"],"目前只能够帮助你在编译时做检查":["61.9"],"类型信息在编译后都会被擦除":["61.9"],"所以":["61.9"],"我们可以用":["61.11"],"方法来复用已创建的":["61.11"],"如":["61.11","77.2","83.14","86.15","86.42","89.0"],"会首先查找全局是否已经有使用":["61.11"],"作为":["61.11"],"可能是":["62.0"],"这个时候":["62.2","71.10"],"我们就能在访问时获得精确地类型推导了":["62.2"],"image":["62.2","96.5","107.79"],"png":["62.2","121.7"],"linbudu599":["62.4"],"分配给类型":["62.4"],"str1":["62.4","80.40"],"str2":["62.4"],"declare":["62.6","64.3","71.5"],"var":["62.6","83.10","96.3","101.6"],"意味着完全的实现这个类型每一个属性的每一个值":["62.8"],"对象字面量类型在实际开发中的使用较少":["62.8"],"我们只需要了解":["62.8"],"总的来说":["62.8"],"在需要更精确类型的情况下":["62.8"],"我们可以使用字面量类型加上联合类型的方式":["62.8"],"但要注意":["62.10"],"延迟求值的枚举值是有条件的":["62.10"],"如果你使用了延迟求值":["62.10"],"那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后":["62.10"],"如上例":["62.10"],"或者放在第一位":["62.10"],"中也可以同时使用字符串枚举值和数字枚举值":["62.10"],"mixed":["62.10"],"num":["62.10","64.2","107.53"],"枚举和对象的重要差异在于":["62.10"],"对象是单向映射的":["62.10"],"我们只能从键映射到键值":["62.10"],"枚举是双向映射的":["62.10"],"即你可以从枚举成员映射到枚举值":["62.10"],"也可以从枚举值映射到枚举成员":["62.10"],"如上面的":["62.12"],"对枚举成员的访问会被":["62.12"],"直接内联替换为枚举的值":["62.12"],"以上的代码会被编译为如下形式":["62.12"],"都使用":["62.14"],"字面量类型":["62.14"],"联合类型":["62.14"],"声明的意义":["62.18"],"我们知道":["62.18"],"声明的变量是可以再次赋值的":["62.18"],"面向对象的编程":["63.0"],"等":["63.0"],"函数部分":["63.0"],"我们主要关注其参数类型":["63.0"],"返回值类型以及重载的应用":["63.0"],"class部分":["63.0"],"除了类型以外":["63.0"],"我们还会学习访问性修饰符":["63.0"],"它是":["63.2"],"的重要特性之一":["63.2"],"箭头函数":["63.2","107.32"],"但在这里":["63.2"],"它其实是":["63.2"],"函数类型签名":["63.2"],"而实际的箭头函数":["63.2"],"我们的类型标注也是类似的":["63.2"],"方式一":["63.2"],"类型是一个实际的":["63.3"],"有意义的类型值":["63.3"],"才代表着空的":["63.3"],"没有意义的类型值":["63.3"],"但此时就不能够使用":["63.4"],"了":["63.4","71.5"],"因为既然都有默认值":["63.4"],"那肯定是可选参数啦":["63.4"],"foo":["63.4","65.1","72.1","80.18","80.24","80.25","82.9","85.4"],"res3":["63.5","75.2"],"这里我们的三个":["63.5"],"其实具有不同的意义":["63.5"],"重载签名一":["63.5"],"传入":["63.5"],"的值为":["63.5"],"函数现在已经基本不再使用":["63.6"],"这里仅做了解即可":["63.6"],"而对于异步函数":["63.6"],"即标记为":["63.6"],"的函数":["63.6"],"其返回值必定为一个":["63.6"],"a":["63.8","66.3","75.1","75.2","76.5","80.34","81.10","96.3","97.3","101.61","107.20"],"唯一需要注意的是":["63.8"],"setter":["63.8"],"而是让它保持默认的":["63.9"],"在扩展阅读中我们会讲到":["63.9"],"修饰构造函数的场景":["63.9"],"如果没有其他语言学习经验":["63.9"],"你可能不太理解":["63.9"],"的意义":["63.9"],"我们简单做个解释":["63.9"],"此类成员在":["63.9"],"类":["63.9"],"类的实例":["63.9"],"prototype":["63.10","83.9","85.4","101.46"],"从中我们可以看到":["63.10"],"静态成员直接被挂载在函数体上":["63.10"],"实例成员挂载在原型上":["63.10"],"这就是二者的最重要差异":["63.10"],"静态成员不会被实例继承":["63.10"],"此时":["63.11","77.2","78.3","107.77"],"我们必须完全实现这个抽象类的每一个抽象成员":["63.11"],"需要注意的是":["63.11","79.0","83.10","84.3","85.16"],"无法声明静态的抽象成员":["63.11"],"对于抽象类":["63.11"],"它的本质就是描述类的结构":["63.11"],"看到结构":["63.11"],"你是否又想到了":["63.11"],"interface":["63.11","64.3","67.1","71.4","73.3","79.9","82.13","92.0","107.41","107.42"],"是的":["63.11"],"不仅可以声明函数结构":["63.11"],"也可以声明类的结构":["63.11"],"foostruct":["63.11"],"中不存在或实现并不完全的能力":["63.12"],"对于函数与类":["63.12"],"你需要更多地实际使用才能掌握得更好":["63.12"],"不妨继续对你手上的":["63.12"],"public":["63.14","68.3"],"static":["63.14"],"identifier":["63.14","89.6","89.7"],"loginhandler":["63.15"],"void":["63.15","67.1","68.3","73.2","79.9","84.4","85.4","107.107"],"wechatloginhandler":["63.15"],"implements":["63.15"],"taobaologinhandler":["63.15"],"tiktokloginhandler":["63.15"],"never":["64.0","67.7","69.0"],"加上这一部分我们就掌握了":["64.0"],"中所有的内置类型标注":["64.0"],"然后是类型断言这一重要能力":["64.0"],"我们会介绍它的正确使用场景":["64.0"],"tips":["64.1"],"如果是类型不兼容报错导致你使用":["64.1"],"考虑用类型断言替代":["64.1"],"我们下面就会开始介绍类型断言的作用":["64.1"],"如果是类型太复杂导致你不想全部声明而使用":["64.1"],"考虑将这一处的类型去断言为你需要的最简类型":["64.1"],"如你需要调用":["64.1"],"就可以先将":["64.1"],"断言为一个具有":["64.1"],"方法的类型":["64.1"],"如果你是想表达一个未知类型":["64.1"],"更合理的方式是使用":["64.1"],"类型和":["64.1"],"类型有些类似":["64.1"],"一个":["64.1","121.5"],"类型的变量可以再次赋值为任意其它类型":["64.1"],"但只能赋值给":["64.1"],"类型的变量":["64.1","68.2"],"unknownvar":["64.1"],"bool":["64.2"],"unknown":["64.2","69.9","70.2","80.31","83.3","89.7"],"如果我们希望这个变量的每一种类型都需要得到妥善处理":["64.2"],"在最后可以抛出一个错误":["64.2"],"但这是运行时才会生效的措施":["64.2"],"是否能在类型检查时就分析出来":["64.2"],"实际上":["64.2","66.2","68.0","69.6","73.1","77.2","83.7"],"由于":["64.2","75.7","79.12"],"强大的类型分析能力":["64.2"],"每经过一个":["64.2"],"语句处理":["64.2"],"的类型分支就会减少一个":["64.2"],"因为已经被对应的":["64.2"],"处理过":["64.2"],"而在最后的":["64.2"],"代码块中":["64.2"],"它的类型只剩下了":["64.2"],"ifoo":["64.3","67.1"],"target":["64.5","83.6"],"item":["64.5","96.19","97.7"],"为什么说非空断言是类型断言的简写":["64.5"],"因为上面的非空断言实际上等价于以下的类型断言操作":["64.5"],"as":["64.5","76.3","107.54"],"类型工具的学习":["64.6"],"进一步探索":["64.6"],"的类型世界":["64.6"],"交叉类型":["64.8","75.1"],"函数类型的情况":["64.8"],"我们会在后面专门有一节进行讲解":["64.8"],"而实际上类型断言的工作原理也和类型层级有关":["64.8"],"在判断断言是否成立":["64.8"],"即差异是否能接受时":["64.8"],"实际上判断的即是这两个类型是否能够找到一个公共的父类型":["64.8"],"比如":["64.8","85.6","89.3"],"其实可以认为拥有公共的父类型":["64.8"],"一个新的":["64.8"],"类型工具顾名思义":["65.0"],"它就是对类型进行处理的工具":["65.0"],"如果按照使用方式来划分":["65.0"],"类型工具可以分成三类":["65.0"],"操作符":["65.0"],"关键字与专用语法":["65.0"],"我们一般不会直接使用工具类型来做类型标注":["65.1"],"而是再度声明一个新的类型别名":["65.1"],"factorywithbool":["65.1"],"同时":["65.1","66.5","83.0","84.5"],"泛型参数的名称":["65.1"],"上面的":["65.1","65.6","83.9"],"也不是固定的":["65.1"],"通常我们使用大写的":["65.1"],"k":["65.1","70.2","83.10","96.23"],"u":["65.1","70.3"],"v":["65.1","70.2","83.10","86.35","103.12","114.1","114.2"],"看起来很奇怪":["65.2"],"但想想我们前面给出的定义":["65.2"],"新的类型会同时符合交叉类型的所有成员":["65.2"],"存在既是":["65.2"],"又是":["65.2"],"的类型吗":["65.2"],"当然不":["65.2"],"这也是":["65.2"],"这一":["65.2"],"bottomtype":["65.2"],"的实际意义之一":["65.2"],"描述":["65.2","107.112"],"根本不存在的类型":["65.2"],"嘛":["65.2"],"对于对象类型的交叉类型":["65.2"],"其内部的同名属性类型同样会按照交叉类型进行合并":["65.2"],"唯一共同点是":["65.3"],"它们都通过索引的形式来进行类型操作":["65.3"],"但索引签名类型是":["65.3"],"在字符串索引签名类型中我们仍然可以声明数字类型的键":["65.4"],"类似的":["65.4","85.26"],"symbol":["65.4"],"类型也是如此":["65.4"],"ddd":["65.4"],"索引签名类型也可以和具体的键值对类型声明并存":["65.4"],"但这时这些具体的键值类型也需要符合索引签名类型的声明":["65.4"],"我们可以写段伪代码来模拟":["65.5"],"从键名到联合类型":["65.5"],"而不是一个":["65.6"],"字符串值":["65.6"],"索引类型查询的本质其实就是":["65.6"],"通过键的字面量类型":["65.6"],"访问这个键对应的键值类型":["65.6"],"看到这你肯定会想到":["65.6"],"keyof":["65.6","70.2"],"操作符能一次性获取这个对象所有的键的字面量类型":["65.6"],"是否能用在这里":["65.6"],"这可是":["65.6"],"啊":["65.6"],"我们还是可以用伪代码的形式进行说明":["65.7"],"of":["65.7","74.1","82.11","89.7","89.8"],"keys":["65.7"],"满足其中所有类型才满足映射联合类型":["65.8"],"索引签名类型":["65.8"],"声明一个拥有任意属性":["65.8"],"键值类型一致的接口结构":["65.8"],"我们本节要介绍的就是两个主要用于类型安全的类型工具":["66.0"],"类型查询操作符":["66.0"],"你不仅可以直接在类型标注中使用":["66.1"],"还能在工具类型中使用":["66.1"],"func2":["66.1"],"内部的判断逻辑并不在函数":["66.2"],"这里的类型控制流分析做不到跨函数上下文来进行类型的信息收集":["66.2"],"但别的类型语言中可能是支持的":["66.2"],"将判断逻辑封装起来提取到函数外部进行复用非常常见":["66.2"],"为了解决这一类型控制流分析的能力不足":["66.2"],"引入了":["66.2"],"关键字":["66.2"],"来显式地提供类型信息":["66.2"],"正确了":["66.2"],"union":["66.3"],"虽然它们是一堆类型的联合体":["66.3"],"但其中每一个类型都具有一个独一无二的":["66.3"],"能让它鹤立鸡群的属性":["66.3"],"这个可辨识属性可以是结构层面的":["66.3"],"比如结构":["66.3"],"的属性":["66.3"],"prop":["66.3"],"是数组":["66.3"],"而结构":["66.3"],"是对象":["66.3"],"或者结构":["66.3"],"中存在属性":["66.3"],"中不存在":["66.3"],"它甚至可以是共同属性的字面量类型差异":["66.3"],"ensurearray":["66.3"],"array":["66.3","75.2"],"isarray":["66.3"],"kind":["66.3","66.8"],"throw":["66.4","86.9","89.4"],"error":["66.4","78.11","80.1","81.6","82.9","86.4","89.4"],"这里使用的是":["66.4"],"来自于实际逻辑":["66.4"],"这也意味着":["66.4"],"我们":["66.4"],"这一逻辑层面的代码":["66.4"],"作为了类型层面的判断依据":["66.4"],"相当于在返回值类型中使用一个逻辑表达式进行了类型标注":["66.4"],"我们初次了解到了类型控制流分析的存在":["66.5"],"以及使用类型保护":["66.5"],"类型守卫来进行类型控制流的分析纠正等":["66.5"],"我们还学习了可辨识联合类型与可辨识属性的概念":["66.5"],"但这些同名属性的类型仍然需要兼容":["66.7"],"此时的表现其实和显式扩展接口基本一致":["66.7"],"后续属性声明必须属于同一类型":["66.7"],"的类型必须为":["66.7"],"但此处却为类型":["66.7"],"f1":["66.8","82.12"],"payload":["66.8"],"仍然是":["66.8"],"那么泛型就是这门语言里的":["67.0"],"参数":["67.0"],"这一节":["67.0"],"prop1":["67.1"],"prop2":["67.1"],"prop3":["67.1"],"prop4":["67.1"],"partialifoo":["67.1"],"等价于":["67.1"],"基类与派生类":["67.2"],"父类与子类":["67.2"],"同理":["67.2"],"完整的类型层级":["67.2"],"我们会在后面一节进行非常详细地说明":["67.2"],"我们来看下面这个例子":["67.2"],"resstatus":["67.2"],"rescode":["67.2"],"success":["67.2"],"failure":["67.2"],"这个例子会根据传入的请求码判断请求是否成功":["67.2"],"这意味着它只能处理数字字面量类型的参数":["67.2"],"因此这里我们通过":["67.2"],"来标明其类型约束":["67.2"],"如果传入一个不合法的值":["67.2"],"会更加复杂":["67.3"],"上面我们说":["67.3"],"多个泛型参数之间的依赖":["67.3"],"其实指的即是在后续泛型参数中":["67.3"],"使用前面的泛型参数作为约束或默认值":["67.3"],"processinput":["67.3"],"secondinput":["67.3"],"比如对存在分页结构的数据":["67.4"],"我们也可以将其分页的响应结构抽离出来":["67.4"],"ipaginationres":["67.4"],"titem":["67.4"],"page":["67.4"],"比如上面的":["67.5"],"现在我们希望做一些代码拆分":["67.5"],"不再处理对象类型的情况了":["67.5"],"extends":["67.5","71.5","80.32"],"现在我们只想处理数字元组的情况":["67.5"],"而多泛型关联也是如此":["67.5"],"lodash":["67.5"],"的":["67.5","70.5","81.12","82.2","88.1","88.4","89.3","94.4","101.50"],"pick":["67.5","75.1"],"这个函数首先接受一个对象":["67.5"],"然后接受一个对象属性名组成的数组":["67.5"],"并从这个对象中截取选择的属性部分":["67.5"],"入队一个任意类型元素":["67.6"],"无需为队列泛型子类型":["67.6"],"enqueuewithunknowntype":["67.6"],"element":["67.6","77.2","79.13"],"第二种":["67.7"],"不能将":["67.7"],"类型的值赋值给":["67.7"],"方法是相对特殊的一个":["67.7"],"它的类型声明存在几种不同的重载":["67.7"],"当你不传入初始值时":["67.7"],"泛型参数会从数组的元素类型中进行填充":["67.7"],"实现更严格的类型保护":["67.8"],"在下一节":["67.8","85.33"],"我们会开始探秘":["67.8"],"可为什么上传一只狗也可以呢":["68.0"],"这就是":["68.0"],"的类型系统特性":["68.0"],"结构化类型系统":["68.0"],"类可以被认为是":["68.1"],"类的子类":["68.1"],"同样的":["68.1"],"面向对象编程中的里氏替换原则也提到了鸭子测试":["68.1"],"如果它看起来像鸭子":["68.1"],"叫起来也像鸭子":["68.1"],"但是却需要电池才能工作":["68.1"],"那么你的抽象很可能出错了":["68.1"],"更进一步":["68.1"],"在比较对象类型的属性时":["68.1"],"同样会采用结构化类型系统进行判断":["68.1"],"而对结构中的函数类型":["68.1"],"即方法":["68.1"],"进行比较时":["68.1"],"同样存在类型的兼容性比较":["68.1"],"函数中可以传入":["68.2"],"这就很离谱了":["68.2"],"人民币与美元这两个单位实际的意义并不一致":["68.2"],"怎么能进行相加":["68.2"],"在标称类型系统中":["68.2"],"被认为是两个完全不同的类型":["68.2"],"相应的":["68.3"],"现在使用方式也要进行变化":["68.3"],"这一节或许能够解答你曾经有过的":["68.4"],"为什么这两个类型竟然是能被视为兼容问题":["68.4"],"为什么这两个类型明明是父子关系却说不兼容":["68.4"],"等问题":["68.4"],"同时在后面的条件类型":["68.4"],"类型层级等内容中":["68.4"],"而对于动态语言":["68.6"],"则在":["68.6"],"运行时":["68.6"],"就是在编译时进行类型检查的":["68.6"],"一个需要注意的地方是":["68.6"],"静态类型与动态类型指的是":["68.6"],"类型检查发生的时机":["68.6"],"并不等于这门语言的类型能力":["68.6"],"到最底层的":["69.0"],"那么":["69.0","75.2","75.7","78.7","87.2"],"如果成立":["69.1"],"意味着":["69.1"],"的类型":["69.1"],"成立":["69.1","75.2"],"即":["69.1","70.1","75.1","76.5","79.13","107.77"],"类型是":["69.1"],"result5":["69.2"],"如果你的所有类型成员都是对象":["69.4"],"数组字面量类型或函数类型":["69.4"],"result11":["69.4"],"budu":["69.4","86.23"],"result17":["69.5"],"result20":["69.5"],"result19":["69.5"],"result21":["69.5"],"是不是感觉匪夷所思":["69.6"],"还是因为":["69.6"],"系统设定":["69.6"],"的原因":["69.6"],"代表了任何可能的类型":["69.6"],"当我们使用":["69.6"],"它包含了":["69.6"],"让条件成立的一部分":["69.6"],"以及":["69.6","90.1","96.18"],"让条件不成立的一部分":["69.6"],"而从实现上说":["69.6"],"内部代码的条件类型处理中":["69.6"],"上面三种情况当然不应该成立":["69.7"],"别忘了在":["69.7"],"result43":["69.9"],"result44":["69.9"],"result45":["69.9"],"的子类型判定":["69.10"],"基本包括了会见到的各种特殊情况":["69.10"],"基础的类型层级可以用以下这张图表示":["69.10"],"img":["69.10","89.0","107.73","107.92","107.110","107.121","107.123","107.124"],"conditional":["70.0"],"那么此时的返回值类型就需要从这个字面量联合类型中推导回其原本的基础类型":["70.1"],"在类型层级一节中":["70.1"],"同一基础类型的字面量联合类型":["70.1"],"其可以被认为是此基础类型的子类型":["70.1"],"的子类型":["70.1"],"因此":["70.1","70.5","75.7","78.7","78.10","83.9","91.9"],"我们可以使用嵌套的条件类型来进行字面量类型到基础类型地提取":["70.1"],"literaltoprimitive":["70.1"],"proptyperesult1":["70.2"],"proptyperesult2":["70.2"],"age":["70.2","71.4","78.2","78.4","81.7","82.13","86.5","107.23","121.8"],"反转键名与键值":["70.2"],"reversekeyvalue":["70.2"],"record":["70.2","80.31","88.4","89.7"],"reversekeyvalueresult1":["70.2"],"来确保分布式特性能够发生":["70.3"],"在某些情况下":["70.3","72.1"],"我们也会需要包裹泛型参数来禁用掉分布式特性":["70.3"],"最常见的场景也许还是联合类型的判断":["70.3"],"即我们不希望进行联合类型成员的分布判断":["70.3"],"而是希望直接判断这两个联合类型的兼容性判断":["70.3"],"就像在最初的":["70.3"],"中那样":["70.3"],"compareunion":["70.3"],"false":["70.3","80.39","96.5","107.21","111.12"],"compareres1":["70.3"],"compareres2":["70.3"],"通过将参数与条件都包裹起来的方式":["70.3"],"我们对联合类型的比较就变成了数组成员类型的比较":["70.3"],"在此时就会严格遵守类型层级一文中联合类型的类型判断了":["70.3"],"子集为其子类型":["70.3"],"另外一种情况则是":["70.3"],"当我们想判断一个类型是否为":["70.3"],"也可以通过类似的手段":["70.3"],"isnever":["70.3"],"isneverres1":["70.3"],"isneverres2":["70.3"],"关键字的使用":["70.4"],"除了我们已经了解的":["70.4"],"在函数结构":["70.4"],"对象结构":["70.4"],"数组结构等不同结构中的使用以外":["70.4"],"因为它并不是":["70.5"],"tmp5":["70.5"],"我们并不能用这个方式来写":["70.5"],"其实现过程要更复杂一些":["70.5"],"我们需要过滤掉其他全部的类型来只剩下":["70.5"],"这里直接看实现":["70.5"],"其次":["71.0"],"工具类型和类型编程并不完全等价":["71.0"],"虽然它是类型编程最常见的一种表现形式":["71.0"],"但不能完全代表类型编程水平":["71.0"],"如很多框架代码中":["71.0"],"infer":["71.1"],"的模式匹配":["71.1"],"即对一个既有类型特定位置类型的提取":["71.1"],"比如提取函数类型签名中的返回值类型":["71.1"],"我们将其统称为":["71.1"],"模式匹配工具类型":["71.1","90.1"],"模板字符串专属的工具类型":["71.1"],"中缺少属性":["71.2"],"但类型":["71.2"],"中需要该属性":["71.2"],"foo1":["71.2"],"foo2":["71.2"],"如果我只想":["71.3"],"修饰部分属性":["71.3"],"呢":["71.3"],"这里的部分属性":["71.3"],"job":["71.4"],"jobuniontype":["71.4"],"pickedfoo":["71.4"],"会将传入的联合类型作为需要保留的属性":["71.4"],"使用这一联合类型配合映射类型":["71.4"],"即上面的例子等价于":["71.4"],"联合类型的成员会被依次映射":["71.4"],"并通过索引类型访问来获取到它们原本的类型":["71.4"],"而对于":["71.4"],"看名字其实能":["71.4"],"到它就是":["71.4"],"omit2":["71.5"],"这里就不能用严格":["71.5"],"我们可能希望":["71.7"],"保留原属性或替换原属性":["71.7"],"foofirstparameter":["71.8"],"barfirstparameter":["71.8"],"除了对函数类型进行模式匹配":["71.8"],"内置工具类型中还有一组对":["71.8"],"class":["71.8","72.1","79.0","80.29","83.14","107.33"],"进行模式匹配的工具类型":["71.8"],"classtype":["71.8"],"abstract":["71.8"],"在某些特殊位置下应该如何处理":["71.9"],"也可能发现某些工具类型离解决问题还差上那么一些":["71.10"],"不妨回想下我们前面学到的这么多类型工具":["71.10"],"tmp3":["71.12"],"看起来好像能满足需求":["71.12"],"但程序员总是精益求精的":["71.12"],"泛型可以声明约束":["71.12"],"只允许传入特定的类型":["71.12"],"上下文类型":["72.0"],"contextual":["72.0"],"typing":["72.0","81.6"],"这一节的内容比较短":["72.0"],"因为上下文类型并不是一个多复杂":["72.0"],"extra":["72.1"],"上下文类型也可以进行":["72.1"],"嵌套":["72.1"],"情况下的类型推导":["72.1"],"如以下这个例子":["72.1"],"func":["72.1","73.3"],"raw":["72.1","83.4"],"上下文类型的推导能力也会失效":["72.1"],"比如这里我们使用一个由函数类型组成的联合类型":["72.1"],"result4":["72.2"],"看起来这是一种很奇怪的":["72.2"],"错误的行为":["72.2"],"但实际上":["72.2"],"我们日常开发中的很多代码都需要这一":["72.2"],"不正确的":["72.2"],"行为才不会报错":["72.2"],"比如以下这个例子":["72.2"],"函数类型兼容性比较":["72.3"],"以及其中的":["72.3"],"协变":["72.3"],"usehandler":["72.5"],"callback":["72.5","103.15"],"arg1":["72.5"],"arg2":["72.5"],"barfunc":["73.0"],"literal":["73.0"],"types":["73.0","79.19"],"bazfunc":["73.0"],"相对严谨地说":["73.1"],"这是因为派生类":["73.1"],"即子类":["73.1"],"会保留基类的属性与方法":["73.1"],"因此说其与基类兼容":["73.1"],"但基类并不能未卜先知的拥有子类的方法":["73.1"],"相对欢脱地说":["73.1"],"因为我们要让这只狗汪汪两声":["73.1"],"柴犬":["73.1"],"德牧都会":["73.1"],"但如果你传个牛进来":["73.1"],"这我就很难办了啊":["73.1"],"里氏替换原则":["73.1"],"子类可以扩展父类的功能":["73.1"],"但不能改变父类原有的功能":["73.1"],"子类型":["73.1"],"subtype":["73.1"],"必须能够替换掉他们的基类型":["73.1"],"base":["73.1","86.12","107.80"],"回到这个函数":["73.1"],"这个函数会实例化一只狗狗":["73.1"],"并传入":["73.1"],"factory":["73.1"],"就像宠物美容":["73.1"],"然后让它叫唤两声":["73.1"],"这个函数同时约束了此类型的参数与返回值":["73.1"],"我只会传入一只正常的狗狗":["73.1"],"但它不一定是什么品种":["73.1"],"而逆变意味着":["73.2"],"而在这里的示例中":["73.2"],"变化":["73.2"],"即指从单个类型到函数类型的包装过程":["73.2"],"我们可以使用工具类型来实现独立的包装类型":["73.2"],"独立指对参数类型与返回值类型":["73.2"],"asfuncargtype":["73.2"],"arg":["73.2","73.3"],"声明":["73.3","78.8"],"t1":["73.3"],"t2":["73.3"],"进行如此约束的原因即":["73.3"],"对于":["73.3","75.3","79.1"],"才能在开启严格函数类型检查的情况下享受到":["73.3"],"基于逆变的参数类型检查":["73.3"],"以及构造函数声明":["73.3"],"其无法享受到这一更严格的检查的原因则是对于如":["73.3"],"style":["73.4","114.14","114.15"],"这条规则来让你的代码质量更上一层楼":["73.4"],"除了对自定义函数类型地比较":["73.4"],"我们也了解了对于部分":["73.4"],"内置的方法":["73.4"],"会通过显式的":["73.4"],"声明方式来确保在调用时":["73.4"],"需要注意的是它们根本就":["73.6"],"不满足逆变与协变的发生条件":["73.6"],"父子类型":["73.6"],"我们允许其遵循协变":["73.7"],"并且会在其中新增其他物种":["73.7"],"比如兔子啊王八":["73.7"],"这个时候你给我一笼兔子就不行了":["73.7"],"因为这个笼子只能放狗":["73.7"],"放兔子进行可能会变异":["73.7"],"的学习曲线是怎么样的":["74.0"],"是否存在一个比较平衡的阶段":["74.0"],"让我的投入产出比最大化":["74.0"],"带来了哪些帮助":["74.1"],"太多啦":["74.1"],"我只讲一个社区中还没见过有人提的点":["74.1"],"我们书写的类型实际上也是逻辑":["74.1"],"只不过是类型世界的逻辑":["74.1"],"并且不存在于运行时":["74.1"],"在我们书写实际的代码逻辑时":["74.1"],"这些类型逻辑就像是飞机起飞前的预检":["74.1"],"preflight":["74.1"],"一样":["74.1"],"在你的代码还没运行时就能够发现其中隐藏的错误":["74.1"],"稳定性":["74.1"],"代码质量":["74.1"],"严谨性":["74.1"],"可读性等等":["74.1"],"其实本质都是这一能力":["74.1"],"它们的确不能让你的页面性能更好或是业务数据更棒":["74.1"],"但却能避免潜在的严重问题":["74.1"],"比如白屏和塞满错误监控的":["74.1"],"read":["74.1"],"property":["74.1","86.22"],"三个等级":["74.2"],"虽然我并没有把每一道题都完成":["74.2"],"但我仍然推荐想要学习更高阶类型编程的同学去花上一定时间看看":["74.2"],"前提是你已经对整个类型能力有比较清晰认知的情况下":["74.2"],"只有此时":["74.2"],"另外":["75.0","77.2","82.3","91.5"],"这一节中介绍的工具类型绝大部分是具有实际应用场景的":["75.0"],"如果你发现某一个工具类型恰好匹配了你的需求":["75.0"],"需要在开启":["75.1"],"strictnullchecks":["75.1"],"下才能正常工作":["75.1"],"搞定了递归属性修饰":["75.1"],"接着就是":["75.1"],"基于已知属性进行部分修饰了":["75.1"],"这其实也很简单":["75.1"],"你想":["75.1"],"如果我们要让一个对象的三个已知属性为可选的":["75.1"],"那只要把这个对象拆成":["75.1"],"两个对象结构":["75.1"],"分别由三个属性和其他属性组成":["75.1"],"然后让对象":["75.1"],"的属性全部变为可选的":["75.1"],"和另外一个对象":["75.1"],"组合起来":["75.1"],"不就行了吗":["75.1"],"拆开来描述一下这句话":["75.1"],"看看这里都用到了哪些知识":["75.1"],"拆分对象结构":["75.1"],"那不就是内置工具类型一节中讲到的":["75.1"],"结构工具类型":["75.1","90.1"],"omit":["75.1"],"三个属性的对象全部变为可选":["75.1"],"那不就是属性修饰":["75.1"],"岂不是可以直接用上面刚学到的":["75.1"],"递归属性修饰":["75.1"],"组合两个对象类型":["75.1"],"也就意味着得到一个同时符合这两个对象类型的新结构":["75.1"],"那不就是":["75.1"],"分析出了需要用到的工具和方法":["75.1"],"那执行起来就简单多了":["75.1"],"这也是使用最广泛的一种类型编程思路":["75.1"],"将复杂的工具类型":["75.1"],"拆解为由基础工具类型":["75.1"],"类型工具的组合":["75.1"],"直接来看基于已知属性的部分修饰":["75.1"],"markpropsasoptional":["75.1","75.3"],"会将一个对象的部分属性标记为可选":["75.1"],"为需要处理的对象类型":["75.1"],"为需要标记为可选的属性":["75.1"],"由于此时":["75.1"],"当条件不再是一个简单的单体类型":["75.2"],"而是一个联合类型时":["75.2"],"我们使用数组的方式就产生问题了":["75.2"],"就是合法的":["75.2"],"第一个数组中的可能元素类型均被第二个数组的元素类型包含了":["75.2"],"无论如何都是其子类型":["75.2"],"那么现在应该怎么办":["75.2"],"其实只要反过来看":["75.2"],"既然":["75.2","87.3"],"肯定是不成立的":["75.2"],"我们只要再加一个反方向的比较即可":["75.2"],"fallback":["75.2"],"在这种情况下":["75.2"],"的界限就比较模糊了":["75.2"],"我们只是在比较两个类型是否严格相等":["75.2"],"并没有值和表达式的概念了":["75.2"],"因此就使用":["75.2"],"来简称":["75.2"],"此时结果就符合预期了":["75.2"],"需要联合类型完全一致":["75.2"],"res2":["75.2"],"因为既然":["75.3"],"那很显然":["75.3"],"所拥有的的属性会更多嘛":["75.3"],"而对于并集":["75.3"],"就不能简单使用属性名并集版本了":["75.3"],"因为使用联合类型实现":["75.3"],"我们并不能控制":["75.3"],"同名属性的优先级":["75.3"],"比如我到底是保持原对象属性类型呢":["75.3"],"还是使用新对象属性类型":["75.3"],"还记得我们在":["75.3"],"pickbyvaluetype":["75.3"],"中使用的方式吗":["75.3"],"将一个对象拆分成数个子结构":["75.3"],"处理各个子结构":["75.3"],"再将它们合并":["75.3"],"那么对于合并两个对象的情况":["75.3"],"其实就是两个对象各自特有的部分加上同名属性组成的部分":["75.3"],"两个对象":["75.3"],"假设以":["75.3"],"的同名属性类型优先":["75.3"],"思路会是这样的":["75.3"],"比":["75.3","99.2","99.5"],"多的部分":["75.3"],"相对于":["75.3"],"的差集":["75.3"],"这也是模式匹配中常用的一种方法":["75.4"],"通过":["75.4","77.3","80.41","97.1","99.1"],"提取到某一个结构":["75.4"],"然后再对这个结构进行":["75.4"],"提取":["75.4"],"我们在此前曾经讲到一个提取":["75.4"],"promise":["75.4","84.7","87.4","101.5","103.4"],"内部值类型的工具类型":["75.4"],"promisevalue":["75.4"],"内置工具类型中也存在这么一个作用的工具类型":["75.4"],"并且它的实现要更为严谨":["75.4"],"awaited":["75.4"],"核心类型能力的入门":["75.5"],"进阶":["75.5"],"归纳与实战":["75.5"],"从基本的类型标注到内置类型的使用":["75.5"],"从掌握类型工具到类型系统的深入探索":["75.5"],"从工具类型入门到进阶再到整理出类型编程的":["75.5"],"是可选的":["75.7"],"那就不一样了":["75.7"],"也可以是一个空的接口结构":["75.7"],"就可以认为是满足的":["75.7"],"expecttype":["75.8"],"expectnottype":["75.8"],"接受一组参数":["76.0"],"然后返回一个新的值":["76.0"],"不能赋值给类型":["76.1"],"v2":["76.1","82.1"],"而在需要声明大量存在关联的字符串字面量类型时":["76.1"],"模板字符串类型也能在减少代码的同时获得更好的类型保障":["76.1"],"举例来说":["76.1","85.5"],"当我们需要声明以下字符串类型时":["76.1"],"sku":["76.1"],"iphone":["76.1"],"16g":["76.1"],"official":["76.1"],"xiaomi":["76.1"],"honor":["76.1"],"second":["76.1"],"hand":["76.1"],"还包含了":["76.2"],"等等情况":["76.2"],"copywithrename":["76.3"],"代表了这一工具类型由":["76.4"],"内部进行实现":["76.4"],"如果我们去看内部的源码":["76.4"],"会发现更神奇的部分":["76.4"],"你可能会想到":["76.5"],"如果传入的字符串字面量类型中有多个空格呢":["76.5"],"这种情况下":["76.5"],"模式匹配将只会匹配首个空格":["76.5"],"c":["76.5","107.17"],"会被匹配为":["76.5"],"这样的两个结构":["76.5"],"join":["76.6"],"到":["77.0","85.13"],"split":["77.0","96.19"],"startswith":["77.0"],"endswith":["77.0"],"等等":["77.0"],"这些方法就是我们本节要学习的内容":["77.0"],"r":["77.1","97.16"],"聪明的你肯定会想到":["77.1"],"我们的字符串边缘可能不止有一个空格":["77.1"],"而这里的实现只能去掉一个":["77.1"],"操作很简单":["77.1"],"我们递归一下就好了":["77.1"],"delimiters":["77.2"],"splitres4":["77.2"],"但需要注意的是":["77.2"],"我们并不能在一个字符串中混用多种分隔符":["77.2"],"在这种情况下由于联合类型在插槽中的排列组合特性":["77.2"],"我们会得到一个诡异的结果":["77.2"],"splitres5":["77.2"],"每次只能依据一种分隔符进行拆分才是符合预期的":["77.2"],"在正常的变量命名中":["77.2"],"通常只会使用一种分隔方式":["77.2"],"module":["77.2","93.7"],"my":["77.2"],"beta":["77.2"],"这个命名中":["77.2"],"实际上只有":["77.2"],"是分隔符":["77.2"],"确实使用了多种具有实际意义的分隔符时":["77.2"],"我们应该进行多次拆分":["77.2"],"css":["77.2","93.3","97.18"],"bem":["77.2"],"命名方式":["77.2"],"modifier":["77.2"],"下":["77.2","107.48"],"我们经常会这么写类名":["77.2"],"footer":["77.2"],"button":["77.2","79.8","80.12","101.50","107.62","107.95","107.103","111.13","115.4"],"danger":["77.2"],"我们就应当先按照":["77.2"],"拆出":["77.2"],"再按照":["77.2"],"类型我们还可以获取字符串长度":["77.2"],"strlength":["77.2"],"t":["77.2","80.18"],"trim":["77.2"],"length":["77.2","101.31","101.32","101.40"],"strlengthres1":["77.2"],"在数组中进行模式匹配时":["77.3"],"我们为何也使用了看似多余的":["77.3"],"这是因为我们的":["77.3"],"会直接传入给插槽":["77.3"],"插槽匹配":["77.3"],"能够确保最终":["77.3"],"得到的":["77.3"],"值一定会是字符串类型":["77.3"],"由于这里的":["77.3"],"被视为两种不同的结构":["77.3"],"因此我们需要再声明一个":["77.3"],"它的作用就是将":["77.3"],"递归地将数组中所有的字符串单元转化为首字母大写形式":["77.3"],"any":["77.3","107.28"],"这样我们就得到了一个初具雏形的":["77.3"],"智能版":["77.3"],"的类型能力掌握个八九不离十了":["77.4"],"接下来":["77.4","84.3"],"我们就要迈入到实战环节了":["77.4"],"包括类型声明":["77.4"],"react":["77.4","78.10","79.9","80.3","80.12","89.2"],"eslint":["77.4","78.11","80.9","86.6","86.16"],"命名空间这么几个部分":["78.0"],"这些概念不仅可以帮助你了解到":["78.0"],"工程能力的核心理念":["78.0"],"也是接下来实战篇内容的前置基础":["78.0"],"要开始学习工程能力":["78.0"],"disable":["78.1"],"lint":["78.1","81.11"],"在这里第二个":["78.2"],"指令会给出一个报错":["78.2"],"无意义的":["78.2"],"指令":["78.2"],"那这两个功能相同的指令应该如何取舍":["78.2"],"我的建议是":["78.2"],"标注类型不同":["78.3"],"我们的赋值操作在类型层面显然是不成立的":["78.3"],"但我们是在":["78.3"],"因此这里并不会有类型报错":["78.3"],"如果希望在":["78.3"],"文件中也能享受到类型检查":["78.3"],"指令就可以登场了":["78.3"],"林不渡":["78.4","83.5"],"foocls":["78.4"],"这段代码在编译后会生成一个":["78.4"],"pkg2":["78.5"],"export":["78.5","78.6","82.13","86.30","89.1","94.8","106.1"],"bar":["78.5","80.9","80.24","80.32","83.10","86.4"],"的类型声明中":["78.5"],"你也可以使用":["78.5"],"效果是一致的":["78.5"],"但由于对":["78.5"],"我们使用了默认导入":["78.5"],"先来看":["78.6"],"node":["78.6","81.4","85.6","90.2"],"中与":["78.6"],"中分别是如何进行类型声明的":["78.6"],"fs":["78.6"],"readfilesync":["78.6"],"省略":["78.6"],"接口中呢":["78.7"],"在接口一节中我们其实已经了解到":["78.7"],"如果你有多个同名接口":["78.7"],"这些接口实际上是会被合并的":["78.7"],"这一特性在类型声明中也是如此":["78.7"],"我们再声明一个":["78.7"],"接口即可":["78.7"],"usertracker":["78.7"],"args":["78.7","83.3"],"的值是一个包名":["78.8"],"也就是你想引入的":["78.8"],"如上面的例子中我们实际上是在声明当前文件对":["78.8"],"的依赖":["78.8"],"而如果你的代码文件":["78.8"],"中声明了对某一个包的类型导入":["78.8"],"那么在编译产生的声明文件":["78.8"],"bark":["78.9"],"corgi":["78.9"],"corgibark":["78.9"],"实际使用时需要导入全部的依赖文件":["78.9"],"对于后续的维护无疑是灾难":["78.10"],"我通常会将这些导入按照实际意义进行组织":["78.10"],"顺序大致是这样":["78.10"],"一般最上面会是":["78.10"],"第三方":["78.10"],"ui":["78.10","80.12","89.3"],"组件":["78.10"],"然后是项目内封装的其他组件":["78.10"],"第三方工具库":["78.10"],"然后是项目内封装的工具方法":["78.10"],"具体":["78.10"],"等分类的顺序可以按照自己偏好来":["78.10"],"类型导入":["78.10"],"包括第三方库的类型导入":["78.10"],"项目内的类型导入等":["78.10"],"我们会在后面介绍如何通过":["78.11"],"规则来进行对应地约束":["78.11"],"而三斜线指令与命名空间这两个概念":["78.11"],"虽然已经不再被大量使用":["78.11"],"但了解它们诞生与存在的意义同样对理解整个":["78.11"],"本身也支持通过":["78.13"],"文件进行配置":["78.13"],"这些组件声明方式都存在哪些特殊用法":["79.0"],"我们只会介绍函数式组件相关":["79.0"],"而不会有":["79.0"],"组件出现":["79.0"],"泛型坑位即":["79.0"],"中预留出的泛型坑位":["79.0"],"parcel":["79.1"],"等工具进行项目搭建":["79.1"],"运行":["79.1"],"npm":["79.1","93.2"],"built":["79.2","106.0"],"asset":["79.2"],"see":["79.2"],"functioncomponent":["79.3"],"的缩写":["79.3"],"同样被作为一个类型导出":["79.3"],"其使用方式是一致的":["79.3"],"接受的唯一泛型参数即为这个组件的属性类型":["79.3"],"其实还存在":["79.3"],"statelesscomponent":["79.3"],"sfc":["79.3"],"这两个同样指函数组件":["79.3"],"使用方式也和":["79.3"],"一致的类型":["79.3"],"但已经不推荐使用":["79.3"],"我们来看":["79.3"],"组件中":["79.4"],"其":["79.4"],"属性在接口结构中约束为":["79.4"],"如在":["79.4"],"中使用时我们基于":["79.4"],"另外一个常见的场景是对于在初始阶段是一个空对象的状态":["79.6"],"你可能会使用断言来这么做":["79.6"],"setdata":["79.6"],"onclick":["79.8"],"接受一个":["79.9"],"一个函数":["79.9"],"一个依赖数组":["79.9"],"这个函数的返回值会被挂载到":["79.9"],"常见的使用方式是用于实现":["79.9"],"父组件调用子组件方法":["79.9"],"子组件将自己的方法挂载到":["79.9"],"后":["79.9","83.10","86.30"],"父组件就可以通过":["79.9"],"来调用此方法":["79.9"],"我们来看具体的例子而后依次讲解":["79.9"],"import":["79.9","84.2","85.17","94.6"],"forwardref":["79.9"],"forwardrefrenderfunction":["79.9"],"from":["79.9","82.11","84.2","85.17","85.24","94.6","95.2","95.5","96.16"],"irefpayload":["79.9"],"parent":["79.9"],"e":["79.10","115.2"],"由于上下文类型的存在":["79.10"],"此时就无需再为":["79.10"],"声明类型了":["79.10"],"它会自动被推导为":["79.10"],"类似的事件定义还有非常多":["79.10"],"formevent":["79.10"],"touchevent":["79.10"],"dragevent":["79.10"],"enhancedbutton":["79.12"],"ref":["79.12","113.12","113.13"],"的存在":["79.12"],"有些时候我们会希望区分组件使用":["79.12"],"它本质上指的是一个有效的":["79.13"],"jsx":["79.13","85.8"],"可以认为包含了":["79.13"],"还有一些概念涉及到项目的规范部分":["79.14"],"我们在这里统一进行讲解":["79.14"],"ipaginationrequeststruct":["79.15"],"curpage":["79.15"],"totalcount":["79.15"],"hasnextpage":["79.15"],"实际使用时":["79.15"],"inputa":["79.16"],"提供的能力":["79.17"],"因此在你学习完毕小册前半部分的类型工具与类型编程概念后":["79.17"],"这些对你来说已经不是特别复杂的知识":["79.17"],"你需要的依旧只是在实践中去熟悉这些工具":["79.17"],"proptypes":["79.19"],"weakvalidationmap":["79.19"],"contexttypes":["79.19"],"validationmap":["79.19"],"defaultprops":["79.19"],"partial":["79.19"],"displayname":["79.19"],"版本后":["79.19"],"内部不再隐式包含":["79.19"],"只会要求减少代码":["80.0"],"但实际上在很多场景":["80.0"],"尤其是在":["80.0"],"场景下":["80.0"],"很多时候":["80.0"],"反而会要求你写":["80.0"],"更多的代码":["80.0"],"scope":["80.1"],"off":["80.1"],"indent":["80.1"],"quotes":["80.1"],"single":["80.1"],"semi":["80.1"],"settings":["80.1","85.17"],"version":["80.1"],"detect":["80.1"],"这条规则有一个需要注意的地方":["80.1"],"其配置项还可以是":["80.1"],"tab":["80.1"],"space":["80.1"],"是仅检查":["80.2"],"才是进入修改":["80.2"],"同时我们还增加了":["80.2"],"来一次性执行两个工具":["80.2"],"即使配置了":["80.2"],"还是可能出现每个人提交代码都不一样的情况":["80.2"],"这是因为这些":["80.2"],"需要手动执行":["80.2"],"非常容易忘记或者绕过去":["80.2"],"而如果我们能让所有开发同学每次提交代码时都自动执行一次格式化":["80.2"],"就能确保所有人成功提交上去的代码风格一致":["80.2"],"要实现这一能力":["80.2"],"我们需要":["80.2"],"它和":["80.2"],"可不一样":["80.2"],"它更贴近生命周期的概念":["80.2"],"即在某一个操作前后执行的额外逻辑":["80.2"],"如我们要实现在":["80.2"],"commit":["80.2"],"前格式化":["80.2"],"就可以使用":["80.2"],"pre":["80.2"],"这个钩子":["80.2"],"如果钩子执行失败":["80.2"],"就不会真地执行":["80.2"],"常用的":["80.2"],"还有":["80.2"],"msg":["80.2"],"可以用于检查":["80.2"],"信息是否规范":["80.2"],"如需要符合":["80.2"],"feat":["80.2"],"core":["80.2"],"enhancement":["80.2"],"这种格式":["80.2"],"push":["80.2"],"以及在服务端":["80.2"],"仓库执行的":["80.2"],"strict":["80.3","80.15"],"parser":["80.3"],"parseroptions":["80.3"],"project":["80.3"],"tsconfig":["80.3","82.2"],"json":["80.3","84.2","86.39","89.2","101.52","107.80","107.87"],"plugins":["80.3"],"rules":["80.3"],"函数类型等使用":["80.6"],"这是为什么呢":["80.6"],"对于这种效果完全一致仅仅在使用上有差异的语法":["80.6"],"存在":["80.7"],"then":["80.7","81.10"],"方法的对象":["80.7"],"这一规则约束使用统一的类型断言语法":["80.8"],"我一般在":["80.8"],"tsx":["80.8","85.8","85.13"],"中使用":["80.8"],"我们能够在看见":["80.9"],"时立刻知道它是一个":["80.9"],"接口":["80.9"],"看见":["80.9"],"时立刻知道它是一个类型别名":["80.9"],"额外配置如下":["80.9"],"时使用默认值":["80.11"],"可选链":["80.11"],"相比于逻辑与":["80.11"],"则能够带来更简洁的语法":["80.11"],"尤其是在属性访问嵌套多层时":["80.11"],"良好组织了导入语句的示例":["80.12"],"useeffect":["80.12"],"dialog":["80.12"],"childcomp":["80.12"],"x":["80.13","86.21"],"当你的函数显式返回了一个":["80.14"],"观察下编译结果":["80.15"],"use":["80.15","95.3"],"这一点类似于上面约束类型断言语法的":["80.16"],"一同搭配使用":["80.20"],"让你的项目里不再出现":["80.20"],"二者的区别主要在于":["80.21"],"前者是":["80.21"],"而空值合并则在左侧值为":["80.23"],"版本以后":["80.26"],"方式":["80.29"],"其实这一规则的核心原因":["80.29"],"我们在协变与逆变一节已经了解过了":["80.29"],"方式类似于在":["80.29"],"等级":["80.33"],"真的做到一个":["80.33"],"不用":["80.33"],"或是全部替换成":["80.33"],"compiler":["80.35","89.2"],"性能":["80.35"],"在这一点上可能会有比较大的分歧":["80.35"],"所以不要想着你的变量值还有可能是":["80.37"],"所以需要这样判断":["80.37"],"如果真的发生了":["80.37"],"oops":["80.38"],"strornumorbool":["80.39"],"最终的结果会仍然是":["80.41"],"但这里仍然会有类型报错":["80.41"],"原因就在于这里":["80.41"],"进行类型推导":["80.41"],"得到了一个":["80.41"],"client":["80.42"],"也是团队协作开发下的基础要求之一":["80.43"],"除了如何配置":["80.43"],"我们还了解了一批推荐使用的":["80.43"],"工具库":["81.0"],"讲解它们的基本使用":["81.0"],"你可以在这里查找是否有符合你需求的工具":["81.0"],"本节的定位类似于":["81.0"],"封装":["81.2"],"能够实现监听文件改动并重新执行文件的能力":["81.2"],"tsc":["81.2"],"watch":["81.2"],"它类似于":["81.2"],"onsuccess":["81.4"],"其实我也写过一个类似的":["81.6"],"suppress":["81.6"],"自动为项目中所有的类型报错添加":["81.6"],"firstname":["81.7"],"years":["81.7"],"zoo":["81.8"],"toolbelt":["81.8"],"目前包含工具类型数量最多的一位":["81.8"],"基本上能满足你的所有需要":["81.8"],"tsd":["81.8"],"great":["81.10"],"about":["81.10"],"hell":["81.10"],"world":["81.10","107.53"],"google":["81.10"],"com":["81.10"],"validate":["81.10"],"errors":["81.10"],"查看是否返回了错误":["81.10"],"工具":["81.11"],"如果使用这一工具来约束项目代码质量":["81.11"],"放在这里是因为它基本可以完全替代":["81.12"],"来编译":["81.12"],"的关系如何":["81.13"],"它们怎么用":["82.0"],"到底有多好用":["82.0"],"版本从":["82.1"],"开始重新来一遍":["82.1"],"有点像删号重开":["82.1"],"candidate":["82.1"],"这一阶段的提案只有在遇到了重大问题才会修改":["82.1"],"需要撰写非常完善的规范文档":["82.1"],"进入":["82.1"],"的前提条件是在规范文档的基础上":["82.1"],"官方的编辑以及指定":["82.1"],"委员会成员签署了同意意见":["82.1"],"通常来说提案进入这一阶段后":["82.1"],"我们就能通过":["82.1"],"babel":["82.1"],"插件或者各种":["82.1"],"polyfill":["82.1","89.11"],"等提前试用上":["82.1"],"finished":["82.1"],"这一阶段的提案将会被纳入到":["82.1"],"es":["82.1","82.2"],"每年发布的规范之中":["82.1"],"正式与大家见面":["82.1"],"想要完成这最后一步":["82.1"],"需要完成所有对应到提案内容的测试用例":["82.1"],"用来给引擎产商们检查实现的兼容程度":["82.1"],"以及官方编辑同意将其合并到":["82.1"],"compileroptions":["82.2"],"lib":["82.2"],"配置中新增":["82.2"],"es2021":["82.2"],"对应的":["82.2"],"版本":["82.2","107.7"],"esnext":["82.2"],"来启用这些新的语法":["82.2"],"的话":["82.3"],"反而容易引发":["82.3"],"bug":["82.3"],"逻辑与短路在属性嵌套过深时简直就是噩梦":["82.3"],"使用可选链的":["82.3"],"我们可以把它改写成这样":["82.3"],"而我们希望的是":["82.4"],"仅在左边为":["82.4"],"才去应用默认值":["82.4"],"大部分情况下我们可以直接使用":["82.4"],"其实可以替代掉以下这段代码":["82.5"],"毕竟":["82.6"],"兼得更简洁的语法以及更安全的逻辑":["82.6"],"有谁会拒绝呢":["82.6"],"06":["82.8"],"最近一次":["82.8"],"measure":["82.9"],"happened":["82.9"],"它们是原始类型":["82.9"],"await":["82.10","83.3","85.23","88.2"],"readfile":["82.10"],"txt":["82.10"],"query":["82.10","87.4"],"ask":["82.10"],"etc":["82.10"],"外还有":["82.11"],"observer":["82.11"],"subscriber":["82.11"],"以及部分":["82.11"],"operators":["82.11"],"目前只有":["82.11"],"等基础的操作符":["82.11"],"f0":["82.12"],"f2":["82.12"],"等同于":["82.12"],"另一个系列":["82.12"],"它接受一系列函数并组合成一个新的高阶函数":["82.12"],"同时仍然保持传入的调用顺序":["82.12"],"并不会立即执行这些一元函数":["82.12"],"而是返回一个新的函数":["82.12"],"person":["82.13"],"coolbool":["82.13"],"从反射到反射元数据":["83.0"],"再到基于这些概念实现依赖注入":["83.0"],"ioc":["83.0"],"容器等等":["83.0"],"本节代码见":["83.0","88.0"],"decorators":["83.0"],"首先我们需要明确的是":["83.0"],"装饰器的本质其实就是一个函数":["83.0"],"只不过它的入参是提前确定好的":["83.0"],"中的装饰器目前":["83.0"],"参数装饰器":["83.1","83.7"],"五种":["83.1"],"上的属性才是会随着继承与实例化过程被传递的":["83.2"],"实例成员":["83.2"],"我们来调用一下看看":["83.2"],"originalsetter":["83.4"],"newvalue":["83.4"],"composed":["83.4"],"actual":["83.4"],"othername":["83.5"],"别名林不渡":["83.5"],"paramidentifier":["83.6"],"而应用则是":["83.7"],"最终装饰器逻辑代码执行":["83.7"],"deco":["83.7"],"执行":["83.7","101.49"],"应用":["83.7"],"对于实例与静态的属性":["83.7"],"方法装饰器而言":["83.7"],"它们的执行与应用顺序其实":["83.7"],"取决于它们定义的位置":["83.7"],"你可以在上面的例子里把方法定义在属性之前":["83.7"],"就会发现执行顺序变成了":["83.7"],"即先定义先执行":["83.7"],"官方文档中对应用顺序给出了详细的定义":["83.7"],"然后依次是":["83.7"],"方法装饰器":["83.7"],"访问符装饰器":["83.7"],"属性装饰器":["83.7"],"应用到每个实例成员":["83.7"],"baz":["83.8"],"apply":["83.8"],"其实也起到了方法收拢的作用":["83.9"],"如果你有":["83.9"],"java":["83.9"],"go":["83.9"],"等语言的基础":["83.9"],"一定会反驳说反射才不是用来干这个的呢":["83.9"],"我们才刚要开始介绍":["83.9"],"对象的":["83.9","101.11"],"这一提案实际上并不依赖":["83.10"],"这些类型信息来自于运行时":["83.10"],"而非我们的类型标注":["83.10"],"同时这些内置元数据取出的值是装箱类型对象":["83.10"],"为其进行了额外的支持":["83.10"],"然后我们才可以获取到类型标注所对应的元数据":["83.10"],"type2":["83.10"],"这也是为什么我们需要启用":["83.10"],"emitdecoratormetadata":["83.10"],"配置的原因之一":["83.10"],"上面的装饰器执行机制代码中我们看到了编译后的装饰器代码":["83.10"],"而启用":["83.10"],"产物中会多出这些代码":["83.10"],"decorate":["83.10"],"新增":["83.10","97.7"],"param":["83.10","85.4"],"cls":["83.10","89.5"],"执行顺序等等":["83.11"],"另外我们还掌握了反射元数据的使用":["83.11"],"我也会更新关于新版装饰器的使用说明":["83.13"],"通常来说":["83.13"],"只会对已经到达":["83.13"],"的提案进行提前的支持":["83.13"],"如可选链":["83.13"],"逻辑赋值等":["83.13"],"最初引入装饰器时大概是在":["83.13"],"通过反射的方式来进行装饰":["83.14"],"我们会使用装饰器配合反射元数据实现这一设计模式":["84.0"],"以及实现基于装饰器的路由体系与一个简单的控制反转容器":["84.0"],"在这里":["84.1"],"我们的":["84.1"],"类会按照传入的":["84.1"],"去查找目标对象":["84.1"],"然后再进行实例化与赋值过程":["84.1"],"而依赖注入的代码则是这样的":["84.1"],"provide":["84.1"],"inject":["84.1"],"可以看到这里我们不需要手动进行赋值":["84.1"],"只需要声明这个属性":["84.1"],"然后使用装饰器标明它需要被注入一个值即可":["84.1"],"这里的":["84.1","86.27"],"replace":["84.2"],"对于开始我们给出的路由使用方法":["84.2"],"收集到的最终信息是这样的":["84.2"],"asyncfunction":["84.2"],"add":["84.2"],"adduser":["84.2"],"现在我们就要来使用一个真正的":["84.2"],"服务来检验一下了":["84.2"],"直接使用内置的":["84.2"],"http":["84.2","97.14"],"模块启动一个服务器":["84.2"],"就有些麻烦了":["84.3"],"我们在前面提到属性装饰器是无法对类的属性进行操作的":["84.3"],"因此我们这里只能使用委托的方式":["84.3"],"我们先告诉容器有哪些属性需要进行注入":["84.3"],"以及需要注入的类的标识符":["84.3"],"等我们从容器中去取这个类的时候":["84.3"],"容器会帮我们处理这些":["84.3"],"因此容器中需要再增加一个":["84.3"],"它的键与键值均为字符串类型":["84.3"],"propertyregistry":["84.3"],"这样在":["84.3"],"我们需要做的就是注册信息":["84.3"],"这里我们注册的是":["84.3"],"的形式":["84.3"],"以此来同时保存这个属性所在的类名称":["84.3"],"现在我们可以同时使用":["84.4"],"driverservice":["84.4"],"这两种方式来实现注入了":["84.4"],"来最后测试一下":["84.4"],"adapt":["84.4"],"consumer":["84.4"],"如果你想自己开发一些基于装饰器的工具库":["84.5"],"这一节的内容也是一个不错的开始":["84.5"],"在接下来两节":["84.5"],"onlyasyncmethoddecorator":["84.7"],"descriptor":["84.7"],"typedpropertydescriptor":["84.7"],"onlyasyncfunc":["84.7"],"propkey":["84.7"],"的参数不能赋给类型":["84.7"],"再来讲解讲解这些配置效果会更好":["85.0"],"为了避免罗列配置这种填鸭式教学":["85.0"],"我将":["85.0"],"分为三个大类":["85.0"],"构建相关":["85.0"],"类型检查相关":["85.0"],"其它":["85.4"],"方法同":["85.4"],"method":["85.4"],"如果你想使用":["85.5"],"preact":["85.5"],"h":["85.5"],"作为处理方法":["85.5"],"可以将其配置为":["85.5"],"类似":["85.5","107.89"],"只不过它影响的是":["85.5"],"fragment":["85.5"],"的提供方":["85.5"],"均是":["85.5"],"ts":["85.5","85.13","86.38","91.1","91.6","121.3"],"版本以前用于实现自定义":["85.5"],"转换的配置项":["85.5"],"当设置了":["85.5"],"此时将":["85.5"],"设置为":["85.5"],"同时将":["85.5"],"当我们配置了":["85.6"],"方法对应的声明文件":["85.6"],"就会被加载":["85.6"],"然后我们的":["85.6"],"类型上才有了":["85.6"],"除了高版本语法以外":["85.6"],"其实也和你的实际运行环境有关":["85.6"],"当你的代码仅在":["85.6"],"环境下运行时":["85.6"],"的情况下只会匹配":["85.8"],"d":["85.8","85.13","85.28"],"文件需要启用":["85.8"],"allowjs":["85.8"],"配置时才会被包括":["85.8"],"在导入语句中使用相对":["85.9"],"的解析路径":["85.9"],"如在上面根目录已经确定为":["85.9"],"如果你将":["85.10"],"更改为推导得到的":["85.10"],"的父级目录":["85.10"],"在这个目录结构中":["85.11"],"下存放我们定义的每个语言的对应翻译":["85.11"],"则是通过扫描项目获得所有需要进行代码替换位置后生成的映射关系":["85.11"],"我们在":["85.11","87.2"],"文件中会导入其中的":["85.11"],"文件来生成对应的导出":["85.11"],"虽然现在":["85.11"],"文件和":["85.11"],"文件被定义在不同的目录下":["85.11"],"下文件的行为":["85.12"],"选项":["85.12","85.30"],"其默认为":["85.12"],"即指定":["85.12"],"下的所有文件":["85.12"],"仍然包括嵌套的":["85.12"],"开始":["85.13"],"再逐级向上直到根目录":["85.13"],"在这基础上增加了对":["85.13"],"优先级按照这一顺序":["85.13"],"扩展名的文件解析":["85.13"],"以及对":["85.13"],"最后才是":["85.14"],"需要最后的空字符串":["85.14"],"配置":["85.14","87.3","121.0"],"但你仍然需要确保导入的模块是一个合法的模块":["85.15"],"开启此配置后":["85.15"],"other":["85.16"],"让常量枚举也像普通枚举那样被编译为一个运行时存在的对象":["85.21"],"则仅会在构建过程中有错误产生才会阻止写入":["85.22"],"一个常见的实践是":["85.22"],"支持了":["85.23"],"top":["85.23"],"level":["85.23"],"spreadarray":["85.24"],"to":["85.24"],"pack":["85.24"],"然而在某些情况下":["85.25"],"降级到普通的":["85.25"],"循环可能造成运行结果不一致":["85.25"],"比如一个":["85.25"],"emoji":["85.25"],"字符在":["85.25"],"循环中只会被遍历一次":["85.25"],"还有一个控制导入语句构建产物的配置":["85.26"],"它主要针对的是值导入":["85.26"],"即非类型导入或混合导入":["85.26"],"这是因为在某些时候我们的值导入可能是通过一些奇怪的方式使用的":["85.26"],"animal":["85.26"],"eval":["85.26"],"但使用":["85.28"],"与原本的":["85.29"],"你可以使用其他构建器比如":["85.30"],"文件中":["85.31","107.80"],"这两个选项当然是互斥的":["85.31"],"inlinesources":["85.31"],"这一选项类似于":["85.31"],"为":["85.32","86.23","107.107"],"unix":["85.32"],"下的换行符":["85.32"],"removecomments":["85.32"],"移除所有":["85.32"],"而是在有特殊的需要时再对应地进行配置":["85.33"],"这一节我们会接着来介绍类型检查与工程相关的":["86.0"],"但并不是说检查越严格越好":["86.1"],"更好的方式是依据实际需要来调整检查的严格程度":["86.1"],"allowxxx":["86.2"],"define":["86.3"],"兜底":["86.3"],"使用全局变量挂载":["86.3"],"标记":["86.5"],"verifyage":["86.5"],"也可以提供":["86.6"],"在这个例子中函数":["86.8"],"的参数":["86.8"],"没有声明类型":["86.8"],"因而被推导为":["86.8"],"一个自定义的错误类":["86.9"],"networkerror":["86.9"],"two":["86.11"],"在这个例子中":["86.11","89.1"],"关键字的情况下就覆盖了基类方法":["86.12"],"print":["86.12"],"beats":["86.13"],"bose":["86.13"],"你可以在实际情况中灵活地指定":["86.14"],"为具体类型":["86.14"],"如果你并不声明":["86.14"],"类型而是直接访问":["86.14"],"就会得到一个错误":["86.14"],"这两条配置的功能就是让对基于索引签名类型声明的结构属性访问更安全一些":["86.15"],"配置禁止了对未知属性":["86.15"],"就像":["86.16"],"其实很容易造成困惑":["86.18"],"你是希望这个属性被移除掉呢":["86.18"],"还是希望表示这个属性目前没有值":["86.18"],"这时难道不应该用":["86.18"],"吗":["86.18"],"为了避免这一情况":["86.18"],"你可以启用":["86.18"],"对所有文件使用严格模式进行检查":["86.19"],"表现在会禁用掉一部分语法":["86.19"],"nofallthroughcasesinswitch":["86.20"],"noimplicitany":["86.20"],"noimplicitthis":["86.20"],"fn":["86.21"],"parseint":["86.21"],"形式声明才会接受严格检查":["86.22"],"即以下代码不会被检查出错误":["86.22"],"methodish":["86.22"],"这也能进一步加快编译速度":["86.25"],"类似于":["86.25"],"但它只会跳过那些使用了":["86.25"],"被配置为父级目录":["86.27"],"因为我们仍然希望这四个项目的构建产物被放置在同一个文件夹下":["86.27"],"你也可以根据自己的实际需要定制":["86.27"],"这三个项目中也是类似":["86.27"],"composite":["86.27"],"确保你的子项目能被":["86.28"],"所有代码文件":["86.30"],"不包括声明文件":["86.30"],"都需要至少存在一个导入或导出语句":["86.30"],"比如最简单的情况下可以使用":["86.30"],"如果你希望禁用对部分":["86.33"],"importstar":["86.35"],"mod":["86.35"],"importdefault":["86.35"],"这些辅助函数会确保":["86.35"],"然后将新的编译信息通过":["86.37"],"tsbuildinfo":["86.37"],"excludedirectories":["86.38"],"build":["86.38"],"excludefiles":["86.38"],"filewhichchangesoften":["86.38"],"package":["86.39"],"除了省略了一些纯做兼容性的配置":["86.42"],"outfile":["86.42"],"的前身":["86.42"],"out":["86.42"],"还有部分没有介绍的配置我们会在后续的漫谈篇中使用专门的一节来进行介绍":["86.42"],"可能还需要再写一本小册才行":["87.0"],"那你可能会问":["87.0"],"上面说的工具我都不了解怎么办呀":["87.0"],"比较友好的一点是":["87.0"],"你不需要对这几个工具非常了解":["87.0"],"因为我们会分别介绍相应的前置知识":["87.0"],"更加友好的是":["87.0"],"或者使用这个命令":["87.1"],"curl":["87.1"],"appservice":["87.2"],"appcontroller":["87.2"],"gethello":["87.2"],"层去处理数据库交互":["87.2"],"bff":["87.2"],"日志等等的逻辑":["87.2"],"然后供":["87.2"],"层来调用":["87.2"],"这并不意味着":["87.2"],"中有一个":["87.2"],"updateuser":["87.2"],"处理方法":["87.2"],"层中也要有专门的":["87.2"],"visible":["87.3"],"createdat":["87.3"],"datetime":["87.3"],"now":["87.3"],"updatedat":["87.3"],"这个部分定义了我们的项目类型与一些":["87.3"],"专门搞了新的":["87.3"],"作为实体声明":["87.3"],"那它肯定不会只支持":["87.3"],"这里我们将":["87.3"],"配置为":["87.3"],"在后面转换一步时":["87.3"],"它就会生成":["87.3"],"代码":["87.3","101.1"],"你才能调用它":["87.3"],"则定义了数据库的类型与地址":["87.3"],"这里我们使用":["87.3"],"articleservice":["87.4"],"res":["87.4"],"findmany":["87.4"],"还记得我们在前面说到":["87.4"],"的核心优势之一就是它的类型安全":["87.4"],"它会基于":["87.4"],"schema":["87.4"],"生成对应的":["87.4"],"的类型安全与性能":["87.5"],"完成了这些前置地知识储备后":["87.5"],"下一节我们就将进入正式的开发与部署阶段了":["87.5"],"但我们并不会走完整个开发阶段":["87.5"],"user":["87.7","100.6"],"userrepository":["87.8"],"connection":["87.8"],"getrepository":["87.8"],"getone":["87.9"],"这么一连串的链式调用":["87.9"],"其实就等价于":["87.9"],"userrepo":["87.9"],"find":["87.9","89.8"],"cli":["88.1"],"现在我们需要通过":["88.1"],"在终端也登录上":["88.1"],"这里我们不能直接运行":["88.1"],"login":["88.1"],"因为你现在大概率是通过代理访问的":["88.1"],"会出现":["88.1"],"ip":["88.1"],"地址不匹配的错误":["88.1"],"我们需要使用":["88.1"],"进行登录":["88.1"],"来到":["88.1"],"全局设置":["88.1"],"页面":["88.1"],"找到授权":["88.1"],"点击创建一个新的":["88.1"],"复制它":["88.1"],"回到终端运行":["88.1"],"title":["88.2"],"content":["88.2"],"而在默认的构建过程中自然是不会有这一步的":["88.3"],"我们需要通过":["88.3"],"postinstall":["88.3"],"这个会在安装过程后执行的":["88.3"],"在其中调用":["88.3"],"scripts":["88.3"],"gen":["88.3"],"你也可以在":["88.3"],"postbuild":["88.3"],"或别的步骤进行":["88.3"],"只要确保在启动应用前执行了":["88.3"],"而在更新方法中":["88.4"],"我们需要先基于":["88.4"],"检查这一条记录是否存在":["88.4"],"且仅在存在时才进行更新":["88.4"],"update":["88.4"],"updateinput":["88.4"],"findunique":["88.4"],"where":["88.4"],"如果你希望在更新记录不存在时创建一条记录":["88.4"],"upsert":["88.4"],"查询接口中":["88.4"],"我们希望实现全量查询和基于":["88.4"],"查询两个版本":["88.4"],"我们也学习了如何使用":["88.5"],"作为云端应用平台":["88.5"],"它其实非常适合个人小项目开发":["88.5"],"毕竟它提供了包括":["88.5"],"ci":["88.5"],"对这棵语法树上的":["89.0"],"结点进行遍历处理":["89.0"],"比如将所有的函数声明转换为函数表达式":["89.0"],"最后由":["89.0"],"基于处理完毕的":["89.0"],"结点转换出新的代码":["89.0"],"就实现了语法的降级":["89.0"],"ast其实就是将代码的每个部分进行拆分":["89.0"],"得到一棵树形的结构表示":["89.0"],"你可以在":["89.0"],"explorer":["89.0"],"实时查看一段代码转换完毕的":["89.0"],"结构":["89.0"],"插件相关":["89.0"],"printer":["89.1"],"createprinter":["89.1"],"newline":["89.1"],"newlinekind":["89.1"],"linefeed":["89.1"],"result":["89.1"],"printnode":["89.1"],"emithint":["89.1"],"unspecified":["89.1"],"这么一长串代码":["89.1"],"最后会生成这样的一段函数声明":["89.1"],"我们从最基础的":["89.1"],"代表变量名的结点":["89.1"],"开始创建":["89.1"],"组装参数":["89.1"],"语句条件与代码块":["89.1"],"函数的返回语句":["89.1"],"最后通过":["89.1"],"完成组装":["89.1"],"要想流畅地使用":["89.1"],"你需要对":["89.1"],"expression":["89.1","89.2"],"declaration":["89.1","89.2"],"删除":["89.2"],"读取等等":["89.2"],"通过使用":["89.2"],"你可以使用非常简便的方式来完成各种有趣好玩的操作":["89.2"],"比如我们下面会讲到的为":["89.2"],"组件添加":["89.2"],"memo":["89.2"],"检查并更新导入语句":["89.2"],"从":["89.2"],"文件转换到":["89.2"],"类型等等":["89.2"],"而实际实现中":["89.2"],"当然也是基于":["89.2"],"的封装":["89.2"],"但是它屏蔽了":["89.2"],"statement":["89.2"],"等等概念":["89.2"],"直接提供给你应用层的实现":["89.2"],"添加泛型参数":["89.2"],"添加属性":["89.2"],"添加继承":["89.2"],"将其设置为导出":["89.2"],"完成":["89.2"],"在这个过程中":["89.2"],"你并不需要理解底层发生了哪些":["89.2"],"结点的变化和操作":["89.2"],"光是这样":["89.2"],"其实还是具有一定使用成本":["89.2"],"你此前可能已经使用过":["89.3"],"它通常会在基础框架发生大版本更新时出现":["89.3"],"用来降低使用者的迁移成本":["89.3"],"antd":["89.3"],"design":["89.3"],"material":["89.3"],"alldeclarations":["89.4"],"allspecifiers":["89.4"],"every":["89.4"],"includes":["89.4","89.7"],"missing":["89.4"],"设计一个通用的替换模式":["89.4"],"forbidden":["89.4"],"要被替换的导入路径":["89.4"],"modulespecifier":["89.4"],"替换为这个值":["89.4"],"replacement":["89.4"],"原本的导入如何更新":["89.4"],"namedimportsreplacement":["89.4"],"source":["89.5","97.21"],"addsourcefileatpath":["89.5","89.7"],"resolve":["89.5","95.2"],"dirname":["89.5"],"impls":["89.5"],"获取所有目标":["89.5"],"filteredclassdeclarations":["89.5"],"getclasses":["89.5"],"filter":["89.5"],"getimplements":["89.5"],"map":["89.5"],"获取原本的导出语句的组件名":["89.6"],"targetidentifier":["89.6"],"gettext":["89.6"],"获取":["89.6"],"对应的导入声明":["89.6"],"reactimport":["89.6"],"getimportdeclaration":["89.6"],"imp":["89.6"],"getmodulespecifiervalue":["89.6"],"新增一个具名导入":["89.6"],"insertnamedimport":["89.6"],"objecttointerfacestruct":["89.7"],"isexported":["89.7"],"entries":["89.7"],"最简单的情况":["89.7"],"直接添加属性":["89.7"],"jsdoccontent":["89.8"],"tags":["89.8"],"gettags":["89.8"],"expiretag":["89.8"],"tag":["89.8"],"gettagname":["89.8"],"如果不存在":["89.8"],"标签":["89.8"],"则跳过":["89.8"],"continue":["89.8"],"将其值处理为可解析的字符串":["89.8"],"expiredesc":["89.8"],"能够大大地简化使用成本与理解负担":["89.9"],"由于封装带来了黑盒的底层实现与各种不确定性":["89.9"],"如果你对操作的稳定性要求高":["89.9"],"最好的方式还是使用原生的":["89.9"],"不会涉及业务逻辑的检查":["89.11"],"比如我们要求对某个":["89.11"],"的导入必须存在":["89.11"],"或者要求必须调用某个全局的顶级方法":["89.11"],"此时就应该是":["89.11"],"从上线到现在":["90.0"],"我也收获了许多真诚的评价":["90.0"],"严格来说":["90.0"],"我们按照内置工具类型基础":["90.1"],"内置工具类型扩展以及模板字符串类型的顺序组织了对类型编程的学习":["90.1"],"帮助你从最简单的例子开始理解类型编程的四大范式":["90.1"],"访问性修饰工具类型":["90.1"],"集合工具类型":["90.1"],"在不考虑类型体操的情况下":["90.1"],"这部分知识已经能够涵盖你日常开发需要的":["90.1"],"拥抱下一代":["90.2"],"框架":["90.2"],"deepkit":["90.2"],"需要说明的是":["90.2"],"的过程中":["90.3"],"最幸运的一件事就是能阅读到他们的作品":["90.3"],"首先你可以放心的是":["91.0"],"面试中大概率不会出现超出这本小册的知识难度":["91.0"],"如果出现了":["91.0"],"都可以描述对象类型":["91.2"],"函数类型":["91.2"],"其不应该具有过于复杂的类型逻辑":["91.3"],"最多局限于泛型约束与索引类型这个层面":["91.3"],"因为通常来说":["91.4"],"认为后者属于前者的子类型":["91.5"],"中实现标称类型系统":["91.6"],"类型层级":["91.6","91.9"],"bottom":["91.7","107.49","107.128"],"也就意味所有类型都是它俩的子类型":["91.8"],"本身就是在描述它们在类型层级中的位置":["91.9"],"如果你能给面试官讲一遍从":["91.9"],"returntype":["91.11"],"pickbystricttype":["91.12"],"又能很少地筛选掉没有实际使用经验的候选人":["91.13"],"而如果要进一步考察技能水平":["91.13"],"routemeta":["92.0"],"03":["93.0"],"description":["93.0","121.3"],"filepath":["93.0","121.3"],"or":["93.2"],"dist":["93.3"],"默认值":["93.6"],"https":["93.6"],"请确保开发模式":["93.8"],"process":["93.8"],"scripturl":["93.9"],"cssurl":["93.10"],"可以在控制台":["93.11"],"对象中获得":["93.11"],"path":["93.11","93.12"],"指定":["93.11"],"cdnjs":["93.12"],"plugin":["94.2"],"usestore":["94.3","94.8"],"那么你可以将一个对象传递给":["94.4"],"persist":["94.4","94.5","94.9","94.10"],"属性来配置持久化":["94.4"],"state":["94.5","94.9","94.10","114.8","114.9"],"somestate":["94.5","94.9","94.10"],"你好":["94.5","94.9","94.10","101.57","107.87"],"两个方法":["94.6"],"definestore":["94.6"],"pinia":["94.6"],"me":["94.7"],"saved":["94.7"],"notme":["94.7"],"savemetoo":["94.7"],"zipson":["94.8"],"ctx":["94.9","94.10"],"持久化":["94.11"],"恢复":["94.11"],"yarn":["95.1"],"createsvgiconsplugin":["95.2"],"virtual":["95.4"],"icons":["95.4"],"register":["95.4"],"usesvgicon":["95.5"],"math":["96.1"],"存储方式":["96.1"],"基础类型存储在栈内存中":["96.1"],"g":["96.2","97.16"],"regexp":["96.2"],"如果有一个操作值是":["96.3"],"那么转换成":["96.3"],"且另一方为":["96.3"],"就会把":["96.3"],"转为原始类型再进行判断":["96.3"],"true规则2":["96.3"],"false规则2":["96.3"],"true规则4字符串转隐式转换成number之后再对比":["96.3"],"e规则布尔型隐式转换成number之后再对比":["96.3"],"enumerable":["96.5"],"obj2":["96.5"],"20240115102506908":["96.5"],"日期对象直接返回一个新的日期对象":["96.6"],"正则对象直接返回一个新的正则对象":["96.6"],"如果循环引用了就用":["96.6"],"来解决":["96.6"],"has":["96.6"],"继承可以使得子类别具有父类的各种方法和属性":["96.7"],"20240117094250912":["96.8"],"五":["96.8"],"寄生式继承":["96.8"],"使用原型式继承可以获得一份目标对象的浅拷贝":["96.8"],"然后利用这个浅拷贝的能力再进行增强":["96.8"],"添加一些方法":["96.8"],"寄生式继承相比于原型式继承":["96.8"],"还是在父类基础上添加了更多的方法":["96.8"],"parent5":["96.8"],"clone":["96.8"],"original":["96.8"],"isobject":["96.9"],"isfunction":["96.9"],"闭包让你可以在一个内层函数访问到起外层函数的作用域":["96.11"],"基本概念":["96.11"],"就去腹肌作用域查找":["96.12"],"实际上就是在使用闭包":["96.13"],"作为函数参数传递的形式":["96.13"],"第二个参数是可选参数":["96.14"],"提供可选的":["96.14"],"reviver":["96.14"],"而不管这个参数是数字还是其他":["96.16"],"设计初衷是快速便捷地基于其他对象创建新数组":["96.16"],"准确来说就是从一个类似数组的可迭代对象中创建换一个新的数组实例":["96.16"],"三个参数":["96.16"],"类似数组的对象":["96.16"],"必选":["96.16"],"加工函数":["96.16"],"新生成的数组会经过该函数的加工再返回":["96.16"],"作用域":["96.16"],"未形成标准的":["96.18"],"tosource":["96.18"],"es7":["96.18"],"includes数组遍历的方法":["96.18"],"some":["96.19"],"tostring":["96.19"],"共同处理":["96.19"],"n":["96.21"],"等来衡量":["96.21"],"堆排序":["96.23"],"堆排序是指利用堆这种数据结构所设计的一种排序算法":["96.23"],"堆积":["96.23"],"是一个近似完全二叉树的结构":["96.23"],"并同时满足堆积的性质":["96.23"],"即子节点的键值或索引总是小于":["96.23"],"或者大于":["96.23"],"它的父节点":["96.23"],"堆的底层":["96.23"],"实际上就是一棵完全二叉树":["96.23"],"可以用数组实现":["96.23"],"heap":["96.23"],"sort":["96.23"],"swap":["96.23"],"max":["96.23"],"heapify":["96.23"],"start":["96.23"],"end":["96.23","107.92"],"dad":["96.23"],"son":["96.23"],"大于":["96.24"],"源码分析":["96.24"],"如果文字换行":["97.2"],"则整个盒子的高度会增大":["97.2"],"属性选择器":["97.3"],"href":["97.3"],"属性哪些可以继承":["97.3"],"选择器":["97.4"],"0100":["97.4"],"第三":["97.4"],"类选择器":["97.4"],"body":["97.5","111.1"],"background":["97.6"],"red":["97.6","114.14","114.15"],"方式二":["97.6"],"position":["97.6"],"relative":["97.6"],"css2":["97.7"],"如何触发":["97.8"],"float":["97.8"],"的值非":["97.8"],"方式三":["97.9"],"创建一个虚拟标签":["97.9"],"after":["97.9"],"最常用":["97.9"],"这样不管是布局也好":["97.10"],"转换":["97.10","101.4"],"是相对于自身":["97.11"],"main":["97.12","107.130","107.139"],"我们使用了":["97.13"],"优点":["97.14"],"减少了":["97.14"],"重绘和回流的问题":["97.15"],"重绘并回流":["97.15"],"只重绘不回流":["97.15"],"产生回流一定会造成重绘":["97.15"],"表示红色":["97.16"],"表示绿色":["97.16"],"是什么":["97.17"],"解决办法":["97.18"],"响应式图片":["97.21"],"性能优化":["97.21"],"html":["97.21"],"picture":["97.21"],"srcset":["97.21"],"图的宽度和电脑的宽度不对应":["97.22"],"怎么办":["97.22"],"把":["97.22"],"display":["99.1"],"进行转换":["99.1"],"inline":["99.1"],"好":["99.2"],"区别二":["99.2","101.66"],"是一个实体标签":["99.3"],"用来给文字加粗":["99.3"],"逻辑标签":["99.3"],"用来加强字符语气的":["99.3"],"标签只有加粗的样式":["99.3"],"没有实际的含义":["99.3"],"标签表示标签内字符比较重要":["99.3"],"用于强调的":["99.3"],"seo":["99.4"],"的层面上":["99.4"],"蜘蛛抓取不到图片的内容":["99.4"],"体积小":["99.5"],"适合做":["99.5"],"ie8":["99.6"],"不兼容":["99.6"],"text":["100.1","107.62","107.86","111.5"],"highlight":["100.2"],"color":["100.2","114.14","114.15"],"android":["100.3"],"callout":["100.4"],"none":["100.4"],"webkit":["100.5"],"select":["100.6"],"才会指向":["101.1"],"按顺序执行":["101.1"],"变成链接的形式":["101.2"],"nan":["101.2"],"是一个数值类型":["101.2"],"但是不是一个具体的数字":["101.2"],"后有":["101.3"],"出来":["101.3"],"事件循环包含":["101.5"],"宏任务":["101.5"],"微任务":["101.5"],"还是没有写":["101.6"],"都是字符串类型":["101.11"],"参数可以写":["101.27"],"items":["101.28"],"unique":["101.30"],"fnarr":["101.33"],"newarr":["101.33"],"将空对象作为构造函数的上下文":["101.36"],"改变":["101.36"],"关闭":["101.38"],"查找规则":["101.41"],"现在对象本身找":["101.41"],"构造函数中找":["101.41"],"张三":["101.43","101.45"],"o":["101.44","101.45"],"call":["101.48"],"所以需要加":["101.49"],"是带":["101.50"],"h1":["101.50"],"现在是冒泡排序":["101.51"],"原理实现链接":["101.51"],"parse":["101.52"],"stringify":["101.52"],"copyobj":["101.52"],"不可以设置过期时间":["101.53"],"document":["101.54"],"documentelement":["101.54"],"clientwidth":["101.54"],"不可以多次声明同一个变量":["101.55"],"区别三":["101.55"],"声明变量的":["101.55"],"指向定义时候外层第一个普通函数的":["101.64"],"箭头函数不能":["101.64"],"fulfilled":["101.65"],"已成功":["101.65"],"返回的是具体的内容":["101.66"],"则返回":["101.67"],"这个问题具体要看项目和业务的情况了":["103.2"],"因为组件的加载顺序是":["103.2"],"里面的方法的":["103.3"],"会报错了":["103.3"],"settimeout":["103.4","103.15"],"请求":["103.4"],"created":["103.5"],"如果没有加入":["103.6"],"子":["103.7","103.11"],"如果当前组价加入了":["103.8"],"判断":["103.9"],"这种方式":["103.11"],"父传子很方便":["103.11"],"但是父传给孙子辈分的组件很麻烦":["103.11"],"父":["103.11"],"model":["103.12","113.27","113.28","114.2","114.17","114.18"],"的优先级大于":["103.13"],"output":["106.2"],"full":["106.3"],"解压之后双击":["107.2"],"exe":["107.2"],"进入安装向导":["107.2"],"选择安装目录":["107.3"],"阅读相关协议":["107.3"],"勾选":["107.3"],"accept":["107.3"],"项目名称":["107.4"],"bundle":["107.4"],"studio提供了多种方式用于运行项目":["107.5"],"包括预览":["107.5"],"布局":["107.6"],"只需打开需要预览的页面文件":["107.6"],"例如下图中的":["107.6"],"下载系统镜像":["107.7"],"注意选择":["107.7"],"api9":["107.7"],"等待下载完成后":["107.7"],"手机会弹框提示选择":["107.8"],"连接方式":["107.8"],"需要选择":["107.8"],"传输文件":["107.8"],"之后会弹窗询问":["107.8"],"是否允许":["107.8"],"可勾选":["107.8"],"始终允许使用这台计算机进行调试":["107.8"],"语法的基础上进行了一系列优化":["107.9"],"使开发者能够以更简洁":["107.9"],"供练习使用":["107.12"],"地址为https":["107.12"],"node之前":["107.13"],"我们需要准备好node":["107.13"],"准备node":["107.13"],"js环境需要完成以下两步操作":["107.13"],"配置环境变量":["107.13"],"在配置完node":["107.13"],"js环境后":["107.13"],"便可在终端执行以下命令来安装ts":["107.13"],"node了":["107.13"],"变量声明":["107.15"],"用于声明常量":["107.16"],"两者的区别是变量在赋值后可以修改":["107.16"],"hello":["107.20","107.31"],"isopen":["107.21"],"item1":["107.22"],"item2":["107.22"],"item3":["107.22"],"进行初始化":["107.22"],"gender":["107.23"],"对象类型的变量可以通过对象字面量":["107.23"],"函数声明语法":["107.25"],"参数详解":["107.26"],"注":["107.27","107.69"],"调用函数时":["107.27"],"未传递可选参数":["107.27"],"则该参数的值为":["107.27"],"默认参数":["107.27"],"可在函数的参数列表为参数指定默认值":["107.27"],"任意类型":["107.28"],"若函数需要处理任意类型的值":["107.28"],"则可以使用":["107.28"],"返回值详解":["107.29"],"作为返回值类型":["107.30"],"其含义为空":["107.30"],"匿名函数能够根据上下文推断出参数类型":["107.32"],"因此参数类型可以省略":["107.32"],"匿名函数的语法还可以进一步的简化":["107.32"],"只保留参数列表和函数体两个核心部分":["107.32"],"通过对象之间的协同合作":["107.34"],"实现更为复杂的程序功能":["107.34"],"是对象的蓝图或模板":["107.34"],"语法说明":["107.35"],"读":["107.37"],"lisi":["107.37"],"写":["107.37"],"introduce":["107.39"],"and":["107.39"],"am":["107.39"],"是面向对象编程中的另一个重要概念":["107.42"],"对象和一个":["107.44"],"注意两个对象的类型均可以设置":["107.44"],"p1":["107.44"],"zhangsan":["107.44"],"变量的类型为":["107.46"],"左":["107.48"],"右":["107.49"],"进行移动":["107.49"],"此时就可以先使用枚举定义好所有可能的输入选项":["107.49"],"direction":["107.49"],"up":["107.49"],"left":["107.49"],"right":["107.49"],"函数的实现如下":["107.49"],"再例如":["107.50"],"每个模块都拥有自己的作用域":["107.52"],"这意味着在一个模块中声明的任何内容":["107.52"],"如变量":["107.52"],"hellofroma":["107.54"],"strfroma":["107.54"],"hellofromc":["107.54"],"strfromc":["107.54"],"modulea":["107.55"],"默认导入":["107.55"],"由于每个模块最多有一个默认导出":["107.55"],"因此默认导入无需关注导入项的原始名称":["107.55"],"并且无需使用":["107.55"],"主要扩展了":["107.56"],"声明式":["107.56"],"是一种编写用户界面的范式":["107.57"],"类型的变量来表示这两个状态":["107.58"],"表示":["107.58"],"在分析完界面状态后":["107.59"],"我们需要准确的描述界面在不同状态下的显示效果":["107.59"],"为了实现点击按钮开":["107.60"],"关灯的效果":["107.60"],"我们可以为按钮绑定点击事件":["107.60"],"当用户点击":["107.60"],"开灯按钮":["107.60"],"的核心思想":["107.61"],"声明式描述":["107.61"],"开发者只需描述在界面在不同状态下要呈现的最终效果":["107.61"],"例如":["107.62","107.98","107.124"],"案例效果":["107.64"],"width":["107.65"],"borderradius":["107.65"],"reference":["107.67"],"就会弹出":["107.67"],"如果组件支持子组件配置":["107.67"],"可在":["107.67"],"后的":["107.67"],"arkts":["107.68","107.98","107.125"],"还支持自定义组件":["107.68"],"被":["107.69"],"装饰后才具备组件化的能力":["107.69"],"装饰器是":["107.69"],"中的一种特殊语法":["107.69"],"常用于装饰类":["107.69"],"案例的完整代码见":["107.70","107.73","107.76"],"demos":["107.70","107.73","107.76","107.99","107.106","107.115","107.124","107.130","107.133"],"entry":["107.70","107.76","107.106","107.115","107.130","107.133","107.139"],"渲染控制":["107.71"],"均可使用条件渲染实现":["107.73"],"ui描述":["107.74"],"会再次使用keygenerator为每个元素重新生成一遍key":["107.77"],"会检查新生成的key在上次渲染时是否已经存在":["107.77"],"若存在":["107.77"],"就会认为这个key对应的数组元素没有发生变化":["107.77"],"那它就会直接复用这个key所对应的组件对象":["107.77"],"若不存在":["107.77"],"就会认为这个key对应的元素发生了变化":["107.77"],"或者该元素为新增元素":["107.77"],"就会为该元素重新创建一个组件对象":["107.77"],"开发者可以通过keygenerator函数自定义key的生成规则":["107.77"],"如果开发者没有定义keygenerator函数":["107.77"],"则系统会使用默认的key生成函数":["107.77"],"cn目录下的资源":["107.80"],"为英文时":["107.80"],"则会使用en":["107.80"],"us目录下的资源":["107.80"],"若没有与当前所处环境相对应的版本":["107.80"],"则使用":["107.80"],"目录下资源":["107.80"],"各目录存储的具体资源如下":["107.80"],"存放媒体资源":["107.80"],"视频等文件":["107.80"],"存放用于描述页面元素的尺寸":["107.80"],"颜色":["107.80"],"样式等的各种类型的值":["107.80"],"每种类型的值都定义在一个相应的":["107.80"],"存放自定义配置文件":["107.80"],"rawfile":["107.80"],"用于存储任意格式的原始文件":["107.80"],"需要注意的是rawfile不会根据设备所处的环境去匹配不同的资源":["107.80"],"总结":["107.80"],"resources目录下可用于存放图片的目录有":["107.80"],"对应的物理像素会更少":["107.82"],"相反在像素密度高的屏幕上":["107.82"],"单个像素的物理尺寸小":["107.82"],"对应的物理像素会更多":["107.82"],"因此就能在不同像素密度的屏幕上":["107.82"],"获得基本一致的观感了":["107.82"],"类型的参数":["107.82","107.89"],"默认以":["107.82","107.89"],"作为单位":["107.82"],"类型参数用于引用resources下的element目录中定义的数值":["107.82"],"引用element目录中的数值":["107.82"],"同样需要使用":["107.82"],"fill":["107.83"],"不保持宽高比进行放大缩小":["107.83"],"使得图片充满显示区域":["107.83"],"scaledown":["107.83"],"保持宽高比进行缩小或不变":["107.83"],"不会放大":["107.83"],"高质量插值":["107.84"],"可能会影响图片渲染的速度":["107.84"],"medium":["107.84","107.90"],"中等质量插值":["107.84"],"low":["107.84"],"内容如下":["107.87"],"greeting":["107.87"],"vp":["107.89"],"具体大小也会随屏幕的像素密度变化而变化":["107.89"],"regular":["107.90"],"字体粗细适中":["107.90"],"bold":["107.90"],"字体较粗":["107.90"],"bolder":["107.90"],"008000":["107.91"],"类型的参数用于使用16进制的数字设置":["107.91"],"尾部对齐":["107.92"],"各选项效果如下":["107.92"],"文本超长时":["107.93"],"进行裁剪显示":["107.93"],"ellipsis":["107.93"],"显示不下的文本用省略号代替":["107.93"],"circle":["107.96"],"圆形":["107.96"],"normal":["107.96"],"普通形状":["107.96"],"相关案例见":["107.99","107.106","107.124"],"点击事件":["107.100"],"我被点击了":["107.100"],"为切换按钮组件":["107.102"],"checkbox":["107.103"],"复选框":["107.103"],"按钮":["107.103"],"方法设置":["107.105"],"toggle":["107.105"],"组件的状态由关闭切换为打开时":["107.107"],"textinput":["107.109","107.118"],"用于设置输入框当前的文本内容":["107.110"],"名称":["107.112"],"可通过":["107.113"],"caretcolor":["107.113"],"的样式":["107.114"],"组件绑定":["107.117"],"该方法的参数定义如下":["107.117"],"组件绑定相关事件":["107.118"],"两个方法的参数定义如下":["107.118"],"event":["107.118"],"progress":["107.120"],"线性样式":["107.121"],"ring":["107.121"],"环形无刻度样式":["107.121"],"eclipse":["107.121"],"属性用于设置":["107.123"],"的刻度数":["107.123"],"提示用户进行操作或收集用户输入":["107.125"],"消息提示":["107.127"],"常用于显示一些简短的消息或提示":["107.127"],"resource":["107.128"],"duration":["107.128"],"可使用全局方法":["107.131","107.134"],"alertdialog":["107.131"],"actionsheet":["107.134"],"u8ed6fe33":["107.136"],"textpickerdialog":["107.137"],"文本滑动选择器弹窗":["107.137"],"官方文档":["107.137"],"fe":["109.1"],"runtime":["109.1"],"的事件":["109.1"],"管理数据":["109.1"],"可以将":["110.3"],"template":["110.5","111.15","114.4","118.1"],"转换为局部作用域":["110.7"],"去掉":["110.7"],"将以下元素渲染成":["111.1"],"span":["111.2","114.4"],"的子元素中":["111.3"],"且默认值为":["111.5"],"active":["111.9","111.10","114.14","114.15"],"mybutton":["111.12"],"disabled":["111.12"],"do":["111.15"],"click":["112.1","112.2","115.4","116.1","116.2"],"dec":["112.5"],"减":["112.5"],"at":["112.9","112.10"],"component":["113.1","113.2","117.1","117.2"],"plusone":["113.9","113.10"],"eleref":["113.12","113.13"],"这意味着你在侦听器回调中访问的":["113.14"],"将是被":["113.14"],"更新之前的状态":["113.14"],"count":["113.16","113.17","118.2"],"这通常在对浅引用的内部值进行深度变更后使用":["113.18"],"doubled":["113.23","113.24"],"调用":["113.25"],"使它从不更新":["114.5"],"更新元素的":["114.6"],"innerhtml":["114.6"],"it":["114.11","114.12"],"vatltexue":["114.18"],"click2":["115.1"],"原生阻止冒泡":["115.2"],"stoppropagation":["115.2"],"添加按键修饰符让即使":["115.4"],"alt":["115.4","121.7"],"被一同按下时也会触发":["115.4"],"被按下的时候才触发":["115.5"],"increment":["116.1","116.2"],"创建的代理返回其原始对象":["118.3"],"你能实现它吗":["119.1"],"increase":["119.2"],"app":["120.1"],"option":["121.0"],"风格的":["121.0"],"methods":["121.1"],"computed":["121.1"],"md":["121.3"],"属性是响应式的":["121.4"],"注意点":["121.4"],"中操作数据需要":["121.4"],"源对象":["121.5"],"返回值":["121.5"],"若":["121.6"],"a8":["121.7"],"a1":["121.7"],"a5":["121.7"],"85value":["121.7"],"自动补充value":["121.7"],"年龄":["121.8"],"性别":["121.8"]},{"0":["0.36","58.36","77.2","83.6","89.4","89.6","100.2"],"1":["13.0","55.4","67.5","72.2","73.2","80.1","80.2","82.9","83.13","101.27","107.39","111.16"],"2":["0.34","0.80","13.0","55.1","56.1","58.34","58.80","67.5","72.2","85.25","101.60","103.4"],"3":["55.1","67.5","72.2","74.1","82.9","83.7","88.2","90.1","93.4","97.11","101.7","101.53","101.64","103.2"],"4":["55.1","71.12","83.7","89.4","96.5","96.13","97.22","101.11"],"5":["0.24","0.60","0.63","0.86","0.90","44.0","58.24","58.60","58.63","58.86","58.90","103.8"],"6":["0.60","56.6","58.60","82.8"],"7":["71.12","77.2","85.23"],"8":["0.34","58.34","77.2"],"10":["0.33","0.83","58.33","58.83","74.1","86.21","96.24","101.54"],"13":["82.1"],"16":["69.5"],"17":["107.44"],"18":["69.5","83.10","86.5"],"19":["69.5"],"20":["90.1"],"21":["69.5"],"31":["90.1"],"35":["107.44"],"43":["105.0"],"50":["121.7"],"60":["107.17"],"80":["90.1"],"100":["101.10"],"200":["78.3","84.2"],"262":["0.26","58.26","82.1"],"400":["54.3"],"599":["68.1","72.5","76.5"],"1500":["107.128"],"2015":["82.1"],"2022":["82.1"],"3000":["84.2","90.2"],"3269":["36.3"],"10000":["107.128"],"20000":["67.2"],"typeof":["0.2","0.25","58.2","58.25","66.3","101.2"],"不能作为函数名":["0.2","58.2"],"关键字":["0.3","56.3","58.3"],"保留字":["0.3","56.3","58.3"],"true":["0.3","0.33","58.3","58.33","60.4","61.5","80.34","83.10","86.5","86.6","86.25","101.67"],"以它们的反向组合":["0.4","58.4"],"结尾":["0.4","58.4"],"语法":["0.5","58.5","76.3","78.5","96.19"],"也可以单独指定一个函数在严格模式下执行":["0.5","58.5"],"continue":["0.7","58.7"],"for":["0.7","20.1","55.3","58.7","84.2","86.35","89.0","89.4","89.5","101.52"],"switch":["0.7","58.7","76.4"],"yield":["0.7","58.7"],"按照规定":["0.8","58.8"],"public":["0.10","58.10"],"hi":["0.13","58.13"],"就变成了全局变量":["0.14","58.14"],"只要调用了一次函数":["0.14","58.14"],"就会定义这个变量":["0.14","58.14"],"并且可以在函数外部访问到":["0.14","58.14"],"虽然可以通过省略":["0.14","58.14"],"操作符定义全局变量":["0.14","58.14"],"但不推荐这么做":["0.14","58.14"],"在局部作用域中定义的全局变量基恩男维护":["0.14","58.14"],"也会造成困惑":["0.14","58.14"],"这是因为不能一下子断定省略":["0.14","58.14"],"也就是把所有变量声明都拉到函数作用域的顶部":["0.15","58.15"],"此外反复多次使用":["0.15","58.15"],"声明同一个变量也没有问题":["0.15","58.15"],"没有定义":["0.16","58.16"],"在这里":["0.16","58.16","64.2","70.2"],"变量之所以不能在":["0.16","58.16"],"块外部被引用":["0.16","58.16"],"是因为它的作用域仅限于该块内部":["0.16","58.16"],"before":["0.17","58.17"],"initialization":["0.17","58.17"],"age":["0.18","58.18","61.4","83.10","113.12","113.13"],"同时也就不可能在没有声明的情况下去声明它":["0.19","58.19"],"变量引用的是一个对象":["0.21","58.21"],"那么修改对象内部的属性并不违反":["0.21","58.21"],"的限制":["0.21","58.21"],"person":["0.21","58.21","121.3"],"let":["0.22","0.32","58.22","58.32","78.9","101.46","101.63","107.22","107.23","107.39"],"string":["0.23","0.42","58.23","58.42","62.8","69.7","70.3","76.2","79.7","80.25","83.3","113.29"],"symbol":["0.23","58.23","70.2","76.4","83.10"],"object":["0.24","0.28","0.44","58.24","58.28","58.44","67.5","69.7","75.4","80.40","91.5"],"表示值为对象":["0.24","58.24"],"而不是函数":["0.24","58.24"],"对未声明的变量调用":["0.25","58.25"],"delete":["0.25","53.0","58.25"],"也不会报错":["0.25","58.25"],"但是这个操作没什么用":["0.25","58.25"],"实际上在严格模式下会抛出错误":["0.25","58.25"],"因此在":["0.26","58.26","85.25"],"ecma":["0.26","58.26"],"将他们定义为表面上相等":["0.26","58.26"],"如":["0.26","58.26","60.3","60.5","78.13","79.19","80.1","80.11","85.28","86.35","87.2","87.3","89.1","91.5"],"console":["0.26","0.32","0.66","1.1","54.2","58.26","58.32","58.66","80.39","81.10","83.3","83.4","83.7","84.2","86.23","89.6","94.9","94.10","96.3","101.43","101.44","101.45","101.61","101.62","107.17","107.49"],"是区分大小写的":["0.27","58.27"],"nan":["0.28","0.74","0.75","58.28","58.74","58.75"],"任意对象":["0.28","58.28"],"在某些语言中也叫双精度值":["0.29","58.29"],"0x":["0.30","58.30"],"区分大小写":["0.30","58.30"],"然后是十六进制数字":["0.30","58.30"],"对于非常大或者非常小的数值":["0.31","58.31"],"浮点值可以用科学计数法来表示":["0.31","58.31"],"科学计数法用于表示一个应该乘以":["0.31","58.31"],"的给定次幂的数值":["0.31","58.31"],"中科学计数法的格式要求是一个数值":["0.31","58.31"],"整数或者浮点数":["0.31","58.31"],"result":["0.32","58.32","86.35"],"log":["0.32","1.1","58.32","80.39","81.10","83.3","83.4","83.7","84.2","84.4","85.26","86.23","89.6","94.9","94.10","96.3","101.14","101.21","101.22","101.24","101.34","101.62","107.49"],"后":["0.33","58.33","85.24","88.4"],"该函数会尝试把它转换为数值":["0.33","58.33"],"某些非数值的值可以直接转换成数值":["0.33","58.33"],"如字符串":["0.33","58.33"],"或布尔值":["0.33","58.33"],"任何不能转换为数值的值都会导致这个函数返回":["0.33","58.33"],"按二进制解析":["0.34","58.34"],"按八进制解析":["0.34","58.34"],"按十进制解析":["0.34","58.34"],"按十六进制解析":["0.34","58.34"],"函数的工作方式和":["0.34","58.34"],"函数相似":["0.34","58.34"],"都是从位置":["0.34","58.34"],"开始检测每个字符":["0.34","58.34"],"同样":["0.34","58.34"],"单引号":["0.35","58.35"],"或反引号":["0.35","58.35"],"是十六进制的":["0.36","58.36"],"x41":["0.36","58.36"],"等于":["0.36","58.36"],"然后将包含新值的另一个字符串保存到该变量":["0.37","58.37"],"时":["0.38","58.38","63.5","84.1","84.3","87.2","89.1","96.24","107.60"],"可以传入一个参数作为底数":["0.38","58.38"],"first":["0.39","58.39"],"line":["0.39","58.39","97.3"],"title":["0.40","31.1","58.40"],"aaa":["0.40","58.40"],"接收到的参数依次是原始字符串数组和对每个表达式求值的结果":["0.41","58.41"],"且符号实例是唯一":["0.43","58.43"],"不可变的":["0.43","58.43"],"not":["0.44","58.44"],"a":["0.44","9.0","51.0","58.44","67.5","79.8","80.9","88.1","96.16","97.16","107.22","107.31","107.39","115.4"],"constructor":["0.44","58.44"],"如果你确实想使用符号包装对象":["0.44","58.44"],"可以借用":["0.44","58.44"],"函数":["0.44","15.0","58.44","107.52","107.82"],"则返回":["0.45","0.74","0.75","58.45","58.74","58.75"],"undefined":["0.45","0.83","58.45","58.83","75.4","79.3","86.21"],"创建全局符号":["0.45","58.45"],"s":["0.45","58.45","78.6","79.8"],"defineproperties":["0.46","58.46"],"定义的属性":["0.46","58.46"],"的值":["0.47","58.47","61.8","96.16"],"来改变":["0.47","58.47"],"在迭代该对象时的行为":["0.47","58.47"],"tolocalstring":["0.60","58.60"],"返回对象的字符串表示":["0.60","58.60"],"该字符串反应对象所在的本地化执行环境":["0.60","58.60"],"中最简单的操作符":["0.62","58.62"],"对于浮点数":["0.63","58.63"],"加":["0.63","58.63"],"主要用于把数值变成负值":["0.64","58.64"],"如把":["0.64","58.64"],"就是每个":["0.65","58.65"],"都变成":["0.65","58.65"],"每个":["0.65","58.65"],"二进制11111111111111111111111111100110":["0.66","58.66"],"正或负":["0.70","58.70"],"对正数来说":["0.71","58.71"],"这跟有符号右移效果相同":["0.71","58.71"],"但对负数来说":["0.71","58.71"],"infinity":["0.73","0.79","58.73","58.79"],"如果操作数是":["0.73","58.73"],"null":["0.73","0.75","0.83","58.73","58.75","58.83","61.3","63.3","65.1","79.3","86.35"],"如果两个操作数都是":["0.75","58.75"],"除法和取模":["0.76","58.76"],"的有限数值":["0.77","58.77"],"则根据第二个操作数的符号返回":["0.77","0.78","58.77","58.78"],"除以任何数值":["0.78","58.78"],"如果是":["0.79","58.79"],"除以":["0.79","58.79"],"有一个是字符串的规则":["0.82","58.82"],"如果两个操作数都是字符串":["0.82","58.82"],"则将第二个字符串拼接到第一个字符串后面":["0.82","58.82"],"如果只有一个操作数是字符串":["0.82","58.82"],"则将另一个操作数转换为字符串":["0.82","58.82"],"如果有任一操作数是字符串":["0.83","58.83"],"布尔值":["0.83","58.83"],"或":["0.83","58.83","79.12","80.23","81.6","82.1","85.20"],"则先在后台使用":["0.83","58.83"],"number":["0.83","58.83","65.4","67.3","68.1","68.6","69.7","73.0","75.1","77.2","80.18","88.4","107.31"],"取得结果后再根据前面的规则执行比较":["0.84","58.84"],"如果没有":["0.84","58.84"],"操作符":["0.84","58.84"],"否则":["0.86","58.86"],"两者不不相等":["0.86","58.86"],"特殊情况":["0.86","58.86"],"表达式":["0.86","58.86"],"结果":["0.86","58.86"],"不全等操作符用一个叹号和两个等于号":["0.87","58.87"],"减后赋值":["0.89","58.89"],"左移后赋值":["0.89","58.89"],"num":["0.90","58.90","80.39","101.57"],"的核心库只关注视图层":["1.0"],"length":["1.1","96.16","101.39","111.16"],"关注了过程":["1.1"],"隐藏":["1.2"],"20240313104458974":["1.2"],"虽然没有完成遵循":["1.2"],"就是一个对象":["1.3"],"用来描述真实":["1.3"],"缺点就是虚拟":["1.4"],"编写麻烦":["1.4"],"测试性":["1.5"],"每个页面必须重新加载js":["2.1"],"css等相关资源":["2.1"],"服务端返回完整的":["2.1"],"同时数据也可以在后端进行获取一并返回":["2.1"],"模板引擎":["2.1"],"相对容易":["2.2"],"相对复杂":["2.2"],"用户体验好":["2.2"],"快":["2.2"],"内容的改变不需要重新加载整个页面":["2.2"],"仅适合静态页面网站":["2.3"],"变化率不高的网站":["2.3"],"ssr":["2.3"],"层的操作效率高":["3.1"],"可以将":["3.1"],"操作转化成对象操作":["3.1"],"最终通过":["3.1"],"返回的对象就是虚拟":["3.2"],"dom":["3.2","85.6"],"做":["3.3"],"操作":["3.3"],"可重用":["4.0"],"可组合":["4.0"],"组件化开发能大幅提高应用的开发效率":["4.0"],"那更新的时候整个页面都要重新更新":["4.1"],"如果过分的拆分组件会导致":["4.1"],"这样会导致大量":["5.0"],"只会劫持已经存在的属性":["6.1"],"数组则是通过重写数组的方法来实现":["6.1"],"多层对象是通过递归来实现劫持":["6.1"],"来进行劫持":["6.2"],"浪费性能":["6.2"],"对所有索引进行劫持会造成性能浪费":["6.2"],"handler":["6.3","37.3","84.7"],"temp":["6.3"],"unshift":["7.1"],"sort":["7.1"],"depend":["8.1"],"当属性发生修改时会触发":["8.1"],"此时会触发依赖收集":["8.2"],"track":["8.2"],"vmcount":["9.0"],"avoid":["9.0"],"adding":["9.0"],"properties":["9.0"],"to":["9.0","76.2"],"instance":["9.0"],"its":["9.0"],"root":["9.0"],"at":["9.0","84.2","86.39","101.51"],"runtime":["9.0"],"declare":["9.0","60.6","62.2","76.5","78.9","89.1"],"it":["9.0"],"show":["10.1","107.131","107.134"],"只是切换当前":["10.1"],"如果页面逻辑在第一次加载的时候已经被确认后续不会频繁更改则采用":["10.3"],"effect":["11.0"],"计算属性可以简化模板中的复杂表达式":["11.1"],"vue3提供了":["11.2"],"oncleanup":["11.2"],"通常用于处理单值的响应式":["12.1"],"重新运行":["13.0"],"将静态语法做静态标记":["14.0"],"markup":["14.0"],"diff":["14.0"],"来做优化":["14.0"],"静态节点跳过":["14.0"],"最终就拿到了":["15.0"],"内部挂在的时候会产生一个":["15.0"],"watcher":["15.0"],"会调用":["15.0"],"函数会触发依赖收集":["15.0"],"eventbus":["16.0"],"或者使用状态管理工具":["16.0"],"中解析时":["17.0"],"先解析":["17.0"],"再解析":["17.0"],"重新渲染和打补丁之前":["18.1"],"此时修改数据不会再次触发更新方法":["18.1"],"updated":["18.1"],"由于数据更改导致的虚拟":["18.1"],"重新渲染和打补丁":["18.1"],"在这之后会调用该钩子":["18.1"],"beforedestroy":["18.1"],"缓存的组件停用时调用":["18.2"],"errorcaptured":["18.2"],"捕获一个来自子孙组件的错误时被调用":["18.2"],"rendertracked":["18.2"],"dev":["18.2"],"调试钩子":["18.2"],"响应式依赖被收集时调用":["18.2"],"的":["19.1","34.1","61.11","75.2","107.44","113.14"],"算法是平级比较":["19.1"],"老的儿子是一个列表":["19.2"],"新的儿子也是一个列表":["19.2"],"updatechildren":["19.2"],"列表优化比较":["19.2"],"头头":["19.2"],"尾尾":["19.2"],"的作用和原理":["20.0"],"v":["20.1","36.2","75.4","89.7"],"渲染的元素列表时":["20.1"],"他默认使用":["20.1"],"就地更新":["20.1"],"无":["20.2","101.3"],"会导致更新的时候出问题":["20.2"],"方法调用时":["21.1"],"会将":["21.1"],"实例方法":["21.2"],"通过把它们添加到":["21.2"],"调用":["21.3","67.7","96.19"],"方法":["21.3","73.3","96.19","101.11","107.34"],"apply":["21.3","83.3","101.48"],"walter":["22.1"],"white":["22.1"],"heisenberg":["22.1"],"两个组件就是两个实例":["23.0"],"希望数据不干扰":["23.0"],"child1":["23.0"],"new":["23.0","61.8","63.14","82.10","82.11","83.5","85.26","101.18","101.43","101.45","101.64","103.15","107.39"],"替换对应组件":["24.0"],"函数式组件不会被记录在组件的父子关系中":["24.0"],"这个写个方法":["25.0"],"不行吗":["25.0"],"vue3":["25.0","26.2","103.13","121.0"],"果断废弃了过滤器":["25.0"],"p":["25.0","118.1"],"只渲染元素和组件一次":["26.1"],"随后的重新渲染":["26.1"],"之后":["26.2","113.14"],"增加了":["26.2"],"memo":["26.2"],"通过依赖列表的方式控制页面渲染":["26.2"],"mixin有很多缺陷":["27.1"],"命名冲突问题":["27.1"],"数据来源问题":["27.1"],"全局混入":["27.2"],"一般情况下全局混入用于编写组件":["27.2"],"directives":["27.3"],"filters会在原型链上叠加":["27.3"],"什么时候使用它":["28.0"],"进行占位":["28.1"],"在使用组件时":["28.1"],"布局组件":["28.2"],"template":["28.3","35.1","79.1","111.5","113.20","121.3"],"是":["29.1","69.5","77.2","82.1"],"事件":["29.2"],"会解决中文输入问题":["29.2"],"target":["29.3","86.23","89.4"],"那组件中如果有多个数据想要做双向数据绑定怎么办":["29.3"],"很遗憾在":["29.3"],"vue2":["29.3"],"中不支持使用多个":["29.3"],"return":["30.0","76.4","82.11","88.2","89.5","94.3","96.3","101.30","103.15","106.1","107.36","107.77"],"c":["30.0","67.5","68.1","96.16","107.19"],"attrs":["30.0","111.13"],"elmenuitem":["31.2"],"nativeonclick":["31.2"],"alert":["31.2","101.40"],"js":["32.0","78.4","83.13","85.11","86.19","96.16"],"sub":["32.0"],"鼠标按键修饰符":["33.0"],"left":["33.0","97.11"],"right":["33.0"],"middle":["33.0"],"code":["34.1","60.2"],"对象":["34.2"],"mycomponent":["34.2"],"异步组件加载时使用的组件":["34.2"],"loading":["34.2","42.0","60.8"],"loadingcomponent":["34.2"],"forceupdate":["34.3"],"html":["35.1","56.4","97.19"],"div":["35.1","85.5","121.3"],"而不是销毁他们":["36.1"],"在组建再次重新激活时可以通过缓存的实例拿到之前渲染的":["36.1"],"app":["36.2","107.80","107.87"],"需要缓存的视图组件":["36.2"],"if":["36.2","84.2","86.5","86.9","86.35","107.49"],"route":["36.2"],"registered":["36.3"],"as":["36.3","79.6","79.19","80.13","80.25"],"different":["36.3"],"local":["36.3"],"components":["36.3","121.3"],"so":["36.3"],"cid":["36.3"],"alone":["36.3"],"is":["36.3"],"enough":["36.3"],"ctor":["36.3"],"tag":["36.3"],"生成缓存的key":["36.3"],"如果有key":["36.3"],"在":["36.4","68.2","85.9","87.8","87.9"],"alive":["36.4"],"缓存组件被激活的时候":["36.4"],"进行扩展":["37.1"],"指令的目的在于可以将操作":["37.1"],"也可能没有":["37.2"],"componentupdated":["37.2"],"指令所在组件的":["37.2"],"bindings":["37.3"],"vnode":["37.3"],"function":["37.3","62.10","71.5","76.4","76.5","78.7","79.15","80.15","82.10","82.11","83.0","96.3","101.13","101.39","107.30","107.49"],"e":["37.3"],"contains":["37.3"],"装饰器的用法":["38.0"],"对功能进行增强":["38.0"],"中介者模式":["38.0"],"中介者是一个行为设计模式":["38.0"],"通过提供一个统一的接口让系统的不同部分进行通信":["38.0"],"函数式组件开销低":["39.0"],"采用异步组件":["39.0"],"借助":["39.0"],"webpack":["39.0"],"分包的能力":["39.0"],"请求":["40.0"],"打包时开启":["40.0"],"gzip":["40.0"],"压缩处理":["40.0"],"compression":["40.0"],"nginx":["41.0"],"做反向代理":["41.0"],"websocket":["41.0"],"增添请求队列":["42.0"],"实现":["42.0","53.0"],"meta":["43.1"],"备注":["43.1"],"用户登录后可得到对应的权限列表":["43.1"],"通过权限列表筛查出对应符合的路由信息":["43.1"],"最后通过":["43.1"],"导航被确认":["44.0"],"aftereach":["44.0"],"不利于":["45.0"],"seo":["45.0"],"优化":["45.0"],"服务端无法响应到对应的资源":["46.0"],"采用集中存储管理应用的所有组件的状态":["47.1"],"核心就是解决数据的共享":["47.1"],"为了解决接口的复用问题":["47.2"],"封装公共的逻辑":["47.2"],"和":["47.3","57.1","64.1","69.5","70.5","77.1","80.1","85.23","85.24","89.1","97.13","107.44"],"action":["47.3"],"的选取":["47.3"],"进行数据共享":["47.4"],"store":["48.0","80.12","94.3","94.6","94.11"],"持久化插件":["49.0"],"非":["50.0"],"中修改数据":["50.0"],"createstore":["51.0"],"modules":["51.0","80.2"],"shaking":["52.0"],"更加友好":["52.0"],"代码也更容易压缩":["52.0"],"组件逻辑共享问题":["52.0"],"采用":["52.0"],"mixins":["52.0"],"setter":["53.0"],"的性能差":["53.0"],"当新增属性和删除属性时无法监控变化":["53.0"],"需要通过":["53.0"],"set":["53.0","96.6","113.29"],"数组不采用":["53.0"],"孙子组件出错时":["54.1"],"错误会一直向上抛":["54.1"],"vm":["54.2"],"info":["54.2","84.2"],"status":["54.3","80.11"],"handleqerror":["54.3"],"enum":["55.1","81.7"],"动态文本节点":["55.1"],"class":["55.1","91.2","107.42","121.3"],"动态c1ass":["55.1"],"style":["55.1","64.5","93.3","110.7","121.7"],"动态sty1e":["55.1"],"除了c1ass":["55.1"],"sty1e动态属性":["55.1"],"full":["55.1"],"有key":["55.1"],"这里我们知道默认根节点是一个":["55.2"],"节点":["55.2"],"如果要是按照之前的套路来搞":["55.2"],"text":["55.4","57.1","113.27","113.28","114.8","114.9"],"定义并提供核心功能":["56.1"],"描述遍历和操作":["56.5"],"树的接口":["56.5"],"domlevel3":["56.5"],"进一步扩展了":["56.5"],"增加了统一的方式加载和保存文档的方法":["56.5"],"包含在一个叫":["56.5"],"提供关于用户屏幕分辨率的详尽信息":["56.6"],"performance":["56.6"],"提供浏览器占用内存":["56.6"],"导航行为和时间统计的详尽信息":["56.6"],"这个值始终都是":["57.1"],"尽管":["57.1"],"ecmascript":["57.1"],"都已经废弃了":["57.1"],"文件的":["57.1"],"类型通常是":["57.1"],"application":["57.1"],"x":["57.1","80.10","112.9","112.10"],"不过给":["57.1"],"关于":["59.0"],"的质疑却一直没有减少":["59.0"],"比如":["59.0","60.8","65.1","68.2","68.6","77.2","79.0","85.8"],"限制了":["59.0"],"的类型派生得到":["59.1"],"它们并不是两个完全独立的类型":["59.1"],"基于这一方式":["59.1"],"我们就能让类型之间存在紧密的关联":["59.1"],"减少冗余的类型代码":["59.1"],"其次":["59.1","73.1"],"当项目规模增大到某一阈值后":["59.1"],"这些类型代码会是你开发时最得力的助手":["59.1"],"让你有底气大胆地进行各种逻辑操作":["59.1"],"不需要先把这些值都打印出来确认一遍":["59.1"],"由于":["59.1","75.2","75.3","79.10"],"强大的类型推导能力":["59.1"],"随着你对变量进行各种操作":["59.1"],"就会自动地推导出变量最终的类型":["59.1"],"你只需要确保类型符合":["59.1"],"中使用这些新语法时":["59.2"],"你只需要简单的配置就能实现语法的降级":["59.2"],"让编译后的代码可以运行在更低的浏览器或":["59.2"],"node":["59.2","77.4","80.2","93.8"],"版本下":["59.2"],"这一部分几乎没有学习成本":["59.2"],"他们就像语言的":["59.2"],"api":["59.2","77.4","83.9","89.6"],"你只需要多提醒自己去使用":["59.2"],"及时查询官方文档就能熟悉了":["59.2"],"类型能力与新语法确实很棒":["59.2"],"但浏览器不认怎么办":["59.2"],"会在构建时被抹除类型代码与语法的降级":["59.2"],"这一能力就是通过":["59.2"],"compiler":["59.2"],"tsc":["59.2","59.3"],"实现的":["59.2","71.4"],"的关系开始说起":["59.3"],"介绍这些新语法的使用":["59.3"],"对其中的重量级角色装饰器":["59.3"],"我们更会搭配实战":["59.3"],"在最后的工程部分":["59.3"],"除了我们已经提到的":["59.3"],"以及":["59.3","79.13","85.0","107.80"],"tsconfig":["59.3","77.4","84.5"],"我们还会有更多的工程场景实战":["59.3"],"也欢迎你在交流群或":["59.4"],"github":["59.4","81.0","88.3","93.0"],"仓库的":["59.4"],"issue":["59.4"],"monorepo":["59.6"],"架构来隔离了各个不同部分的示例代码":["59.6"],"我们也会介绍":["60.0"],"官方提供的":["60.0"],"playground":["60.0"],"利用它你可以快速开始编写及分享":["60.0"],"筛选出所有":["60.1"],"有关的配置":["60.1"],"点击左侧的":["60.1"],"这里才是官方内置的配置":["60.1"],"我们需要做的就是开启一些代码提示功能":["60.1"],"hints":["60.1"],"我们知道":["60.1"],"能够在很多地方进行类型地自动推导":["60.1"],"但你往往要把鼠标悬浮在代码上才能看到推导得到的类型":["60.1"],"其实我们可以通过配置将这些推导类型显示出来":["60.1"],"在前面配置搜索处":["60.1"],"搜索":["60.1"],"vs":["60.2"],"真的够够的了":["60.3"],"最强大的能力其实在于":["60.3"],"支持非常简单的配置切换":["60.3"],"r":["60.4","79.8","107.80"],"register":["60.4"],"但此时":["60.4"],"如果想要传递参数给":["60.4"],"你就需要使用环境变量了":["60.4"],"比如要传递之前的":["60.4"],"选项":["60.4"],"transpile":["60.4"],"only":["60.4"],"关于选项对应的环境变量":["60.4"],"请参考":["60.4"],"的官方文档了解更多":["60.4"],"我们声明了一个仅在类型空间存在的变量":["60.5"],"它在运行时完全不存在":["60.5"],"这样就避免了略显繁琐的属性声明":["60.5"],"对于类型兼容的检查":["60.5"],"除了两两声明然后进行赋值以外":["60.5"],"我们还可以通过工具类型的形式":["60.5"],"tsd":["60.5","60.6"],"这个":["60.5","94.5"],"npm":["60.5","107.13"],"包提供的一系列工具类型":["60.5"],"能帮助你进行声明式的类型检查":["60.5"],"我们稍微提前了一些对后面学习大有裨益的知识":["60.6"],"即通过类型声明":["60.6"],"去":["60.8"],"cache":["60.8"],"这个全局变量中":["60.8"],"查找此文件是否已经已缓存":["60.8"],"并在存在时直接使用缓存的文件内容":["60.8"],"即这个文件的导出信息等":["60.8"],"基于绝对路径实例化一个":["60.8"],"类实例":["60.8"],"基于路径后缀名调用内置的处理函数":["60.8"],"json":["60.8","107.77","107.82"],"文件都是通过":["60.8"],"读取文件内容":["60.8"],"wrapping":["60.8"],"对于":["60.8","62.2","63.4","66.4","74.1","86.38","121.4"],"这么设计主要是因为它们之间的内容环环相扣":["61.0"],"而且也不难":["61.0"],"放在一起能帮助你一次性建立":["61.0"],"相对完整的知识体系":["61.0"],"如果你已经对这一章的知识点有基本了解或者非常熟悉了":["61.0"],"bigintvar1":["61.1"],"9007199254740991n":["61.1"],"bigintvar2":["61.1"],"9007199254740991":["61.1"],"tmp3":["61.2"],"仅在关闭":["61.2","61.8"],"时成立":["61.2","61.8"],"下同":["61.2","61.8"],"都表示":["61.3"],"没有返回一个有意义的值":["61.3"],"这里可能有点绕":["61.3"],"你可以认为":["61.3"],"表示一个空类型":["61.3"],"而":["61.3","63.6","77.2","80.29","84.1","85.6","86.15","86.35"],"都是一个具有意义的实际类型":["61.3"],"注意与它们在":["61.3"],"中的意义区分":["61.3"],"labeled":["61.4"],"elements":["61.4"],"的支持":["61.4"],"使得我们可以为元组中的元素打上类似属性的标记":["61.4"],"arr7":["61.4"],"name":["61.4","107.82","121.3"],"male":["61.4"],"有没有很酷":["61.4"],"考虑到某些拼装对象太麻烦":["61.4"],"我们完全可以使用具名元组来做简单替换":["61.4"],"具名元组可选元素的修饰符将成为以下形式":["61.4"],"这里的":["61.5","66.4","69.5","77.2","77.3","82.1","87.3"],"描述":["61.5"],"指":["61.5"],"每一个属性的值必须":["61.5"],"一一对应":["61.5"],"到接口的属性类型":["61.5"],"不能有多的属性":["61.5"],"obj3":["61.6"],"无法分配到":["61.6"],"而类型别名用来":["61.7"],"将一个函数签名":["61.7"],"一组联合类型":["61.7"],"作为类型签名就是一个合法的":["61.8"],"但":["61.8","80.0","81.2","91.2"],"内部无属性定义的空对象":["61.8"],"这类似于":["61.8"],"想想":["61.8"],"它意味着任何非":["61.8"],"tmp25":["61.8"],"tmp26":["61.8"],"tmp27":["61.8"],"等价于":["61.8"],"tmp28":["61.8"],"tmp29":["61.8"],"并不会在实际运行时报错":["61.9"],"学习完这一小节后":["61.9"],"不妨找出你曾经的":["61.9"],"项目":["61.9"],"试试用本章学到的知识为这些":["61.9"],"key":["61.11","84.7","101.52"],"注册":["61.11"],"如果有":["61.11","84.2","97.11"],"则返回这个":["61.11"],"否则才会创建新的":["61.11"],"如果要引用已创建的":["61.11"],"success":["62.0"],"failure":["62.0"],"而上面的类型只给出了一个宽泛的":["62.0"],"此时我们既不能在访问":["62.0"],"var":["62.2","62.10","80.15","96.16"],"str3":["62.4"],"上面的代码":["62.4"],"原始类型的值可以包括任意的同类型值":["62.4"],"而字面量类型要求的是":["62.4"],"值级别的字面量一致":["62.4"],"单独使用字面量类型比较少见":["62.4"],"在这个例子中":["62.6"],"属性会满足普通用户与":["62.6"],"用户两种类型":["62.6"],"这里":["62.6","67.5"],"属性的类型基于布尔字面量类型声明":["62.6"],"我们在实际使用时可以通过判断此属性为":["62.6"],"将类型从":["62.8"],"这种宽泛的原始类型直接收窄到":["62.8"],"resolved":["62.8"],"pending":["62.8"],"foovalue":["62.10"],"fookey":["62.10"],"要了解这一现象的本质":["62.10"],"我们需要来看一看枚举的编译产物":["62.10"],"如以上的枚举会被编译为以下":["62.10"],"代码":["62.10","74.1","85.26","89.2"],"use":["62.10","86.3"],"strict":["62.10","86.3"],"javascript":["62.12","63.3","68.6","74.1","82.2","83.9","86.11","101.4"],"的形式改写":["62.14"],"获得更详细的类型信息与更严格的类型约束":["62.14"],"中要求赋值类型始终与原类型一致":["62.18"],"如果声明了的话":["62.18"],"因此对于":["62.18"],"声明":["62.18","65.3"],"继承":["63.0","66.7"],"抽象类等来自于面向对象理念的实际使用":["63.0"],"这一节之后":["63.0"],"我们就算正式入门":["63.0"],"了":["63.0","64.8","71.1","75.2"],"此时":["63.0","79.4","85.10","86.18"],"方式二":["63.2"],"在方式二的声明方式中":["63.2"],"你会发现函数类型声明混合箭头函数声明时":["63.2"],"代码的可读性会非常差":["63.2"],"因此":["63.2","73.6","79.17"],"一般不推荐这么使用":["63.2"],"要么":["63.2"],"相比之下":["63.3"],"类型就像是":["63.3"],"中的":["63.3","81.13","85.20","96.19"],"一样":["63.3","83.10","86.16"],"因此在我们没有实际返回值时":["63.3"],"使用":["63.3","86.42"],"在某些情况下":["63.4"],"这里的可选参数类型也可以省略":["63.4"],"如这里原始类型的情况可以直接从提供的默认值类型推导出来":["63.4"],"但对于联合类型或对象类型的复杂情况":["63.4"],"还是需要老老实实地进行标注":["63.4"],"参数的类型标注也比较简单":["63.4"],"函数返回值为":["63.5"],"重载签名二":["63.5"],"不传入":["63.5"],"或传入":["63.5"],"类型":["63.6","70.2","70.5","73.1","86.18","91.2","107.28"],"内部包含的类型则通过泛型的形式书写":["63.6"],"即":["63.6","64.3","66.2","73.3","78.9","82.9"],"t":["63.6","75.7"],"不允许进行返回值的类型标注":["63.8"],"你可以理解为":["63.8"],"的返回值并不会被消费":["63.8"],"它是一个只关注过程的函数":["63.8"],"类的方法同样可以进行函数那样的重载":["63.8"],"且语法基本一致":["63.8"],"这里我们不再赘述":["63.8"],"就像函数可以通过":["63.8"],"函数声明":["63.8"],"与":["63.8","66.0","70.3","71.4","72.3","73.1","73.3","79.4","81.12","86.38"],"函数表达式":["63.8"],"创建一样":["63.8"],"类也可以通过":["63.8"],"子类":["63.9"],"中都能被访问":["63.9"],"此类成员仅能在":["63.9"],"类的内部":["63.9"],"被访问":["63.9"],"类与子类中":["63.9"],"你可以将类和类的实例当成两种概念":["63.9"],"即一旦实例化完毕":["63.9"],"出厂零件":["63.9"],"那就和类":["63.9"],"工厂":["63.9"],"没关系了":["63.9"],"它始终只属于当前定义的这个类":["63.10"],"以及其子类":["63.10"],"而原型对象上的实例成员则会":["63.10"],"沿着原型链进行传递":["63.10"],"也就是能够被继承":["63.10"],"而对于静态成员和实例成员的使用时机":["63.10"],"其实并不需要非常刻意地划分":["63.10"],"比如我会用":["63.10"],"类":["63.10"],"input":["63.11"],"我们让类去实现了一个接口":["63.11"],"这里接口的作用和抽象类一样":["63.11"],"都是":["63.11","69.7"],"描述这个类的结构":["63.11"],"除此以外":["63.11"],"我们还可以使用":["63.11"],"newable":["63.11"],"来描述一个类的结构":["63.11"],"类似于描述函数结构的":["63.11"],"callable":["63.11"],"进行改造":["63.12"],"让函数与类都能披上类型的铠甲":["63.12"],"获得完整的类型能力":["63.12"],"在下一节":["63.12","66.5","70.4","78.11","82.6","86.42"],"我们将要接触的就是":["63.12"],"makeuhappy":["63.14"],"或者在一个类希望把实例化逻辑通过方法来实现":["63.14"],"而不是通过":["63.14"],"handlermap":["63.15"],"record":["63.15"],"双重断言与非空断言等":["64.0"],"以及类型断言的幕后原理":["64.0"],"类型层级":["64.0"],"这一节是全新的知识":["64.0"],"error":["64.1","77.2","78.3","80.9","83.5","83.10"],"val5":["64.1"],"val6":["64.1"],"的一个主要差异体现在赋值给别的变量时":["64.1"],"就像是":["64.1"],"我身化万千无处不在":["64.1"],"所有类型都把它当自己人":["64.1"],"我虽然身化万千":["64.1"],"但我坚信我在未来的某一刻会得到一个确定的类型":["64.1"],"只有":["64.1","70.5"],"自己把它当自己人":["64.1"],"简单地说":["64.1"],"即一个无法再细分":["64.2"],"本质上并不存在的虚空类型":["64.2"],"我们可以利用":["64.2"],"类型变量仅能赋值给":["64.2"],"类型变量的特性":["64.2"],"来巧妙地分支处理检查":["64.2"],"一定是字符串":["64.2"],"charat":["64.2"],"tofixed":["64.2","66.8"],"exhaustivecheck":["64.2"],"这里从":["64.3"],"字面量类型断言为了":["64.3"],"即为解构赋值默认值进行了预期的类型断言":["64.3"],"当然":["64.3","82.1"],"更严谨的方式应该是定义为":["64.3"],"partial":["64.3","71.4","79.3","79.6"],"的属性均为可选的":["64.3"],"除了使用":["64.3"],"语法以外":["64.3"],"使用尖括号断言":["64.4"],"怎么样":["64.5"],"非空断言是不是简单多了":["64.5"],"你可以通过":["64.5"],"non":["64.5"],"nullable":["64.5"],"type":["64.5","66.7","80.16","80.31","87.4","96.2","114.8","114.9","114.17","114.18"],"assertion":["64.5"],"规则来检查代码中是否存在类型断言能够被简写为非空断言的情况":["64.5"],"类型断言还有一种用法是作为代码提示的辅助工具":["64.5"],"比如对于以下这个稍微复杂的接口":["64.5"],"interface":["64.5","78.9","89.1","107.46"],"istruct":["64.5"],"包括类型别名":["64.6"],"交叉类型":["64.6"],"索引类型":["64.6","65.4","71.10"],"映射类型等等":["64.6"],"如果说基础类型是积木":["64.6"],"你可以理解为这是一个基类":["64.8"],"参与断言的":["64.8"],"其实是它的派生类":["64.8"],"如果找不到具有意义的公共父类型呢":["64.8"],"这个时候就需要请出":["64.8"],"如果我们把它先断言到":["64.8"],"我们会在这两节中掌握这些不同的使用方式":["65.0"],"以及如何去结合地进行使用":["65.0"],"而按照使用目的来划分":["65.0"],"类型工具可以分为":["65.0"],"类型创建":["65.0"],"m":["65.1","69.6"],"o":["65.1","101.43","101.46"],"这种形式":["65.1","86.2"],"如果为了可读性考虑":["65.1"],"我们也可以写成大驼峰形式":["65.1"],"即在驼峰命名的基础上":["65.1"],"首字母也大写":["65.1"],"的名称":["65.1"],"newtype":["65.1"],"声明一个简单":["65.1"],"有实际意义的工具类型":["65.1"],"maybenull":["65.1"],"这个工具类型会接受一个类型":["65.1"],"并返回一个包括":["65.1"],"struct1":["65.2"],"primitiveprop":["65.2"],"objectprop":["65.2"],"struct2":["65.2"],"composed":["65.2"],"后两者则是":["65.3"],"的属性":["65.4"],"propa":["65.4"],"不能赋给":["65.4"],"boolean":["65.4","75.1","83.10","92.0"],"这里的符合即指子类型":["65.4"],"keys":["65.5"],"join":["65.5","77.0"],"除了应用在已知的对象类型结构上以外":["65.5"],"你还可以直接":["65.5"],"propc":["65.6"],"proptypeunion":["65.6"],"看起来好像很奇怪":["65.7"],"我们应该很少会需要把一个接口的所有属性类型映射到":["65.7"],"这有什么意义吗":["65.7"],"别忘了":["65.7"],"既然拿到了键":["65.7"],"那键值类型其实也能拿到":["65.7"],"clone":["65.7"],"索引类型查询":["65.8"],"从一个接口结构":["65.8"],"创建一个由其键名字符串字面量组成的联合类型":["65.8"],"索引类型访问":["65.8"],"使用键名字符串字面量访问到对应的键值类型":["65.8"],"类型守卫":["66.0"],"本节代码见":["66.0","84.0","86.0"],"这里我们暂时不用深入了解":["66.1"],"returntype":["66.1"],"这个工具类型":["66.1"],"只需要知道它会返回一个函数类型中返回值位置的类型":["66.1"],"funcreturntype":["66.1"],"函数称为类型守卫":["66.2"],"在它的返回值中":["66.2"],"我们不再使用":["66.2"],"作为类型标注":["66.2"],"而是使用":["66.2"],"这么个奇怪的搭配":["66.2"],"拆开来看它是这样的":["66.2"],"函数的某个参数":["66.2"],"预期类型":["66.2"],"即如果这个函数成功返回为":["66.2"],"那么":["66.2"],"关键字前这个入参的类型":["66.2"],"就会":["66.2"],"被这个类型守卫调用方后续的类型控制流分析收集到":["66.2"],"需要注意的是":["66.2","75.2","76.3","79.14","107.80"],"类型守卫函数中并不会对判断逻辑和实际类型的关联进行检查":["66.2"],"difftype":["66.3"],"handle1":["66.3"],"如上例所示":["66.3"],"对于同名但不同类型的属性":["66.3"],"我们需要使用字面量类型的区分":["66.3"],"并不能使用简单的":["66.3"],"handle2":["66.3"],"举例来说":["66.4"],"这么一个断言":["66.4"],"如果函数成功返回":["66.4"],"就说明其后续的代码中":["66.4"],"均成立":["66.4"],"也就是":["66.4","68.4","83.13"],"神奇地变成了一个":["66.4"],"想必以后你对如何处理联合类型会更有思路":["66.5"],"我们就将开始学习泛型":["66.5"],"它在许多语言中都是相当重要的类型能力":["66.5"],"这也是接口和类型别名的重要差异之一":["66.7"],"那么接口和类型别名之间的合并呢":["66.7"],"其实规则一致":["66.7"],"如接口":["66.7"],"类型别名":["66.7","89.1"],"和类型别名使用交叉类型":["66.7"],"合并":["66.7"],"我们就来了解":["67.0"],"中无处不在的泛型":["67.0"],"以及它在类型别名":["67.0"],"内置工具类型地解析":["67.1"],"扩展":["67.1"],"进阶":["67.1"],"在后面我们会一路升级打怪":["67.1"],"完全地掌握它们":["67.1"],"类型别名与泛型的结合中":["67.1"],"除了映射类型":["67.1"],"索引类型等类型工具以外":["67.1"],"还有一个非常重要的工具":["67.1"],"条件类型":["67.1","71.10"],"我们先来简单了解一下":["67.1"],"就会出现类型错误":["67.2"],"res1":["67.2"],"res2":["67.2"],"res3":["67.2"],"thirdinput":["67.3"],"这里的内部类型操作并不是重点":["67.3"],"我们直接忽略即可":["67.3"],"从这个类型别名中你能获得哪些信息":["67.3"],"totalcount":["67.4"],"hasnextpage":["67.4"],"fetchuserprofilelist":["67.4"],"b":["67.5","96.16","101.61"],"这个函数很明显需要在泛型层面声明关联":["67.5"],"即数组中的元素只能来自于对象的属性名":["67.5"],"组成的字面量联合类型":["67.5"],"因此我们可以这么写":["67.5"],"部分简化":["67.5"],"keyof":["67.5","75.7"],"props":["67.5"],"array":["67.5","73.3","77.2","80.8","89.7","96.2","101.21","101.24","101.51","101.52"],"声明约束为对象类型":["67.5"],"声明约束为":["67.5"],"出队":["67.6"],"dequeue":["67.6"],"当你传入初始值时":["67.7"],"如果初始值的类型与数组元素类型一致":["67.7"],"则使用数组的元素类型进行填充":["67.7"],"即这里第一个":["67.7"],"当你传入一个非数组元素类型的初始值":["67.7"],"比如这里的第二个":["67.7"],"的泛型参数会默认从这个初始值推导出的类型进行填充":["67.7"],"如这里是":["67.7"],"其中第三种情况也就意味着":["67.7"],"信息不足":["67.7"],"无法推导出正确的类型":["67.7"],"我们可以手动传入泛型参数来解决":["67.7"],"typescript":["67.8","71.1","78.1","79.1","82.3","82.11","85.9","91.9","107.16","107.22","107.23","107.117"],"类型系统核心特性之一":["67.8"],"结构化类型系统":["67.8"],"也是我们这一节要学习的概念":["68.0"],"我们会了解结构化类型系统的比较方式":["68.0"],"对比另一种类型系统":["68.0"],"标称类型系统":["68.0"],"的工作方式":["68.0"],"以及在":["68.0"],"对于独立函数类型的进一步比较":["68.1"],"我们会在后面的":["68.1"],"函数类型的比较":["68.1"],"类型系统中的协变与逆变":["68.1"],"一节中深入讲解":["68.1"],"这就是结构化类型系统的核心理念":["68.1"],"即基于类型结构进行判断类型兼容性":["68.1"],"结构化类型系统在":["68.1"],"python":["68.1"],"objective":["68.1"],"等语言中都被广泛使用或支持":["68.1"],"严格来说":["68.1","69.2"],"因此能够避免这一情况发生":["68.2"],"编程与类型系统":["68.2"],"一书中提到":["68.2"],"类型的重要意义之一是":["68.2"],"限制了数据的可用操作与实际意义":["68.2"],"这一点在标称类型系统中的体现要更加明显":["68.2"],"上面我们可以通过类型的结构":["68.2"],"来让结构化类型系统认为两个类型具有父子类型关系":["68.2"],"而对于标称类型系统":["68.2"],"通过这种方式":["68.3","79.15"],"也还会有结构化类型系统出场的部分":["68.4"],"下一节":["68.4"],"我们要来了解一个":["68.4"],"中常常被忽略的部分":["68.4"],"实际上是动态类型语言":["68.6"],"它的类型检查发生在运行时":["68.6"],"另外一个静态类型与动态类型的重要区别体现在变量赋值时":["68.6"],"如在":["68.6"],"中无法给一个声明为":["68.6"],"从上至下的类型兼容关系到底长什么样呢":["69.0"],"这一节":["69.0","73.0"],"我们就从原始类型变量和字面量类型开始比较":["69.0"],"分别向上":["69.0"],"类型的子类型":["69.1"],"在这里即是":["69.1"],"这明显是不成立的":["69.1"],"觉得不好理解":["69.1"],"那可以试着这么想":["69.1"],"我们有一个":["69.1"],"狗":["69.1"],"类型的变量":["69.1"],"还有两个分别是":["69.1"],"result6":["69.2"],"很明显":["69.2","84.1","85.14"],"一个基础类型和它们对应的字面量类型必定存在父子类型关系":["69.2"],"result12":["69.4"],"void":["69.4","71.5","72.5","73.6","107.118"],"同一基础类型的字面量联合类型":["69.4"],"此基础类型":["69.4"],"合并一下结论":["69.4"],"去掉比较特殊的情况":["69.4"],"我们得到了这个最终结论":["69.4"],"同一基础类型":["69.4"],"这两对":["69.5","87.3"],"为什么无论如何判断都成立":["69.5"],"难道说明":["69.5"],"类型相等":["69.5"],"也和":["69.5"],"类型一致":["69.5"],"当然不":["69.5"],"实际上是两种完全不同的比较方式":["69.5"],"意味着":["69.5"],"如果接受判断的是":["69.6"],"那么会直接":["69.6"],"返回条件类型结果组成的联合类型":["69.6"],"并不能简单地认为等价于以下条件类型":["69.6"],"result30":["69.6"],"i":["69.6","88.1","107.36"],"这种情况下":["69.6"],"由于联合类型的成员并非均是字符串字面量类型":["69.6"],"条件显然不成立":["69.6"],"在前面学习":["69.6"],"类型时":["69.6"],"切实存在":["69.7"],"有实际意义的类型":["69.7"],"它们和":["69.7"],"并没有什么本质区别":["69.7"],"我们在此前了解过":["69.7"],"关闭":["69.7"],"result46":["69.9"],"any":["69.9","70.3","79.3","79.8","80.20","83.7"],"result47":["69.9"],"result48":["69.9"],"never":["69.9","70.5","71.2","91.8"],"而学习了类型层级以后":["69.10"],"下一节的条件类型学习起来就简单多了":["69.10"],"但条件类型中可不仅仅是类型层级":["69.10"],"types":["70.0","78.7","78.9","85.13","85.28","86.39","87.4"],"10n":["70.1"],"条件类型还可以用来对更复杂的类型进行比较":["70.1"],"比如函数类型":["70.1"],"func":["70.1","96.9"],"args":["70.1","82.12"],"为了体现":["70.2"],"作为类型工具的属性":["70.2"],"我们结合了索引类型与映射类型":["70.2"],"以及使用":["70.2"],"来确保属性名为":["70.2"],"类型的小技巧":["70.2"],"为什么需要这个小技巧":["70.2"],"如果不使用又会有什么问题呢":["70.2"],"不满足约束":["70.2"],"明明约束已经声明了":["70.2"],"的类型是":["70.2"],"为什么还是报错了":["70.2"],"这是因为":["70.2","80.1"],"泛型参数":["70.2"],"的来源是从键值类型推导出来的":["70.2"],"中这样对键值类型进行":["70.2"],"推导":["70.2"],"将导致类型信息丢失":["70.2"],"而不满足索引签名类型只允许":["70.2"],"的要求":["70.2"],"还记得映射类型的判断条件吗":["70.2"],"linbudu":["70.3","72.5","84.7"],"这里的原因其实并不是因为分布式条件类型":["70.3"],"我们此前在类型层级中了解过":["70.3"],"当条件类型的判断参数为":["70.3"],"会直接返回条件类型两个结果的联合类型":["70.3"],"而在这里其实类似":["70.3"],"当通过泛型传入的参数为":["70.3"],"则会直接返回":["70.3"],"需要注意的是这里的":["70.3"],"的情况并不完全相同":["70.3"],"在直接":["70.3"],"作为判断参数时":["70.3"],"作为泛型参数时":["70.3"],"都会产生这一效果":["70.3"],"直接使用":["70.3"],"返回联合类型":["70.3"],"tmp1":["70.3"],"tmp2":["70.3"],"通过泛型参数传入":["70.3"],"同样返回联合类型":["70.3"],"tmp2res":["70.3"],"如果判断条件是":["70.3"],"那么仍然会进行判断":["70.3"],"special1":["70.3"],"请你不妨再试试它在更复杂场景下的使用":["70.4"],"感受一下模式匹配的魅力":["70.4"],"我们会开始探秘":["70.4"],"首先过滤掉":["70.5"],"然后对于":["70.5"],"类型编程的复杂度也体现在":["71.0"],"函数的重载与泛型约束":["71.0"],"方面":["71.0"],"但通过工具类型":["71.0"],"我们能够更好地理解类型编程的本质":["71.0"],"比如神奇地将一个对象类型中的所有属性名转换为大驼峰的形式":["71.1"],"这一类当然就统称为":["71.1"],"模板字符串工具类型":["71.1"],"这一节我们要讲解的":["71.1"],"内置工具类型":["71.1"],"这是因为对于结构声明来说":["71.2"],"一个属性是否必须提供仅取决于其是否携带可选标记":["71.2"],"即使你使用":["71.2"],"也无法标记这个属性为可选":["71.2"],"不能将类型":["71.2"],"可能是":["71.3"],"基于传入已知的键名":["71.3"],"来确定":["71.3"],"的反向实现":["71.4"],"是保留这些传入的键":["71.4"],"比如从一个庞大的结构中选择少数字段保留":["71.4"],"需要的是这些少数字段":["71.4"],"则是移除这些传入的键":["71.4"],"也就是从一个庞大的结构中剔除少数字段":["71.4"],"需要的是剩余的多数部分":["71.4"],"但它的实现看起来有些奇怪":["71.4"],"首先我们发现":["71.4"],"是基于":["71.4"],"这也是":["71.4","80.0"],"中成对工具类型的另一种实现方式":["71.4"],"上面的":["71.4"],"required":["71.4","81.7","83.10"],"combinespread":["71.5"],"t1":["71.5"],"t2":["71.5"],"obj":["71.5","96.2","96.5","96.16","101.52"],"otherobj":["71.5"],"rest":["71.5","77.2"],"point3d":["71.5"],"除了差集和交集":["71.6"],"我们也可以很容易实现并集与补集":["71.6"],"为了更好地建立印象":["71.6"],"这里我们使用集合相关的命名":["71.6"],"export":["71.6","75.7","78.7","94.4","94.6","95.2","95.4"],"可能希望":["71.7"],"替换原属性的同时并不追加新的属性":["71.7"],"constructorparameters":["71.8"],"instancetype":["71.8"],"比如上面我们写了第一个参数类型":["71.9"],"映射类型等以及各种关键字":["71.10"],"那":["71.12"],"中能否也添加约束":["71.12"],"只提取特定的类型":["71.12"],"就支持了":["71.12"],"约束功能来实现":["71.12"],"对特定类型地提取":["71.12"],"比如上面的例子可以改写为这样":["71.12"],"多庞大的概念":["72.0"],"不涉及实现源码的情况下":["72.0"],"但在实际开发中":["72.0"],"我们经常会受益于上下文类型的推导能力":["72.0"],"只不过你可能不知道背后是它得作用":["72.0"],"bar":["72.1"],"extends":["72.1","79.8","79.9","86.12","107.40"],"f1":["72.1"],"参数":["72.1"],"隐式具有":["72.1"],"y":["72.1","112.9","112.10"],"我们预期的结果是":["72.1"],"被推导为":["72.1"],"arr":["72.2"],"list":["72.2","77.2"],"foreach":["72.2","96.18","101.33"],"item":["72.2","79.19","101.33"],"push":["72.2","73.3","88.1","88.3","101.33"],"这是我们常用的简写方式":["72.2"],"方法的返回值是一个":["72.2"],"逆变":["72.3","73.4"],"概念":["72.3"],"函数的类型签名很明显与":["72.5"],"没什么头绪对吧":["73.0"],"我们就来对比函数类型的类型层级":["73.0"],"以及隐藏在这一比较幕后的理论":["73.0"],"协变与逆变":["73.0"],"这一篇文章中的概念我曾在此前的掘金文章中分享过":["73.0"],"你返回的必须也是一只狗狗":["73.1"],"我并不在意它是什么品种":["73.1"],"对于这两条约束依次进行检查":["73.1"],"无论它的参数类型是什么":["73.1"],"它的返回值类型都是不满足条件的":["73.1"],"因为它返回的不一定是合法的狗狗":["73.1"],"即我们说它不是":["73.1"],"的子类型":["73.1"],"其返回值满足了条件":["73.1"],"但是参数类型又不满足了":["73.1"],"这两个类型需要接受":["73.1"],"可能内部需要它腿短的这个特性":["73.1"],"但我们可没说一定会传入柯基":["73.1"],"如果我们传个德牧":["73.1"],"程序可能就崩溃了":["73.1"],"asfuncreturntype":["73.2"],"unknown":["73.2","80.26"],"再使用这两个包装类型演示我们上面的例子":["73.2"],"checkreturntype":["73.2"],"这样的内置定义":["73.3"],"我们希望它的函数方法就是以协变的方式进行检查":["73.3"],"举个栗子":["73.3"],"是否成立":["73.3"],"我们并不能简单的比较":["73.3"],"而是要将它们视为两个完整的类型比较":["73.3"],"的每一个成员":["73.3"],"属性":["73.3","79.19","107.69"],"是否都能对应的赋值给":["73.3"],"由":["73.3"],"对参数类型检查采用":["73.4"],"双变":["73.4"],"而非":["73.4","89.11"],"到这里":["73.4"],"你已经了解了":["73.4"],"类型系统中绝大部分的知识":["73.4"],"writable":["73.7"],"rabit":["73.7"],"所以这一节":["74.0"],"我们不学习代码":["74.0"],"只是来聊一聊":["74.0"],"类型编程的学习意义":["74.0"],"来说最重要的":["74.1"],"其实是与":["74.1"],"的紧密结合":["74.1"],"类型能力是添加在":["74.1"],"之上的":["74.1"],"也就意味着我们不需要学习一门全新的编程语言来获得类型检查":["74.1"],"同时":["74.1","77.3"],"我们可以说它的学习曲线是相对平缓的":["74.1"],"因为并不需要学习太长时间就能写出还过得去的":["74.1"],"但它的边际成本是明显递增的":["74.1"],"也就是说":["74.1","79.4"],"假如你最开始只需要花":["74.1"],"个单位的精力和时间":["74.1"],"就能提升":["74.1"],"个单位的类型覆盖程度":["74.1"],"用来衡量":["74.1"],"才能为你带来正面作用":["74.2"],"这本小册中并不会有过于复杂的工具类型讲解":["74.2"],"如果你学完之后感觉意犹未尽":["74.2"],"不妨在自己的项目中复制一份":["75.0"],"随着不断的积累":["75.0"],"你会发现":["75.0","79.2"],"你拥有了一个最适合自己的工具类型合集":["75.0"],"必须为":["75.1"],"内部的属性":["75.1"],"因此我们将其约束为":["75.1"],"即对象属性组成的字面量联合类型":["75.1"],"同时为了让它能够直接代替掉":["75.1"],"我们为其指定默认值也为":["75.1"],"这样在不传入第二个泛型参数时":["75.1"],"它的表现就和":["75.1"],"一致":["75.1","79.12"],"即全量的属性可选":["75.1"],"而其组成中":["75.1"],"为需要标记为可选的属性组成的对象子结构":["75.1"],"则为不需要处理的部分":["75.1"],"使用交叉类型将其组合即可":["75.1"],"我们验证下效果":["75.1"],"markpropsasoptionalstruct":["75.1"],"baz":["75.1"],"img":["75.1","89.2","107.15","107.61","107.83","107.93"],"啊哦":["75.1"],"这可不好看出来具体效果":["75.1"],"此时我们可以引入一个辅助的工具类型":["75.1"],"我称其为":["75.1"],"flatten":["75.1"],"对于这种交叉类型的结构":["75.1"],"能够将它展平为单层的对象结构":["75.1"],"而它的实现也很简单":["75.1"],"就是复制一下结构罢了":["75.1"],"应用到":["75.2"],"typefilter":["75.2"],"strictvaluetypefilter":["75.2"],"为了避免嵌套太多工具类型":["75.2"],"这里就不使用":["75.2"],"strictpickbyvaluetype":["75.2"],"strictomitbyvaluetype":["75.2"],"需要的是":["75.2"],"不符合类型的属性":["75.2"],"因此这里":["75.2"],"泛型参数也需要传入":["75.2"],"的交集":["75.3"],"的优先级更高":["75.3"],"在交集处理中将":["75.3"],"作为原集合":["75.3"],"作为后传入的集合":["75.3"],"我们就得到了":["75.3"],"merge":["75.3"],"加上":["75.3"],"交集的部分":["75.3"],"类型不同则以":["75.3"],"优先级更高":["75.3"],"再加上":["75.3"],"多的部分即可":["75.3"],"then":["75.4","84.2","101.5"],"onfulfilled":["75.4"],"f":["75.4","82.12"],"value":["75.4","84.7","107.82"],"大范式":["75.5"],"访问性修饰":["75.5"],"集合以及模式匹配":["75.5"],"对于类型编程部分":["75.5"],"我想带给你的最重要收获其实就是":["75.5"],"你不会再畏惧眼花缭乱的类型编程了":["75.5"],"正如始终贯穿这几节的核心理念":["75.5"],"我们可以这么实现":["75.7"],"k":["75.7"],"in":["75.7","78.10","84.7","86.35","101.52"],"pick":["75.7"],"而模板字符串类型":["76.0"],"其实也完全可以映射到":["76.0"],"中的概念":["76.0"],"64g":["76.1"],"随着商品":["76.1"],"内存数":["76.1"],"货品类型的增加":["76.1"],"我们可能需要成几何倍地新增":["76.1"],"但如果使用模板字符串类型":["76.1"],"我们可以利用其":["76.1"],"自动分发的特性":["76.1"],"来实现简便而又严谨的声明":["76.1"],"同样的":["76.2"],"模板字符串类型和模板字符串也拥有着紧密的关联":["76.2"],"const":["76.2","80.11","82.10","86.21","94.2","94.6","95.4","101.52"],"greet":["76.2"],"copiedfoo":["76.3"],"这里我们其实就是通过":["76.3"],"将映射的键名作为变量":["76.3"],"映射到一个新的字符串类型":["76.3"],"applystringmapping":["76.4"],"str":["76.4","80.39"],"intrinsictypekinds":["76.4"],"get":["76.4","96.6"],"escapedname":["76.4"],"case":["76.4"],"intrinsictypekind":["76.4"],"touppercase":["76.4"],"reversedres1":["76.5"],"除了显式使用":["76.5"],"进行模式匹配操作以外":["76.5"],"由于模板字符串的灵活性":["76.5"],"我们甚至可以直接声明一个泛型来进行模式匹配操作":["76.5"],"我们在重映射中再次进行了条件类型判断":["76.8"],"并在其成立时才重映射到原键名":["76.8"],"否则只返回一个":["76.8"],"类似的":["76.8","83.8"],"我们也可以实现":["76.8"],"从简单的":["77.0"],"includes":["77.0","86.23","89.5"],"到需要稍微绕一绕的":["77.0"],"再到较为复杂的":["77.0"],"这样":["77.1","79.19"],"在字符串的两边不包含空格时":["77.1"],"递归就会停止":["77.1"],"从而返回一致":["77.1"],"干净":["77.1"],"的字符串":["77.1"],"而类型版本的":["77.1"],"两个工具类型":["77.1"],"的实现非常接近":["77.1"],"我们直接看其中":["77.1"],"strlengthres2":["77.2"],"budu":["77.2"],"strlengthres3":["77.2"],"strlengthres4":["77.2"],"这是因为即使是在类型层面":["77.2"],"元祖类型的长度也会是一个有实际意义的值":["77.2"],"我们上面介绍的许多方法之间其实存在关联":["77.2"],"trimleft":["77.2"],"trimend":["77.2"],"startswith":["77.2","89.6"],"endswith":["77.2","89.4"],"是作用位置相反":["77.2"],"的进化版本":["77.2"],"也有这么一位伙伴":["77.2"],"与它作用相反的":["77.2"],"方法是":["77.2"],"将字符串按分隔符拆分成一个数组":["77.2"],"方法则是":["77.2"],"将一个数组中的所有字符串按照分隔符组装成一个字符串":["77.2"],"我们只需要通过递归依次取出每一个字符串单元":["77.2"],"使用模板插槽组装即可":["77.2"],"ts":["77.2","78.4","80.37","83.5","83.10","83.13","85.31","85.32"],"expect":["77.2","78.3","81.6","83.5","83.10"],"类型无法被正确地推导":["77.2"],"因此使用了":["77.2"],"来忽略错误":["77.2"],"看起来似乎没啥问题":["77.2"],"我们来试一下":["77.2"],"tail":["77.3"],"这个类型确实有一定复杂度":["77.3"],"但它本质上仍然是数个基础工具类型与概念的组合":["77.3"],"包括模板字符串类型":["77.3"],"插槽与模式匹配结合":["77.3"],"等等":["77.3","91.12","103.4","107.62"],"我们并没有想一口气把它实现出来":["77.3"],"而是先整理了思路":["77.3"],"拆分":["77.3"],"重组":["77.3"],"确定了能够依赖的基础工具类型":["77.3"],"才一步步实现了它":["77.3"],"其实还有一些需要改进的地方":["77.3"],"比如首字母大写的":["77.3"],"和全大写的":["77.3"],"也需要转化为小驼峰形式的":["77.3"],"这里我放上":["77.3"],"fest":["77.3"],"中的工程实践":["77.4"],"装饰器":["77.4"],"配置":["77.4","85.26","86.18"],"开发等等":["77.4"],"其实我们可以从一个很简单的场景开始":["78.0"],"如果你已经有一定":["78.0"],"的使用经验":["78.0"],"那你很有可能遇到过这么一个场景":["78.0"],"ignore":["78.1","80.20","81.6"],"等":["78.1","79.10","80.1","80.2","80.3","82.13","89.0","89.1","89.3"],"中同样提供了数个行内注释":["78.1"],"在所有地方都不要使用":["78.2"],"直接把这个指令打入冷宫封存起来":["78.2"],"原因在上面我们也说了":["78.2"],"对于这类":["78.2"],"本来就应当确保":["78.2"],"下一行真的存在错误时":["78.2"],"才去使用":["78.2"],"这两个指令只能对单行代码生效":["78.2"],"但如果我们有非常多的类型报错要处理":["78.2"],"报错":["78.3"],"这里我们的":["78.3"],"指令为":["78.3"],"文件也带来了类型检查":["78.3"],"而我们同时还可以使用":["78.3"],"指令来忽略掉单行的代码检查":["78.3"],"文件和一个":["78.4"],"d":["78.4"],"文件":["78.4","78.5","81.12"],"而后者即是类型声明文件":["78.4"],"生成的类型定义":["78.4"],"因此必须要有一个":["78.5"],"除了为缺失类型的模块声明类型以外":["78.5"],"使用类型声明我们还可以为非代码文件":["78.5"],"如图片":["78.5"],"css文件等声明类型":["78.5"],"对于非代码文件":["78.5"],"比如说":["78.5"],"markdown":["78.5"],"假设我们希望导入一个":["78.5"],"md":["78.5"],"由于其本质和":["78.5"],"包一样是一条导入语句":["78.5"],"因此我们可以类似地使用":["78.5"],"index":["78.5","87.4","101.33","107.6"],"buffer":["78.6"],"usestate":["78.6"],"dispatch":["78.6"],"setstateaction":["78.6"],"可以看到":["78.6"],"promise":["78.7","79.15"],"click":["78.7","111.12","114.14","114.15","121.8"],"我们也可以扩展来自":["78.7"],"包的类型定义":["78.7"],"module":["78.7","107.82"],"fs":["78.7"],"bump":["78.7"],"中会自动包含引用它的指令":["78.8"],"指令类似于":["78.8"],"只不过这里":["78.8"],"导入的是":["78.8"],"内置的类型声明":["78.8"],"如下面的例子我们声明了对":["78.8"],"除了在":["78.9"],"文件中使用以外":["78.9"],"命名空间也可以在声明文件中使用":["78.9"],"cat":["78.9"],"但如果你在":["78.9"],"系列的包下":["78.9"],"想要通过":["78.9"],"进行模块的声明":["78.9"],"还需要注意将其导出":["78.9"],"然后才会加载到对应的模块下":["78.9"],"以":["78.9"],"react":["78.9","85.14"],"为例":["78.9"],"css":["78.10","79.10","93.11"],"方案的组件应该被放在第二条中其他组件部分":["78.10"],"示例如下":["78.10"],"useeffect":["78.10"],"button":["78.10","79.9","107.98","121.8"],"dialog":["78.10"],"childcomp":["78.10"],"child":["78.10","79.9","80.12"],"工程能力很有帮助":["78.11"],"我们还会与三斜线指令再次碰面":["78.11"],"无论你是在将":["78.11"],"集成到什么框架或者工具里":["78.11"],"在使用":["78.13"],"进行配置时":["78.13"],"一种方式是简单地使用它提供的类型作为一个对象的标注":["78.13"],"而目前更常见的一种方式其实是框架内部提供":["78.13"],"defineconfig":["78.13","95.2"],"这样的方法":["78.13"],"让你能直接获得类型提示":["78.13"],"就像我们在前面学习的一样":["79.0"],"这些泛型可以通过输入一个值来隐式推导":["79.0"],"也可以直接显式声明来约束后续的值输入":["79.0"],"而内置类型定义则主要是事件信息的类型定义以及内置工具类型两个部分":["79.0"],"在你的":["79.0"],"onclick":["79.0","79.9","101.40","111.12","111.13"],"函数中应当如何为参数声明类型":["79.0"],"onchange":["79.0"],"函数呢":["79.0"],"g":["79.1","89.8","107.13"],"your":["79.1"],"project":["79.1"],"对于基于":["79.1"],"src":["79.2","87.4","107.73","107.92","107.93","107.99","107.100","107.106","107.110","107.124"],"constants":["79.2"],"images":["79.2"],"jpg":["79.2","97.21"],"fonts":["79.2"],"woff":["79.2"],"的声明是什么样的":["79.3"],"propswithchildren":["79.3"],"context":["79.3"],"reactelement":["79.3"],"proptypes":["79.3"],"weakvalidationmap":["79.3"],"contexttypes":["79.3"],"validationmap":["79.3"],"进行约束":["79.4"],"组件的":["79.4"],"属性就":["79.4"],"只能传入":["79.4"],"两个值":["79.4"],"idata":["79.6"],"这么做的坏处在于":["79.6"],"后续的调用方中会认为这是一个完整实现了":["79.6"],"结构的对象":["79.6"],"可能会出现遗漏的未赋值属性":["79.6"],"此时你也可以使用":["79.6"],"类型标记它为可选":["79.6"],"推导为":["79.7"],"result1":["79.7"],"some":["79.7","89.5","96.18"],"expensive":["79.7"],"process":["79.7"],"在上面的例子中":["79.8"],"的泛型参数分别被填充为":["79.8"],"以及其初始状态":["79.8"],"prevstate":["79.8"],"reducerstate":["79.8"],"childref":["79.9"],"invokecontroller":["79.9"],"invoke":["79.9"],"ichildpropstruct":["79.9"],"iextendedrefpayload":["79.9"],"disposer":["79.9"],"但无需对所有定义都了解":["79.10"],"在实际用到时再去导入即可":["79.10"],"inputevent":["79.10"],"并非在所有浏览器都得到了支持":["79.10"],"因此并不存在对应的类型定义":["79.10"],"你可以使用":["79.10","86.37"],"keyboardevent":["79.10"],"来代替":["79.10"],"除了这些事件类型以外":["79.10"],"还有一个常见的类型是在你声明组件属性中的样式时会用到的":["79.10"],"那就是":["79.10"],"cssproperties":["79.10"],"它描述了所有的":["79.10"],"和没使用":["79.12"],"的情况":["79.12"],"此时可以使用内置类型":["79.12"],"componentpropswithref":["79.12"],"componentpropswithoutref":["79.12"],"其使用方式与":["79.12"],"也可以用来提取一个":["79.12"],"组件的属性类型":["79.12"],"其内部实现对":["79.12"],"它还包含":["79.13"],"reactfragment":["79.13"],"等一些特殊的部分":["79.13"],"其类型定义如下":["79.13"],"这些项目规范具有强烈的个人偏好风格":["79.14"],"iuserprofile":["79.15"],"fetchuserlist":["79.15"],"你的类型代定义之间就能够建立起清晰的":["79.15"],"inputb":["79.16"],"inputc":["79.16"],"本着":["79.17"],"渐进式学习":["79.17"],"也就不再推荐使用":["79.19"],"在组件库中还有一个常见场景":["79.19"],"即我们使用组件同时作为命名空间":["79.19"],"table":["79.19"],"column":["79.19","107.77"],"form":["79.19"],"如果使用":["79.19"],"你需要使用交叉类型补充上这些命名空间内的子组件":["79.19"],"import":["79.19","85.13","94.4","107.53","107.55"],"from":["79.19","85.13","94.4","107.55"],"如要求你为函数的返回值显式声明类型等等":["80.0"],"实际上":["80.0","80.6"],"lint":["80.0"],"工具的核心功能":["80.0"],"我们后面会介绍的":["80.0"],"prettier":["80.0"],"也是":["80.0","81.8"],"如果你把上面的":["80.1"],"改成":["80.1"],"大概率项目中会出现巨量报错":["80.1"],"expected":["80.1"],"indentation":["80.1"],"of":["80.1","84.2","89.0","89.4","89.5","96.6","106.3"],"but":["80.1"],"found":["80.1","86.39"],"spaces":["80.1"],"并不是等价的":["80.1"],"也和你的编辑器配置有关":["80.1"],"而我们这里的":["80.1"],"其具体意义为":["80.1"],"完成配置后":["80.1"],"我们需要确定接受":["80.1"],"receive":["80.2"],"update":["80.2"],"post":["80.2"],"直接写":["80.2"],"不太优雅":["80.2"],"我们可以通过":["80.2"],"husky":["80.2"],"来实现相对简便的配置":["80.2"],"关于各种初始化方式":["80.2"],"你可以阅读文档了解更多":["80.2"],"我们这里只介绍自动安装的方式":["80.2"],"npx":["80.2"],"dlx":["80.2"],"yarn2":["80.2"],"这样做只是安装了":["80.2"],"huksy":["80.2"],"以及配置了相关环境":["80.2"],"我们实际上还没有添加":["80.2"],"也提供了快速创建的方式":["80.2"],"我们直接把后面要执行的命令先添加进来":["80.2"],"bin":["80.2"],"现在你应该拥有了一个":["80.2"],"文件夹":["80.2"],"以及内部的":["80.2"],"jsx":["80.3","86.32","89.0"],"scope":["80.3"],"off":["80.3"],"规则主要由四个部分组成":["80.3"],"仅在":["80.3"],"约束基础上支持了":["80.3"],"语法解析":["80.3"],"如缩进":["80.3"],"indent":["80.3"],"单双引号":["80.3"],"quote":["80.3"],"逗号":["80.3"],"comma":["80.3"],"我们需要的只是确定一个规范":["80.6"],"然后在所有地方使用这一规范":["80.6"],"这一类规则":["80.6"],"还有后面的类型断言语法":["80.6"],"可以避免无意义的":["80.7"],"在其他时候尽可能的使用":["80.8"],"原因则是":["80.8"],"更加简洁":["80.8"],"类似于":["80.8","85.20"],"selector":["80.9"],"format":["80.9"],"pascalcase":["80.9"],"custom":["80.9","94.5","111.12"],"regex":["80.9"],"z":["80.9"],"res":["80.11","84.2"],"data":["80.11","84.2","103.3"],"以及与":["80.11"],"更好的协作":["80.11"],"usecookie":["80.12"],"hooks":["80.12"],"非空断言的目的就是提供快速去除类型中":["80.13"],"就说明它应当是一个异步过程":["80.14"],"consistent":["80.16"],"指令":["80.20"],"而如果说乱写":["80.20"],"直接放弃了下一行的类型检查而无论下一行是否真的有错误":["80.21"],"而后者则是期望下一行确实存在一个错误":["80.21"],"并且会在实际不存在错误时反而抛出一个错误":["80.21"],"额外的非空断言是无意义的":["80.22"],"和上一条规则类似":["80.24"],"属于非常有害的结合使用方式":["80.24"],"对于未指定的泛型约束":["80.26"],"默认使用":["80.26"],"在这之前则是":["80.26"],"中定义方法":["80.29"],"则是就像定义普通的接口属性":["80.29"],"只不过它的值是函数类型":["80.29"],"推荐使用":["80.29"],"对于函数类型":["80.31"],"应使用入参":["80.31"],"返回值被标注出来的具体类型":["80.31"],"没有父类型的空接口实际上就等于":["80.32"],"虽然无法不确定你使用它是为了什么":["80.32"],"类型断言":["80.33"],"都是成本极高的":["80.33"],"需要团队所有人都有着严格的代码质量意识":["80.33"],"如果你真的想这么做":["80.33"],"对于普通变量来说":["80.34"],"与实际赋值一致的类型标注确实是没有意义的":["80.34"],"认为它成本太高":["80.35"],"而我认为首先":["80.35"],"强大的类型推导能力是能够直接为你推导出最终返回值类型的":["80.35"],"那么说明你的":["80.37"],"类型标注并不准确":["80.37"],"这条规则是通过变量类型来进行判断的":["80.37"],"抛出的":["80.38"],"实例能够自动的收集调用栈信息":["80.38"],"else":["80.39","81.10","101.9","107.49","107.74"],"要解决也很简单":["80.41"],"只要给":["80.41"],"显式传入泛型参数即可":["80.41"],"来声明对这个声明文件的依赖":["80.42"],"规则":["80.43"],"明白了它们的功能与意义":["80.43"],"上的":["81.0"],"awesome":["81.0"],"xxx":["81.0","103.4"],"主要功能也是监听文件变化然后重新执行":["81.2"],"dist":["81.4","85.11"],"注释":["81.6"],"重构项目时很有帮助":["81.6"],"haircolor":["81.7"],"black":["81.7"],"brown":["81.7"],"blue":["81.7"],"additionalproperties":["81.7"],"false":["81.7","85.24","88.4","107.58","107.107"],"exampleschema":["81.7"],"用于进行类型层面的单元测试":["81.8"],"即验证工具类型计算结果是否是符合预期的类型":["81.8"],"校验失败":["81.10"],"错误信息":["81.10"],"校验通过":["81.10"],"superstruct":["81.10"],"功能与使用方式类似于":["81.10"],"更老牌一些":["81.10"],"ow":["81.10"],"用于函数参数的校验":["81.10"],"我通常在":["81.10"],"cli":["81.10","87.1"],"工具里大量使用":["81.10"],"也可以放在":["81.11"],"pre":["81.11","114.6"],"commit":["81.11"],"rollup":["81.12","85.20"],"dts":["81.12"],"能够将你项目内定义与编译生成的类型声明文件重新进行打包":["81.12"],"parcel":["81.12"],"一个":["81.12"],"bundler":["81.12"],"在扩展阅读中":["82.0"],"我们会聊到更多有趣的":["82.0"],"正在进行中的":["82.0"],"ecma262":["82.1"],"仓库":["82.1"],"会议的频率大概是两月一次":["82.1"],"并且由于疫情的原因也从线上":["82.1"],"线下结合改成了完全线上的模式":["82.1"],"上面我们提到的":["82.1"],"意为":["82.1"],"维护的第":["82.1"],"条标准":["82.1"],"目前它的最新版本是":["82.1"],"年发布的第":["82.1"],"版":["82.1"],"es2022":["82.1"],"es13":["82.1"],"各位同学最熟悉的肯定还是":["82.1"],"年发布的":["82.1"],"es2015":["82.1"],"这一版本":["82.1"],"而在":["82.2"],"中想要使用则需要运行时支持或者使用":["82.2"],"polyfill":["82.2"],"corejs":["82.2"],"shims":["82.2"],"对于可选链":["82.2"],"空值合并以及逻辑赋值":["82.2"],"除了更简洁的写法以外":["82.3"],"可选链也更符合我们的预期":["82.3"],"它会在短路时返回一个":["82.3"],"可选链不仅能应用在属性访问":["82.3"],"也可以用在计算属性访问以及方法调用上":["82.3"],"配合可选链":["82.4"],"既然逻辑操作符可以":["82.5"],"那没道理我空值合并不行":["82.5"],"毕竟我们长得这么像":["82.5"],"这个时候为了区分逻辑赋值":["82.5"],"我们可以称其为":["82.5"],"短路赋值":["82.5"],"短路赋值在一些需要懒初始化的场景中非常好用":["82.5"],"我们会用很长的篇幅来聊聊":["82.6"],"会议为":["82.8"],"年":["82.8"],"月召开":["82.8"],"也就是说是按值比较而非对象那样按引用地址比较的":["82.9"],"getencoder":["82.10"],"encoding":["82.10"],"encoder":["82.10"],"utf8":["82.10"],"utf8encoder":["82.10"],"utf16le":["82.10"],"listen":["82.11","84.2"],"element":["82.11"],"eventname":["82.11"],"lodash":["82.12"],"对于首个函数":["82.12"],"它可以是任意元函数":["82.12"],"有任意个参数":["82.12"],"而对于余下的函数都必须是一元函数":["82.12"],"这一提案其实也支持了泛型":["82.13"],"但就目前来看":["82.13"],"泛型还是过于激进了":["82.13"],"可能会在后续拆分成独立的提案进行独立地迭代":["82.13"],"另外":["82.13"],"此提案目前不包括涉及到运行时代码":["82.13"],"枚举":["82.13"],"namespace":["82.13"],"的功能":["82.13"],"因为它真的就":["82.13"],"只是想引入编译时擦除类型":["82.13"],"只能在类以及类成员上使用":["83.0"],"装饰器通过":["83.0"],"语法来使用":["83.0"],"deco":["83.0"],"foo":["83.0","83.14"],"这样的装饰器只能起到固定的功能":["83.0"],"我们实际上使用更多的是":["83.0"],"最常见的主要还是类装饰器":["83.1"],"方法装饰器以及属性装饰器":["83.1"],"我们在这里调用的方法并没有直接在":["83.2"],"中定义":["83.2"],"而是通过装饰器来强行添加":["83.2"],"我们也可以在装饰中返回一个子类":["83.2"],"overridebar":["83.2"],"this":["83.3","84.4","96.3","101.36","107.43"],"执行原本的逻辑":["83.3"],"end":["83.3"],"call":["83.4","101.23"],"篡改":["83.4"],"使得这个值无视":["83.4"],"的更新":["83.4"],"返回一个固定的值":["83.4"],"应用到每个静态成员":["83.7"],"应用到构造函数":["83.7"],"类装饰器":["83.7"],"应用到类":["83.7"],"最后":["83.7"],"我们再看一个例子":["83.7"],"来更深刻地了解执行顺序与应用顺序":["83.7"],"identifier":["83.7"],"构造函数参数装饰器":["83.7"],"method":["83.8","89.5"],"方法是运行时才实际执行的":["83.9"],"也就是说我们通过反射":["83.9"],"运行时去修改了程序的行为":["83.9"],"这就是反射的核心要素":["83.9"],"在程序运行时去检查以及修改程序行为":["83.9"],"比如在代码运行时通过":["83.9"],"construct":["83.9"],"实例化一个类":["83.9"],"通过":["83.9"],"setprototypeof":["83.9"],"修改对象原型指向":["83.9"],"这些其实都属于反射":["83.9"],"此前":["83.9"],"有了装饰器":["83.10"],"反射元数据以及内置的基于类型的元数据信息":["83.10"],"我们就可以实现":["83.10"],"的能力了":["83.10"],"以看似平平无奇的属性装饰器为例":["83.10"],"我们使用元数据来实现基于装饰器的属性校验":["83.10"],"在这个例子里":["83.10"],"我们会实现两种校验逻辑":["83.10"],"对必填属性":["83.10"],"与属性类型的校验":["83.10"],"其基本使用方式如下":["83.10"],"user":["83.10"],"valuetype":["83.10"],"typevalidation":["83.10"],"我们会将":["83.10"],"实例传递给校验方法":["83.10"],"在这里应当给出两处错误":["83.10"],"没有提供必填属性":["83.10"],"属性的类型不符":["83.10"],"如果理解了元数据的作用":["83.10"],"那我们的思路就很明确了":["83.10"],"装饰器将元数据附加到属性或类上":["83.10"],"然后校验方法中遍历属性读取这些元数据":["83.10"],"再对比类型是否匹配即可":["83.10"],"首先是":["83.10"],"我们肯定下意识是这么写":["83.10"],"propertydecorator":["83.10"],"也就是在这个属性上定义了一个名为":["83.10"],"的元数据":["83.10"],"但你是否想过":["83.10"],"如果实例中根本就没有这个属性呢":["83.10"],"就像上面的":["83.10"],"那这里的元数据不就丢失了":["83.10"],"要解决这一问题":["83.10"],"其实只需要将元数据定义在类上即可":["83.10"],"我们用一个专门描述必填属性的元数据":["83.10"],"存储这个类内部所有的必填属性即可":["83.10"],"requiredmetadatakey":["83.10"],"requiredkeys":["83.10"],"existrequiredkeys":["83.10"],"目前看起来它好像并没有什么特别之处":["83.11"],"那么在下一节":["83.11"],"此时装饰器提案位于":["83.13"],"阶段":["83.13"],"促使":["83.13"],"提前引入的一个重要原因是":["83.13"],"当时存在一门":["83.13"],"的超集语言":["83.13"],"的超集的超集":["83.13"],"atscript":["83.13"],"它在":["83.13"],"一组装饰器":["83.14"],"即标明这个类需要被注册到容器中":["84.1"],"如果别的地方需要这个类":["84.1"],"其内部的":["84.1"],"属性需要被注入一个":["84.1"],"的实例":["84.1"],"的实例又需要":["84.1"],"的实例等等":["84.1"],"这一系列的过程是完全交给容器的":["84.1"],"我们需要做的就只是用装饰器简单标明下依赖关系即可":["84.1"],"相比于依赖查找":["84.1"],"依赖注入使用起来更加简洁":["84.1"],"几乎不需要额外的业务代码":["84.1"],"即不需要一个额外的":["84.1"],"方法去维护实例化逻辑":["84.1"],"但其依赖逻辑要更加黑盒":["84.1"],"而装饰器如何实现依赖注入":["84.1"],"我想其实你也能":["84.1"],"createserver":["84.2"],"req":["84.2"],"on":["84.2"],"listening":["84.2"],"ready":["84.2"],"localhost":["84.2"],"n":["84.2","84.4","89.8","96.24"],"接下来我们需要做的":["84.2"],"就是在":["84.2"],"内去依据请求路径与请求方法调用对应的实现了":["84.2"],"我们会遍历收集到的信息":["84.2"],"查看是否有某一个对象的路径与请求方法都匹配上了":["84.2"],"就调用这个方法返回":["84.2"],"url":["84.2"],"tolocaleuppercase":["84.2"],"writehead":["84.2"],"content":["84.2"],"我们需要做的就是":["84.3"],"方法了":["84.3"],"方法简单":["84.3"],"直接注册":["84.3"],"就好":["84.3"],"方法就要复杂一些了":["84.3"],"它需要在我们取出一个类":["84.3"],"帮我们实例化这个类以及注入这个类内部声明的依赖":["84.3"],"整理一下具体步骤":["84.3"],"使用传入的标识符在容器内查找这个类是否已经注册":["84.3"],"如果有则进行下一步":["84.3"],"没有就返回":["84.3"],"对于已注册的类":["84.3"],"首先将其实例化":["84.3"],"然后检查":["84.3"],"查看这个类内部是否声明了对外部的依赖":["84.3"],"将这些外部依赖的类从容器中取出":["84.3"],"同样通过":["84.3"],"然后实例化":["84.3"],"将这些实例传递给对应的属性":["84.3"],"我们的大致实现如下":["84.3"],"驱动已生效于":["84.4"],"fuel":["84.4"],"fill":["84.4"],"燃料已填充完毕":["84.4"],"car":["84.4"],"fule":["84.4"],"run":["84.4"],"bus":["84.4"],"我们将投入另一个方面的实战":["84.5"],"配置解析":["84.5"],"的参数":["84.7"],"async":["84.7"],"asynchandler":["84.7"],"以及属性装饰器只用应用在特定类型的属性上":["84.7"],"literalpropertydecorator":["84.7"],"onlyliteralproperty":["84.7"],"pickbyvaluetype":["84.7"],"工程相关":["85.0"],"这其实也对应着我们的开发流程":["85.0"],"使用工程能力进行项目开发":["85.0"],"检查源码是否符合配置约束":["85.0"],"然后才是输出产物":["85.0"],"每一个大类又可以划分为几个小类":["85.0"],"paramtypes":["85.4"],"转换为以下代码":["85.5"],"require":["85.5","89.1"],"为了简化自定义":["85.5"],"转换的配置":["85.5"],"版本以后":["85.5"],"支持使用":["85.5"],"属性快速地调整":["85.5"],"当你的":["85.5","85.6"],"你的":["85.6"],"中不应当包含":["85.6"],"这个值":["85.6"],"对应的":["85.6"],"代码中无法使用":["85.6"],"window":["85.6","96.2"],"document":["85.6","96.2","101.50"],"等全局变量":["85.6"],"对":["85.6","86.35"],"的影响在于":["85.6"],"为更高的版本时":["85.6"],"它会自动地将这个版本新语法对应的":["85.6"],"声明加载进来":["85.6"],"以上面的代码为例":["85.6"],"为":["85.6"],"由于我们会在":["85.8"],"中大量使用":["85.8"],"来一次性匹配许多文件":["85.8"],"如果存在某些非预期的文件也符合这一匹配模式":["85.8"],"test":["85.8","107.30"],"file":["85.8"],"excluded":["85.8"],"中":["85.9","87.9","88.2"],"你就可以直接使用基于根目录的绝对路径导入文件":["85.9"],"比如在这里把它更改到了项目根目录":["85.10"],"会被视为":["85.10"],"的一部分":["85.10"],"因此最终构建目录结构中会多出":["85.10"],"这一级":["85.10"],"但在构建产物中它们实际上是位于同一层级的":["85.11"],"team":["85.12","86.41"],"typings":["85.12"],"字段的加载":["85.13"],"而对于":["85.13"],"模式":["85.13","89.1"],"其解析逻辑可能不太符合直觉":["85.13"],"其相对路径导入与绝对路径导入均不会解析":["85.13"],"中的文件":["85.13"],"对于相对路径导入":["85.13"],"它只会尝试":["85.13"],"这一配置主要是为了":["85.14"],"配置中的多平台构建配置":["85.14"],"但你可以用它在":["85.14"],"这个指令指向的声明文件将不会被加载":["85.15"],"reference":["85.15","86.25"],"的解析是基于":["85.16"],"作为相对路径的":["85.16"],"esbuild":["85.20","85.22"],"swc":["85.22","85.30"],"等工具进行实际构建":["85.22"],"版本还新增了":["85.23"],"node16":["85.23"],"两个":["85.23"],"在启用":["85.24"],"辅助函数":["85.24"],"都将从":["85.24"],"中导出":["85.24"],"而其实际":["85.25"],"循环中会被拆开来分别遍历":["85.25"],"次":["85.25"],"这种情况下我们的预期应当是仍然保留为":["85.25"],"此时就可以启用":["85.25"],"isdangerous":["85.26"],"配置会将所有的值导入都保留下来":["85.26"],"如果你使用":["85.26"],"babel":["85.26","89.9"],"等无法处理类型的编译器来构建":["85.26"],"即启用了":["85.26"],"isolatedmodules":["85.26"],"你可以将这些类型声明文件输出到一个独立的文件夹下":["85.28"],"那就可以直接跳转到变量对应的原始":["85.29"],"来构建代码文件":["85.30"],"只不过它是映射到原本的":["85.31"],"也就是你可以从压缩过的代码直接定位到原本的":["85.31"],"文件的注释":["85.32"],"默认启用":["85.32"],"stripinternal":["85.32"],"这一选项会阻止为被标记为":["85.32"],"internal":["85.32"],"的代码语句生成对应的类型":["85.32"],"我们会介绍检查相关与工程相关的配置项":["85.33"],"其中检查部分包括了类型检查":["85.33"],"比如小小":["86.1"],"demo":["86.1"],"self":["86.3"],"handle":["86.3"],"oops":["86.4"],"unused":["86.5"],"verified":["86.5"],"这段代码实际上想返回一个对象字面量":["86.5"],"这部分配置的值通常只有":["86.6"],"这就导致你可以使用任意类型的值来调用":["86.8"],"这无疑是非常危险的":["86.8"],"如果你希望禁止这一类行为":["86.8"],"可以启用":["86.8"],"err":["86.9"],"instanceof":["86.9"],"的语句都会执行":["86.11"],"这是因为在":["86.11"],"derived1":["86.12"],"我们在":["86.13"],"分支忘记了":["86.13"],"这里立刻就给到了一个报错":["86.13"],"隐式具有类型":["86.14"],"的访问":["86.15"],"即使它们已在索引类型签名中被隐式声明":["86.15"],"而对于具体声明的已知属性访问":["86.15"],"则不会有问题":["86.15"],"不会再被允许作为可选属性的值":["86.18"],"除非你显式添加一个":["86.18"],"同时生成的":["86.19"],"文件开头也会有":["86.19"],"strictnullchecks":["86.20"],"strictbindcallapply":["86.20"],"n1":["86.21"],"find":["86.23","89.4"],"u":["86.23"],"no":["86.25"],"default":["86.25","95.2"],"commonjs":["86.27"],"中去引用其余三个项目":["86.27"],"引用":["86.28","107.80"],"而在子项目中必须启用":["86.28"],"declaration":["86.28"],"无法导出类型":["86.30"],"并不知道这个值是类型还是值":["86.30"],"以及无法使用":["86.30"],"与常量枚举":["86.30"],"常量枚举在构建后会被内联到产物中":["86.30"],"文件的检查":["86.33"],"或者仅对部分":["86.33"],"文件进行检查":["86.33"],"的默认导入":["86.35"],"与命名空间导入":["86.35"],"能正确地对应到":["86.35"],"中的导出":["86.35"],"会检查目标模块的使用规范":["86.35"],"模块直接返回":["86.35"],"否则将其挂载在一个对象的":["86.35"],"属性上":["86.35"],"转换结果等价于以下":["86.35"],"即命名空间导入的辅助函数":["86.35"],"的实现则要复杂一些":["86.35"],"存储起来":["86.37"],"提供了":["86.38"],"使用操作系统的原生事件来进行监听":["86.38"],"fixedpollinginterval":["86.38"],"has":["86.39"],"compileroptions":["86.41"],"或者在团队的所有项目间使用基本统一的配置":["86.41"],"如从定义编辑器插件的":["86.42"],"plugins":["86.42"],"配置到编辑器插件的开发":["86.42"],"我们会进入完全的实战环节":["86.42"],"你也不需要有自己的服务器与数据库":["87.0"],"已经帮我们准备好了":["87.0"],"但你仍然需要有基本的":["87.0"],"nodejs":["87.0"],"使用经验":["87.0"],"https":["87.1","97.7"],"assets":["87.1"],"更好的方式是将":["87.2"],"拆得更细一些":["87.2"],"需要依次调用":["87.2"],"queryuser":["87.2"],"检查当前用户是否存在":["87.2"],"checkusermutationavaliable":["87.2"],"当前用户是否被允许进行信息更新":["87.2"],"更新用户":["87.2"],"noticeuserfollowerupdate":["87.2"],"提醒用户的粉丝发生了资料更新":["87.2"],"等等数个细粒度的":["87.2"],"这样一来":["87.2"],"在未来新增":["87.2"],"你只需要重新按照逻辑组装":["87.2"],"即可":["87.2","88.3","107.2"],"而不需要再完全重写一个功能大半相似的":["87.2"],"injectable":["87.2"],"hello":["87.2","107.36","107.38","110.5"],"world":["87.2","101.34","107.38"],"这一文件是应用的核心文件":["87.2"],"我们需要这一模块才能在":["87.2"],"函数从环境变量中注入定义":["87.3"],"下面的":["87.3"],"部分就是数据库的实体定义了":["87.3"],"我们定义了":["87.3"],"三个实体":["87.3"],"中内置了一些特殊语法与函数":["87.3"],"将这一列标记为主键":["87.3"],"意为使用自增主键作为默认值":["87.3"],"意为使用创建":["87.3"],"修改时的日期作为默认值":["87.3"],"中我们可以用非常自然的方式声明关联":["87.3"],"实际上我们就是声明了":["87.3"],"多对多":["87.3"],"的级联关系":["87.3"],"接着":["87.3"],"我们来体验下转换":["87.3"],"执行以下命令":["87.3"],"generate":["87.3"],"imagea1dd0f09cd0c6303":["87.3"],"类型定义":["87.4"],"而我们实际上可以直接复用这些类型":["87.4"],"这里会存放项目中的类型定义":["87.4"],"在这个项目中我们只需要使用从":["87.4"],"中导出的":["87.4"],"articlecreateinput":["87.4"],"articleupdateinput":["87.4"],"articlewhereuniqueinput":["87.4"],"我更相信授人以渔的教学方式":["87.5"],"因此实际开发时我们只会完成一部分开发":["87.5"],"走通整个流程":["87.5"],"如果这两个框架让你感到有点意思":["87.5"],"你就会自驱地完成整个流程开发的":["87.5"],"manager":["87.7"],"模式下":["87.8"],"的作用":["87.9"],"看起来更麻烦了":["87.9"],"但你是否感觉到了灵活性的成倍增长":["87.9"],"每一次链式调用都会对最终生成的":["87.9"],"产生一些调整":["87.9"],"因此我们可以通过非常细粒度的调整来更加的贴近原生":["87.9"],"blog":["88.0"],"账号名输入你的邮箱":["88.1"],"密码输入":["88.1"],"确认登录":["88.1"],"同时我们仍然可以将":["88.1"],"的仓库添加为一个单独的远程仓库":["88.1"],"这么做的原因是我们可以先":["88.1"],"到":["88.1"],"的远程仓库来进行构建与部署的测试":["88.1"],"等测试验证完毕了再推送到":["88.1"],"运行":["88.1"],"bash":["88.1","88.3"],"remote":["88.1"],"你的应用名":["88.1"],"query":["88.2"],"别忘了把":["88.2"],"添加到":["88.2"],"appmodule":["88.2"],"现在才是真正的万事具备":["88.3"],"我们可以启动项目了":["88.3"],"这一过程我们通常会用到两个命令":["88.3"],"git":["88.3"],"如果你已经连接到了":["88.3"],"其实直接推送":["88.3"],"仓库即可":["88.3"],"但这一命令的主要作用是会展示":["88.3"],"接收到推送以后":["88.3"],"拉取代码":["88.3"],"安装依赖":["88.3"],"queryrecords":["88.4"],"includeinvisible":["88.4"],"findmany":["88.4"],"querysinglerecord":["88.4"],"在全量查询中":["88.4"],"我们支持了通过":["88.4"],"includevisible":["88.4"],"选项进行过滤":["88.4"],"而在单条查询中则不会进行过滤":["88.4"],"完成了":["88.4"],"controller":["88.4"],"其实就简单多了":["88.4"],"我们通常会在这里进行鉴权":["88.4"],"校验参数":["88.4"],"限流拦截等操作":["88.4"],"但现在我们只需要简单地调用":["88.4"],"创建与更新比较类似":["88.4"],"我们放在一起看":["88.4"],"集成":["88.5"],"数据库":["88.5"],"监控":["88.5"],"热更新":["88.5"],"负载均衡以及域名服务等等基础设施":["88.5"],"小册到这里已经接近了尾声":["88.5"],"plugin":["89.0","89.1","95.2"],"syntax":["89.0"],"transform":["89.0","97.18"],"proposal":["89.0"],"decorators":["89.0"],"上面的核心部分只包括最简单的处理逻辑":["89.0"],"如果你想转换":["89.0"],"想将":["89.0"],"statement":["89.1"],"ast":["89.1"],"的结点类型有比较清晰地了解":["89.1"],"比如上面的":["89.1"],"语句需要使用哪些":["89.1"],"token":["89.1"],"来组装":["89.1"],"还需要了解":["89.1"],"装饰器等实际的":["89.1"],"结构":["89.1","89.2"],"jscodeshift":["89.1"],"等工具的使用方式都不同":["89.1"],"是声明式的":["89.1"],"visitor":["89.1"],"我们声明对哪一部分语句做哪些处理":["89.1"],"然后":["89.1"],"在遍历":["89.1"],"traverse":["89.1"],"发现这些语句被注册了操作":["89.1"],"就进行对应地执行":["89.1"],"以下示例来自于神光的文章分享":["89.1"],"也推荐各位有兴趣进一步学习编译原理的同学关注神光老师的社区分享":["89.1"],"helper":["89.1"],"utils":["89.1"],"不允许函数类型的赋值":["89.1"],"nofuncassignlint":["89.1"],"毕竟要对":["89.2"],"进行操作":["89.2"],"还是需要分析出整个":["89.2"],"以及定位到需要操作的目标":["89.2"],"结点":["89.2"],"如果是和我一样没有学习过编译原理的同学":["89.2"],"这一步仍然是天堑":["89.2"],"感谢万能的社区":["89.2"],"我们可以使用":["89.2"],"viewer":["89.2","89.9"],"这个在线网页来直观地检查一段代码的":["89.2"],"从左到右依次是输入的源码":["89.2"],"左上":["89.2"],"与对应的":["89.2"],"左下":["89.2"],"结构以及其在":["89.2"],"内部的编译产物":["89.2"],"你可以通过右上角的配置来调整":["89.2"],"版本等功能":["89.2"],"除了":["89.2"],"以外":["89.2"],"此前你可能也使用过支持数十种语言或":["89.2"],"这些":["89.3"],"会进行依赖升级":["89.3"],"配置文件更新以及源码更新等操作":["89.3"],"这里我们指的":["89.3"],"其实就只是源码更新这一部分":["89.3"],"raw":["89.4"],"slice":["89.4","96.5"],"specifiers":["89.4"],"specifier":["89.4"],"impl":["89.5"],"gettext":["89.5","89.8"],"methods":["89.5"],"拿到所有方法":["89.5"],"getmethods":["89.5"],"新增":["89.6"],"包裹":["89.6"],"setexpression":["89.6"],"我们主要调用了这些":["89.6"],"简单起见":["89.7"],"不处理混合或者更复杂的情况":["89.7"],"isarray":["89.7","101.52"],"对象类型元素":["89.7"],"objectelement":["89.7"],"filter":["89.7","96.18"],"原始类型元素":["89.7"],"primitiveelement":["89.7"],"primitiveelementtypes":["89.7"],"map":["89.7","96.18"],"对对象类型元素":["89.7"],"只取第一个来提取类型":["89.7"],"replace":["89.8"],"split":["89.8"],"expiredate":["89.8"],"date":["89.8","96.2"],"gettime":["89.8"],"now":["89.8"],"对比时间":["89.8"],"authortag":["89.8"],"一点点进行实现":["89.9"],"而通过":["89.9"],"的帮助":["89.9"],"我们还可以更进一步简化操作":["89.9"],"的工作范畴":["89.11"],"更多关注的是纯粹的":["89.11"],"完全不涉及业务逻辑的规则":["89.11"],"目前大部分评价对内容都是持肯定态度的":["90.0"],"而对于持批评态度的评价":["90.0"],"以上场景了":["90.1"],"工程部分":["90.1"],"光学类型能力可不能说掌握了":["90.1"],"因此我们花了将近":["90.1"],"漫谈篇的内容并不会正文一样动辄":["90.2"],"字":["90.2"],"而是会尽可能控制在":["90.2"],"冴羽":["90.3"],"老师帮我进行的安利和推广":["90.3"],"也推荐所有在阅读这本小册时卡住的同学":["90.3"],"那可能说明这场面试比较奇妙":["91.0"],"在这一节中":["91.0"],"我们会来聊聊几个可能出现的面试题":["91.0"],"依次进行一下从及格线到优秀回答的进阶":["91.0"],"面试题了":["91.1"],"无法像":["91.2"],"alias":["91.3"],"就是用于将一组类型的重命名":["91.3"],"或是对类型进行复杂编程":["91.3"],"只有具有一定经验的使用者才会开始了解类型兼容性的相关规则":["91.4"],"类型中还存在着一部分特殊的规则":["91.5"],"类型兼容性的比较本质上其实也就是在类型层级中进行比较":["91.6"],"一个类型能够兼容其子类型":["91.6"],"就这么回事":["91.6"],"的理解":["91.7"],"则相反":["91.8"],"向上到":["91.9"],"的类型链":["91.9"],"我觉得起码在":["91.9"],"这个技能点上你已经基本得到肯定了":["91.9"],"parametertype":["91.11"],"小册中均已介绍了相关实现与原理":["91.11"],"我不仅了解这些工具类型的实现":["91.12"],"还了解它们可以被归纳为访问性修饰工具类型":["91.12"],"则可能会考察类型工具使用":["91.13"],"类型的控制流分析":["91.13"],"hidden":["92.0"],"noshowingchildren":["92.0"],"xuchp":["93.0"],"io":["93.0"],"install":["93.2","107.13"],"cdn":["93.6"],"jsdelivr":["93.6"],"net":["93.6"],"env":["93.8"],"omit":["93.9","93.10"],"上的加载路径":["93.11"],"cloudflare":["93.12"],"ajax":["93.12"],"yarn":["94.1"],"persistedstate":["94.2"],"state":["94.3","94.8"],"definestore":["94.4"],"pinia":["94.4"],"my":["94.5"],"usestore":["94.6"],"persist":["94.7","94.8"],"该":["94.7"],"somestate":["94.8"],"你好":["94.8"],"即将恢复":["94.9"],"id":["94.9","94.10"],"刚刚恢复完":["94.10"],"时可能发生的任何错误都将使用":["94.11"],"add":["95.1"],"icons":["95.2","95.5"],"usesvgicon":["95.4"],"被引用或者拷贝时":["96.1"],"会创建一个完全相等的变量":["96.1"],"引用类型存储在堆内存中":["96.1"],"htmldocument":["96.2"],"gettype":["96.2"],"注意这里a又可以等于1":["96.3"],"f规则object隐式转换":["96.3"],"注":["96.3","107.13"],"但是执行过3遍之后":["96.3"],"再重新执行a一3或之前的数字就是false":["96.3"],"因为valuei已经加上去了":["96.3"],"这里需要注意一下":["96.3"],"号操作符":["96.3"],"不仅可以用作数字相加":["96.3"],"还可以用作字符串拼接":["96.3"],"如果其中有一个是字符串":["96.3"],"另外一个是":["96.3"],"或布尔型":["96.3"],"则调用":["96.3"],"方法进行字符串拼接":["96.3"],"如果是纯对象":["96.3"],"数组":["96.3"],"正则等":["96.3"],"扩展运算符方式":["96.5"],"利用":["96.5"],"的扩展预算符":["96.5"],"在构造对象的同时完成浅拷贝的功能":["96.5"],"扩展预算符的语法为":["96.5"],"cloneobj":["96.5"],"concat":["96.5"],"拷贝数组":["96.5"],"数组的":["96.5"],"方法其实也是浅拷贝":["96.5"],"方法仅仅针对数组类型":["96.5"],"alldesc":["96.6"],"遍历传入参数所有键的特性":["96.6"],"getprototypeof":["96.6"],"继承原型链":["96.6"],"getfriends":["96.8"],"20240117094316990":["96.8"],"六":["96.8"],"寄生组合式继承":["96.8"],"在前面这几种继承方式的优缺点基础上进行改造":["96.8"],"得出了寄生组合式的继承方法":["96.8"],"这也是所有继承方式里面相对最优的继承方式":["96.8"],"parent":["96.8"],"这里改用":["96.8"],"就可以减少组合继承中多进行一次构造的过程":["96.8"],"parent6":["96.8"],"是挂在":["96.9"],"对象上的个方法":["96.9"],"调用这三个方法的必须是一个函数":["96.9"],"thisarg":["96.9"],"param1":["96.9"],"param2":["96.9"],"闭包其实就是一个可以访问其他函数内部变量的函数":["96.11"],"通常情况下":["96.11"],"直到找到该变量或者不存在父级作用域中":["96.12"],"iife":["96.13"],"立即执行函数":["96.13"],"方法是将一个":["96.14"],"表示加工函数执行时":["96.16"],"every":["96.18"],"es6":["96.19"],"flat":["96.19"],"直接调用":["96.19"],"可以直接实现数组扁平化":["96.19"],"depth":["96.19"],"表示展开深度":["96.19"],"其实大多数时候我们对此并未建立形象的认知":["96.21"],"归并排序":["96.23"],"归并排序是建立在归并操作上的一种有效的排序算法":["96.23"],"该算法是采用分治法的一个非常典型的应用":["96.23"],"将已有序的子序列合并":["96.23"],"得到完全有序的序列":["96.23"],"先使每个子序列有序":["96.23"],"再使子序列段间有序":["96.23"],"若将两个有序表合并成一个有序表":["96.23"],"称为":["96.23"],"二路归并":["96.23"],"归并排序是一种稳定的排序方法":["96.23"],"归并排序的性能不收输入数据的影响":["96.23"],"为排序个数":["96.24"],"当":["96.24"],"采用插入排序":["96.24"],"如何转换盒子模型":["97.1"],"box":["97.1"],"sizing":["97.1"],"行数":["97.2"],"行高":["97.2"],"文字系列":["97.3"],"font":["97.3"],"size":["97.3"],"color":["97.3"],"权重":["97.4"],"0010":["97.4"],"第四":["97.4"],"此元素会作为列表展示":["97.7"],"www":["97.7","107.12"],"w3school":["97.7"],"none":["97.8","100.6"],"overflow":["97.8"],"visible":["97.8"],"display":["97.8"],"px":["97.10"],"是相对于第一个有":["97.11"],"的父元素定位的":["97.11"],"l":["97.12"],"左":["97.12"],"这是由":["97.13"],"nicolas":["97.13"],"gallagher":["97.13"],"请求的次数":["97.14"],"提升了性能":["97.14"],"但是重绘不一定会造成回流":["97.15"],"产生回流的情况":["97.15"],"改变元素的位置":["97.15"],"表示蓝色":["97.16"],"取值可以在正整数或者百分数":["97.16"],"表示透明度":["97.16"],"在元素之前":["97.17"],"webkit":["97.18","100.4","100.6"],"是针对于根":["97.19"],"meida":["97.21"],"图进行等比缩放":["97.22"],"缩放成和电脑一样的尺寸":["97.22"],"换":["97.22"],"的电脑":["97.22"],"移动端的设计图":["97.22"],"把某元素转化成行内元素":["99.1"],"不独占一行":["99.1"],"不能设置宽高":["99.1"],"题外话":["99.3"],"为了符合":["99.3"],"css3":["99.3"],"的规范":["99.3"],"标签尽量少用":["99.3"],"改用":["99.3"],"就可以了":["99.3"],"所以前端在写":["99.4"],"标签的时候":["99.4"],"banner":["99.5"],"等中大图片":["99.5"],"一般是做动图的":["99.5"],"html5":["99.6"],"标签的":["99.6"],"解决":["99.6"],"autocapitalize":["100.1"],"rgba":["100.2"],"长按时下载图片":["100.3"],"脚本":["101.1"],"会阻塞":["101.1"],"结果是":["101.2"],"就是为了填补之前的坑":["101.3"],"具体区别":["101.3"],"是一个表示":["101.3"],"的对象":["101.3"],"方法通常由":["101.4"],"在后台自动调用":["101.4"],"settimeout":["101.5"],"要执行宏任务的前提是清空了所有的微任务":["101.5"],"有变量提升的":["101.6"],"变量悬挂声明":["101.6"],"除了函数外没有块级作用域":["101.7"],"对象如何找属性":["101.11"],"查找规则":["101.11"],"tostring":["101.23","101.25"],"功能有插入":["101.28"],"删除":["101.28"],"指向":["101.36"],"了函数的自由变量":["101.38"],"对象原型中找":["101.41"],"构造函数原型中找":["101.41"],"对象上一层原型中找":["101.41"],"参数不同":["101.49"],"第二个参数是数组":["101.49"],"getelementbyid":["101.50"],"ad82a40509c5b5b4680d4299c8f08d6c6d31af3c":["101.51"],"newobj":["101.52"],"有过期时间":["101.53"],"可以设置过期时间":["101.53"],"把时间调整到之前的时间":["101.53"],"就过期了":["101.53"],"声明常量":["101.55"],"声明的变量可以再次赋值":["101.55"],"obj1":["101.63"],"不能当做构造函数":["101.64"],"rejected":["101.65"],"返回整体":["101.66"],"父组件引入了子组件":["103.2"],"那么先执行父的前":["103.2"],"个生命周期":["103.2"],"再执行子组件的":["103.2"],"中没有":["103.3"],"beforemount":["103.5"],"beforecreated":["103.6"],"第一次进入这个组件会执行":["103.8"],"是否相等":["103.9"],"如果不相同发起请求":["103.9"],"孙子":["103.11"],"子组件不能直接修改父组件的数据":["103.11"],"子组件直接使用父组件的数据":["103.11"],"description":["105.0"],"filepath":["105.0"],"extensions":["106.0"],"msg":["106.1","111.2"],"highlighted":["106.1"],"output":["106.1"],"点击":["107.2","107.8"],"next":["107.2"],"image":["107.2","107.62"],"png":["107.2"],"选择安装路径":["107.2"],"完成后点击":["107.2"],"浏览配置汇总页":["107.3"],"确认无误后点击":["107.3"],"等待下载":["107.3"],"下载完成后":["107.3"],"包名":["107.4"],"通常为公司域名倒置":["107.4"],"save":["107.4"],"location":["107.4"],"项目目录":["107.4"],"模拟器和真机运行":["107.5"],"ets":["107.6","107.70","107.73","107.76","107.99","107.106","107.115","107.124","107.130","107.133","107.139"],"然后点击":["107.6","107.8"],"系统镜像下载完毕后":["107.7"],"配置模拟器":["107.7"],"可选":["107.7"],"至此模拟器安装完毕":["107.7"],"确定":["107.8"],"回到":["107.8"],"ide":["107.8"],"在右上角的设备列表中选择连接的手机":["107.8"],"默认已选中":["107.8"],"最后点击运行按钮":["107.8"],"即可将项目运行到真机中":["107.8"],"首次运行会提示缺少签名信息":["107.8"],"更自然的方式开发应用":["107.9"],"值得注意的是":["107.9"],"typescriptlang":["107.12"],"org":["107.12"],"完成后需要重新启动vscode":["107.13"],"另其重新加载环境变量和相关依赖":["107.13"],"编写程序并运行":["107.13"],"在完成上述环境的准备后":["107.13"],"就可以编写":["107.13"],"而常量在赋值后便不能再修改":["107.16"],"进行初始化":["107.23"],"声明函数的基础语法如下":["107.25"],"print":["107.28"],"sum":["107.31"],"两者用":["107.32"],"符号连接":["107.32"],"它定义了对象的属性":["107.34"],"数据":["107.34"],"和行为":["107.34"],"introduce":["107.36"],"对象方法的调用":["107.37"],"对象创建后":["107.37"],"xiaoming":["107.39"],"三年二班":["107.39"],"student":["107.40"],"接口通常会作为一种契约或规范让类":["107.42"],"p2":["107.44"],"lisi":["107.44","107.77"],"最后分别调用":["107.44"],"这样改造完之后":["107.45"],"就可以很容易的在不改变现有代码的情况下":["107.45"],"支持新的支付方式了":["107.45"],"比如现在需要支持":["107.45"],"那我们就可以创建":["107.45"],"这个类":["107.45"],"并实现":["107.45"],"implement":["107.45"],"此时就可以声明一个接口来描述该对象的类型":["107.46"],"如下":["107.46","107.58"],"右":["107.48"],"或季节":["107.48"],"春":["107.48"],"向上移动":["107.49"],"类等":["107.52"],"在该模块外部是不可见的":["107.52"],"导入":["107.53"],"导入须使用":["107.53"],"创建模块对象":["107.54"],"上述导入重命名的方式能够很好的解决命名冲突的问题":["107.54"],"但是当冲突内容较多时":["107.54"],"这种写法会比较冗长":["107.54"],"除了导入重命名外":["107.54"],"hellofroma":["107.55"],"由于默认导入时无需关注导入项的名称":["107.55"],"ui":["107.56"],"下面通过一个具体案例来学习这种开发范式":["107.57"],"在当前案例中":["107.59"],"我们就将":["107.60"],"而无需关注界面变化的具体过程":["107.61"],"并且":["107.62"],"案例的最终效果如下图所示":["107.64"],"dark":["107.65"],"row":["107.65"],"中添加子组件":["107.67"],"若不支持子组件":["107.67"],"则不需要写":["107.67"],"属性方法":["107.67"],"属性方法用于配置组件的样式和其他属性":["107.67"],"可以在组件声明的末尾进行链式调用":["107.67"],"各组件支持的属性可查看":["107.67"],"使用自定义组件":["107.68"],"用于修改或扩展其原有的行为":["107.69"],"在学完自定义组件的语法之后":["107.69"],"我们会发现前文案例中的每个页面实际上都是一个自定义组件":["107.69"],"但是和自定义组件的语法相比":["107.69"],"前边的每个案例还会多出一个":["107.69"],"entry":["107.69","107.73","107.84","107.92","107.93","107.99","107.100","107.110","107.124"],"main":["107.70","107.73","107.76","107.92","107.99","107.106","107.115","107.124","107.133"],"pages":["107.70","107.76","107.106","107.115","107.130","107.133","107.139"],"条件渲染":["107.72"],"循环渲染":["107.75"],"stringify":["107.77"],"在某些情况下默认的key生成函数":["107.77"],"会导致界面渲染效率低下":["107.77"],"此时可考虑通过keygenerator函数自定义生成逻辑":["107.77"],"例如如下场景":["107.77"],"状态变量数组定义如下":["107.77"],"zhangsan":["107.77"],"wangwu":["107.77"],"语句如下":["107.77"],"为图片组件":["107.79"],"两个目录下图片的使用方式有所不同":["107.80"],"下面逐一介绍":["107.80"],"目录":["107.80"],"该目录下的资源":["107.80"],"需要使用":["107.80"],"filename":["107.80"],"的方式引用":["107.80"],"无需指定具体版本":["107.80"],"系统会自动根据所处环境选择相应版本":["107.80"],"例如上图中的img":["107.80"],"png图片":["107.80"],"可通过":["107.80"],"的返回值即为":["107.80"],"要了解具体语法":["107.82"],"需要先熟悉element目录下的文件内容":["107.82"],"前文提到过":["107.82"],"element目录中可保存各种类型的数值":["107.82"],"且每种类型的值分别定义在一个":["107.82"],"文件中":["107.82"],"文件中的内容为键值对":["107.82"],"的形式":["107.82"],"具体内容如下":["107.82"],"desc":["107.82"],"模块描述":["107.82"],"使得图片完全显示在显示区域内":["107.83"],"auto":["107.83"],"自适应显示":["107.83"],"各选项的效果如下图所示":["107.83"],"相关案例见":["107.83","107.84","107.89","107.92","107.93","107.100","107.107","107.110","107.118"],"低等质量插值":["107.84"],"各选项效果如下图所示":["107.84"],"demos":["107.84","107.92","107.93","107.100","107.107","107.110","107.118"],"为文本组件":["107.86"],"此时我们便可通过如下方式引用并显示":["107.87"],"的内容":["107.87"],"作为单位":["107.89"],"类型参数用于引用resources下的element目录中定义的数值":["107.89"],"字体非常粗":["107.90"],"类型的参数仅支持":["107.90"],"类型和":["107.90"],"类型参数的字符串形式":["107.90"],"具体写法为":["107.91"],"0x008000":["107.91"],"类型的参数用于应用resources下的element目录中定义的值":["107.91"],"各选项效果如下":["107.93"],"为按钮组件":["107.95"],"表示是否开启点击效果":["107.96"],"点击效果如下":["107.96"],"子组件会作为按钮上显示的内容":["107.96"],"可以是图片":["107.96"],"文字等":["107.96"],"这种方式下":["107.96"],"组件就不在需要":["107.96"],"绿色按钮":["107.98"],"一般用于两种状态之间的切换":["107.102"],"例如下图中的蓝牙开关":["107.102"],"组件的状态":["107.103"],"例如":["107.103"],"组件在选中":["107.105"],"或打开":["107.105"],"从打开切换为关闭时":["107.107"],"为文本输入组件":["107.109"],"normal":["107.112"],"基本输入模式":["107.112"],"方法设置光标的颜色":["107.113"],"用于设置字体":["107.114"],"包括字体大小":["107.114"],"callback":["107.117"],"为进度条组件":["107.120"],"月食样式":["107.121"],"scalering":["107.121"],"环形有刻度样式":["107.121"],"capsule":["107.121"],"的刻度线的宽度":["107.123"],"2vp":["107.123"],"提供了多种内置的弹窗供开发者使用":["107.125"],"一般会在短暂停留后自动消失":["107.127"],"属性用于设置提示信息":["107.128"],"属性用于设置提示信息停留时长":["107.128"],"单位为毫秒":["107.128"],"取值范围是":["107.128"],"component":["107.130","107.133","107.139"],"datepickerdialog":["107.136","107.137"],"日期滑动选择期弹窗":["107.136","107.137"],"管理变量的生命周期":["109.1"],"model":["109.1","114.1"],"和展示形式":["109.1"],"标签中的":["110.7"],"的子元素":["111.1"],"span":["111.1"],"vue":["111.5"],"activeindex":["111.9","111.10"],"toggle":["111.9","111.10","112.1","112.2"],"something":["111.15"],"count":["113.1","113.2","114.4","114.5","116.1","116.2","117.1","117.2","118.1"],"如果想在侦听器回调中能访问被":["113.14"],"更新":["113.14"],"输出":["113.21"],"stop":["113.25"],"val":["113.29"],"capitalize":["114.1","114.2"],"使它从不更新":["114.4"],"跳过该元素及其所有子元素的编译":["114.6"],"元素内具有":["114.6"],"many":["114.11","114.12"],"times":["114.11","114.12"],"activetab":["114.14","114.15"],"me":["115.1"],"onclick1":["115.4"],"添加按键修饰符让有且只有":["115.4"],"被按下的时候才触发":["115.4"],"onctrlclick":["115.5"],"添加按键修饰符让没有任何系统修饰符被按下的时候才触发":["115.5"],"reactivestate":["118.1"],"让我们来试试吧":["119.1"],"若想新增或者修改一个需求":["121.1"],"就需要分别修改":["121.1"],"compositionapi2":["121.3"],"h2":["121.3"],"姓名":["121.3"],"但模板中不需要":["121.4"],"直接使用即可":["121.4"],"proxy":["121.5"],"的实例对象":["121.5"],"简称":["121.5"],"接收的是对象类型":["121.6"],"zoom":["121.7"],"重新分配一个新对象":["121.7"],"会":["121.7"],"失去":["121.7"],"响应式":["121.7"],"gender":["121.8"],"changename":["121.8"],"修改名字":["121.8"]},{"0":["64.0","66.2","69.4","76.4","80.2","82.2","86.3","89.1","89.7","96.6","97.18","107.77"],"1":["0.64","55.5","58.64","67.1","67.3","71.4","74.1","76.4","107.77"],"2":["67.1","71.4","73.2","101.40"],"3":["0.31","14.0","31.0","56.1","58.31","67.3","81.10","82.2","101.60"],"4":["0.90","58.90","82.2","101.36","101.41","101.64","103.2"],"5":["9.0","19.2","55.1","81.10","101.6"],"6":["0.12","0.24","0.63","0.79","9.0","55.1","58.12","58.24","58.63","58.79","96.19"],"7":["0.60","0.79","55.1","56.6","58.60","58.79","82.2","82.9","82.12","89.1"],"8":["0.90","55.1","56.6","58.90"],"9":["0.30","58.30"],"11":["0.83","58.83","96.3"],"16":["0.15","58.15"],"17":["85.5"],"18":["61.8"],"26":["0.17","0.18","58.17","58.18"],"34":["0.34","58.34"],"40":["69.9"],"41":["69.9"],"50":["97.6","107.65"],"150":["107.82"],"200":["34.2"],"222":["101.9"],"256":["55.5"],"404":["45.0"],"599":["60.5","69.4","88.4"],"726":["101.51"],"750":["97.22"],"1000":["96.24"],"1500":["90.2"],"2020":["82.9"],"13407036":["63.11"],"因为它是一个关键字":["0.2","58.2"],"但是":["0.2","1.2","58.2","77.4"],"false":["0.3","0.32","0.33","58.3","58.32","58.33","66.2","67.1","82.10","86.6","101.12"],"和":["0.3","0.32","0.82","29.1","58.3","58.32","58.82","75.4","86.33","94.7","101.1","107.90"],"null":["0.3","0.24","0.28","21.3","58.3","58.24","58.28","66.2","80.13","85.4","96.5"],"只要把这个预处理命令放到函数头的开头即可":["0.5","58.5"],"function":["0.5","0.7","0.24","1.1","28.3","30.0","58.5","58.7","58.24","60.1","65.1","85.6","96.16","101.50"],"dosomething":["0.5","58.5"],"debugger":["0.7","58.7","85.31"],"import":["0.7","57.1","58.7","60.5","78.7","85.9","85.24","86.27"],"this":["0.7","58.7","83.2","103.11"],"default":["0.7","58.7","80.11"],"保留的关键字不能用作标识符或属性名":["0.8","58.8"],"static":["0.10","58.10"],"只能在":["0.12","58.12"],"合法":["0.13","58.13"],"但不推荐":["0.13","58.13"],"不初始化的情况下":["0.13","58.13"],"是不是有意为之":["0.14","58.14"],"在严格模式下":["0.14","58.14"],"如果像这样给未声明的变量赋值":["0.14","58.14"],"则会导致抛出":["0.14","58.14"],"如果需要定义多个变量":["0.14","58.14"],"可以在一条语句中用逗号分隔每个变量":["0.14","58.14"],"及可选的初始化":["0.14","58.14"],"快作用域是函数作用域的子集":["0.16","58.16"],"因此使用与":["0.16","58.16"],"的作用域限制也适用于":["0.16","58.16"],"不允许同一个块作用域中出现冗余声明":["0.16","58.16"],"这样会导致报错":["0.16","58.16"],"在":["0.17","24.0","58.17","66.3","67.2","67.7","78.3","80.1","80.11","84.2","85.5"],"声明之前的执行瞬间被称为":["0.17","58.17"],"temporal":["0.17","58.17"],"因此不能依赖条件声明模式":["0.19","58.19"],"ok":["0.21","58.21","78.3"],"for":["0.21","58.21","76.3","80.3","83.10","84.3"],"循环中":["0.21","58.21"],"不能用":["0.21","58.21"],"声明迭代变量":["0.21","58.21"],"迭代变量会自增":["0.21","58.21"],"次之":["0.22","58.22"],"复杂数据类型":["0.23","58.23"],"object":["0.23","12.1","58.23","85.6","121.7"],"或":["0.24","58.24","69.9","70.5","86.28"],"表示值为函数":["0.24","58.24"],"log":["0.26","0.66","0.80","23.0","54.2","58.26","58.66","58.80","79.9","86.27","89.5","89.8","96.16","101.30","101.35","101.43","101.44","101.45","101.46","101.61","107.17","107.30","107.39"],"true":["0.26","58.26","67.1","82.10","85.12","85.17","86.3","86.18","96.6"],"用等于操作符":["0.26","58.26"],"比较":["0.26","58.26"],"undefined":["0.28","0.74","0.75","0.82","58.28","58.74","58.75","58.82","66.2","77.3","86.4","86.15","101.13","101.17"],"n":["0.28","25.0","58.28"],"a":["0.28","0.30","0.36","29.3","58.28","58.30","58.36","67.1","70.1","71.4","73.1","82.3","82.4","101.63","107.54"],"不同的数值类型相应地也有不同的数值字面量格式":["0.29","58.29"],"以及":["0.30","58.30","59.2","62.12","91.5"],"后跟一个大写或者小写字母":["0.31","58.31"],"e":["0.31","58.31"],"再加上一个要乘的":["0.31","58.31"],"的多少次幂":["0.31","58.31"],"isfinite":["0.32","58.32"],"使用":["0.32","39.0","58.32","88.4","103.4"],"negative":["0.32","58.32"],"是数值":["0.33","58.33"],"可以转换为数值10":["0.33","58.33"],"它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止":["0.34","58.34"],"这意味着第一次出现的小数点是有效的":["0.34","58.34"],"但是第二次出现的小数点就无效了":["0.34","58.34"],"此时剩余的字符会被忽略":["0.34","58.34"],"将转换为":["0.34","58.34"],"函数的另一个不同之处在于":["0.34","58.34"],"他始终忽略字符串开头的零":["0.34","58.34"],"这个函数能识别前面讨论的所有的浮点格式":["0.34","58.34"],"以及十进制格式":["0.34","58.34"],"开头的":["0.34","58.34"],"始终被忽略":["0.34","58.34"],"十六进制数值最终会返回":["0.34","58.34"],"因为":["0.34","58.34","63.6","82.13","85.10","97.22"],"只解析十进制值":["0.34","58.34"],"因此不能指定底数":["0.34","58.34"],"最后":["0.34","58.34","60.0","61.8","85.0"],"如果字符串表示整数":["0.34","58.34"],"没有小数点或者小数点后面全是":["0.34","58.34"],"则":["0.34","58.34"],"返回整数":["0.34","58.34"],"标示":["0.35","58.35"],"必须成对出现":["0.35","58.35"],"unnn":["0.36","58.36"],"nnnn":["0.36","58.36"],"默认情况下返回的是十进制":["0.38","58.38"],"second":["0.39","58.39"],"subtitle":["0.40","58.40"],"bbbb":["0.40","58.40"],"header":["0.40","58.40"],"这个函数的返回值是对模板字面量求":["0.41","58.41"],"值得到的字符串":["0.41","58.41"],"raw":["0.42","58.42","78.5"],"标签函数":["0.42","58.42"],"符号的用途是确保对象属性使用唯一标识符":["0.43","58.43"],"不会发生属性冲突的风险":["0.43","58.43"],"mywrappedsymbol":["0.44","58.44"],"创建普通符号":["0.45","58.45"],"s2":["0.45","58.45"],"对象字面量只能在计算属性语法中使用符号作为属性":["0.46","58.46"],"这些内置符号也没有什么特别之处":["0.47","58.47"],"它们就是全局函数":["0.47","58.47"],"的普通字符串属性":["0.47","58.47"],"指向一个符号":["0.47","58.47"],"tostring":["0.60","0.82","0.84","58.60","58.82","58.84","61.8","89.1"],"valueof":["0.60","0.63","0.83","58.60","58.63","58.83"],"返回对象对应的字符串":["0.60","58.60"],"或减":["0.63","58.63"],"如果是对象":["0.63","58.63"],"则调用其":["0.63","0.83","58.63","58.83"],"方法取得可以操作的值":["0.63","58.63"],"对得到的值应用上述规则":["0.63","58.63"],"转换为":["0.64","58.64"],"给结果加":["0.65","58.65"],"注意":["0.65","58.65","93.3","107.39"],"在位操作中":["0.65","58.65"],"特殊值":["0.65","58.65"],"有符号右移实际上是左移的逆运算":["0.70","58.70"],"结果就差太多了":["0.71","58.71"],"无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理":["0.71","58.71"],"因为负数是其绝对值的二补数":["0.71","58.71"],"nan":["0.73","58.73"],"逻辑与操作符是一种短路操作符":["0.74","58.74"],"意思就是如果第一个操作数决定了结果":["0.74","58.74"],"那么永远不会对第二个操作数求值":["0.74","58.74"],"如果是非":["0.78","58.78"],"的有限值除以":["0.78","58.78"],"则根据第一个操作数的符号返回":["0.78","58.78"],"除数是无限值":["0.79","58.79"],"则返回被除数":["0.79","58.79"],"如果有不是数值的操作数":["0.79","58.79"],"console":["0.80","23.0","58.80","79.9","86.27","89.5","89.8","94.11","96.16","101.30","101.35","101.46","101.63","107.30","107.39"],"再将两个字符串拼接在一起":["0.82","58.82"],"如果有任一操作数是对象":["0.82","0.83","58.82","58.83"],"数值或布尔值":["0.82","58.82"],"则调用它们的":["0.82","58.82"],"方法以获取字符串":["0.82","58.82"],"然后再应用前面的关于字符串的规则":["0.82","58.82"],"对于":["0.82","6.2","58.82"],"将其转换为数值":["0.83","58.83"],"然后再根据前面的规则执行数学运算":["0.83","58.83"],"如果转换结果是":["0.83","58.83"],"则减法计算的结果是":["0.83","58.83"],"方法取得表示它的数值":["0.83","58.83"],"如果该值是":["0.83","58.83"],"则调用":["0.84","58.84"],"只有两个操作数在不转换的前提下不相等才返回":["0.87","58.87"],"右移后赋值":["0.89","58.89"],"无符号右移后赋值":["0.89","58.89"],"image":["1.0","84.4","107.84"],"20240313101558411":["1.0"],"声明式编程":["1.1"],"total2":["1.1"],"reduce":["1.1","96.18"],"memo":["1.1"],"current":["1.1","36.3"],"模型":["1.2"],"vue":["1.2","18.1","103.4","114.6","119.1"],"设计也受到了它的启发":["1.2"],"因此在文档中经常会使用":["1.2"],"vm":["1.2"],"的":["1.3","59.3","79.0","80.33","89.2","96.8","96.9"],"github":["1.3","101.51"],"专门写个编译时可以将模板编译成虚拟":["1.4"],"在构建的时候进行编译性能更高":["1.4"],"复用性等":["1.5","4.0"],"降低更新范围":["1.5","4.0"],"多页应用跳转需要整页资源刷新":["2.1"],"server":["2.1","81.4"],"服务端渲染":["2.1"],"ssr":["2.1","18.2"],"如何分清在哪渲染":["2.1"],"服务器压力小":["2.2"],"应用不利于搜索引擎的抓取":["2.2"],"首次渲染速度相对较慢":["2.2"],"第一次返回空的":["2.2"],"csr":["2.3"],"的方式":["2.3","80.0"],"首屏采用服务端渲染的方式":["2.3"],"diff":["3.1","53.0"],"算法比对差异进行更新":["3.1"],"减少了对真实":["3.1"],"会在后续的":["3.2"],"patch":["3.2","55.1"],"过程中进一步转化为真实":["3.2"],"将更改的部分应到真实":["3.3"],"dom":["3.3","36.1","37.1","44.0","56.1"],"上":["3.3","107.54"],"从而转化为最小量的":["3.3"],"测试性":["4.0"],"的产生而且看浪费内存":["5.0"],"如果粒度过低也无法精准检测变化":["5.0"],"所以采用":["5.0"],"vue3":["6.1","17.0","18.2","19.2","24.0","27.1","29.3"],"则采用":["6.1"],"需要对数组进行单独处理":["6.2"],"es6":["6.2","57.1","66.3","96.8"],"中新产生的":["6.2"],"new":["6.3","22.1","63.11","67.5","78.5","83.4","83.6","83.9","87.3","101.16"],"proxy":["6.3"],"收集":["6.3"],"effect":["6.3"],"触发":["6.3","44.0"],"更新":["6.3","8.1","44.0","70.5"],"reverse":["7.1"],"方法":["7.1","43.1","63.10","96.9","107.44"],"notify":["8.1"],"当属性发生修改时会找对应的":["8.2"],"列表依次执行":["8.2"],"upfront":["9.0"],"the":["9.0","36.3"],"option":["9.0"],"如果不是响应式的也不需要将其定义成响应式属性":["9.0"],"将属性定义成响应式的":["9.0"],"definereactive":["9.0"],"的显示或者隐藏":["10.1"],"计算属性中不支持异步逻辑":["11.1"],"computed属性是可以在模板中使用的":["11.1"],"函数":["11.2","85.5"],"让用户方便使用也解决了清理问题":["11.2"],"主要解决原始值的响应式问题":["12.1"],"cb":["13.0"],"重新生成代码":["14.0"],"codegen":["14.0"],"内部还会给所有的响应式数据增加":["15.0"],"dep":["15.0"],"属性":["15.0","79.3","80.29"],"让属性记录自己当前的":["15.0"],"用户后续的修改可以触发":["15.0"],"重新渲染":["15.0"],"但是功能不复杂的时候":["16.0"],"我们可以考虑使用":["16.0"],"会导致循环后再对每一项进行判断":["17.0"],"浪费性能":["17.0","53.0"],"中":["17.0","80.3","83.13","85.5","86.11","91.3","93.3","94.7"],"实例销毁之前调用":["18.1"],"实例仍然完全可用":["18.1"],"destroyed":["18.1","103.9"],"实例销毁后调用":["18.1"],"调用后":["18.1"],"实例指示的所有东西都会解绑定":["18.1"],"所有的事件监听器会被移出":["18.1"],"rendertriggered":["18.2"],"响应式依赖被触发时调用":["18.2"],"serverprefetch":["18.2"],"only":["18.2"],"组件实例在服务器上被渲染之前调用":["18.2"],"不考虑跨级比较的情况":["19.1"],"内部采用深度递归的方式":["19.1"],"头尾":["19.2"],"尾头":["19.2"],"比对查找进行复用":["19.2"],"中采用最长递增子序列来实现":["19.2"],"谈谈你对它的理解":["20.0"],"的策略":["20.1"],"如果数据项的顺序被改变":["20.1"],"将不会移动":["20.1"],"尽量不要采用索引作为":["20.2"],"作为参数传入":["21.1"],"这样插件中就不再需要依赖":["21.1"],"prototype":["21.2","66.3","86.35","101.24","101.64"],"else":["21.3","36.3","89.7"],"直接调用方法":["21.3"],"创建":["22.1","80.1"],"实例":["22.1"],"并挂在到一个元素上":["22.1"],"mount":["22.1"],"方法将其进行渲染":["22.2"],"但是需要引入编译时":["22.2"],"child2":["23.0"],"中因为所有的组件都不用":["24.0"],"format":["25.0"],"number":["25.0","65.5","71.5","79.13","83.7","107.16"],"const":["25.0","61.3","63.8","63.11","64.8","71.5","75.2","76.3","83.9","84.4","86.22","86.27","87.3","94.4","96.5"],"元素":["26.1"],"组件及其所有的子节点将被视为静态内容并跳过":["26.1"],"valuea":["26.2"],"valueb":["26.2"],"class":["26.2","66.5","67.0","68.2","84.2"],"box":["26.2"],"采用":["27.1","53.0"],"compisitionapi":["27.1"],"局部混入用于复用逻辑":["27.2"],"组件的扩展除了mixin之外":["27.3"],"还有一个属性叫做":["27.3"],"extends":["27.3","67.1","73.2","80.9","83.2","96.8"],"组件标签内部的内容会分发到对应的":["28.1"],"表格组件":["28.2"],"树组件":["28.2"],"scopedslots":["28.3"],"u":["28.3","75.2"],"key":["28.3"],"fn":["28.3"],"value":["29.1","86.3","96.16","107.117"],"input":["29.1","65.1","81.10","107.110","107.115"],"复选框会被解析成":["29.2"],"checked":["29.2"],"change":["29.2"],"中可以通过以下方法进行绑定":["29.3"],"html":["29.3","80.1"],"my":["29.3","111.12"],"on":["30.0","88.1"],"update":["30.0","36.3"],"event":["30.0","82.11","115.2"],"elmenu":["31.2"],"子组件会通过":["32.0"],"键值修饰符":["33.0"],"对":["33.0","47.3","56.6"],"keycode":["33.0"],"solitting":["34.1"],"功能一起配合使用":["34.1"],"加载失败时使用的组件":["34.2"],"error":["34.2","82.10","89.1","94.11"],"errorcomponent":["34.2"],"展示加载时组件的延时时间":["34.2"],"默认值是":["34.2"],"毫秒":["34.2"],"delay":["34.2","36.3"],"强制更新":["34.3"],"id":["35.1","96.6"],"count":["35.1","113.20","113.21"],"进行渲染":["36.1"],"mata":["36.2"],"keepalive":["36.2"],"不需要缓存的视图组件":["36.2"],"将组件实例直接复用":["36.3"],"componentinstance":["36.3"],"make":["36.3"],"freshest":["36.3"],"remove":["36.3","89.4"],"push":["36.3","61.6","64.2","82.5","83.10","89.1","101.31","101.32"],"lru算法":["36.3"],"setting":["36.3"],"until":["36.3"],"vnodetocache":["36.3"],"钩子":["36.4","44.0"],"的逻辑进行复用":["37.1"],"及其子":["37.2"],"全部更新后调用":["37.2"],"unbind":["37.2"],"target":["37.3","88.1"],"let":["37.3","82.5","82.11"],"method":["37.3"],"expression":["37.3"],"contextmethod":["37.3"],"document":["37.3"],"addeventlistener":["37.3","82.11"],"策略模式":["38.0"],"策略模式值对象有某个行为":["38.0"],"但是在不同的场景中":["38.0"],"该场景有不同的实现方案":["38.0"],"keep":["39.0"],"alive":["39.0"],"缓存组件":["39.0"],"webpack":["40.0"],"plugin":["40.0"],"插件":["40.0"],"静态资源采用":["40.0"],"cdn":["40.0","93.0"],"进行通信":["41.0","109.1"],"搭建":["41.0"],"bff":["41.0"],"backend":["41.0"],"效果":["42.0"],"维护取消请求":["42.0"],"addroutes":["43.1"],"动态添加路由":["43.1"],"按钮权限":["43.1"],"按钮权限一般采用自定义指令实现":["43.1"],"调用":["44.0"],"historyapi":["45.0"],"美观":["45.0"],"刷新会出现":["45.0"],"所以会出现":["46.0"],"以相应的规则保证状态以一种可预测的方式发生变化":["47.1"],"模块需要增加":["47.3"],"namespaced":["47.3"],"vuex4":["47.4"],"核心就是通过创建一个响应式对象进行数据共享":["47.4"],"subscribe":["48.0"],"监控状态变化":["48.0"],"将数据存储到":["49.0"],"localstorage":["49.0","94.5"],"或者":["49.0","81.12","86.6"],"在严格模式下会发生异常":["50.0"],"dispatch":["50.0"],"时会将":["50.0"],"包装成":["50.0"],"b":["51.0","67.1","71.3","71.4","73.1","82.4","101.63","107.16","107.20","107.22","107.31"],"的状态":["51.0"],"实现组件之间的逻辑共享":["52.0"],"但是会有数据来源不明确":["52.0"],"命名冲突等问题":["52.0"],"提供公共逻辑非常方便":["52.0"],"来进行劫持":["53.0"],"对所有索引进行劫持会造成性能浪费":["53.0"],"需要对数组单独进行处理":["53.0"],"算法也进行了重写":["53.0"],"模块编译优化":["53.0"],"parchflags":["53.0"],"如果":["54.1","73.3","77.2"],"中返回":["54.1"],"统一处理异常接口":["54.3"],"promise":["54.3","64.5","67.5","70.2"],"reject":["54.3"],"需要完整diff":["55.1"],"hydrate":["55.1"],"events":["55.1"],"挂载过事件的":["55.1"],"stable":["55.1"],"fragment":["55.1","55.3"],"稳定序列":["55.1"],"子节点顺序不会发生变化":["55.1"],"keyed":["55.1"],"子节点有key的fragment":["55.1"],"unkeyed":["55.1","55.5"],"子节点没有key的fragment":["55.1"],"need":["55.1"],"这时候切换":["55.2"],"的状态将无法从":["55.2"],"标签切换到":["55.2"],"block":["55.4","55.5","97.9","99.1"],"text":["55.5","83.7","97.3","107.77","107.92","107.93","114.17","114.18"],"可以试想一下":["55.5"],"如果不增加这个":["55.5"],"文档对象模型":["56.1"],"提供与网页内容交互的方法和接口":["56.1"],"操作符":["56.3"],"全局对象":["56.3"],"中使用扩展的":["56.4"],"xml":["56.4"],"load":["56.5"],"and":["56.5","107.36"],"save":["56.5"],"的新模块中":["56.5"],"还有验证文档的方法":["56.5"],"validation":["56.5"],"cookie":["56.6"],"的支持":["56.6"],"对其他自定义对象":["56.6"],"如":["56.6","60.4","66.3","67.5","75.2","78.9","80.3","84.1","85.8","85.14","91.0"],"属性这个值有可能导致脚本被忽略":["57.1"],"在非":["57.1"],"ie":["57.1"],"浏览器中有效的其他值还有":["57.1"],"如果这个值是":["57.1"],"module":["57.1","85.20","88.2"],"则代码会被当成":["57.1"],"模块":["57.1","84.1"],"而且只有这时候代码中才能出现":["57.1"],"的灵活性":["59.0"],"并不能提高应用程序的性能":["59.0"],"开发需要更多额外的类型代码":["59.0"],"最终的结果就是符合你预期的":["59.1"],"而在你敲击下":["59.1"],"来访问一个变量的属性时":["59.1"],"也会将所有的属性展示出来供你挑选":["59.1"],"这就是类型代码对开发效率的提升所在":["59.1"],"而在最终编译时":["59.1"],"又会将这些类型代码抹除":["59.1"],"还给你可以直接放进浏览器里跑的":["59.1"],"纯粹的":["59.1"],"代码":["59.1","60.0","60.8"],"因此":["59.1","60.4","61.7","73.3","85.8","85.23","91.6"],"确实不能提高应用程序的性能":["59.1"],"因为最终运行的仍然是":["59.1"],"总的来说":["59.1"],"配置":["59.2","85.6","85.8","85.25","86.8","86.35"],"tsconfig":["59.2","80.33","90.1"],"是":["59.2"],"工程层面的重要部分":["59.2"],"除此以外":["59.2"],"工程能力的另一重要体现就是":["59.2"],"我们可以通过类型声明的方式":["59.2"],"中愉快地使用":["59.2"],"社区的大量":["59.2"],"npm":["59.2","78.7","79.15","85.23","85.29","93.6"],"包":["59.2"],"类型声明与类型指令":["59.3"],"react":["59.3","67.7","78.11","78.13","90.1"],"eslint":["59.3","64.3","78.2","90.1"],"等框架或工具的紧密结合":["59.3"],"开发并部署一个基于":["59.3"],"node":["59.3","85.23","87.3","87.9"],"区":["59.4"],"与我交流":["59.4"],"学习路上的问题":["59.4"],"同时在每一节也会给出对应代码的地址":["59.6"],"我们还会介绍如何通过":["60.0"],"声明的方式来检查类型兼容性":["60.0"],"inlay":["60.1"],"展示的配置就都是提示相关的了":["60.1"],"推荐开启的有这么几个":["60.1"],"like":["60.1"],"return":["60.1","76.2","83.0","86.5","95.2","101.31","101.32","101.33","107.31"],"types":["60.1"],"显示推导得到的函数返回值类型":["60.1"],"parameter":["60.1"],"names":["60.1"],"显示函数入参的名称":["60.1"],"显示函数入参的类型":["60.1"],"底部问题栏的错误下直接显示到代码文件中的对应位置":["60.2"],"比如这样":["60.2"],"版本":["60.3"],"左上角":["60.3"],"以及通过可视化的方式配置":["60.3"],"左上角的配置":["60.3"],"本身并不支持自动地监听文件变更然后重新执行":["60.4"],"而这一能力又是某些项目场景下的刚需":["60.4"],"nodejs":["60.4","84.1"],"的开发":["60.4"],"我们需要":["60.4"],"库来实现这一能力":["60.4"],"基于":["60.4"],"你可以理解一个类似":["60.4"],"nodemon":["60.4"],"的库":["60.4"],"提供监听文件重新执行的能力":["60.4"],"实现":["60.4"],"并在重启文件进程时共享同一个":["60.4"],"编译进程":["60.4"],"避免了每次重启时需要重新实例化编译进程等操作":["60.4"],"首先":["60.4","73.0"],"我们还是在全局安装":["60.4"],"expecttype":["60.5"],"from":["60.5","78.7","78.13","80.42","86.27","107.53"],"linbudu":["60.5","63.10","69.4","76.5","82.5","83.4","83.6"],"这一部分的内容并不是初学需要掌握的":["60.5"],"但你可以选择提前用起来":["60.5"],"不必急着去理解具体的实现原理":["60.5"],"它的结构大致是这样":["60.5"],"来进行更方便的类型兼容性检查":["60.6"],"这些知识不仅仅只在这本小册的学习过程中起到作用":["60.6"],"它们在未来实际项目开发中也是你的得力助手":["60.6"],"本着磨刀不误砍柴工的原则":["60.6"],"请务必搭建出你最舒适的":["60.6"],"将文件内容字符串外层包裹一个函数":["60.8"],"执行这个函数":["60.8"],"将内容包裹挂载到":["60.8"],"exports":["60.8"],"下":["60.8","87.3"],"evaluating":["60.8"],"执行这个文件内容":["60.8"],"caching":["60.8"],"对于未曾缓存的文件":["60.8"],"将其执行结果缓存起来":["60.8"],"在上述过程中进行操作拦截":["60.8"],"就可以实现很多有用的功能":["60.8"],"比如对":["60.8"],"文件去注册自定义的处理函数":["60.8"],"将其编译为可以直接执行的":["60.8"],"那我建议你利用它来查缺补漏":["61.0"],"为后面的学习打好基础":["61.0"],"比如元组就是一个很容易被大家忽视的知识点":["61.0"],"话不多说":["61.0"],"跟着我一起往下看吧":["61.0"],"symbolvar":["61.1"],"unique":["61.1","68.3"],"其中":["61.1","67.6","86.41","107.117"],"除了":["61.1","61.8","87.9"],"tmp4":["61.2","70.3"],"除了上面介绍的原始类型以及":["61.2"],"类型以外":["61.2"],"能够被赋值给":["61.3"],"类型的变量":["61.3"],"就像在":["61.3"],"中一个没有返回值的函数会默认返回一个":["61.3"],"类型也可以":["61.3"],"但需要在关闭":["61.3"],"strictnullchecks":["61.3"],"配置的情况下才能成立":["61.3"],"voidvar1":["61.3"],"voidvar2":["61.3"],"实际上除了显式地越界访问":["61.4"],"还可能存在隐式地越界访问":["61.4"],"如通过解构赋值的形式":["61.4"],"ele1":["61.4"],"ele2":["61.4"],"rest":["61.4"],"对于数组":["61.4"],"此时仍然无法检查出是否存在隐式访问":["61.4"],"因为类型层面并不知道它到底有多少个元素":["61.4"],"但对于元组":["61.4"],"隐式的越界访问也能够被揪出来给一个警告":["61.4"],"也不能有少的属性":["61.5"],"包括直接在对象内部声明":["61.5"],"或是":["61.5"],"other":["61.5","85.15"],"xxx":["61.5","103.11"],"这样属性访问赋值的形式":["61.5"],"除了声明属性以及属性的类型以外":["61.5"],"我们还可以对属性进行修饰":["61.5"],"因为它是只读属性":["61.6"],"林不渡":["61.6"],"其实在数组与元组层面也有着只读的修饰":["61.6"],"但与对象类型有着两处不同":["61.6"],"你只能将整个数组":["61.6"],"元组标记为只读":["61.6"],"而不能像对象那样标记某个属性为只读":["61.6"],"一旦被标记为只读":["61.6"],"那这个只读数组":["61.6"],"元组的类型上":["61.6"],"将不再具有":["61.6"],"pop":["61.6"],"一个工具类型等等抽离成一个完整独立的类型":["61.7"],"但大部分场景下接口结构都可以被类型别名所取代":["61.7"],"tmp30":["61.8"],"tmp31":["61.8"],"tmp32":["61.8"],"虽然能够将其作为变量的类型":["61.8"],"但你实际上":["61.8"],"无法对这个变量进行任何赋值操作":["61.8"],"age":["61.8","121.3"],"类型":["61.8","61.11","63.4","67.2","69.6","69.9","72.2","76.3","77.2","78.11","86.21"],"上不存在属性":["61.8"],"这是因为它就是纯洁的像一张白纸一样的空对象":["61.8"],"上面没有任何的属性":["61.8"],"这种与生俱来的":["61.8"],"在类型层级一节我们还会再次见到它":["61.8"],"不过那个时候它已经被称为":["61.8"],"万物的起源":["61.8","69.5"],"了":["61.8","73.1"],"为了更好地区分":["61.8"],"这三个具有迷惑性的类型":["61.8"],"我们再做下总结":["61.8"],"代码添加一些类型":["61.9"],"再把某些场景下的数组换成元组":["61.9"],"为部分对象类型的属性添加":["61.9"],"来感受":["61.9"],"代码的严格之美":["61.9"],"在下一节我们要介绍的字面量类型以及枚举":["61.9"],"则需要使用类型查询操作符":["61.11"],"typeof":["61.11","96.5","101.52","107.17"],"declare":["61.11","63.11"],"uniquesymbolbaz":["61.11"],"时获得精确的提示":["62.0"],"也失去了":["62.0"],"类型即文档的功能":["62.0"],"这个时候要怎么做":["62.0"],"你可以认为它其实就是快速生成一个符合指定类型":["62.2"],"但没有实际值的变量":["62.2"],"同时它也不存在于运行时中":["62.2"],"因为单个字面量类型并没有什么实际意义":["62.4"],"它通常和联合类型":["62.4"],"即这里的":["62.4"],"一起使用":["62.4"],"表达一组字面量类型":["62.4"],"interface":["62.4","63.2","75.2","79.10"],"tmp":["62.4","89.1"],"确保接下来的类型推导都会将其类型收窄到":["62.6"],"用户的类型":["62.6"],"即联合类型的第一个分支":["62.6"],"这一能力的使用涉及类型守卫与类型控制流分析":["62.6"],"我们会在后面的章节详细来说":["62.6"],"我们也可以通过类型别名来复用一组字面量联合类型":["62.6"],"type":["62.6","63.2","64.3","66.0","68.1","79.3","79.16","81.11","91.5"],"code":["62.6"],"rejected":["62.8"],"这种精确的字面量类型集合":["62.8"],"需要注意的是":["62.8","65.7","81.7","85.10","85.25","89.6"],"无论是原始类型还是对象类型的字面量类型":["62.8"],"它们的本质都是类型而不是值":["62.8"],"它们在编译时同样会被擦除":["62.8"],"obj":["62.10","82.4"],"k":["62.10"],"v":["62.10"],"的返回值即是":["62.10"],"因此这里的":["62.10"],"本质上就是进行了":["62.10"],"与":["62.10","80.22"],"这样两次赋值":["62.10"],"但需要注意的是":["62.10"],"仅有值为数字的枚举成员才能够进行这样的双向枚举":["62.10"],"字符串枚举成员仍然只会进行单次映射":["62.10"],"实际上":["62.12","63.9","86.35"],"常量枚举的表现":["62.12"],"编译产物还受到配置项":["62.12"],"isolatedmodules":["62.12"],"preserveconstenums":["62.12"],"而对于枚举":["62.14"],"我们可以使用它来替换掉之前使用对象进行常量收敛的代码":["62.14"],"而如果你希望减少编译后的代码":["62.14"],"只需要推导至这个值从属的类型即可":["62.18"],"而":["62.18","69.5","69.6","69.9","72.2","75.2","78.3","78.6","79.8","82.12","89.11"],"声明的原始类型变量将不再可变":["62.18"],"因此类型可以直接一步到位收窄到最精确的字面量类型":["62.18"],"但对象类型变量仍可变":["62.18"],"你已经掌握了从":["63.0"],"迁移到":["63.0"],"后的主要技巧":["63.0"],"可以开始大胆地在新项目中使用":["63.0"],"直接在函数中进行参数和返回值的类型声明":["63.2"],"使用类型别名将函数声明抽离出来":["63.2"],"funcfoo":["63.2"],"如果只是为了描述这个函数的类型结构":["63.2"],"我们甚至可以使用":["63.2"],"类型能更好地说明这个函数":["63.3"],"没有进行返回操作":["63.3"],"但在上面的第二个例子中":["63.3"],"其实更好的方式是使用":["63.3"],"由于其实际上是一个数组":["63.4"],"这里我们也应当使用数组类型进行标注":["63.4"],"any":["63.4","63.12","64.4","65.4","65.5","79.12","80.21","83.10"],"你可以简单理解为它包含了一切可能的类型":["63.4"],"我们会在下一节详细介绍":["63.4"],"arg1":["63.4","80.31"],"函数的实现签名":["63.5"],"会包含重载签名的所有可能情况":["63.5"],"基于重载签名":["63.5"],"我们就实现了将入参类型和返回值类型的可能情况进行关联":["63.5"],"获得了更精确的类型标注能力":["63.5"],"这里有一个需要注意的地方":["63.5"],"拥有多个重载声明的函数在被调用时":["63.5"],"是按照重载的声明顺序往下查找的":["63.5"],"因此在第一个重载声明中":["63.5"],"为了与逻辑中保持一致":["63.5"],"即在":["63.5"],"关于泛型我们会在后面进行详细了解":["63.6"],"在函数这一节中":["63.6"],"我们主要关注函数的类型标注":["63.6"],"中的函数实际上相比":["63.6"],"javascript":["63.6","78.2","82.0","96.8","107.9"],"类声明":["63.8"],"类表达式":["63.8"],"的方式创建":["63.8"],"很明显上面的写法即是类声明":["63.8"],"而使用类表达式的语法则是这样的":["63.8"],"即":["63.9","64.4","68.3","69.4","69.5","69.6"],"不允许再访问受保护的成员":["63.9"],"当你不显式使用访问性修饰符":["63.9"],"成员的访问性默认会被标记为":["63.9"],"在上面的例子中":["63.9"],"我们通过构造函数为类成员赋值的方式还是略显麻烦":["63.9"],"需要声明类属性以及在构造函数中进行赋值":["63.9"],"简单起见":["63.9"],"我们可以":["63.9"],"在构造函数中对参数应用访问性修饰符":["63.9"],"来收敛变量与":["63.10"],"utils":["63.10","80.12"],"identifier":["63.10"],"newablefoo":["63.11"],"上面有问题":["63.11"],"参考这个":["63.11"],"https":["63.11","88.1"],"stackoverflow":["63.11","73.4"],"com":["63.11","87.1","97.7","101.51"],"questions":["63.11"],"how":["63.11"],"does":["63.11"],"interfaces":["63.11"],"with":["63.11"],"construct":["63.11"],"signatures":["63.11"],"work":["63.11"],"中完全没有类似概念的新朋友了":["63.12"],"它们是":["63.12"],"类型编程最基础的一部分":["63.12"],"包括了":["63.12","79.2"],"的形式时":["63.14"],"也可以使用私有构造函数来达成目的":["63.14"],"你可能会想到":["63.14"],"既然有私有构造函数":["63.14"],"那没道理没有受保护的构造函数":["63.14"],"protected":["63.14"],"啊":["63.14"],"l":["63.15"],"里式替换原则":["63.15"],"一个派生类可以在程序的任何一处对其基类进行替换":["63.15"],"这也就意味着":["63.15","83.14","85.11"],"子类完全继承了父类的一切":["63.15"],"对父类进行了功能地扩展":["63.15"],"而非收窄":["63.15"],"i":["63.15","89.7"],"中基本没有类似的概念":["64.0"],"但你也不用担心":["64.0"],"我们会一步一步从":["64.0"],"开始学习":["64.0"],"让你顺利进入类型编程的世界":["64.0"],"放弃了所有的类型检查":["64.1"],"并没有":["64.1"],"这一点也体现在对":["64.1"],"类型的变量进行属性访问时":["64.1"],"报错":["64.1","66.2","66.3","66.7","101.57"],"对象类型为":["64.1"],"要对":["64.1"],"类型进行属性访问":["64.1"],"需要进行类型断言":["64.1"],"别急":["64.1"],"马上就讲类型断言":["64.1"],"虽然这是一个未知的类型":["64.1"],"但我跟你保证它在这里就是这个类型":["64.1"],"as":["64.1","78.9","79.2","80.3","80.42"],"在类型未知的情况下":["64.1"],"更推荐使用":["64.1"],"标注":["64.1"],"这相当于你使用额外的心智负担保证了类型在各处的结构":["64.1"],"后续重构为具体类型时也可以获得最初始的类型信息":["64.1"],"同时还保证了类型检查的存在":["64.1"],"用起来很麻烦":["64.1"],"一堆类型断言写起来可不太好看":["64.1"],"归根结底":["64.1"],"假设某个粗心的同事新增了一个类型分支":["64.2"],"变成了":["64.2"],"strornumorboolorfunc":["64.2"],"却忘记新增对应的处理分支":["64.2"],"此时在":["64.2"],"代码块中就会出现将":["64.2"],"类型赋值给":["64.2"],"类型变量的类型错误":["64.2"],"这实际上就是利用了类型分析能力与":["64.2"],"类型只能赋值给":["64.2"],"类型这一点":["64.2"],"来确保联合类型变量被妥善处理":["64.2"],"前面我们提到了主动使用":["64.2"],"类型的两种方式":["64.2"],"其实还会在某些情况下不请自来":["64.2"],"比如说":["64.2"],"你可能遇到过这样的类型错误":["64.2"],"arr":["64.2","82.5","96.5","96.6","96.16"],"的参数不能赋给类型":["64.2","86.21"],"你也可以使用":["64.3"],"语法":["64.3","78.9"],"它虽然书写更简洁":["64.3"],"但效果一致":["64.3"],"只是在":["64.3"],"tsx":["64.3","67.5","80.1"],"中尖括号断言并不能很好地被分析出来":["64.3"],"你也可以通过":["64.3","81.2"],"提供的":["64.3","89.2"],"consistent":["64.3"],"assertions":["64.3","80.16"],"规则来约束断言风格":["64.3"],"这是因为你的断言类型和原类型的差异太大":["64.4"],"需要先断言到一个通用的类":["64.4"],"string":["64.5","65.5","78.5","79.3","79.13","82.5","92.0","107.117"],"bar":["64.5","82.4","82.9","83.2"],"barpropa":["64.5"],"barpropb":["64.5"],"barmethod":["64.5"],"void":["64.5","80.31","86.3","107.117"],"baz":["64.5"],"handler":["64.5","76.5","82.11","85.4"],"假设你想要基于这个结构随便实现一个对象":["64.5"],"你可能会使用类型标注":["64.5"],"那这些类型工具就是积木工厂":["64.6"],"它们在基础类型的基础之上进行类型编程运算如组合":["64.6"],"过滤等":["64.6"],"得到更贴近你实际需要形状的积木":["64.6"],"那么就拥有了公共父类型":["64.8"],"再断言到具体的类型也是同理":["64.8"],"你可以理解为先向上断言":["64.8"],"再向下断言":["64.8"],"比如前面的双重断言可以改写成这样":["64.8"],"str":["64.8","96.6"],"类型安全保护":["65.0"],"两类":["65.0"],"这一节我们将学习的类型工具就属于类型创建":["65.0"],"它们的作用都是基于已有的类型创建新的类型":["65.0"],"这些类型工具包括类型别名":["65.0"],"交叉类型":["65.0"],"的联合类型":["65.1"],"这样一来":["65.1","78.4"],"在实际使用时就可以确保你处理了可能为空值的属性读取与方法调用":["65.1"],"process":["65.1","95.2"],"类似的还有":["65.1"],"maybepromise":["65.1"],"maybearray":["65.1","88.4"],"这也是我在日常开发中最常使用的一类工具类型":["65.1"],"函数泛型我们会在后面了解":["65.1"],"primitiveproptype":["65.2"],"objectproptype":["65.2"],"如果是两个联合类型组成的交叉类型呢":["65.2"],"其实还是类似的思路":["65.2"],"既然只需要实现一个联合类型成员就能认为是实现了这个联合类型":["65.2"],"那么各实现两边联合类型中的一个就行了":["65.2"],"也就是两边联合类型的交集":["65.2"],"读取":["65.3"],"接下来":["65.3","80.0","83.1","87.3"],"因此自然也包括联合类型":["65.4"],"stringorbooleantypes":["65.4"],"propb":["65.4"],"索引签名类型的一个常见场景是在重构":["65.4"],"代码时":["65.4"],"为内部属性较多的对象声明一个":["65.4"],"来生产一个联合类型":["65.5"],"它会由所有可用作对象键值的类型组成":["65.5"],"symbol":["65.5","68.3","76.3"],"使用字面量联合类型进行索引类型访问时":["65.6"],"其结果就是将联合类型每个分支对应的类型进行访问后的结果":["65.6"],"重新组装成联合类型":["65.6"],"索引类型查询":["65.6"],"索引类型访问通常会和映射类型一起搭配使用":["65.6"],"前两者负责访问键":["65.6"],"而映射类型在其基础上访问键值类型":["65.6"],"我们在下面一个部分就会讲到":["65.6"],"在未声明索引签名类型的情况下":["65.6"],"我们不能使用":["65.6"],"这种原始类型的访问方式":["65.6"],"而只能通过键名的字面量类型来进行访问":["65.6"],"这里的":["65.7","70.5","93.3"],"其实就是上面说到的索引类型访问":["65.7"],"我们使用键的字面量类型访问到了键值的类型":["65.7"],"这里就相当于克隆了一个接口":["65.7"],"这里其实只有":["65.7"],"属于映射类型的语法":["65.7"],"从一个联合类型依次映射到其内部的每一个类型":["65.8"],"在下一节":["65.8","80.43"],"我们会继续来介绍类型工具中的类型查询操作符":["65.8"],"internal":["66.0","79.9"],"绝大部分情况下":["66.1"],"返回的类型就是当你把鼠标悬浮在变量名上时出现的推导后的类型":["66.1"],"并且是":["66.1"],"最窄的推导程度":["66.1"],"即到字面量类型的级别":["66.1"],"你也不必担心混用了这两种":["66.1"],"在逻辑代码中使用的":["66.1"],"一定会是":["66.1"],"中的":["66.1","80.1","86.30","86.35","88.5","89.8","94.5"],"而类型代码":["66.1"],"如类型标注":["66.1"],"类型别名中等":["66.1"],"中的一定是类型查询的":["66.1"],"在这里变成了":["66.2"],"从这个角度来看":["66.2"],"其实类型守卫有些类似于类型断言":["66.2"],"但类型守卫更宽容":["66.2"],"也更信任你一些":["66.2"],"你指定什么类型":["66.2"],"它就是什么类型":["66.2"],"除了使用简单的原始类型以外":["66.2"],"我们还可以在类型守卫中使用对象类型":["66.2"],"联合类型等":["66.2"],"比如下面我开发时常用的两个守卫":["66.2"],"export":["66.2","71.8","79.10","86.27"],"falsy":["66.2"],"并没有起到区分的作用":["66.3"],"在两个代码块中都是":["66.3"],"除此之外":["66.3"],"中还存在一个功能类似于":["66.3"],"的操作符":["66.3"],"它判断的是原型级别的关系":["66.3"],"base":["66.3","66.7"],"会沿着":["66.3"],"的原型链查找":["66.3"],"是否存在其上":["66.3"],"当然":["66.3","79.0","86.8","89.0"],"已经无处不在的今天":["66.3"],"我们也可以简单地认为这是判断":["66.3"],"是否是":["66.3"],"甚至还可以结合使用":["66.4"],"is":["66.4","68.1","76.5","83.2","83.10","89.8"],"关键字来提供进一步的类型守卫能力":["66.4"],"assertisnumber":["66.4"],"val":["66.4"],"我们会了解泛型和类型别名的结合":["66.5"],"以及它在接口":["66.5"],"函数与":["66.5","67.0"],"中的作用":["66.5"],"iderived":["66.7"],"就像继承接口一样需要类型兼容":["66.7"],"touppercase":["66.8"],"而在":["66.8","68.6"],"版本中则对这一情况下的":["66.8"],"联合类型辨识":["66.8"],"即元组":["66.8"],"对象类型":["67.0"],"中的使用方式":["67.0"],"isequal":["67.1"],"不满足约束":["67.2"],"与此同时":["67.2"],"如果我们想让这个类型别名可以无需显式传入泛型参数也能调用":["67.2"],"并且默认情况下是成功地":["67.2"],"这样就可以为这个泛型参数声明一个默认值":["67.2"],"res4":["67.2"],"这个工具类型接受":["67.3"],"个泛型参数":["67.3"],"第二":["67.3"],"三个泛型参数的类型需要是":["67.3"],"首个泛型参数的子类型":["67.3"],"当只传入一个泛型参数时":["67.3"],"其第二个泛型参数会被赋值为此参数":["67.3"],"而第三个则会赋值为第二个泛型参数":["67.3"],"这些结构看起来很复杂":["67.4"],"但其实就是":["67.4"],"简单的泛型参数填充":["67.4"],"而已":["67.4"],"就像我们会封装请求库":["67.4"],"请求响应拦截器一样":["67.4"],"对请求中的参数":["67.4"],"响应中的数据的类型的封装其实也不应该落下":["67.4"],"甚至在理想情况下":["67.4"],"这些结构体封装应该在请求库封装一层中就被处理掉":["67.4"],"同时对应的":["67.5"],"其返回值类型中使用了":["67.5"],"这一工具类型":["67.5"],"它与":["67.5"],"函数的作用一致":["67.5"],"对一个对象结构进行裁剪":["67.5"],"我们会在后面内置工具类型一节讲到":["67.5"],"函数的泛型参数也会被内部的逻辑消费":["67.5"],"payload":["67.5"],"res":["67.5"],"rej":["67.5"],"对于箭头函数的泛型":["67.5"],"其书写方式是这样的":["67.5"],"需要注意的是在":["67.5"],"文件中泛型的尖括号可能会造成报错":["67.5"],"编译器无法识别这是一个组件还是一个泛型":["67.5"],"此时你可以让它长得更像泛型一些":["67.5"],"shift":["67.6"],"方法的入参类型":["67.6"],"我们同样可以找到无处不在的泛型坑位":["67.7"],"state":["67.7","89.1","94.6","107.58"],"setstate":["67.7"],"usestate":["67.7","78.9"],"不传入默认值":["67.7"],"则类型为":["67.7"],"你可能此前听说过它的别名":["67.8"],"鸭子类型":["67.8"],"但还未深入地了解过":["67.8"],"中去模拟另一种类型系统":["68.0"],"结构化类型系统的概念非常基础但十分重要":["68.0"],"它不仅能让你明确类型比较的核心原理":["68.0"],"从根上理解条件类型等类型工具":["68.0"],"也能够在日常开发中帮你解决许多常见的类型报错":["68.0"],"鸭子类型系统和结构化类型系统并不完全一致":["68.1"],"结构化类型系统意味着":["68.1"],"基于完全的类型结构来判断类型兼容性":["68.1"],"而鸭子类型则只基于":["68.1"],"运行时访问的部分":["68.1"],"来决定":["68.1"],"如果我们调用了走":["68.1"],"游泳":["68.1"],"叫这三个方法":["68.1"],"那么传入的类型只需要存在这几个方法即可":["68.1"],"而不需要类型结构完全一致":["68.1"],"但由于":["68.1"],"本身并不是在运行时进行类型检查":["68.1"],"也做不到":["68.1"],"同时官方文档中同样认为这两个概念是一致的":["68.1"],"one":["68.1"],"of":["68.1","81.10","83.10","84.3"],"s":["68.1","78.9","96.2"],"core":["68.1"],"principles":["68.1"],"that":["68.1","86.39"],"父子类型关系只能通过显式的继承来实现":["68.2"],"称为":["68.2"],"标称子类型":["68.2"],"subtyping":["68.2"],"cat":["68.2"],"实现一只短毛猫":["68.2"],"shorthaircat":["68.2"],"我们可以在运行时添加更多的检查逻辑":["68.3"],"同时在类型层面也得到了保障":["68.3"],"这两种方式的本质都是通过非公开":["68.3"],"的额外属性实现了类型信息的附加":["68.3"],"从而使得结构化类型系统将结构一致的两个类型也视为不兼容的":["68.3"],"另外":["68.3","68.6","69.6","82.8","89.11","90.2","91.3"],"fest":["68.3"],"中也通过":["68.3"],"opaque":["68.3"],"支持了类似的功能":["68.3"],"其实现如下":["68.3"],"的类型层级":["68.4"],"我们都知道":["68.4"],"变量的类型之间需要存在兼容性才能进行赋值":["68.4"],"而按照这个兼容性一层层地扩展出来":["68.4"],"我们就得到了":["68.4"],"的变量使用字符串赋值":["68.6"],"因为这个变量在声明时的类型就已经确定了":["68.6"],"中则没有这样的限制":["68.6"],"你可以随时切换一个变量的类型":["68.6"],"在编程语言中还有强类型":["68.6"],"弱类型的概念":["68.6"],"它们体现在对变量类型检查的程度":["68.6"],"向下延伸":["69.0"],"依次把这些类型串起来形成层级链":["69.0"],"让你能够构建出":["69.0"],"的整个类型体系":["69.0"],"柯基":["69.1"],"类型与":["69.1"],"橘猫":["69.1"],"意味着将柯基作为狗":["69.1"],"这是没问题的":["69.1"],"很明显不对":["69.1","77.2"],"程序对":["69.1"],"这个变量的使用":["69.1"],"出现在这里并不恰当":["69.2"],"因为它实际上代表着":["69.2"],"所有非原始类型的类型":["69.2"],"即数组":["69.2"],"对象与函数类型":["69.2"],"所以这里":["69.2"],"成立的原因即是":["69.2"],"这个字面量类型也可以被认为是":["69.2"],"对应的原始类型":["69.4"],"result13":["69.4"],"的字面量类型":["69.5"],"是从":["69.5"],"类型信息的层面":["69.5"],"出发的":["69.5"],"字面量类型在基础类型之上提供了更详细的类型信息":["69.5"],"则是从":["69.5"],"结构化类型系统的比较":["69.5"],"作为一个一无所有的空对象":["69.5"],"几乎可以被视作是所有类型的基类":["69.5"],"如果混淆了这两种类型比较的方式":["69.5"],"就可能会得到":["69.5"],"这样的错误结论":["69.5"],"你可能也感受到了奇怪之处":["69.6"],"在赋值给其他类型时":["69.6"],"any来者不拒":["69.6"],"则只允许赋值给":["69.6"],"类型和":["69.6"],"这也是由于":["69.6"],"可以表达为任何类型":["69.6"],"你需要我赋值给这个变量":["69.6"],"那我现在就是这个变量的子类型了":["69.6"],"我是不是很乖巧":["69.6"],"类型的比较也是互相成立的":["69.6"],"strictnullcheckes":["69.7"],"的情况下":["69.7"],"会被视为":["69.7"],"等类型的子类型":["69.7"],"但正常情况下我们不会这么做":["69.7"],"因此这里不做讨论":["69.7"],"而是将其视为与":["69.7"],"等类型同级的一个类型":["69.7"],"我们一个个来讲解":["69.9"],"这个元组类型实际上能确定其内部成员全部为":["69.9"],"因此是":["69.9"],"的子类型":["69.9"],"中混入了别的类型元素":["69.9"],"因此认为不成立":["69.9"],"42混入了别的类型":["69.9"],"但其判断条件为":["69.9"],"即其成员需要为":["69.9"],"43的成员是未确定的":["69.9"],"等价于":["69.9"],"我们还要见识":["69.10"],"infer":["69.10","79.8"],"关键字":["69.10","78.9"],"分布式条件类型等新朋友":["69.10"],"functionconditiontype":["70.1"],"non":["70.1"],"stringresult":["70.1"],"nonstringresult1":["70.1"],"需要同时满足其两端的类型":["70.2"],"我们使用":["70.2"],"这一形式":["70.2"],"就确保了最终符合条件的类型参数":["70.2"],"一定会满足":["70.2"],"这个类型":["70.2"],"因此可以被视为合法的索引签名类型":["70.2"],"结构还可以是":["70.2"],"结构":["70.2","71.1","89.9"],"promisevalue":["70.2"],"promisevalueresult1":["70.2"],"promisevalueresult2":["70.2"],"但并没有发生提取":["70.2"],"就像条件类型可以嵌套一样":["70.2"],"关键字也经常被使用在嵌套的场景中":["70.2"],"包括对类型结构深层信息地提取":["70.2"],"以及对提取到类型信息的筛选等":["70.2"],"比如上面的":["70.2"],"如果传入了一个嵌套的":["70.2"],"类型就失效了":["70.2"],"promisevalueresult3":["70.2"],"boolean":["70.2","86.21","96.6"],"special2":["70.3"],"special2res":["70.3"],"仅在作为泛型参数时才会产生":["70.3"],"仍然会进行判断":["70.3"],"tmp3":["70.3"],"会跳过判断":["70.3"],"tmp4res":["70.3"],"还是仅在作为泛型参数时才跳过判断":["70.3"],"special3":["70.3"],"special4":["70.3"],"内置的工具类型":["70.4"],"看看它们是如何设计":["70.4"],"以及又是用来解决什么问题的":["70.4"],"并且思考如何让它们变得更完善":["70.4"],"类型能够同时符合":["70.5"],"还记得我们在类型层级一节进行的尝试吗":["70.5"],"如果再过滤掉":["70.5"],"那肯定就只剩下":["70.5"],"类型啦":["70.5"],"感谢评论区":["70.5"],"红花绿叶肉夹馍":["70.5"],"同学的指出":["70.5"],"类型其实可以使用更简单的方式实现":["70.5"],"利用":["70.5"],"时仅有":["70.5"],"为":["70.5","73.1"],"此前我们已经了解了类型工具":["71.0"],"类型系统的相关概念":["71.0"],"那么这一节":["71.0"],"我们就从内置工具类型解读开始":["71.0"],"打开类型编程的新世界":["71.0"],"包括了访问性修饰":["71.1"],"集合以及模式匹配工具类型这四种":["71.1"],"我们会讲解它们的具体实现":["71.1"],"也就是使用了哪些类型操作以及操作背后的原理":["71.1"],"再思考它们存在哪些不足":["71.1"],"存在的扩展方向有哪些":["71.1"],"分配给类型":["71.2"],"反而你会惊喜地发现你没法为这个属性声明值了":["71.2"],"毕竟除本身以外没有类型可以赋值给":["71.2"],"而类似":["71.2"],"中也可以使用":["71.2"],"比如属性a":["71.3"],"也可能是":["71.3"],"基于属性类型":["71.3"],"使用类似的结构":["71.4"],"在关键位置使用一个相反操作来实现反向":["71.4"],"而这里的":["71.4"],"类型则是基于":["71.4"],"类型实现":["71.4"],"也就是":["71.4","78.7","83.8"],"反向工具类型基于正向工具类型实现":["71.4"],"首先接受的泛型参数类似":["71.4"],"也是一个类型与联合类型":["71.4"],"要剔除的属性":["71.4"],"但是在将这个联合类型传入给":["71.4"],"时多了一个":["71.4"],"这一工具类型属于工具类型":["71.4"],"我们可以暂时理解为":["71.4"],"的结果就是联合类型":["71.4"],"中不存在于":["71.4"],"中的部分":["71.4"],"tmp1":["71.4"],"tmp2":["71.4"],"x":["71.5"],"y":["71.5"],"z":["71.5"],"p1":["71.5"],"能够检测出错误":["71.5"],"中缺少了":["71.5"],"concurrence":["71.6"],"intersection":["71.6"],"difference":["71.6"],"complement":["71.6"],"补集基于差集实现":["71.6"],"我们只需要约束":["71.6"],"进来":["71.7"],"即仅使用新的对象类型中的属性值覆盖原本对象类型中的同名属性值":["71.7"],"的通用类型签名可能看起来比较奇怪":["71.8"],"但实际上它就是声明了可实例化":["71.8"],"与可抽象":["71.8"],"罢了":["71.8"],"我们也可以使用接口来进行声明":["71.8"],"不妨试着来写写":["71.9"],"最后一个参数类型":["71.9"],"思考下如果把泛型当成函数参数":["71.10"],"你要如何写一个函数才能实现自己想要的效果":["71.10"],"然后尝试将函数的逻辑迁移到类型编程中":["71.10"],"学完这一节":["72.0"],"以后感受到上下文类型存在时":["72.0"],"你就可以在心里默默地说一句":["72.0"],"谢谢你":["72.0"],"也就是所有符合结构的函数类型的参数":["72.1"],"但却失败了":["72.1"],"中的上下文类型目前暂时不支持这一判断方式":["72.1"],"而不是这不属于上下文类型的能力范畴":["72.1"],"你可以直接使用一个联合类型参数的函数签名":["72.1"],"f2":["72.1"],"而如果联合类型中将这两个类型再嵌套一层":["72.1"],"此时上下文类型反而正常了":["72.1"],"f3":["72.1"],"后数组的长度":["72.2"],"的上下文类型声明中要求返回值是":["72.2"],"如果此时":["72.2"],"类型真的不允许任何返回值":["72.2"],"那这里我们就需要多套一个代码块才能确保类型符合了":["72.2"],"但这真的是有必要的吗":["72.2"],"对于一个":["72.2"],"类型的函数":["72.2"],"我们真的会去消费它的返回值吗":["72.2"],"我们在前面类型层级一节中":["72.3"],"并没有提及函数类型地比较":["72.3"],"这也是因为其中的概念相对复杂":["72.3"],"函数的":["72.5"],"类型签名并不一致":["72.5"],"但这里却没有报错":["72.5"],"从实用意义的角度来看":["72.5"],"如果我们需要类型签名完全一致":["72.5"],"那么就需要为":["72.5"],"再声明一个额外的对应到":["72.5"],"但大部分读者表示内容过于晦涩难懂":["73.0"],"因此在这一节中我会换更接地气的方式来讲解":["73.0"],"我们通过逐步推导比较函数的类型层级":["73.0"],"引出协变与逆变的概念":["73.0"],"然后了解在":["73.0"],"首先它们的参数类型正确的满足了约束":["73.1"],"能接受一只狗狗":["73.1"],"它们的返回值类型也一定会能汪汪汪":["73.1"],"而实际上":["73.1"],"如果我们去掉了包含":["73.1"],"类型的例子":["73.1"],"会发现只剩下":["73.1"],"也即是说":["73.1"],"成立":["73.1"],"意为":["73.1"],"不成立":["73.2"],"checkargtype":["73.2"],"方法的类型签名进一步推导":["73.3"],"在逆变的情况下意味着":["73.3"],"而这很明显是不对的":["73.3"],"简单来说":["73.3"],"是否成立本身就为":["73.3"],"提供了一个前提答案":["73.3"],"我想在未来你再遇到奇怪的类型报错时":["73.4"],"应该再也不会憋着气打开":["73.4"],"搜索":["73.4"],"而是微微一笑胸有成竹地轻松解决":["73.4"],"所凭借的自然就是我们对类型系统的深刻掌握":["73.4"],"类型工具":["73.4"],"类型系统":["73.4"],"类型编程这三辆马车我们已经解决了俩":["73.4"],"或者反过来":["73.6"],"turtle":["73.7"],"彼此之间是互斥的":["73.7"],"我们称为":["73.7"],"不变":["73.7"],"invariant":["73.7"],"用来放狗的笼子绝不能用来放兔子":["73.7"],"即无法进行分配":["73.7"],"如果我们再修改下规则":["73.7"],"现在一个笼子可以放任意物种的动物":["73.7"],"狗和兔子可以放一个笼子里":["73.7"],"因为此时你已经具备了深入学习类型编程的前置基础":["74.0"],"又马上要进入工具类型进阶部分的学习":["74.0"],"那在挑战这座最高的":["74.0"],"山峰":["74.0"],"代码质量的指标之一":["74.1"],"后面可能需要花":["74.1"],"个单位的精力和时间才能再提升":["74.1"],"个单位的类型覆盖":["74.1"],"但你真的需要如此高的类型覆盖程度":["74.1"],"以及愿意花如此多的精力时间吗":["74.1"],"我的建议是":["74.1"],"在你优化":["74.1"],"代码的过程中":["74.1"],"如果感到边际成本明显提升":["74.1"],"重构工作开始有些吃力":["74.1"],"那你很可能已经达到了一个临界值":["74.1"],"也是该停下来的时候了":["74.1"],"而对于":["74.1"],"的学习曲线":["74.1"],"自然也存在着这么一个平衡点":["74.1"],"它标志着你的投入精力和获得回报达成了相对的平衡":["74.1"],"再继续投入更多精力也无法看到明显的效果":["74.1"],"你是否要问":["74.1"],"这本小册中是否也存在着这么个平衡点":["74.1"],"当然也是":["74.1"],"还想尝试更多复杂的类型编程":["74.2"],"此时就可以打开它来上那么几题了":["74.2"],"请务必牢记":["74.2"],"本节代码见":["75.0","76.0"],"advanced":["75.0"],"builtin":["75.0"],"现在它就直观多了":["75.1"],"那我们也就无需再进行实际验证了":["75.1"],"在这里你其实也可以使用":["75.1"],"来把这些属性标记为深层的可选状态":["75.1"],"我们来实现其它类型的部分修饰":["75.1"],"markpropsasrequired":["75.1"],"markpropsasreadonly":["75.1"],"markpropsasmutable":["75.1"],"即第五个参数中的":["75.2"],"同时整体应当基于":["75.2"],"来实现":["75.2"],"对于基于属性类型的结构工具类型就到这里":["75.2"],"这一部分可能需要你先稍微放慢速度":["75.2"],"好好理解一番":["75.2"],"因为并不完全是我们此前了解到的知识":["75.2"],"比如分布式条件类型中":["75.2"],"我们并没有说到条件为联合类型时可能出现的问题":["75.2"],"这是因为脱离实际使用去讲":["75.2"],"很难建立并加深你对这一场景的印象":["75.2"],"但我想现在你已经深刻记住它了":["75.2"],"接下来是基于结构的互斥工具类型":["75.2"],"想象这样一个场景":["75.2"],"假设我们有一个用于描述用户信息的对象结构":["75.2"],"除了共有的一些基础结构以外":["75.2"],"vip":["75.2"],"用户和普通用户":["75.2"],"游客这三种类型的用户各自拥有一些独特的字段":["75.2"],"vipexpires":["75.2"],"代表":["75.2"],"过期时间":["75.2"],"仅属于":["75.2"],"用户":["75.2"],"promotionused":["75.2"],"代表已领取过体验券":["75.2"],"属于普通用户":["75.2"],"referertype":["75.2"],"代表跳转来源":["75.2"],"属于游客":["75.2"],"先来看看如何声明一个接口":["75.2"],"它要么拥有":["75.2"],"要么拥有":["75.2"],"字段":["75.2"],"而不能同时拥有这两个字段":["75.2"],"你可能会首先想到使用联合类型":["75.2"],"commonuser":["75.2"],"user":["75.2","85.14","88.4"],"很遗憾":["75.2"],"这种方式并不会约束":["75.2"],"不能同时拥有":["75.2"],"这个条件":["75.2"],"user1":["75.2"],"为了表示不能同时拥有":["75.2"],"实际上我们应该使用":["75.2"],"类型来标记一个属性":["75.2"],"这里我们直接看完整的实现":["75.2"],"without":["75.2"],"p":["75.2"],"exclude":["75.2"],"xor":["75.2"],"xoruser":["75.2"],"如果要保证原对象优先级更高":["75.3"],"那么只需要在交集处理中将":["75.3"],"视为原集合":["75.3"],"assign":["75.3","121.7"],"首先你会发现":["75.4"],"在这里":["75.4","86.23"],"并非通过":["75.4"],"来提取函数类型":["75.4"],"而是通过":["75.4"],"方法提取":["75.4"],"首先提取到":["75.4"],"方法中的函数类型":["75.4"],"再通过这个函数类型的首个参数来提取出实际的值":["75.4"],"更严谨地来说":["75.4"],"并不应该放在一起比较":["75.4"],"无论多复杂的类型编程":["75.5"],"最终都可以拆分为数个基础的工具类型来实现":["75.5"],"你需要锻炼的就是拆分的思路":["75.5"],"下一节我们还要继续接触类型":["75.5"],"先别激动":["75.5"],"接下来的类型要更好玩有趣一些":["75.5"],"它是":["75.5"],"never":["75.7","79.8","84.7"],"也是类似":["75.7"],"模板字符串":["76.0"],"template":["76.0"],"brand":["76.1"],"memory":["76.1"],"itemtype":["76.1"],"在插槽中传入联合类型":["76.1"],"然后你就会发现":["76.1"],"所有的联合类型排列组合都已经自动组合完毕了":["76.1"],"img":["76.1","89.8","107.25","107.57","107.59","107.64","107.102","107.113","107.127"],"你可能会想":["76.1"],"如果某一种组合并不存在":["76.1"],"就像":["76.1"],"32g":["76.1"],"系列":["76.1","81.0"],"我们在内置工具类型环节中提到了作为类型编程范式之一的集合工具类型":["76.1"],"使用差集就可以解决这里的问题":["76.1"],"比如我们可以只是":["76.1"],"剔除数个确定商品集合":["76.1"],"也可以":["76.1","86.35"],"再利用模板字符串类型的排列组合能力生成要剔除的集合":["76.1"],"hello":["76.2","83.9","94.3","101.34","107.13"],"这个例子进一步体现了类型与值的紧密关联":["76.2"],"由于对象的合法键名类型包括了":["76.3"],"而模板字符串类型插槽中并不支持":["76.3"],"因此我们使用":["76.3"],"来确保了最终交由模板插槽的值":["76.3"],"一定会是合法的":["76.3"],"我们也可以通过伪代码来帮助理解":["76.3"],"copied":["76.3"],"tolowercase":["76.4"],"charat":["76.4"],"slice":["76.4"],"arg":["76.5"],"guess":["76.5"],"who":["76.5"],"trim":["76.6"],"还有":["76.6"],"trimleft":["76.6"],"trimright":["76.6"],"甚至还有":["76.6"],"case":["76.6","77.0"],"omitbytype":["76.8"],"等等":["76.8","85.0"],"这也是":["76.8","85.5"],"的更新中经常会出现的一个有趣现象":["76.8"],"新版本的能力有时可以让我们大大简化类型编程中的操作":["76.8"],"转换":["77.0"],"我们都将一一实现":["77.0"],"万事开头难并不是绝对的":["77.0"],"也可能是你的开头不一定对":["77.0"],"模板字符串相关的工具类型既有非常简单的":["77.0"],"也有极度复杂烧脑的":["77.0"],"为了秉持本小册一路循序渐进的优良作风":["77.0"],"的最终实现与验证":["77.1"],"startswithres1":["77.1"],"joinres1":["77.2"],"啊哦":["77.2"],"我们分析一下原因":["77.2"],"在递归进行到最后一次时":["77.2"],"我们面对的条件类型大致是这样的":["77.2"],"jointmp":["77.2"],"这个条件很明显不会成立":["77.2"],"因此它返回了":["77.2"],"而这个":["77.2"],"类型我们的本义是用来兜底":["77.2"],"无法拼接一个列表":["77.2"],"那至少要返回一个":["77.2"],"要解决这种情况":["77.2"],"我们只需要额外处理一下空数组的情况":["77.2"],"但最终结果还是不太对":["77.2"],"的最终实现":["77.3"],"基本上处理了绝大部分的边界情况":["77.3"],"plainobjecttype":["77.3"],"record":["77.3"],"wordseparators":["77.3"],"readonly":["77.3","88.4"],"prev":["77.3"],"uncapitalize":["77.3"],"都是我们将攻克的对象":["77.4"],"类型能力和工程实战毕竟是两个基本独立的部分":["77.4"],"因此我更建议你在此稍微驻足":["77.4"],"做一个阶段性总结":["77.4"],"看看是否已经把类型能力概念都掌握了":["77.4"],"相比之下":["77.4"],"出现了莫名其妙的类型报错":["78.0"],"但你又不知道从何入手解决":["78.0"],"想让":["78.0"],"直接忽略掉这一行出错的代码":["78.0"],"这里我们称为类型指令":["78.1"],"来进行单行代码或单文件级别的配置能力":["78.1"],"这些指令均以":["78.1"],"ts":["78.1","82.2","85.25","86.30","86.35"],"比如正在将一个":["78.2"],"文件迁移到":["78.2"],"难道要一个个为所有报错的地方都添加上禁用检查指令":["78.2"],"当然不":["78.2"],"正如":["78.2"],"中可以使用":["78.2"],"next":["78.2","82.11"],"line":["78.2"],"文件中的作用和":["78.3"],"文件其实也一致":["78.3"],"如果别的文件或是别的项目导入了这段代码":["78.4"],"它们就能够从这些类型声明获得对应部分的类型":["78.4"],"这也是类型声明的核心作用":["78.4"],"将类型独立于":["78.4"],"note":["78.5"],"content":["78.5","97.9"],"replace":["78.5","86.23","96.2"],"date":["78.5"],"getday":["78.5"],"中仍然使用":["78.6"],"的方式为":["78.6"],"这个内置模块声明了类型":["78.6"],"则使用的是我们没见过的":["78.6"],"别担心":["78.6"],"我们会在后面详细介绍":["78.6"],"回到上面的最后一个问题":["78.6"],"如果第三方库并不是通过导出来使用":["78.6"],"而是直接在全局注入了变量":["78.6"],"总结一下这两个部分":["78.7"],"通过":["78.7"],"definitelytyped":["78.7"],"系列的":["78.7"],"包来为无类型定义的":["78.7"],"包提供类型支持":["78.7"],"这些类型定义":["78.7"],"vite":["78.8","78.13"],"client":["78.8"],"而如果我们使用":["78.8"],"esnext":["78.8"],"省略了不必要的类型标注":["78.9"],"initialstate":["78.9"],"首先我们声明了一个命名空间":["78.9"],"然后使用":["78.9"],"将它导出了":["78.9"],"这样我们就能够在从":["78.9"],"中导入方法时":["78.9"],"获得命名空间内部的类型声明":["78.9"],"从这一个角度来看":["78.9"],"其实就类似于普通的":["78.9"],"只是内部的类型我们不再需要使用":["78.9"],"比如我们直接在":["78.9"],"内部":["78.9"],"即可":["78.9"],"而还有一行":["78.9"],"store":["78.10"],"usecookie":["78.10"],"some":["78.10","80.12"],"fc":["78.10"],"其实你在做的只是一件事":["78.11"],"那就是":["78.11"],"包括我们在下一节所要学习的":["78.11"],"中的做法":["78.13"],"typescript":["78.13","82.1","82.5","83.9","85.32","86.27","88.5","107.58"],"我们会首先从项目搭建开始":["79.0"],"但我们的关注点":["79.0"],"并非代码的实际运行":["79.0"],"而只是结合":["79.0"],"代码书写":["79.0"],"因此你也可以直接阅读仓库中的代码":["79.0"],"的搭建":["79.1"],"参考我的这个":["79.1"],"demo":["79.1"],"本质上":["79.1"],"其实这里面包含的就是对于非实际代码文件导入的类型定义":["79.2"],"图片":["79.2"],"视频等类型":["79.2"],"通过这里的类型封装":["79.2"],"在你导入这些文件时就也能获得基本的类型保障":["79.2"],"三斜线指令并不是导入类型的唯一方式":["79.2"],"我们前面也提到了":["79.2"],"可以使用":["79.2"],"的方式来导入类型":["79.2"],"viteclientenv":["79.2","80.42"],"displayname":["79.3"],"可以看到":["79.3","80.2"],"代表着属性类型的泛型参数":["79.3"],"实际上就是直接传给了类型别名":["79.3"],"而它其实就是为":["79.3"],"新增了一个":["79.3"],"children":["79.3"],"reactnode":["79.3"],"也就是说我们连这个组件的":["79.3"],"都约束了":["79.3"],"我们可以为这个组件显式声明泛型参数":["79.4"],"来获得填充属性时的类型提示与检查":["79.4"],"但很明显":["79.4"],"我们并不能做到这一点":["79.4"],"以上示例代码来自于":["79.4"],"geist":["79.4"],"ui":["79.4"],"一个我认为最符合自己审美的":["79.4"],"组件库":["79.4"],"关于更多简单函数声明与":["79.4"],"如果你需要消费":["79.6"],"返回值的类型":["79.6"],"可以搭配":["79.6"],"returntype":["79.6","85.4"],"result2":["79.7"],"name":["79.7","83.7","89.5","93.6","96.6","121.4"],"通常情况下":["79.7"],"我们不会主动为":["79.7"],"reduceraction":["79.8"],"分析一下这里的填充":["79.8"],"被填充为了一整个函数类型":["79.8"],"props":["79.9"],"internalcontroller":["79.9"],"描述了我们将会在":["79.9"],"上挂载的对象结构":["79.9"],"在函数组件中":["79.9"],"接受":["79.9"],"的函数组件":["79.9"],"子组件":["79.9"],"需要被":["79.9"],"包裹才能正确接收到":["79.9"],"属性及对应的属性值类型":["79.10"],"你也可以直接用它来检查":["79.10"],"样式时的值":["79.10"],"icontainerprops":["79.10"],"style":["79.10","101.54"],"元素和":["79.12"],"组件这两种情况也做了区分":["79.12"],"t":["79.12","80.8","88.4"],"keyof":["79.12","84.7"],"jsx":["79.12"],"intrinsicelements":["79.12"],"jsxelementconstructor":["79.12"],"组件":["79.12"],"reacttext":["79.13"],"reactchild":["79.13"],"它们并不是必须严格遵守的规则":["79.14"],"只是我个人在项目开发中习惯使用的一套规范":["79.14"],"和业务逻辑一致的引用关系":["79.15"],"工具类型定义":["79.15"],"一般是推荐把比较通用的工具类型抽离到专门的工具类型库中":["79.15"],"这里只存放使用场景特殊的部分":["79.15"],"全局的类型声明":["79.15"],"包括非代码文件的导入":["79.15"],"无类型":["79.15"],"包的类型声明":["79.15"],"全局变量的类型定义等等":["79.15"],"你也可以进一步拆分为":["79.15"],"env":["79.15","80.2","89.0"],"iaprop":["79.16"],"的理念":["79.17"],"不妨再次找出你的":["79.17"],"icolumnprops":["79.19"],"但对于简单函数来说就不需要如此":["79.19"],"只关心风格统一部分":["80.0"],"我们希望通过一种":["80.0"],"自动化的":["80.0"],"存在确定规范":["80.0"],"来提升项目中的代码质量":["80.0"],"我们会了解如何配置":["80.0"],"检查的项目文件":["80.1"],"我个人的习惯是只让":["80.1"],"检查核心代码文件":["80.1"],"包括":["80.1","88.3"],"文件":["80.1","86.32","107.13"],"因此我们需要忽略掉部分文件":["80.1"],"eslintignore":["80.1"],"ini":["80.1"],"json":["80.1","89.8","96.19"],"rc":["80.1"],"svg":["80.1"],"css":["80.1"],"package":["80.1","80.2","89.8"],"scripts":["80.1"],"中添加以下命令":["80.1"],"sh":["80.2","87.1"],"usr":["80.2"],"dirname":["80.2","89.1"],"我们实际上要执行的就是":["80.2"],"这个命令":["80.2"],"的作用即是":["80.2"],"找出你添加到暂存区":["80.2"],"的文件":["80.2","85.10"],"然后执行对应的":["80.2"],"接着我们来学习如何将它添加到项目里":["80.2"],"首先还是安装":["80.2"],"然后在":["80.2"],"中新增这段配置":["80.2"],"list":["80.2"],"different":["80.2"],"这些规则我们不会做额外介绍":["80.3"],"因为已经被包含在":["80.3"],"对语法的统一约束":["80.3"],"比如类型断言有":["80.3"],"和尖括号两种":["80.3"],"可以通过规则来约束只能使用一种断言语法":["80.3"],"以及对于某些对实际逻辑无影响":["80.3"],"可加可不加的语法约束":["80.3"],"循环和":["80.3"],"就类似于单引号":["80.6"],"双引号":["80.6"],"加不加分号这种基础规则":["80.6"],"如果你不能接受上一行代码单引号这一行代码双引号":["80.6"],"那么也没理由能接受这里一个":["80.6"],"同时还能帮助你发现某个异步函数忘记加":["80.7"],"async":["80.7","84.2"],"这条规则也是主要做语法统一":["80.8"],"但需要注意的是在":["80.8"],"项目中使用":["80.8"],"断言会导致报错":["80.8"],"因为此时无法像泛型那样通过":["80.8"],"match":["80.9"],"接口在类型编程中的作用非常局限":["80.9"],"仅支持":["80.9"],"泛型等简单的能力":["80.9"],"它也只应当被用于定义确定的结构体":["80.9"],"而类型别名能够使用除":["80.9"],"以外所有的类型编程语法":["80.9"],"同时":["80.9","81.0","81.8","87.2"],"如果不是为了兼容性考虑":["80.10"],"在仅访问索引的情况下":["80.10"],"我们的确没有必要使用":["80.10"],"foo":["80.11","83.9"],"c":["80.11","82.4","101.60"],"d":["80.11","85.15","107.13","107.19"],"constants":["80.12"],"typings":["80.12"],"值的类型断言能力":["80.13"],"这一规则的本质是检查":["80.13"],"就应当被标记为":["80.14"],"规则":["80.16"],"与默认值一致的泛型参数是没有意义的":["80.18"],"叫":["80.20"],"anyscript":["80.20"],"那么乱写":["80.20"],"这一类干涉代码检查指令的使用本就应该慎之又慎":["80.21"],"在任何情况下都不应该被作为逃生舱门":["80.21"],"因为它真的比":["80.21"],"只要一次非空断言就能移除掉":["80.22"],"时应用一个默认值":["80.23"],"这么结合使用将非常有害":["80.23"],"你的同事看到它会陷入思考":["80.23"],"同时这也意味着":["80.24"],"你对":["80.24"],"类似于不允许默认值一致的泛型":["80.25"],"这条规则的目的也是减少不必要的类型代码":["80.25"],"这也就意味着没必要再多写":["80.26"],"的最重要原因是":["80.29"],"通过使用":["80.29"],"函数值":["80.29"],"的方式定义":["80.29"],"作为值的函数的类型能享受到更严格的类型校验":["80.29"],"strictfunctiontypes":["80.29","86.20"],"somefunc":["80.31"],"或在入参与返回值类型未知的场景下使用":["80.31"],"但它显然是不对的":["80.32"],"而单继承的空接口场景则更常见":["80.32"],"比如可以先确定下继承关系":["80.32"],"我推荐配合":["80.33"],"noimplicitany":["80.33"],"来检查隐式":["80.33"],"的控制流分析能很好地进行类型自动推导":["80.34"],"而对于函数参数与类属性":["80.34"],"允许其进行类型标注则主要是为了确保一致性":["80.34"],"即函数的所有参数":["80.34"],"包括重载的各个声明":["80.34"],"你完全可以直接复制上去":["80.35"],"其次":["80.35"],"显式标注返回值类型也能够通过上下文类型的能力":["80.35"],"即实际":["80.35"],"虽然此规则的配置项允许":["80.37"],"这样的值与":["80.37"],"同时借助":["80.38"],"proposal":["80.38"],"cause":["80.38"],"bool":["80.39"],"exhaustivecheck":["80.39"],"str2":["80.40"],"无论哪种情况都不会是你想看到的":["80.40"],"推荐在规则配置中仅开启":["80.40"],"allownumber":["80.40"],"我们会在工程实践的道路上更进一步":["80.43"],"了解一批基本涵盖了整个":["80.43"],"我们更多是在简单介绍工具的作用与使用场景":["81.0"],"不会有深入的讲解与分析":["81.0"],"本节的内容会持续更新":["81.0"],"的编译过程更明显":["81.2"],"也需要自己执行编译后的文件":["81.2"],"onsuccess":["81.2"],"js":["81.4","99.6","110.5"],"translator":["81.6"],"将":["81.6"],"报错翻译成更接地气的版本":["81.6"],"并且会根据代码所在的上下文来详细说明报错原因":["81.6"],"目前只有英文版本":["81.6"],"并不是我们常见到的":["81.7"],"描述实际值的":["81.7"],"中工具类型的单元测试就是基于它":["81.8"],"conditional":["81.8"],"unicorn":["81.10"],"minlength":["81.10"],"argumenterror":["81.10"],"expected":["81.10"],"be":["81.10","83.10"],"but":["81.10"],"received":["81.10"],"中进行":["81.11"],"的核心差异是零配置":["81.12"],"不需要任何":["81.12"],"配置就能对常见基本所有的样式方案":["81.12"],"语言方案":["81.12"],"框架方案进行打包":["81.12"],"我在之前搭过一个基于":["81.12"],"语法如何使用":["81.13"],"以及未来的":["81.13"],"提案":["82.0"],"要相信":["82.0"],"未来的":["82.0"],"网上很多说法是将":["82.1"],"后的版本统称为":["82.1"],"我不太认同的原因也就在于此":["82.1"],"说了这么多":["82.1"],"想必你现在至少对":["82.1"],"到底是什么":["82.1"],"它们的存在意义以及工作方式等等都有了一个大致了解":["82.1"],"如果你想了解更多历史故事":["82.1"],"我推荐阅读雪碧老师的作品":["82.1"],"二十年":["82.1"],"的关系又是啥":["82.1"],"知道了":["82.1"],"的具体意义就比较好懂了":["82.1"],"上面说到一个新语法从提出到最终成为":["82.1"],"的一部分":["82.1"],"需要走完漫长的":["82.1"],"如果这个语法真的究极无敌好用":["82.1"],"比如我们下面要说的可选链":["82.1"],"空值合并以及装饰器":["82.1"],"实在是等不及想用怎么办":["82.1"],"聪明的你一定会想到":["82.1"],"前两者在":["82.2"],"版本引入":["82.2"],"逻辑赋值则在":["82.2"],"版本被引入":["82.2"],"它们早在":["82.2"],"expr":["82.3"],"对应到":["82.3"],"func":["82.3","96.6"],"在所有情况下":["82.3"],"空值合并就如它的名字一样":["82.4"],"只会对真正意义上的空值":["82.4"],"比如":["82.5","86.15"],"等价于以下这段":["82.5"],"假设":["82.5"],"有可能在多处被初始化":["82.5"],"中的装饰器":["82.6"],"从演进到了解":["82.6"],"从原理到熟悉":["82.6"],"为准":["82.8"],"如果你想了解更多提案":["82.8"],"可以阅读我此前的文章":["82.8"],"聊一聊进行中的tc39提案":["82.8"],"都是成立的":["82.9"],"这一提案自从在":["82.9"],"年":["82.9"],"月会议上进入到":["82.9"],"utf16encoder":["82.10"],"utf16be":["82.10"],"unsupported":["82.10"],"g":["82.12"],"g0":["82.12"],"则分别是它们的异步版本":["82.12"],"即应用对象变成了异步函数":["82.12"],"我个人对于这一提案其实是持支持态度的":["82.13"],"其实就包含类型和新的":["82.13"],"ecmascript":["82.13","90.1"],"语法两个部分":["82.13"],"对应到编译时就是类型擦除和语法降级":["82.13"],"类似":["82.13","86.38"],"babel":["82.13"],"随着浏览器等运行时对":["82.13"],"语法的支持越来越好":["82.13"],"decorator":["83.0"],"factory":["83.0"],"即装饰器工厂的形式":["83.0"],"在这种情况下":["83.0"],"我们会依次介绍这几种装饰器的具体使用":["83.1"],"print":["83.2"],"overridedprint":["83.2"],"overrided":["83.2"],"被覆盖了":["83.2"],"现在是一个空方法":["83.2"],"time":["83.3"],"gettime":["83.3"],"在这个例子中":["83.4"],"后面我们会了解如何基于参数装饰器进行参数的默认值注入与校验":["83.6"],"现在就先到这儿":["83.6"],"实例属性装饰器":["83.7"],"实例方法装饰器":["83.7"],"实例方法参数装饰器":["83.7"],"args":["83.7"],"以上的代码输出是这样的":["83.7"],"执行顺序就不再赘述":["83.7"],"如果一个方法中的多个参数均存在装饰器":["83.8"],"那么同样是":["83.8"],"parma1":["83.8"],"param2":["83.8"],"param1":["83.8"],"后面参数的装饰器逻辑":["83.8"],"反而先执行":["83.8"],"但我们通常不会在同种装饰器中进行存在依赖关系的操作":["83.8"],"中的反射":["83.9"],"散落在各个顶级对象的命名空间下":["83.9"],"因此我们需要":["83.9","89.0"],"来进行一次统一":["83.9"],"比如通过反射来实例化一个类":["83.9"],"普通情况":["83.9"],"基于反射":["83.9"],"而对于属性的校验其实就简单了":["83.10"],"由于对类型的校验逻辑可以归到一起":["83.10"],"我们就使用":["83.10"],"装饰器工厂":["83.10"],"入参":["83.10"],"的形式来注入对应的元数据信息":["83.10"],"这次我们只需要在属性层面注入元数据即可":["83.10"],"enum":["83.10"],"validationmetadatakey":["83.10"],"expectedtype":["83.10"],"然后就是校验逻辑了":["83.10"],"我们需要一个额外的":["83.10"],"validator":["83.10"],"entity":["83.10"],"如果校验完全通过":["83.10"],"那这一方法的返回值则是一个空数组":["83.10"],"否则的话内部会存有报错信息":["83.10"],"首先是对于必填属性的校验":["83.10"],"我们需要取出注册在类上的":["83.10"],"描述必填属性的元数据":["83.10"],"再检查这些必填属性是否都存在了":["83.10"],"clsname":["83.10"],"constructor":["83.10"],"messages":["83.10"],"先检查所有必填属性":["83.10"],"基于反射拿到所有存在的属性":["83.10"],"existkeys":["83.10"],"ownkeys":["83.10"],"includes":["83.10"],"should":["83.10"],"throw":["83.10"],"然后是对属性类型的校验":["83.10"],"我们就会在反射元数据的基础上":["83.11"],"去了解一个新的概念":["83.11"],"的基础上去支持了装饰器语法":["83.13"],"来供":["83.13"],"angular":["83.13","84.1","85.14"],"框架使用":["83.13"],"团队与":["83.13"],"团队在某种契机下达成一致":["83.13"],"决定将装饰器以及相关的注解能力直接引入":["83.13"],"团队不再维护":["83.13"],"你甚至可以":["83.14"],"在方法内部去装饰某一个类或其成":["83.14"],"decorators":["84.0"],"到":["84.1","85.6","90.1"],"不就是我们上面所说的元数据吗":["84.1"],"比如在属性中通过":["84.1"],"装饰器注册一份元数据":["84.1"],"告诉容器这个类的哪些属性需要被注入":["84.1"],"然后容器会在内部存储的类里面对应地进行查找":["84.1"],"在部分前端框架中同样大量使用了基于装饰器的依赖注入体系":["84.1"],"nest":["84.1"],"midwayjs":["84.1"],"等":["84.1","85.6","87.2"],"目前来看在":["84.1"],"框架中的使用要更为常见":["84.1"],"midway":["84.1"],"中基于装饰器实现了路由":["84.1"],"生命周期":["84.1"],"中间件与拦截器等等功能":["84.1"],"举例来说":["84.1","86.13"],"基于装饰器的路由可能是这么写的":["84.1"],"controller":["84.1"],"application":["84.2"],"end":["84.2","96.5"],"stringify":["84.2"],"中新增简单的方法返回":["84.2"],"usercontroller":["84.2"],"servicekey":["84.3"],"检查是否注册":["84.3"],"cons":["84.3"],"if":["84.3","89.5","96.5","101.52"],"实例化这个类":["84.3"],"ins":["84.3"],"遍历注册信息":["84.3"],"info":["84.3"],"注入标识符与要注入类的标识符":["84.3"],"injectkey":["84.3"],"拆分为":["84.3"],"名与属性名":["84.3"],"classkey":["84.3"],"propkey":["84.3"],"split":["84.3"],"如果不是这个类":["84.3"],"就跳过":["84.3"],"png":["84.4","88.1","88.3"],"学习完这一节后":["84.4"],"请你试着把上一部分的装饰器路由体系也基于这个简单的容器重新实现与改善":["84.4"],"如新增对":["84.4"],"service":["84.4","85.14"],"层与中间件层的注入":["84.4"],"如果你也曾对着一堆配置较劲半天":["84.5"],"却没看出个所以然的经历":["84.5"],"这一次可以放心了":["84.5"],"我们将在下面两节全面解析大部分配置":["84.5"],"stringtypepropertydecorator":["84.7"],"onlystringtypeproperty":["84.7"],"比如构建相关又可以分为":["85.0"],"构建源码相关":["85.0"],"构建产物相关":["85.0"],"我们会按照这些分类的方式进行聚合地讲解":["85.0"],"时":["85.5","85.6","89.0"],"指定你的":["85.5"],"从何处导入":["85.5"],"如设置为":["85.5"],"会从":["85.5"],"导入":["85.5","107.52"],"用于进行":["85.5"],"组件的转换":["85.5"],"类似的":["85.5","87.4"],"在另一个类":["85.5"],"框架":["85.5"],"solid":["85.5"],"也将此配置修改为了自己的实现":["85.5"],"中的变化之一":["85.5"],"版本前后的构建后代码如下":["85.5"],"你不需要添加":["85.6"],"中也能使用":["85.6"],"ecmascript2021":["85.6"],"的新方法":["85.6"],"这是因为既然你的编译产物都到这个版本了":["85.6"],"那你当然可以直接使用这个方法啦":["85.6"],"如果你希望使用自己提供的":["85.6"],"声明定义":["85.6"],"可以启用":["85.6"],"这样":["85.6","85.8","85.11"],"将不会去加载内置的类型定义":["85.6"],"但你需要为所有内置对象提供类型定义":["85.6"],"此时专门为需要匹配的文件书写精确的匹配模式就太麻烦了":["85.8"],"我们可以使用":["85.8"],"来从被":["85.8"],"匹配到的文件中再移除一部分":["85.8"],"会自动解析到对应的文件":["85.9"],"如果你显式指定":["85.10"],"需要确保其包含了所有":["85.10"],"被包括":["85.10"],"需要确保这所有的文件都被生成在":["85.10"],"内":["85.10"],"我们应当是在":["85.11"],"文件中直接通过":["85.11"],"的路径来引用":["85.11"],"文件的":["85.11"],"而不是":["85.11"],"此时":["85.11"],"我们就可以利用":["85.11"],"skiplibcheck":["85.12"],"以上配置会尝试加载":["85.12"],"而对于绝对路径导入":["85.13"],"它会按照以下顺序来解析":["85.13"],"项目中":["85.14"],"确保所有文件都使用了一个额外的后缀名":["85.14"],"path":["85.15","89.1","107.80"],"因此需要确保指定了":["85.16"],"在填写别名路径时":["85.16"],"我们可以传入一个数组":["85.16"],"对应的类型报错":["85.17"],"bundle":["85.20"],"选项":["85.20","113.14"],"它会将所有的产物":["85.20"],"其中非模块的文件":["85.20"],"打包为单个文件":["85.20"],"但仅能在":["85.20"],"tsc":["85.22","85.30"],"使用这两个配置意味着你构建的":["85.23"],"包或者代码仅在":["85.23"],"环境下运行":["85.23"],"同时在运行环境中确保":["85.25"],"接口的存在":["85.25"],"如通过":["85.25"],"polyfill":["85.25"],"这样就可以保留":["85.25"],"循环的实现":["85.25"],"启用这一配置只是意味着":["85.25"],"由于它们并不知道这里到底是值导入还是类型导入":["85.26"],"所以此时你必须将类型导入显式标记出来":["85.26"],"animalkind":["85.26"],"或使用两条导入":["85.26"],"当然一般发布":["85.29"],"包时并不会携带这些文件":["85.29"],"但在":["85.29"],"而只使用":["85.30"],"sourceroot":["85.31"],"maproot":["85.31"],"这两个选项通常供":["85.31"],"即被":["85.32"],"jsdoc":["85.32"],"标记为":["85.32"],"推荐的做法是为仅在内部使用而没有导出的变量或方法进行标记":["85.32"],"来减少生成代码的体积":["85.32"],"逻辑检查等":["85.33"],"而工程配置则包括了一系列兼容性与工程能力的配置":["85.33"],"project":["86.0"],"references":["86.0","86.39"],"就不需要太严格检查啦":["86.1"],"对于推荐使用的配置":["86.1"],"defineproperty":["86.3"],"esmodule":["86.3"],"配置的默认值为":["86.4"],"表现为在编译过程中并不会抛出阻止过程的错误":["86.4"],"而只是一个警告":["86.4"],"它也可以配置为":["86.4"],"但却忘记了":["86.5"],"导致这里错误地声明了一个":["86.5"],"类似于":["86.5"],"allowunreachablecode":["86.5"],"这条配置也可使用":["86.5"],"然后这种由于无类型标注导致的隐式":["86.8"],"类型推导就会抛出一个错误":["86.8"],"你仍然可以显式地标记一个类型为":["86.8"],"autherror":["86.9"],"当":["86.11"],"语句执行完毕匹配的那个":["86.11"],"子句后":["86.11"],"如果没有":["86.11"],"derived2":["86.12"],"错误":["86.12"],"这一配置可以确保在存在复杂嵌套路径的函数中":["86.13"],"所有路径最后都显式执行了":["86.13"],"假设我们的函数希望先检查一遍参数":["86.13"],"因为它没有类型注释":["86.14"],"这就是":["86.14","107.44"],"配置所关注的内容":["86.14"],"它确保你在使用":["86.14"],"配置则宽松一些":["86.15"],"它会将一个":["86.15"],"类型附加到对未知属性访问的类型结果上":["86.15"],"这里就不做介绍了":["86.16"],"不能分配给":["86.18"],"的类型":["86.18"],"请考虑将":["86.18"],"添加到目标类型":["86.18"],"use":["86.19","94.2"],"strict":["86.19"],"strictpropertyinitialization":["86.20"],"的参数":["86.21"],"m":["86.22"],"没有对函数参数类型进行逆变检查":["86.22"],"wuhu":["86.23"],"的类型应该是":["86.23"],"init":["86.24"],"此时报错仍然存在":["86.24"],"但我们其实已经确保了有初始值的存在":["86.24"],"这种情况下可以依据实际需要使用非空断言或可选修饰":["86.24"],"指令的声明文件":["86.25"],"如内置的":["86.25"],"util":["86.27"],"其他三个项目的导出函数也只是一个简单函数":["86.27"],"这里就不展示代码了":["86.27"],"现在来执行构建命令":["86.27"],"bash":["86.27","101.9"],"命令下无需也不能使用":["86.27"],"必须通过":["86.28"],"files":["86.28"],"除了这些构建器以外":["86.30"],"配置也适用于使用":["86.30"],"compiler":["86.30","88.5"],"api":["86.30","86.42","88.0","105.0"],"可以对应地使用":["86.33"],"nocheck":["86.33"],"hasownproperty":["86.35"],"call":["86.35"],"它会在目标模块不是":["86.35"],"规范时":["86.35"],"将模块中除了":["86.35"],"属性以外的导出都挂载到返回对象上":["86.35"],"然后将这个对象的":["86.35"],"属性设置为原本的模块信息":["86.35"],"这样你既可以":["86.35"],"访问某个值":["86.35"],"访问原本的模块":["86.35"],"这些辅助方法也属于":["86.35"],"importhelpers":["86.35"],"helper":["86.35"],"因此你也可以通过启用":["86.35"],"配置来从":["86.35"],"tslib":["86.35"],"导入这些辅助方法":["86.35"],"本身是通过":["86.35"],"导出的":["86.35"],"在你使用默认导入时":["86.35"],"也会提醒你此模块只能在启用了":["86.35"],"的情况下使用默认导入":["86.35"],"启用":["86.35"],"配置的同时":["86.35"],"也会启用":["86.35"],"tsbuildinfofile":["86.37"],"配置项来控制这些编译信息文件的输出位置":["86.37"],"不进行具体监听":["86.38"],"而只是在每秒以固定的时间间隔后去检查发生变更的文件":["86.38"],"prioritypollinginterval":["86.38"],"但对某些特殊类型文件的检查频率会降低":["86.38"],"dynamicprioritypolling":["86.38"],"对变更不频繁的文件":["86.38"],"检查频率降低":["86.38"],"field":["86.39"],"lib":["86.39"],"config":["86.41"],"nestjs":["86.42"],"prisma":["86.42"],"开发一个博客":["86.42"],"从项目搭建":["86.42"],"基本语法":["86.42"],"数据库":["86.42","88.1"],"至少使用":["87.0"],"express":["87.0"],"koa":["87.0"],"进行过基本的":["87.0"],"开发":["87.0","107.56"],"以及了解数据库":["87.0"],"关于其他安装方式":["87.1"],"中去启动应用":["87.2"],"在实际开发中":["87.2"],"可能会有多个":["87.2"],"文件来实现对业务逻辑的模块拆分":["87.2"],"upload":["87.2"],"在这个文件内我们会定义属于这一模块的":["87.2"],"别的模块可以通过导入这个模块来使用内部的":["87.2"],"而不是直接导入":["87.2"],"造成模块间的混乱引用":["87.2"],"controllers":["87.2","88.2"],"会被生成到":["87.3"],"modules":["87.3"],"image013d3fbf7ddad47c":["87.3"],"而在实际使用时":["87.3"],"我们就需要导入它并实例化":["87.3"],"prismaclient":["87.3"],"你将体验到":["87.3"],"最大的特色之一":["87.3"],"类型安全":["87.3"],"我们尝试访问以下":["87.3"],"的属性":["87.3"],"image749525dface6a1d2":["87.3"],"每一个实体上的每一种方法都有全面覆盖的类型提示":["87.3"],"而这背后当然是":["87.3"],"命令中由":["87.3"],"所生成的":["87.3"],"类型定义":["87.3"],"你可能会问":["87.3"],"支持也很好":["87.3"],"为什么我单单说":["87.3"],"是类型安全的":["87.3"],"这是因为在这些基于编程的语言中":["87.3"],"类型实际上是我们自己书写的":["87.3"],"由这些定义映射到数据库的过程中并不能保证是安全的":["87.3"],"如在":["87.3"],"一个字段是否可能为空是通过额外的选项":["87.3"],"nullable":["87.3"],"的方式来声明的":["87.3"],"tag":["87.4","93.9","93.10"],"category":["87.4"],"直接在代码中使用这些类型":["87.4"],"create":["87.4"],"createinput":["87.4"],"毕竟兴趣才是我们最好的老师":["87.5"],"相比于开发部分":["87.5"],"我们对部署部分的介绍要更加详细":["87.5"],"因为我们将使用":["87.5"],"此时我们的":["87.7"],"实体类不能够自己进行数据库操作":["87.8"],"而是需要先获取到一个对应到表的":["87.8"],"仓库":["87.8"],"然后再调用这个":["87.8"],"上的方法":["87.8"],"这一模式同样由":["87.8"],"fowler":["87.8"],"前辈最初命名":["87.8"],"就像是一层拦在操作者与实际数据之间的访问层":["87.8"],"就如上面例子中":["87.8"],"需要先获取具有访问权限":["87.8"],"即相应方法":["87.8"],"的对象":["87.8"],"再进行数据的操作":["87.8"],"对这两个模式进行比较":["87.8"],"很容易发现":["87.8"],"模式要更加简单":["87.8"],"适用于较简单的应用":["87.8"],"可以减少很多代码":["87.8"],"以外":["87.9"],"中使用较多的":["87.9"],"还包括":["87.9"],"knex":["87.9"],"kysely":["87.9"],"接下来我们需要申请一个可用的数据库":["88.1"],"监控":["88.1"],"负载均衡":["88.1"],"redis":["88.1"],"等功能在":["88.1"],"上被称为":["88.1"],"add":["88.1","94.1"],"你可以访问":["88.1"],"市场":["88.1"],"查看更多":["88.1"],"在这里我们直奔":["88.1"],"image380be9c6e463109c":["88.1"],"link":["88.1"],"juejin":["88.1"],"cn":["88.1","97.7"],"prismamodule":["88.2"],"data":["88.2","107.82"],"imports":["88.2"],"构建以及启动过程":["88.3"],"imagef0c3c4a1ded5150f":["88.3"],"imagea22f61b473e93e2c":["88.3"],"你会发现":["88.3","107.44"],"似乎缺少了应用程序启动的日志":["88.3"],"这时候就需要使用另一个命令了":["88.3"],"logs":["88.3"],"tail":["88.3"],"命令用于展示这个应用运行过程中的日志":["88.3"],"的系统日志与我们的应用程序日志":["88.3"],"参数意为仅展示最新的一部分日志":["88.3"],"articlecontroller":["88.4"],"post":["88.4","113.14"],"body":["88.4"],"声明了此接口需要通过":["88.4"],"方法访问":["88.4"],"而通过":["88.4"],"装饰器我们将请求携带的":["88.4"],"数据注入":["88.4"],"req":["88.4"],"然后直接传给对应的":["88.4"],"对于查询接口":["88.4"],"我们通常使用":["88.4"],"get":["88.4","89.1"],"以及使用":["88.4"],"来传参":["88.4"],"两种常见方式":["88.4"],"query":["88.4"],"下一节也就是最后一节":["88.5"],"我们会来了解":["88.5"],"降级为":["89.0"],"循环":["89.0"],"想使用装饰器等语法":["89.0"],"就需要这些插件来支持":["89.0"],"这些插件其实就是遍历":["89.0"],"对目标的":["89.0"],"结点注册处理逻辑":["89.0"],"一般来说一个插件只会关注一种特定的语法":["89.0"],"每个浏览器支持的语法版本都是差异巨大的":["89.0"],"preset":["89.0"],"自动地基于浏览器版本去确定需要使用的插件":["89.0"],"除了依赖":["89.0"],"options":["89.1"],"assertversion":["89.1"],"pre":["89.1"],"file":["89.1","107.80"],"set":["89.1"],"errors":["89.1"],"assignmentexpression":["89.1"],"assigntarget":["89.1"],"left":["89.1","97.6","97.15"],"binding":["89.1"],"scope":["89.1"],"getbinding":["89.1"],"isfunctiondeclaration":["89.1"],"isfunctionexpression":["89.1"],"stacktracelimit":["89.1"],"sdl":["89.2"],"以及其对应的":["89.2"],"parser":["89.2"],"explorer":["89.2"],"它们的功能是类似的":["89.2"],"但":["89.2"],"目前并不支持使用":["89.2"],"来解析":["89.2"],"有了":["89.2"],"我们的操作流程就会变得非常流畅了":["89.2"],"首先一级级向下找到目标":["89.2"],"这一步我们可以使用":["89.2"],"getfirstchildbykind":["89.2"],"方法来获取一个":["89.2"],"结点内我们需要的子结点":["89.2"],"bykind":["89.2"],"kind":["89.2"],"指的是":["89.2"],"它需要对源码进行新增":["89.3"],"更新以及删除等等操作":["89.3"],"接下来我们会使用":["89.3"],"来实现数个示例":["89.3"],"它们没有什么难度":["89.3"],"毕竟我们的目的在于熟悉":["89.3"],"分析":["89.3"],"定位":["89.3"],"处理":["89.3"],"检查是否是要被替换的模块":["89.4"],"找到要被替换的导入声明":["89.4"],"replacementmatch":["89.4"],"收集原本的具名导入":["89.4"],"namedimports":["89.4"],"getnamedimports":["89.4"],"替换为新的具名导入":["89.4"],"gettext":["89.4"],"移除原本的导入":["89.4"],"增加新的导入":["89.4"],"addimportdeclaration":["89.4"],"getname":["89.5","89.7","89.8"],"拿到目标方法声明":["89.5"],"methoddeclaration":["89.5"],"getmethod":["89.5"],"adddecorator":["89.5"],"arguments":["89.5","96.16"],"我们主要使用了这么几个":["89.5"],"获取一个":["89.6"],"结点下首个目标类型的子结点":["89.6"],"在上面我们都是直接使用":["89.6"],"getclasses":["89.6"],"形式获取目标类型":["89.6"],"而这里则是另外一种方式":["89.6"],"即意味着拿到源码中的第一个导出语句":["89.6"],"使用这种方式必须首先拿到":["89.6"],"类型的子结点":["89.6"],"length":["89.7"],"再次遍历此方法":["89.7"],"objecttype":["89.7"],"使用联合类型":["89.7"],"数组作为此属性的类型":["89.7"],"join":["89.7"],"continue":["89.7"],"再次遍历":["89.7"],"nestedstruct":["89.7"],"unknown":["89.8"],"red":["89.8","97.20"],"yellow":["89.8"],"expired":["89.8"],"white":["89.8"],"使用效果是这样的":["89.8"],"扩展":["89.8"],"上面的例子只能基于硬编码的日期进行处理":["89.8"],"而另外一种可能的情况是基于版本来做检查":["89.8"],"比如某一部分代码应该在":["89.8"],"version":["89.8","93.6"],"检查":["89.9"],"确定目标":["89.9"],"执行操作以及保存":["89.9"],"就能完成一次处理":["89.9"],"规则的维度通常更高":["89.11"],"比如我要求团队内的所有代码库都必须遵守一系列规则":["89.11"],"我也尽可能进行了内容的优化与调整":["90.0"],"无论评价是正面还是负面":["90.0"],"其实都代表读者认真地阅读了内容":["90.0"],"的篇幅来学习工程侧的应用":["90.1"],"从":["90.1"],"从装饰器":["90.1"],"依赖注入到":["90.1"],"全解":["90.1"],"再从":["90.1"],"字以内":["90.2"],"你应该把它当小说":["90.2"],"而不是当论文看":["90.2"],"先阅读冴羽老师的":["90.3"],"入门教程":["90.3"],"完成筑基阶段的积累":["90.3"],"本节不会包含过于基础的内容":["91.0"],"因此这里我们放在第一个知识点来讲解":["91.1"],"那样表达元组":["91.2"],"一组联合类型等等":["91.2"],"你也可以提到在官方的":["91.3"],"wiki":["91.3"],"而了解这部分规则也就意味着你至少能够独立解决相当一部分类型报错":["91.4"],"top":["91.5","97.11","97.15"],"不妨扩展地讲一讲":["91.6"],"属于相对少见的考察":["91.7"],"因此通常也不会要求过高":["91.7"],"作为":["91.8","107.80"],"bottom":["91.8","97.11"],"条件类型":["91.9"],"带来的底层规则还不止表现在类型兼容性方面":["91.9"],"这里就不再赘述":["91.11"],"结构处理工具类型":["91.12"],"集合工具类型与模式匹配工具类型等等":["91.12"],"复杂的类型编程以及装饰器等知识":["91.13"],"这些内容同样在小册中有所体现":["91.13"],"alwaysshow":["92.0"],"title":["92.0"],"docs":["93.0"],"vue插件":["93.0"],"字段是插件的全局变量名":["93.3"],"通常挂载在":["93.3"],"window":["93.3","96.13"],"因此名字可以到":["93.3"],"moment":["93.4"],"dayjs":["93.4"],"axios":["93.4"],"development":["93.8"],"htmltagdescriptor":["93.9","93.10"],"可以指定从":["93.11"],"地址上加载多个样式表":["93.11"],"produrl":["93.11"],"libs":["93.12"],"somestate":["94.3","94.4","94.6"],"usestore":["94.4"],"main":["94.4","107.83","107.84","107.87","107.89","107.90","107.91","107.93","107.100","107.103","107.107","107.110","107.118","107.121","107.123","107.128"],"将被持久化存储在":["94.5"],"你好":["94.6","107.82"],"persist":["94.6"],"只有":["94.7"],"该":["94.8"],"将使用":["94.8"],"将会在恢复数据":["94.9","94.10"],"之前":["94.9"],"输出":["94.9","94.10","101.10"],"之后":["94.10"],"command":["95.2"],"plugins":["95.2"],"指定要缓存的文件夹":["95.2"],"href":["95.3"],"symbolid":["95.3"],"globally":["95.4"],"app":["95.5"],"存储的是地址":["96.1"],"多个引用指向同一个地址":["96.1"],"这里会涉及一个":["96.1"],"先进行typeof判断":["96.2"],"如果是基础数据类型":["96.2"],"对于typeofi返回结果是object的":["96.2"],"再进行如下的判断":["96.2"],"正则返回结果":["96.2"],"注意正则中间有个空格":["96.2"],"代码验证":["96.2"],"需要注意大小写":["96.2"],"哪些是typeof判断":["96.2"],"哪些是tostring判断":["96.2"],"思考下":["96.2"],"是object":["96.2"],"因此tostring返回":["96.2"],"则默认调用对象的转换方法会存在优先级":["96.3"],"然后再进行拼接":["96.3"],"如果其中有一个是数字":["96.3"],"布尔值或者数字":["96.3"],"则会将其转换成数字进行加法运算":["96.3"],"对象的情况还是参照上一条规则":["96.3"],"如果其中一个是字符串":["96.3"],"一个是数字":["96.3"],"则按照字符规则进行拼接":["96.3"],"常规情况":["96.3"],"下面看一下特殊情况":["96.3"],"lundefined":["96.3"],"规则1":["96.3"],"undefined转换字符串":["96.3"],"1null":["96.3"],"null转换字符串":["96.3"],"1true":["96.3"],"true转换字符串":["96.3"],"1n":["96.3"],"begin":["96.5"],"手动实现一个浅拷贝":["96.5"],"对基础类型做一个最基本的一个拷贝":["96.5"],"对引用类型开辟一个新的存储":["96.5"],"并且拷贝一层对象属性":["96.5"],"shallowclone":["96.5"],"clonetarget":["96.5"],"下面是验证代码":["96.6"],"num":["96.6"],"unf":["96.6"],"nul":["96.6"],"我是一个对象":["96.6"],"我是一个函数":["96.6"],"reg":["96.6"],"我是一个正则":["96.6"],"ig":["96.6"],"child6":["96.8"],"child5":["96.8"],"person6":["96.8"],"20240117094338932":["96.8"],"七":["96.8"],"关键字实现逻辑":["96.8"],"使用关键词很容易直接实现":["96.8"],"共同点":["96.9"],"改变函数":["96.9"],"指向":["96.9"],"不同点":["96.9"],"直接返回执行结果":["96.9"],"返回的是一个函数":["96.9"],"特征":["96.9"],"方法参数":["96.9"],"多个":["96.9"],"函数内部变量是无法被外部访问的":["96.11"],"因此使用闭包的作用":["96.11"],"闭包产生的本质就是当前环境中存在指向父级作用域的引用":["96.12"],"创建了闭包":["96.13"],"保存了全局作用域":["96.13"],"对象或者值转换为":["96.14"],"第一个参数传入的是要转换的对象":["96.14"],"第二个参数是一个":["96.14"],"index":["96.16"],"reduceright":["96.18"],"entries":["96.18"],"infinity":["96.19"],"表示一直展开":["96.19"],"正则和":["96.19"],"方法共同处理":["96.19"],"空间复杂度":["96.21"],"对一个算法在运行过程中临时占用存储空间大小的度量":["96.21"],"但表现比选择排序好很多":["96.23"],"代价是需要额外的内存空间":["96.23"],"mergesort":["96.23"],"merge":["96.23"],"il":["96.23"],"ir":["96.23"],"mid":["96.23"],"采用三路快速排序":["96.24"],"是一个死值":["97.2"],"height":["97.3"],"align":["97.3"],"background":["97.3"],"css不可继承属性":["97.3"],"伪元素选择器":["97.4"],"0001":["97.4"],"第五":["97.4"],"absolute":["97.6"],"cssref":["97.7"],"pr":["97.7"],"的值为":["97.8"],"inline":["97.8"],"table":["97.8"],"cell":["97.8"],"display":["97.9"],"也好":["97.10"],"方便一点":["97.10"],"right":["97.11"],"最终只有":["97.11"],"r":["97.12"],"右":["97.12"],"jonathan":["97.13"],"neal":["97.13"],"维护的一个":["97.13"],"缺点":["97.14"],"维护比较差":["97.14"],"例如图片位置进行调整或者内容宽高修改":["97.14"],"显示隐藏元素":["97.15"],"产生重绘的情况":["97.15"],"取值":["97.16"],"继承的区别":["97.16"],"在元素之后":["97.17"],"清除浮动":["97.17"],"scale":["97.18"],"元素的":["97.19"],"color":["97.20","107.50","107.98"],"700px":["97.21"],"宽度":["97.22"],"设计图":["97.22"],"就是":["97.22"],"把某元素转化成行内块元素":["99.1"],"可以设置宽高":["99.1"],"加载顺序有区别":["99.2"],"浏览器先加载标签":["99.2"],"用来作文字倾斜的":["99.3"],"是一个逻辑标签":["99.3"],"用来强调文字内容的":["99.3"],"只是一个倾斜的标签":["99.3"],"没有实际含义":["99.3"],"为了增加":["99.4"],"效果要加入":["99.4"],"webp":["99.5"],"同时支持有损和无损压缩":["99.5"],"相同质量的图片":["99.5"],"可以通过":["99.6"],"html5shiv":["99.6"],"off":["100.1"],"解析是同步的":["101.1"],"一起的":["101.1"],"不是按顺次执行":["101.1"],"空对象指针":["101.3"],"转为数值为":["101.3"],"并不显式地出现在代码中":["101.4"],"除了比较值":["101.4"],"流程":["101.5"],"同步":["101.5"],"优先级":["101.6"],"声明变量":["101.6"],"声明普通函数":["101.6"],"普通声明函数是不看写函数的顺序的":["101.7"],"bas":["101.10"],"现在对象本身找":["101.11"],"构造函数中找":["101.11"],"对象原型中找":["101.11"],"因为key":["101.14"],"为对象时":["101.14"],"都会被转成":["101.14"],"输出结果":["101.16","101.17","101.19"],"funca":["101.18"],"array":["101.22","101.23","101.25"],"indexof":["101.23","101.25"],"替换":["101.28"],"返回":["101.28"],"删除的元素":["101.28"],"math":["101.33"],"max":["101.33"],"最多的字符是":["101.35"],"次数是":["101.35"],"对构造函数有返回值的处理判断":["101.36"],"onclick":["101.39","101.50","107.65"],"就是把原型串联起来":["101.41"],"bind":["101.48","103.12"],"存储大小的限制":["101.53"],"存储量不能超过":["101.53"],"4k":["101.53"],"声明的常量不能被再次赋值":["101.55"],"区别四":["101.55"],"声明的变量没有自身的作用域":["101.55"],"不报错":["101.59"],"箭头函数没有":["101.64"],"已失败":["101.65"],"每一个匹配到的都返回":["101.66"],"全部匹配才会返回":["101.67"],"那么我们的业务是父组件引入子组件":["103.2"],"并且优先加载子组件的数据":["103.2"],"那么在父组件中的请求要放":["103.2"],"中有":["103.3"],"中可以拿到":["103.3"],"的方法的":["103.3"],"系统内置的":["103.4"],"mounted":["103.5","103.7"],"created":["103.6","103.8"],"beforemount":["103.6","103.8"],"beforecreated":["103.8"],"关闭页面":["103.9"],"记录视频播放的时间":["103.9"],"parent":["103.11"],"使用父组件的数据":["103.11"],"resolve":["103.15"],"blog":["105.0"],"examples":["105.0"],"provided":["106.0"],"by":["106.0"],"markdown":["106.3"],"extensions":["106.3"],"配置安装选项":["107.2"],"勾选第一项创建桌面快捷方式即可":["107.2"],"install":["107.2"],"finish":["107.3"],"完成配置":["107.3"],"完成配置后":["107.3"],"可根据喜好调整deveco":["107.3"],"studio主题风格":["107.3"],"configure":["107.3"],"下的":["107.3"],"ide":["107.4","107.6"],"界面说明":["107.4"],"项目结构概述":["107.4"],"下面逐一演示":["107.5"],"右侧的":["107.6"],"perviewer":["107.6"],"若想将项目运行到模拟器":["107.7"],"首先需要启动模拟器":["107.7"],"点击下图中的启动按钮":["107.7"],"稍等片刻":["107.7"],"等待模拟器开机":["107.7"],"开机后的模拟器如下图所示":["107.7"],"回到":["107.7"],"open":["107.8"],"signing":["107.8"],"configs":["107.8"],"进行配置即可":["107.8"],"生成签名信息需要先登陆华为开发者账号":["107.8"],"sign":["107.8"],"in":["107.8"],"浏览器会自动跳转到登录页面":["107.8"],"本身也是由另一门语言":["107.9"],"zh":["107.12"],"play":["107.12"],"程序并运行了":["107.13"],"具体操作如下":["107.13"],"首先在合适的位置创建一个工程目录":["107.13"],"例如":["107.13","107.80","107.105"],"workspace":["107.13"],"然后使用vscode打开目录":["107.13"],"之后创建":["107.13"],"isdone":["107.21"],"person":["107.23","107.34"],"通过类可以创建多个具有相似结构和行为的对象":["107.34"],"例如定义一个":["107.34"],"其对象可以有":["107.34"],"am":["107.36"],"便可通过对象调用类中声明的方法":["107.37"],"如下":["107.37"],"intro":["107.37"],"使用静态成员":["107.38"],"静态成员无需通过对象实例访问":["107.38"],"直接通过类本身访问即可":["107.38"],"类的继承需要使用关键字":["107.39"],"子类构造器中需使用":["107.39"],"说明":["107.40"],"修饰的属性或方法是私有的":["107.40"],"只能在声明它的类中的被访问":["107.40"],"修饰的属性或方法是受保护的":["107.40"],"只能在声明它的类和其子类中被访问":["107.40"],"去遵守":["107.42"],"确保类实现某些特定的行为或功能":["107.42"],"同样是":["107.44"],"类型的两个对象":["107.44"],"调用同一个":["107.44"],"方法时":["107.44"],"表现出了不同的行为":["107.44"],"这个接口":["107.45"],"implements":["107.45"],"夏":["107.48"],"秋":["107.48"],"冬":["107.48"],"向下移动":["107.49"],"通过为枚举属性赋值":["107.50"],"可以赋予枚举属性一些更有意义的信息":["107.50"],"例如以下枚举":["107.50"],"为了在一个模块中使用其他模块的内容":["107.52"],"必须对这些内容进行":["107.52"],"modulea":["107.53"],"还可以将某个模块的内容统一导入到一个":["107.54"],"模块对象":["107.54"],"这样就能简洁有效的解决命名冲突的问题了":["107.54"],"具体语法如下":["107.54"],"所以默认导出支持匿名内容":["107.55"],"比如匿名函数":["107.55"],"相关的能力":["107.56"],"假如现在要实现如下界面":["107.57"],"ison":["107.58"],"具体逻辑如下图所示":["107.59"],"当用于点击":["107.60"],"关灯按钮":["107.60"],"状态数据驱动界面更新":["107.61"],"开发者只需修改状态变量的值":["107.61"],"界面就会自动更新":["107.61"],"还支持自定义组件":["107.62"],"让开发者可根据具体需求自定义组件中的内容":["107.62"],"button":["107.65","111.12","121.3"],"关灯":["107.65"],"开灯":["107.65"],"除去每个组件的专有属性":["107.67"],"还有各组件都能配置的通用属性":["107.67"],"通用属性也可通过":["107.67"],"文档查看":["107.67"],"事件方法":["107.67"],"事件方法用于为组件绑定交互事件":["107.67"],"各组件的支持的事件可查看":["107.67"],"可使代码的结构更加清晰":["107.68"],"并且能提高代码的复用性":["107.68"],"那":["107.69"],"的作用又是啥呢":["107.69"],"在鸿蒙应用中":["107.69"],"每个页面都是由一些列组件组合而成的":["107.69"],"并且这些组件都是逐层嵌套的":["107.69"],"因此这些组件最终形成了一个组件树的结构":["107.69"],"helloworld":["107.70","107.73","107.76"],"custom":["107.70","107.139","111.13"],"solution":["107.70","107.73","107.76","107.130","107.133","107.139"],"pages":["107.73","107.83","107.84","107.87","107.89","107.91","107.92","107.93","107.99","107.100","107.107","107.110","107.118","107.124"],"condition":["107.73"],"初次渲染时":["107.77"],"每个元素对应的key依次为":["107.77"],"zhagnsan":["107.77"],"若现有一个操作是向":["107.77"],"数组头部插入新的元素":["107.77"],"例如新元素为wanger":["107.77"],"按照默认的key生成逻辑":["107.77"],"插入新元素之后每个元素的key就会依次变为":["107.77"],"wanger":["107.77"],"用于在应用中显示图片":["107.79"],"因此可以直接将":["107.80"],"组件的参数":["107.80"],"to":["107.80"],"your":["107.80"],"文件的路径为相对于":["107.80"],"的路径":["107.80"],"例如上图中的icon":["107.80"],"greeting":["107.82"],"integer":["107.82"],"我们可以通过":["107.82"],"引用相应的":["107.82"],"具体语法为":["107.82"],"demos":["107.83","107.87","107.89","107.90","107.91","107.96","107.103","107.121","107.123","107.128"],"entry":["107.83","107.87","107.89","107.90","107.91","107.96","107.103","107.107","107.118","107.121","107.123","107.128"],"src":["107.83","107.84","107.87","107.89","107.90","107.91","107.103","107.107","107.118","107.121","107.123","107.128"],"ets":["107.83","107.84","107.87","107.89","107.90","107.91","107.92","107.93","107.100","107.103","107.107","107.110","107.118","107.121","107.123"],"component":["107.83","107.84","107.89","107.91","107.92","107.93","107.99","107.100","107.106","107.107","107.110","107.115","107.118","107.124"],"用于显示文字内容":["107.86"],"相关案例见":["107.87","107.90","107.91","107.96","107.103","107.121","107.123","107.128"],"例如例如":["107.90"],"attribute":["107.92","107.93","107.99","107.106","107.115","107.124"],"通常用于响应用户的点击操作":["107.95"],"参数了":["107.96"],"具体如下":["107.96"],"状态下的背景色":["107.105"],"用于接收用户输入的文本内容":["107.109"],"password":["107.112"],"密码输入模式":["107.112"],"效果如下":["107.113"],"字体粗细等":["107.114"],"用于设置字体颜色":["107.114"],"用于显示各种进度":["107.120"],"胶囊样式":["107.121"],"progress":["107.124"],"除此之外还支持自定义弹窗":["107.125"],"来满足各种不同的需求":["107.125"],"具体效果如下":["107.127"],"属性用于设置提示信息到底部的距离":["107.128"],"dialog":["107.130","107.133","107.139"],"显示警告对话框":["107.131"],"具体用法可参考相关案例或者官方文档":["107.131","107.134"],"显示操作列表弹窗":["107.134"],"uc3dbfab7":["107.136"],"timepickerdialog":["107.137"],"时间滑动选择器弹窗":["107.137"],"view":["109.1"],"什么是模块":["109.1"],"的值链接到动态的组件状态":["110.3"],"scoped":["110.7"],"也可以将其内的":["110.7"],"msg":["111.1"],"emit":["111.13"],"click":["111.13","121.3"],"reset":["112.5"],"清空":["112.5"],"你需要指明":["113.14"],"可以停止监听":["113.25"],"operations":["113.29"],"ipttext":["114.2"],"所有":["114.6"],"quickly":["114.11","114.12"],"toggletab":["114.14","114.15"],"onctrlclick":["115.4"],"添加按键修饰符让没有任何系统修饰符被按下的时候才触发":["115.4"],"exact":["115.5"],"onclick2":["115.5"],"组合":["121.0"],"不便于维护和复用":["121.1"],"年龄":["121.3"],"changename":["121.3"],"修改姓名":["121.3"],"张三":["121.4"],"来说":["121.4"],"注意点":["121.5"],"定义的响应式数据是":["121.5"],"内部其实也是调用了":["121.6"],"reactive":["121.6"],"去整体替换":["121.7"],"使用原则":["121.7"],"若需要一个基本类型的响应式数据":["121.7"],"必须使用":["121.7"],"若需要一个响应式对象":["121.7"],"changeage":["121.8"],"修改年龄":["121.8"]},{"0":["0.90","36.3","58.90","75.2","79.6"],"1":["0.20","58.20","62.4","65.2","68.6","75.5","89.8","101.13"],"2":["0.20","25.0","58.20","62.4","65.2","71.5","82.8","85.17","107.8"],"3":["0.20","58.20","62.4","65.2","71.4","82.8","103.11","121.7"],"4":["0.20","31.0","58.20","71.4","85.6","96.24"],"5":["0.84","58.84"],"6":["0.31","58.31","85.6"],"7":["0.24","58.24"],"9":["0.80","55.1","58.80","67.2"],"10":["55.1","71.5","86.22","101.57"],"11":["55.1","101.19"],"12":["107.50"],"16":["87.3","107.50"],"17":["71.1"],"18":["84.2"],"20":["88.4","96.8","107.50"],"24":["107.50"],"26":["0.66","58.66"],"28":["84.2"],"29":["0.14","58.14"],"36":["0.15","58.15"],"43":["69.9"],"44":["69.9"],"46":["69.9"],"47":["69.9"],"48":["69.9"],"75":["97.18"],"100":["107.65"],"200":["96.24","107.16"],"215":["96.24"],"375":["97.22"],"760":["101.51"],"908":["0.34","58.34"],"1000":["107.45"],"2021":["82.2"],"3000":["34.2","87.2","88.2"],"3003":["83.3"],"5000":["87.3"],"10000":["62.6","84.2"],"10001":["62.6"],"50000":["62.6"],"31250000":["0.31","0.34","58.31","58.34"],"是一个完全有效的函数名":["0.2","58.2"],"不能作为标识符":["0.3","58.3"],"这是多行注释":["0.4","58.4"],"函数体":["0.5","58.5"],"if":["0.7","58.7","70.1"],"throw":["0.7","58.7","80.39"],"delete":["0.7","58.7"],"及更晚的版本中使用":["0.12","58.12"],"变量会保存一个特殊值":["0.13","58.13"],"undefined":["0.13","0.18","0.73","36.3","58.13","58.18","58.73","71.6","86.5","96.16"],"found":["0.14","58.14"],"false":["0.14","54.1","58.14","62.4","80.37","86.4","86.5","86.21","96.6","101.19","107.60"],"age":["0.14","58.14","84.2","96.8"],"不能定义名为":["0.14","58.14"],"eval":["0.14","58.14","96.9"],"和":["0.14","0.21","0.26","0.65","18.1","58.14","58.21","58.26","58.65","64.4","66.2"],"arguments":["0.14","58.14","101.64"],"的变量":["0.14","58.14"],"否则会导致语法错误":["0.14","0.35","58.14","58.35"],"syntaxerror":["0.16","58.16"],"标识符已经声明过了":["0.16","58.16"],"dead":["0.17","58.17"],"zone":["0.17","58.17"],"在此阶段引用任何后面才声明的变量都会抛出":["0.17","58.17"],"但是可以用在":["0.21","58.21"],"in":["0.21","58.21","77.3","96.5"],"of":["0.21","58.21","80.3"],"中":["0.21","28.1","58.21","63.6","64.2","67.2","75.8","86.35","94.5","101.40","103.2"],"因为每次迭代只是创建一个新的变量":["0.21","58.21"],"symbol":["0.24","58.24","65.2","66.2"],"表示值为符号":["0.24","58.24"],"始终返回":["0.26","58.26"],"但要注意":["0.26","58.26"],"这个操作符会为了比较而转换它的操作数":["0.26","58.26"],"及其他大小混写形式":["0.27","58.27"],"是有效的标识符":["0.27","58.27"],"但不是布尔值":["0.27","58.27"],"不存在":["0.28","58.28"],"f":["0.30","58.30","101.17"],"十六进制数字中的字母大小写均可":["0.30","58.30"],"125e7":["0.31","0.34","58.31","58.34"],"等于":["0.31","58.31"],"会将小数点后至少包含":["0.31","58.31"],"个零的浮点值转换为科学计数法":["0.31","58.31"],"positive":["0.32","58.32"],"也可以获取正":["0.32","58.32"],"负":["0.32","58.32"],"这两个属性包含的值分别就是":["0.32","58.32"],"blue":["0.33","58.33","107.50"],"不可以转换为数值":["0.33","58.33"],"可以转换为数值1":["0.33","58.33"],"00":["0.34","58.34"],"0908":["0.34","58.34"],"x03a3":["0.36","58.36"],"表示希腊字符":["0.36","58.36"],"console":["0.44","58.44","63.11","67.5","89.4","89.7","101.31","101.32","101.33","107.43"],"log":["0.44","58.44","63.11","67.5","89.4","89.7","101.31","101.32","101.33","101.63","107.43"],"bar":["0.45","58.45","89.1"],"的实例":["0.47","58.47"],"所有内置符号属性都是不可写":["0.47","58.47"],"不可枚举":["0.47","58.47"],"不可配置的":["0.47","58.47"],"数值或布尔值表示":["0.60","58.60"],"通常与":["0.60","58.60"],"的返回值相同":["0.60","58.60"],"则调用":["0.63","0.82","58.63","58.82"],"tostring":["0.63","0.83","58.63","58.83"],"并再次应用其他规则":["0.63","58.63"],"变量类型从对象变成数值":["0.63","58.63"],"nan":["0.65","58.65","101.3"],"infinity":["0.65","34.2","58.65"],"会被当成":["0.65","58.65"],"处理":["0.65","58.65","75.1","77.2"],"所以右移之后结果变":["0.71","58.71"],"得非常之大":["0.71","58.71"],"对逻辑与操作符来说":["0.74","58.74"],"如果第一个操作数是":["0.74","58.74"],"那么无论第二个操作数是什么值":["0.74","58.74"],"结果也不可能等于":["0.74","58.74"],"同样与逻辑与类似":["0.75","58.75"],"逻辑或操作符也具有短路的特性":["0.75","58.75"],"只不过对逻辑或而言":["0.75","58.75"],"第一个操作数求值为":["0.75","58.75"],"第二个操作数就不会再被求值了":["0.75","58.75"],"如果有不是数值的操作数":["0.77","0.78","58.77","58.78"],"则先在后台用":["0.77","0.78","0.79","58.77","58.78","58.79"],"number":["0.77","0.78","0.79","58.77","58.78","58.79","79.6","80.6","107.17","107.112"],"将其转换为数值":["0.77","58.77"],"然后再应用上述规则":["0.77","0.78","0.79","58.77","58.78","58.79"],"函数将其转换为数值":["0.78","0.79","58.78","58.79"],"null":["0.82","58.82","71.6","101.41"],"string":["0.82","58.82","76.0"],"函数":["0.82","58.82","82.12","121.6"],"分别获取":["0.82","58.82"],"如果对象没有":["0.83","58.83"],"方法":["0.83","58.83","84.1","86.30","89.8","103.3"],"然后再将得到的字符串转换为数值":["0.83","58.83"],"如果有任一操作数是布尔值":["0.84","58.84"],"则将其转换为数值再执行比较":["0.84","58.84"],"num的值为0":["0.90","58.90"],"return":["1.1","25.0","65.1","80.35","85.5","89.7","96.5","96.16","101.52"],"viewmodel":["1.2"],"的缩写":["1.2"],"这个变量表示":["1.2"],"实例":["1.2"],"com":["1.3"],"不需要运行的时候进行编译":["1.4"],"只重新渲染变化的组件":["1.5","4.0"],"是在前端动态生成的":["2.1"],"在服务端处理好并返回的是":["2.1"],"html":["2.2"],"需要再次请求首屏数据":["2.2"],"白屏时间长":["2.2"],"后续交互采用客户端渲染的方式":["2.3"],"nuxtjs":["2.3"],"的操作":["3.1"],"虚拟":["3.1"],"不依赖真实平台环境从而也可以实现跨平台":["3.1"],"高效更新视图":["3.3"],"产生过多也会造成性能浪费":["4.1"],"算法":["5.0"],"组件级watcher":["5.0"],"proxy":["6.1"],"map":["6.2","83.7"],"这些数据结构不支持":["6.2"],"reactive":["6.3","47.4"],"数组中如果是对象数据类型也会进行递归劫持":["7.1"],"image":["8.1","19.2","20.2","81.6","96.6","96.16","107.83"],"png":["8.1","78.5","81.6","107.80"],"trigger":["8.2"],"通知视图更新":["9.0"],"dep":["9.0"],"notify":["9.0"],"当我们选择新增属性时":["9.0"],"可以考虑使用对象合并的方式实现":["9.0"],"this":["9.0","31.2","36.4","68.1","101.50","103.4"],"info":["9.0"],"newproperty1":["9.0"],"newproperty2":["9.0"],"he":["9.0"],"defineproperty":["12.1","96.6"],"实现的":["12.1"],"内部会调用":["13.0"],"newval":["13.0"],"oldval":["13.0"],"vue3中的模板转换":["14.0"],"做了更多的优化操作":["14.0"],"vue2":["14.0"],"仅仅是标记了静态节点而已":["14.0"],"更新的时候采用虚拟":["15.0"],"dom":["15.0"],"的方式进行":["15.0"],"diff":["15.0"],"算法更新":["15.0"],"实例生命周期":["15.0"],"优先级高于":["17.0"],"所有的子实例也会被销毁":["18.1"],"该钩子在服务器端渲染期间不被调用":["18.1"],"keep":["18.1"],"alive":["18.1"],"activated":["18.1"],"deactivated":["18.1"],"中新增了组合式":["18.2"],"api":["18.2","59.3","74.1","89.0","89.5","89.7","90.1"],"生命周期钩子":["18.2"],"但是不存在":["18.2"],"onbeforecreate":["18.2"],"oncreated":["18.2"],"钩子":["18.2"],"双指针的方式进行比较":["19.1"],"优化":["19.2"],"20240314160716656":["19.2"],"20240314160803893":["19.2"],"元素来匹配数据项的顺序":["20.1"],"而是就地更新每个元素":["20.1"],"并且确保他们在每个索引位置正确渲染":["20.1"],"20240314161812712":["20.2"],"了":["21.1","24.0","75.1","78.6","79.3","80.7","80.20","80.26"],"上实现":["21.2"],"push":["21.3","88.4","96.6"],"缓存插件":["21.3"],"point":["22.1"],"jw":["23.0"],"所以在性能上没有可优势":["24.0"],"parsefloat":["25.0"],"tofixed":["25.0"],"这可以用于优化更新性能":["26.1"],"item":["26.2"],"key":["26.2","76.3","85.32"],"提取公共逻辑非常方便":["27.1"],"但是不怎么常用":["27.3"],"s":["28.3"],"普通插槽渲染在父级":["28.3"],"作用域插槽在组件内部渲染":["28.3"],"的语法糖":["29.1"],"b":["29.3","70.3"],"c":["29.3","63.5","67.1","68.2"],"vue3":["30.0"],"语法被移除":["30.0"],"属性":["32.0","75.2","84.3"],"将自己也注册到组件中":["32.0"],"出来":["33.0"],"sync":["33.0"],"修饰符":["33.0"],"如果提供了超时时间并且组件加载也超时了":["34.2"],"则使用加载失败时使用的组件":["34.2"],"timeout":["34.2"],"渲染加载完毕后的组件":["34.3"],"无需重新生成节点":["36.1"],"缓存组件":["36.3"],"keytocache":["36.3"],"ts":["36.3","47.3","67.2","75.2","81.7","85.15"],"expect":["36.3","75.2"],"error":["36.3","54.3","75.2","76.5","80.39","85.6"],"can":["36.3","89.1"],"data":["36.3"],"be":["36.3"],"keepalive":["36.3"],"在firstcomponent的vnode中增加keep":["36.3"],"alive属性":["36.3"],"指令与元素解绑时调用":["37.2"],"unbind":["37.3"],"removeeventlistener":["37.3","82.11"],"mergeoptions":["38.0"],"外观模式":["38.0"],"提供了统一的接口":["38.0"],"用来访问子系统中的一群接口":["38.0"],"once":["39.0"],"分页":["39.0"],"虚拟滚动":["39.0"],"时间分片等策略":["39.0"],"提速":["40.0"],"终极的手段":["40.0"],"ssr":["40.0"],"对首屏做服务端渲染":["40.0"],"for":["41.0","96.5"],"frontend":["41.0"],"层解决跨域问题":["41.0"],"在页面切换时通过导航守卫可以取消上一个页面中正在发送的请求":["42.0"],"当用户登录后端会返回对应的按钮权限":["43.1"],"在按钮上使用此指令":["43.1"],"指令内部会判断用户是否有此按钮权限":["43.1"],"如果没有则会移除按钮":["43.1"],"守卫中传给":["44.0"],"next":["44.0"],"的回调函数":["44.0"],"创建好的组件实例会作为回调函数的参数传入":["44.0"],"cli":["45.0"],"webpack":["45.0","79.1"],"fallback":["45.0"],"问题":["46.0"],"支持并不友好":["47.3"],"sessionstorage":["49.0","94.6"],"promise":["50.0","78.8"],"而":["50.0","60.4","67.6","71.12","80.1","89.1","94.7","97.11","107.69"],"则没进行包装":["50.0"],"简单的组件仍然可以采用":["52.0"],"进行编写":["52.0"],"在复杂的逻辑中有着明显的优势":["52.0"],"优化动态节点":["53.0"],"blocktree":["53.0"],"进行靶向更新等":["53.0"],"相比":["53.0","87.3"],"来说":["53.0"],"新增了很多新的特性":["53.0"],"则会阻断传播":["54.1"],"收集到错误后":["54.3"],"提交到前端监控系统中":["54.3"],"这样我们可以分析前端代码的异常信息":["54.3"],"进行非props比较":["55.1"],"ref比较":["55.1"],"dynamic":["55.1"],"slots":["55.1","111.13"],"动态插槽":["55.1"],"dev":["55.1"],"root":["55.1"],"hoisted":["55.1"],"表示静态节点":["55.1"],"内容变化":["55.1"],"不比较儿子":["55.1"],"bail":["55.1"],"表示diff算法应该结束":["55.1"],"标签":["55.2"],"解决方案":["55.2"],"就是将不稳定的结构也作为":["55.2"],"来进行处理":["55.2"],"父节点除了会收集动态节点之外":["55.4"],"也会收集子":["55.4"],"更新时因":["55.4"],"值不同会进行删除重新创建":["55.4"],"前后元素不一致是无法做到靶向更新的":["55.5"],"因为":["55.5","81.6"],"dynamicchildren":["55.5"],"中还有可能有其他层级的元素":["55.5"],"同时这里还生成了一个":["55.5"],"因为前后元素个数不一致":["55.5"],"所以称之为":["55.5"],"不稳定序列":["55.5"],"浏览器对象模型":["56.1"],"bom":["56.1"],"提供和浏览器交互的方法和接口":["56.1"],"domlevel4":["56.5"],"新增的内容包括替代":["56.5"],"mutation":["56.5"],"events":["56.5"],"的":["56.5","56.6","65.7","73.3","83.2","87.8","89.0","94.8","107.40","121.5"],"observes":["56.5"],"xmlhttprequest":["56.6"],"ie":["56.6","101.40"],"activexobject":["56.6"],"export":["57.1","78.13"],"关键字":["57.1"],"使用了":["57.1"],"属性的":["57.1"],"元素不应该再在":["57.1"],"标签中包含其他":["57.1"],"代码":["57.1","59.2"],"如果两者都提供的话":["57.1"],"则浏览器只会下载并执行脚本文件":["57.1"],"从而忽略行内代码":["57.1"],"这些质疑其实可以归纳为一点":["59.0"],"会影响实际项目的开发效率":["59.0"],"事实真的是这样吗":["59.0"],"对开发效率的影响和项目的规模息息相关":["59.1"],"在小项目中":["59.1"],"确实不可避免地降低了项目的开发效率":["59.1"],"但如果我们放眼于项目的整个生命周期":["59.1"],"得益于严密的类型检查与如臂使指的类型推导":["59.1"],"不仅避免了":["59.1"],"灵活性可能会带来的隐患":["59.1"],"还能让你在面对":["59.1"],"bug":["59.1"],"时更快地定位问题":["59.1"],"让程序跑得更稳定一些":["59.1"],"从这个方面来说":["59.1"],"对开发效率的提升是终身制的":["59.1"],"语法":["59.2"],"工程其实也代表了三个不同阶段使用":["59.2"],"目的":["59.2"],"为":["59.2","75.2","85.10"],"代码添加类型与类型检查来确保健壮性":["59.2"],"提前使用新语法或新特性来简化代码":["59.2"],"以及最终获得可用的":["59.2"],"因此":["59.2","64.4","69.7","71.4","80.13","85.24","107.77"],"工程":["59.2"],"也是学习":["59.2"],"的最佳路径":["59.2"],"就像这本小册的名字":["59.3"],"全面进阶指南":["59.3"],"一样":["59.3"],"我们的目标是全方位":["59.3"],"无死角地掌握":["59.3"],"除了与其他读者互相交流解惑以外":["59.4"],"我也会安排固定的答疑时间来统一解决问题":["59.4"],"期待与你一同进步":["59.4"],"话不多说":["60.0"],"我们快点开始吧":["60.0"],"本节代码见":["60.0","61.0","62.0","63.0","64.0","65.0","67.0","68.0","69.0","71.0","72.0","73.0","77.0","78.0","79.0","80.0","82.0","87.0"],"starter":["60.0"],"variable":["60.1"],"显示变量的类型":["60.1"],"以上选项开启后的效果如下":["60.1"],"eg":["60.1"],"并不是所有人都习惯这样的显示方式":["60.1"],"你可以根据自己的需要进行调整":["60.1"],"除了这些提示的配置以外":["60.1"],"还支持了百余项":["60.1"],"配置":["60.1","64.2","78.3"],"你可以看看是否有你需要的配置":["60.1"],"img":["60.2","64.5","80.2","84.2","84.3","86.27","87.3","88.4","97.21","107.6","107.9","107.12","107.52","107.60","107.62","107.105","107.114","121.1"],"等":["60.3","70.2","83.2","85.14","87.9","91.5"],"非常适合在这里研究":["60.3"],"各项配置的作用":["60.3"],"在全局提供了":["60.4"],"tsnd":["60.4"],"这一简写":["60.4"],"你可以运行":["60.4"],"来检查安装情况":["60.4"],"最常见的使用命令是这样的":["60.4"],"respawn":["60.4"],"app":["60.4","79.3","85.5"],"选项启用了监听重启的能力":["60.4"],"提供了更快的编译速度":["60.4"],"你可以查看官方仓库来了解更多选项":["60.4"],"但在大部分场景中以上这个命令已经足够了":["60.4"],"你预期的类型":["60.5"],"表达式或变量等":["60.5"],"除了":["60.5","68.1","77.3"],"检查预期类型与表达式或变量的类型是否一致":["60.5"],"还提供了":["60.5"],"expectnottype":["60.5"],"检查预期类型与表达式或变量的类型是否不同":["60.5"],"expectassignable":["60.5"],"检查表达式或变量的类型是否能赋值给预期类型":["60.5"],"等工具类型":["60.5"],"其中涉及工具类型与泛型的知识":["60.5"],"我们会在后面的课程中一一讲解":["60.5"],"开发环境后":["60.6"],"再开始这本小册的学习":["60.6"],"register":["60.8"],"对":["60.8","61.3","71.8","75.2"],"代码进行预处理":["60.8"],"babel":["60.8","86.35"],"在代码执行时进行覆盖率统计":["60.8"],"istanbul":["60.8"],"以及":["60.8","80.0","80.9","82.3","84.2"],"进行缓存清除来实现":["60.8"],"服务的热更新":["60.8"],"decache":["60.8"],"但这里涉及到":["60.8"],"的缓存策略":["60.8"],"与本小册的主题没有太大关联":["60.8"],"就不做展开啦":["60.8"],"primitive":["61.0","66.2"],"and":["61.0","62.0","63.0","73.0"],"object":["61.0","77.3","101.14"],"以外":["61.1","66.2","68.1","77.3","79.9"],"余下的类型基本上可以完全对应到":["61.1"],"javascript":["61.1","61.4","72.5","82.13"],"中的数据类型概念":["61.1"],"因此这里我们只对":["61.1"],"展开介绍":["61.1"],"中还存在着一个特殊的类型":["61.2"],"void":["61.2","67.5"],"它和":["61.2"],"中的":["61.2","88.4"],"同样不是一回事":["61.2"],"我们接着往下看":["61.2"],"需要关闭":["61.3"],"到这里":["61.3"],"我们了解了":["61.3","64.2"],"中原始数据类型到":["61.3"],"原始类型概念地映射":["61.3"],"你应当能感觉到":["61.3"],"开发者的友好":["61.3"],"大部分概念都能比较自然地过渡":["61.3"],"下面的数组与对象的类型标注同样如此":["61.3"],"other":["61.4"],"的开发者对元组":["61.4"],"的概念可能比较陌生":["61.4"],"毕竟在":["61.4"],"中我们很少声明定长的数组":["61.4"],"但使用元组确实能帮助我们进一步提升":["61.4"],"数组结构的严谨性":["61.4"],"包括基于位置的类型标注":["61.4"],"避免出现越界访问等等":["61.4"],"除了通过数组类型提升数组结构的严谨性":["61.4"],"中的对象类型也能帮助我们提升对象结构的严谨性":["61.4"],"接下来我们就一起来看看":["61.4"],"常见的修饰包括":["61.5"],"可选":["61.5"],"optional":["61.5"],"与":["61.5","64.2","69.4","78.11","80.3","82.4","86.4","88.4","89.5"],"只读":["61.5"],"readonly":["61.5","68.3"],"这两种":["61.5"],"等方法":["61.6"],"即会修改原数组的方法":["61.6"],"因此报错信息也将是":["61.6"],"类型":["61.6","66.7","86.8"],"xxx":["61.6","78.5","78.6"],"上不存在属性":["61.6"],"这种":["61.6"],"这一实现的本质是":["61.6"],"只读数组与只读元组的类型实际上变成了":["61.6"],"readonlyarray":["61.6"],"而不再是":["61.6"],"array":["61.6","65.1","85.6","96.5"],"只要你觉得统一使用类型别名让你觉得更整齐":["61.7"],"也没什么问题":["61.7"],"在任何时候都":["61.8"],"不要":["61.8"],"不要使用":["61.8"],"以及类似的装箱类型":["61.8"],"当你不确定某个变量的具体类型":["61.8"],"但能确定它不是原始类型":["61.8"],"可以使用":["61.8"],"但我更推荐进一步区分":["61.8"],"也就是使用":["61.8"],"record":["61.8","76.1"],"unknown":["61.8","63.12","67.2","68.3","80.39"],"或":["61.8"],"any":["61.8","64.2","67.2","78.9","91.9"],"表示对象":["61.8"],"表示数组":["61.8"],"args":["61.8","80.31"],"表示函数这样":["61.8"],"我们同样要避免使用":["61.8"],"意味着任何非":["61.8"],"从这个层面上看":["61.8"],"使用它和使用":["61.8"],"一样恶劣":["61.8"],"在某些方面其实可以理解为是原始类型与对象类型的进一步延伸":["61.9"],"也同样是日常会被重度使用的语法":["61.9"],"在完成下一节的学习后":["61.9"],"你就可以开始进一步地改造你的":["61.9"],"让那些类型变得更精确一些":["61.9"],"这里的":["61.11","70.3","79.8"],"等使用":["61.11"],"都会在后面有详细地讲解":["61.11"],"同时":["61.11","66.1","78.4","83.4"],"在日常开发的使用非常少见":["61.11"],"这里做了解就好":["61.11"],"literal":["62.0"],"enum":["62.0"],"上面引入了一些新的概念":["62.2"],"我们来一个一个了解":["62.2"],"lin":["62.4"],"bu":["62.4"],"du":["62.4"],"status":["62.6"],"success":["62.6","84.2"],"failure":["62.6"],"除了原始类型的字面量类型以外":["62.6"],"对象类型也有着对应的字面量类型":["62.6"],"同时也是被存储在内存中的类型空间而非值空间":["62.8"],"如果说字面量类型是对原始类型的进一步扩展":["62.8"],"对象字面量类型的使用较少":["62.8"],"那么枚举在某些方面则可以理解为是对对象类型的扩展":["62.8"],"barvalue":["62.10"],"bazvalue":["62.10"],"编译结果":["62.10"],"只会进行":["62.10"],"键":["62.10"],"值":["62.10"],"的单向映射":["62.10"],"除了数字枚举与字符串枚举这种分类以外":["62.10"],"其实还存在着普通枚举与常量枚举这种分类方式":["62.10"],"等的影响":["62.12"],"我们会在后面的":["62.12"],"tsconfig":["62.12","78.3","79.2","82.1"],"详解中了解更多":["62.12"],"可以进一步地使用在编译后会被完全抹除的常量枚举":["62.14"],"但同样会要求其属性值类型保持一致":["62.18"],"这些现象的本质都是":["62.18"],"的类型控制流分析":["62.18"],"我们会在后面的类型系统部分中讲到":["62.18"],"是不是很期待":["63.0"],"让我们赶快开始今天的课程吧":["63.0"],"function":["63.0","63.11","85.5","87.2"],"来进行函数声明":["63.2"],"funcfoostruct":["63.2"],"这时的":["63.2"],"被称为":["63.2"],"callable":["63.2"],"看起来可能很奇怪":["63.2"],"但我们可以这么认为":["63.2"],"就是用来描述一个类型结构的":["63.2"],"而函数类型本质上也是一个结构固定的类型罢了":["63.2"],"此时我们想表达的则是":["63.3"],"这个函数":["63.3"],"进行了返回操作":["63.3"],"但没有返回实际的值":["63.3"],"你也可以使用我们前面学习的元祖类型进行标注":["63.4"],"boolean":["63.4","63.9","79.13","84.7"],"linbudu":["63.4","63.9","64.8","67.1","84.2","85.32"],"true":["63.4","63.9","82.11","84.2","84.7","86.4","107.28","107.65"],"时返回":["63.5"],"这里我们需要将第一个重载声明的":["63.5"],"声明为必选的字面量类型":["63.5"],"你可以试着为第一个重载声明的":["63.5"],"参数也加上可选符号":["63.5"],"然后就会发现第一个函数调用错误地匹配到了第一个重载声明":["63.5"],"实际上":["63.5","71.12","84.2","87.8"],"中的重载更像是伪重载":["63.5"],"它只有一个具体实现":["63.5"],"其重载体现在方法调用的签名上而非具体实现上":["63.5"],"而在如":["63.5"],"等语言中":["63.5"],"重载体现在多个":["63.5"],"名称一致但入参不同的函数实现上":["63.5"],"这才是更广义上的函数重载":["63.5"],"也只是多在重载这一点上":["63.6"],"我们需要着重掌握的仍然是类型标注":["63.6"],"但在":["63.6"],"class":["63.6","66.3","67.2","79.4","96.8","97.7"],"我们的学习重点其实更侧重于其语法与面向对象的编程理念":["63.6"],"arg1":["63.9"],"arg2":["63.9"],"new":["63.9","80.39","84.2","107.45"],"此时":["63.9","78.0"],"参数会被直接作为类的成员":["63.9"],"即实例的属性":["63.9"],"免去后续的手动赋值":["63.9"],"makeuhappy":["63.10"],"studywithu":["63.10"],"n":["63.11","70.2","96.23"],"foofromstring":["63.11"],"constructor":["63.11"],"ctor":["63.11"],"invoked":["63.11"],"fooobj":["63.11"],"hello":["63.11","107.22","107.30","107.43"],"never":["63.12","66.7","91.9"],"内置类型":["63.12"],"以及类型断言等概念":["63.12"],"这些类型工具会是你以后玩转类型编程时最常打交道的一部分":["63.12"],"还真有":["63.14"],"但这里我想留给你自己去探寻":["63.14"],"你可以先查找下这么做的意义":["63.14"],"再想想":["63.14"],"什么场景下我们非用它不可":["63.14"],"接口分离原则":["63.15"],"类的实现方应当只需要实现自己需要的那部分接口":["63.15"],"比如微信登录支持指纹识别":["63.15"],"支付宝支持指纹识别和人脸识别":["63.15"],"这个时候微信登录的实现类应该不需要实现人脸识别方法才对":["63.15"],"这也就意味着我们提供的抽象类应当按照功能维度拆分成粒度更小的组成才对":["63.15"],"d":["63.15"],"依赖倒置原则":["63.15"],"这是实现开闭原则的基础":["63.15"],"它的核心思想即是":["63.15"],"对功能的实现应该依赖于抽象层":["63.15"],"即不同的逻辑通过实现不同的抽象类":["63.15"],"还是登录的例子":["63.15"],"我们的登录提供方法应该基于共同的登录抽象类实现":["63.15"],"最终调用方法也基于这个抽象类":["63.15"],"而不是在一个高阶登录方法中去依赖多个低阶登录提供方":["63.15"],"到底用哪个完全取决于你自己":["64.1"],"毕竟语言只是工具嘛":["64.1"],"如果说":["64.1"],"是比原始类型":["64.1"],"对象类型等更广泛的类型":["64.1"],"也就是说它们更上层一些":["64.1"],"就像":["64.1","70.1"],"字符串类型比":["64.1"],"字符串字面量更上层一些":["64.1"],"原始类型":["64.1","69.5"],"对象类型":["64.1"],"字面量类型":["64.1","69.2","69.7"],"是否存在比字面量类型更底层一些的类型":["64.1"],"这里的上层与底层":["64.1"],"其实即意味着包含类型信息的多少":["64.1"],"类型包括了任意的类型":["64.1"],"字符串类型包括任意的字符串字面量类型":["64.1"],"而字面量类型只表示一个精确的值类型":["64.1"],"如要还要更底层":["64.1"],"也就是再少一些类型信息":["64.1"],"那就只能什么都没有了":["64.1"],"而内置类型":["64.1"],"就是这么一个":["64.1"],"什么都没有":["64.1"],"的类型":["64.1"],"此前我们已经了解了另一个":["64.1"],"但相比于":["64.1"],"还要更加空白一些":["64.1"],"的参数":["64.2","72.5","79.8"],"此时这个未标明类型的数组被推导为了":["64.2"],"这种情况仅会在你启用了":["64.2"],"strictnullchecks":["64.2"],"同时禁用了":["64.2"],"noimplicitany":["64.2"],"配置时才会出现":["64.2"],"解决的办法也很简单":["64.2"],"为这个数组声明一个具体类型即可":["64.2"],"关于这两个配置的具体作用":["64.2"],"我们会在后面有详细的介绍":["64.2"],"在这一部分":["64.2","77.1","89.7"],"top":["64.2","69.5","97.6"],"它们的表现":["64.2"],"在讲":["64.2"],"的时候":["64.2"],"我们在小":["64.2"],"tips":["64.2"],"中提到":["64.2"],"可以使用类型断言来避免对":["64.2"],"类型的滥用":["64.2"],"那么接下来":["64.2"],"我们就来学习类型断言这一概念":["64.2"],"需要注意的是":["64.3","67.5","79.8","83.3","85.8"],"类型断言应当是在迫不得己的情况下使用的":["64.3"],"虽然说我们可以用类型断言纠正不正确的类型分析":["64.3"],"但类型分析在大部分场景下还是可以智能地满足我们需求的":["64.3"],"总的来说":["64.3","79.19"],"在实际场景中":["64.3","79.15"],"还是":["64.3"],"这一种操作更多":["64.3"],"但这也是让你的代码编程":["64.3"],"anyscript":["64.3"],"的罪魁祸首之一":["64.3"],"请务必小心使用":["64.3"],"这一通用类型包含了所有可能的类型":["64.4"],"断言到它":["64.4"],"从它断言到另一个类型":["64.4"],"差异不大":["64.4"],"这个时候等待你的是一堆类型报错":["64.5"],"你必须规规矩矩地实现整个接口结构才可以":["64.5"],"但如果使用类型断言":["64.5"],"我们可以在保留类型提示的前提下":["64.5"],"不那么完整地实现这个结构":["64.5"],"这个例子是不会报错的":["64.5"],"类型提示仍然存在":["64.5"],"在你错误地实现结构时仍然可以给到你报错信息":["64.5"],"也带你认识到":["64.6"],"原来不止可以对变量进行编程":["64.6"],"类型也可以":["64.6"],"as":["64.8","77.3","86.39","89.7"],"handler":["64.8"],"这一部分的扩展阅读只是为了让你提前意识到类型层级的存在":["64.8"],"并不需要完全理解":["64.8"],"毕竟我们后面还有一整节会讲类型系统层级呢":["64.8"],"索引类型与映射类型":["65.0"],"internal":["65.0"],"type":["65.0","68.0","69.0","79.6","107.82"],"tools":["65.0","66.0"],"ensurearray":["65.1"],"isarray":["65.1","96.5"],"另外":["65.1","69.4","77.3","79.4","79.15","86.27"],"类型别名中可以接受任意个泛型":["65.1"],"以及为泛型指定约束":["65.1"],"默认值等":["65.1"],"这些内容我们都会在泛型一节深入了解":["65.1"],"总之":["65.1"],"对于工具类型来说":["65.1"],"它的主要意义是":["65.1"],"基于传入的泛型进行各种类型操作":["65.1"],"得到一个新的类型":["65.1"],"而这个类型操作的指代就非常非常广泛了":["65.1"],"甚至说类型编程的大半难度都在这儿呢":["65.1"],"这也是这本小册占据篇幅最多的部分":["65.1"],"unionintersection1":["65.2"],"unionintersection2":["65.2"],"总结一下交叉类型和联合类型的区别就是":["65.2"],"联合类型只需要符合成员之一即可":["65.2"],"而交叉类型需要严格符合每一位成员":["65.2"],"我们来依次介绍三个部分":["65.3"],"的索引签名类型":["65.4"],"以此来暂时支持":["65.4"],"对类型未明确属性的访问":["65.4"],"并在后续一点点补全类型":["65.4"],"anytypehere":["65.4"],"value":["65.4","83.7","96.6"],"也就是说":["65.5","73.7","83.7"],"它是由无数字面量类型组成的":["65.5"],"由此我们可以知道":["65.5"],"的产物必定是一个联合类型":["65.5"],"没有匹配的类型":["65.6"],"的索引签名":["65.6"],"索引类型的最佳拍档之一就是映射类型":["65.6"],"同时映射类型也是类型编程中常用的一个手段":["65.6"],"属于":["65.7"],"操作符":["65.7"],"属于索引签名类型":["65.7"],"属于索引类型访问":["65.7"],"typeof":["65.8","79.6"],"以及类型守卫":["65.8"],"如果说这一节我们了解的工具主要是生产新的类型":["65.8"],"那类型守卫就像是流水线的质量检查员一样":["65.8"],"它可以帮助你的代码进一步提升类型安全性":["65.8"],"为了更好地避免这种情况":["66.1"],"也就是隔离类型层和逻辑层":["66.1"],"类型查询操作符后是不允许使用表达式的":["66.1"],"isinputvalid":["66.1"],"不允许表达式":["66.1"],"let":["66.1","107.45"],"isvalid":["66.1"],"isfalsy":["66.2"],"val":["66.2"],"不包括不常用的":["66.2"],"bigint":["66.2"],"isprimitive":["66.2"],"includes":["66.2","86.28"],"除了使用":["66.2","66.3"],"我们还可以使用许多类似的方式来进行类型保护":["66.2"],"只要它能够在联合类型的类型成员中起到筛选作用":["66.2"],"类的实例":["66.3"],"同样的":["66.3","75.4"],"也可以用来进行类型保护":["66.3"],"foobase":["66.3"],"barbase":["66.3"],"extends":["66.3","68.2","78.9","80.8"],"is":["66.3"],"关键字的类型守卫以外":["66.3"],"其实还存在使用":["66.3"],"asserts":["66.3"],"关键字的类型断言守卫":["66.3"],"not":["66.4","83.10","89.1"],"a":["66.4","86.39","107.43"],"在这种情况下":["66.4"],"你无需再为断言守卫传入一个表达式":["66.4"],"而是可以将这个判断用的表达式放进断言守卫的内部":["66.4"],"来获得更独立地代码逻辑":["66.4"],"再到泛型约束":["66.5"],"泛型默认值等概念":["66.5"],"让你从此不再看到泛型就脑壳痛":["66.5"],"ibase":["66.7"],"合并后的":["66.7"],"同样是":["66.7"],"derived":["66.7"],"做了支持":["66.8"],"如果你有兴趣了解":["66.8"],"中的类型控制流分析以及更多可辨识联合类型的场景":["66.8"],"可以阅读":["66.8"],"中的类型控制流分析演进":["66.8"],"generic":["67.0"],"types":["67.0","71.0","75.0","76.0","77.0","78.5","79.0"],"在条件类型参与的情况下":["67.1"],"通常泛型会被作为条件类型中的判断条件":["67.1"],"condition":["67.1"],"或者":["67.1","86.11"],"以及返回值":["67.1"],"即":["67.1","77.2","85.9"],"两端的值":["67.1"],"这也是我们筛选类型需要依赖的能力之一":["67.1"],"泛型参数存在默认约束":["67.2"],"在下面的函数泛型":["67.2"],"泛型中也是":["67.2"],"这个默认约束值在":["67.2"],"版本以前是":["67.2"],"而在":["67.2"],"版本以后则为":["67.2"],"eslint":["67.2"],"你可以使用":["67.2"],"no":["67.2"],"unnecessary":["67.2"],"constraint":["67.2"],"规则":["67.2"],"来避免代码中声明了与默认约束相同的泛型约束":["67.2"],"相当于":["67.3","70.1","79.6"],"均使用了这唯一传入的泛型参数":["67.3"],"当传入两个泛型参数时":["67.3"],"第三个泛型参数":["67.3"],"会默认赋值为第二个泛型参数的值":["67.3"],"多泛型关联在一些复杂的工具类型中非常常见":["67.3"],"我们会在后续的内置类型讲解":["67.3"],"内置类型进阶等章节中再实战":["67.3"],"这里先了解即可":["67.3"],"直到目前为止":["67.4"],"我们了解的泛型似乎就是一个类型别名的参数":["67.4"],"它需要手动传入":["67.4"],"可以设置类型层面约束和默认值":["67.4"],"看起来似乎没有特别神奇的地方":["67.4"],"接下来":["67.4","69.2","78.4","79.2","82.2","83.0"],"我们要来看看泛型的另一面":["67.4"],"也是你实际上会打交道最频繁的一面":["67.4"],"类型的自动提取":["67.4"],"函数的泛型是日常使用较多的一部分":["67.5"],"更明显地体现了":["67.5"],"泛型在调用时被填充":["67.5"],"这一特性":["67.5"],"而类型别名中":["67.5"],"我们更多是手动传入泛型":["67.5"],"这一差异的缘由其实就是它们的场景不同":["67.5"],"我们通常使用类型别名来":["67.5"],"对已经确定的类型结构进行类型操作":["67.5"],"比如将一组确定的类型放置在一起":["67.5"],"而在函数这种场景中":["67.5"],"我们并不能确定泛型在实际运行时会被什么样的类型填充":["67.5"],"不要为了用泛型而用泛型":["67.5"],"就像这样":["67.5"],"arg":["67.5"],"在这个函数中":["67.5"],"泛型参数":["67.5"],"没有被返回值消费":["67.5"],"也没有被内部的逻辑消费":["67.5"],"这种情况下即使随着调用填充了泛型参数":["67.5"],"也是没有意义的":["67.5"],"因此这里你就完全可以用":["67.5"],"来进行类型标注":["67.5"],"被约束为队列类型的子类型":["67.6"],"方法中的":["67.6"],"类型参数则不会受此约束":["67.6"],"它会在其被调用时再对应地填充":["67.6"],"同时也会在返回值类型中被使用":["67.6"],"体现在":["67.7"],"ref":["67.7"],"current":["67.7"],"上":["67.7","99.3"],"useref":["67.7"],"context":["67.7"],"createcontext":["67.7"],"contexttype":["67.7"],"关于":["67.7","87.3","87.9"],"中的更多泛型坑位以及":["67.7"],"结合使用":["67.7"],"我们会在后面的实战一节进行详细讲解":["67.7"],"那么下一节我们就来学习这个有趣的类型特性":["67.8"],"structual":["68.0"],"system":["68.0","85.20"],"checking":["68.1"],"focuses":["68.1"],"on":["68.1"],"the":["68.1"],"shape":["68.1"],"values":["68.1","83.10","96.18"],"have":["68.1","81.10"],"sometimes":["68.1"],"called":["68.1"],"or":["68.1"],"structural":["68.1"],"因此在这里":["68.1"],"我们可以直接认为鸭子类型与结构化类型是同一概念":["68.1"],"基于类型结构进行兼容性判断的结构化类型系统":["68.1"],"还有一种":["68.1"],"基于类型名进行兼容性判断的类型系统":["68.1"],"标称类型系统":["68.1"],"java":["68.2"],"rust":["68.2"],"等语言中都主要使用标称类型系统":["68.2"],"那么":["68.2","73.3","83.8"],"我们是否可以在":["68.2"],"中模拟出标称类型系统":["68.2"],"tagged":["68.3"],"token":["68.3"],"总结一下":["68.3","78.5"],"中我们可以通过类型或者逻辑的方式来模拟标称类型":["68.3"],"这两种方式其实并没有非常明显的优劣之分":["68.3"],"基于类型实现更加轻量":["68.3"],"你的代码逻辑不会受到影响":["68.3"],"但难以进行额外的逻辑检查工作":["68.3"],"而使用逻辑实现稍显繁琐":["68.3"],"但你能够进行更进一步或更细致的约束":["68.3"],"类型系统中的类型层级":["68.4"],"了解类型层级以后再学习条件类型与工具类型":["68.4"],"简直不要太":["68.4"],"easy":["68.4"],"中可以实现":["68.6"],"这样神奇的运算":["68.6"],"通过隐式转换":["68.6"],"这其实就是弱类型语言的显著特点之一":["68.6"],"levels":["69.0"],"都建立在它是一个":["69.1"],"类型的基础上":["69.1"],"你给个猫":["69.1"],"让后面咋办":["69.1"],"这两种判断方式并没有明显的区别":["69.1"],"只在使用场景上略有差异":["69.1"],"在需要判断多个类型的层级时":["69.1"],"条件类型更为直观":["69.1"],"而如果只是两个类型之间的兼容性判断时":["69.1"],"使用类型声明则更好理解一些":["69.1"],"你可以依据自己的习惯来进行选择":["69.1"],"的字面量类型":["69.2"],"我们将结论简记为":["69.2"],"对应的原始类型":["69.2"],"我们就从这个原始类型与字面量出发":["69.2"],"向上":["69.2"],"向下去探索类型层级":["69.2"],"对于这种嵌套的联合类型":["69.4"],"我们这里直接观察最后一个条件语句的结果即可":["69.4"],"因为如果所有条件语句都成立":["69.4"],"那结果就是最后一个条件语句为真时的值":["69.4"],"由于联合类型实际上是一个比较特殊的存在":["69.4"],"大部分类型都存在至少一个联合类型作为其父类型":["69.4"],"因此在后面我们不会再体现联合类型":["69.4"],"现在":["69.4","69.5"],"我们关注的类型变成了基础类型":["69.4"],"这一类":["69.4","78.5"],"这两者的情况就要特殊一些":["69.5"],"它们是因为":["69.5"],"系统设定":["69.5"],"的问题":["69.5"],"包含了所有除":["69.5"],"以外的类型":["69.5"],"基础类型":["69.5"],"函数类型等":["69.5"],"包含了所有非原始类型的类型":["69.5"],"即数组":["69.5"],"对象与函数类型":["69.5"],"这就导致了你中有我":["69.5"],"我中有你的神奇现象":["69.5"],"在这里":["69.5","70.1","71.4"],"我们暂时只关注从类型信息层面出发的部分":["69.5"],"即结论为":["69.5","69.6"],"原始类型对应的装箱类型":["69.5"],"我们关注的类型为":["69.5"],"result31":["69.6"],"result32":["69.6"],"虽然还是存在系统设定的部分":["69.6"],"但我们仍然只关注类型信息层面的层级":["69.6"],"而到这里":["69.6"],"我们已经触及了类型世界的最高一层":["69.6"],"接下来我们再回到字面量类型":["69.6"],"只不过这一次我们要向下探索了":["69.6"],"这里我们得到的结论是":["69.7"],"这就是类型世界的最底层":["69.7"],"有点像我的世界那样":["69.7"],"当你挖穿地面后":["69.7"],"出现的是一片茫茫的空白与虚无":["69.7"],"那现在":["69.7"],"我们可以开始组合整个类型层级了":["69.7"],"结果仍然为":["69.8"],"同理":["69.9"],"45类似于41":["69.9"],"即可能存在的元素类型是符合要求的":["69.9"],"还记得身化万千的":["69.9"],"类型和小心谨慎的":["69.9"],"类型嘛":["69.9"],"类似于":["69.9","81.8","81.10"],"由于":["69.9"],"类型本就位于最下方":["69.9"],"这里显然成立":["69.9"],"只不过":["69.9"],"类型的数组也就无法再填充值了":["69.9"],"可别完全掉以轻心":["69.10"],"它们同样是类型编程中具有一定难度的概念":["69.10"],"nonstringresult2":["70.1"],"我们的条件类型用于判断两个函数类型是否具有兼容性":["70.1"],"而条件中并不限制参数类型":["70.1"],"仅比较二者的返回值类型":["70.1"],"与此同时":["70.1"],"存在泛型约束和条件类型两个":["70.1"],"可能会让你感到疑惑":["70.1"],"但它们产生作用的时机完全不同":["70.1"],"泛型约束要求你传入符合结构的类型参数":["70.1"],"参数校验":["70.1"],"而条件类型使用类型参数进行条件判断":["70.1"],"else":["70.1","96.5","101.52"],"实际内部逻辑":["70.1"],"我们上面讲到的这些条件类型":["70.1"],"本质上就是在泛型基于调用填充类型信息的基础上":["70.1"],"新增了":["70.1"],"基于类型信息的条件判断":["70.1"],"看起来很不错":["70.1"],"但你可能也发现了一个无法满足的场景":["70.1"],"提取传入的类型信息":["70.1"],"只提取了一层":["70.2"],"这种时候我们就需要进行嵌套地提取了":["70.2"],"当然":["70.2","82.13","83.7","86.14"],"在这时应该使用递归来处理任意嵌套深度":["70.2"],"条件类型在泛型的基础上支持了基于类型信息的动态条件判断":["70.2"],"但无法直接消费填充类型信息":["70.2"],"关键字则为它补上了这一部分的能力":["70.2"],"让我们可以进行更多奇妙的类型操作":["70.2"],"内置的工具类型中还有一些基于":["70.2"],"关键字的应用":["70.2"],"我们会在内置工具类型讲解一章中了解它们的具体实现":["70.2"],"而我们上面了解的":["70.2"],"结合其他类型工具":["70.2"],"递归":["70.2"],"都是日常比较常用的操作":["70.2"],"这些例子应当能让你再一次意识到":["70.2"],"类型编程":["70.2"],"的真谛":["70.2"],"special4res":["70.3"],"两种情况都不会实际地执行条件类型":["70.3"],"而在这里我们通过包裹的方式让它不再是一个孤零零的":["70.3"],"也就能够去执行判断了":["70.3"],"之所以分布式条件类型要这么设计":["70.3"],"我个人理解主要是为了处理联合类型这种情况":["70.3"],"就像我们到现在为止的伪代码都一直使用数组来表达联合类型一样":["70.3"],"在类型世界中联合类型就像是一个集合一样":["70.3"],"通过使用分布式条件类型":["70.3"],"我们能轻易地进行集合之间的运算":["70.3"],"比如交集":["70.3"],"intersection":["70.3"],"intersectionres":["70.3"],"进一步的":["70.3"],"当联合类型的组成是一个对象的属性名":["70.3"],"keyof":["70.3","77.3"],"iobject":["70.3"],"此时对这样的两个类型集合进行处理":["70.3"],"得到属性名的交集":["70.3"],"那我们就可以在此基础上获得两个对象类型结构的交集":["70.3"],"除此以外":["70.3"],"还有许多相对复杂的场景可以降维到类型集合":["70.3"],"即联合类型的层面":["70.3"],"然后我们就可以愉快地使用分布式条件类型进行各种处理了":["70.3"],"关于类型层面的集合运算":["70.3"],"对象结构集合运算":["70.3"],"我们都会在小册的后续章节有详细的讲解":["70.3"],"而在更后面":["70.4"],"我们会了解更多类型系统的知识与更复杂的工具类型实现":["70.4"],"欢迎与我一起深入类型编程的世界":["70.4"],"时成立这一点":["70.5"],"我们可以直接将类型收窄到":["70.5"],"然后在去掉":["70.5"],"类型时":["70.5"],"我们仍然可以利用上面的身化万千特性":["70.5"],"builtin":["71.0"],"tool":["71.0","75.0"],"在第":["71.1"],"节内置工具类型进阶":["71.1"],"我们会将这些扩展方向一一实现":["71.1"],"进一步拓宽你的类型编程思路":["71.1"],"虽然":["71.2","77.3","80.2"],"中并没有提供它的另一半":["71.2"],"但参考":["71.2"],"其实我们很容易想到这么实现一个工具类型":["71.2"],"mutable":["71.2","75.1"],"来将属性中的":["71.2"],"修饰移除":["71.2"],"比如所有函数类型的值":["71.3"],"tmp3":["71.4"],"tmp4":["71.4"],"其实就是":["71.4"],"的键名联合类型中剔除了":["71.4"],"的部分":["71.4"],"将其作为":["71.4"],"的键名":["71.4"],"就实现了剔除一部分类型的效果":["71.4"],"这里我们使用":["71.5"],"obj2":["71.5"],"去剔除":["71.5"],"obj1":["71.5"],"此时如果声明约束反而不符合预期":["71.5"],"此前我在掘金发表过一篇详细介绍这一问题的文章":["71.5"],"你可以参考":["71.5"],"你的":["71.5"],"类型还可以更严格一些":["71.5"],"即可":["71.6"],"内置工具类型中还有一个场景比较明确的集合工具类型":["71.6"],"nonnullable":["71.6"],"很明显":["71.6","82.10"],"它的本质就是集合":["71.6"],"的差集":["71.6"],"因此我们可以用之前的差集来进行实现":["71.6"],"在基于分布式条件类型的工具类型中":["71.6"],"其实也存在着正反工具类型":["71.6"],"但":["71.6","75.3"],"并不都是简单地替换条件类型结果的两端":["71.6"],"如交集与补集就只是简单调换了结果":["71.6"],"但二者作用却":["71.6"],"完全不同":["71.6"],"联合类型中会自动合并相同的元素":["71.6"],"因此我们可以默认这里指的类型集合全部都是类似":["71.6"],"set":["71.6"],"那样的结构":["71.6"],"不存在重复元素":["71.6"],"此时要如何灵活地处理这些情况":["71.7"],"interface":["71.8"],"tinstancetype":["71.8"],"的模式匹配思路类似于函数":["71.8"],"或者说这是一个通用的思路":["71.8"],"即基于放置位置的匹配":["71.8"],"放在参数部分":["71.8"],"那就是构造函数的参数类型":["71.8"],"放在返回值部分":["71.8"],"那当然就是":["71.8"],"的实例类型了":["71.8"],"或许你会恍然大悟":["71.10"],"约束的场景是非常常见的":["71.12"],"尤其是在某些连续嵌套的情况下":["71.12"],"一层层的":["71.12"],"提取再筛选会严重地影响代码的可读性":["71.12"],"约束这一功能无疑带来了更简洁直观的类型编程代码":["71.12"],"typings":["72.0","78.10"],"这里被推导为":["72.1"],"的原因":["72.1","77.2","85.5"],"其实还和我们此前了解的协变":["72.1"],"逆变有关":["72.1"],"任何接收":["72.1"],"类型参数的地方":["72.1"],"都可以接收一个":["72.1"],"类型参数":["72.1"],"因此推导到":["72.1"],"类型要更加安全":["72.1"],"既然不会":["72.2"],"那么它想返回什么":["72.2"],"全凭它乐意就好了":["72.2"],"我们还可以用另一种方式来描述这个概念":["72.2"],"你可以":["72.2"],"将返回值非":["72.2"],"作为返回值类型为":["72.2"],"的函数类型参数":["72.2"],"需要更多的前置知识与更多的消化过程":["72.3"],"因此我单独准备了一节内容":["72.3"],"然而我们的":["72.5"],"代码里实际上并没有去消费第二个参数":["72.5"],"这实际上在":["72.5"],"中也是我们经常使用的方式":["72.5"],"即使用更少入参的函数来作为一个预期更多入参函数参数的实现":["72.5"],"的内部定义是如何使用协变与逆变的":["73.0"],"以及如何通过额外的配置启用这一检查":["73.0"],"covariance":["73.0","80.29"],"contravariance":["73.0","80.29"],"观察以上排除方式的结论":["73.1"],"参数类型":["73.1"],"允许":["73.1"],"的父类型":["73.1"],"不允许":["73.1"],"返回值类型":["73.1"],"你是否":["73.1"],"get":["73.1"],"到了什么":["73.1"],"这里用来比较的两个函数类型":["73.1"],"其实就是把具有父子关系的类型放置在参数位置以及返回值位置上":["73.1"],"最终函数类型的关系直接取决于类型的父子关系":["73.1"],"取决于":["73.1"],"也就意味着":["73.1"],"其中有规律可循":["73.1"],"那么这个时候":["73.1"],"我们就可以引入协变与逆变的概念了":["73.1"],"进行一个总结":["73.2"],"函数类型的参数类型使用子类型逆变的方式确定是否成立":["73.2"],"而返回值类型使用子类型协变的方式确定":["73.2"],"学习了函数类型的比较以及协变逆变的知识以后":["73.2"],"你已经了解了如何通过":["73.2"],"公式":["73.2"],"来确定函数类型之间的兼容性关系":["73.2"],"但实际上":["73.2"],"基于协变逆变地检查并不是始终启用的":["73.2"],"毕竟":["73.2"],"在严格检查全关与全开的情况下":["73.2"],"简直像是两门语言":["73.2"],"我们需要通过配置来开启":["73.2"],"在此时仍然强制使用参数逆变的规则进行检查":["73.3"],"就无法成立":["73.3"],"也就意味着无法将":["73.3"],"赋值给":["73.3"],"这不就前后矛盾了吗":["73.3"],"所以在大部分情况下":["73.3"],"我们确实希望方法参数类型的检查可以是":["73.3"],"这也是为什么它们的声明中类型结构使用":["73.3"],"方式来声明":["73.3"],"items":["73.3"],"在下一节":["73.4"],"我们就将开始进入类型编程的世界里":["73.4"],"此前我们所学的所有类型工具与类型系统知识将轮番上阵接受考验":["73.4"],"而你也将从看见复杂工具类型就头疼":["73.4"],"变成看见类型就两眼放光的":["73.4"],"高高手":["73.4"],"无论在严格检查与默认情况下均不成立":["73.6"],"这个时候任意的笼子都可以放任意的物种":["73.7"],"放狗的可以放兔子":["73.7"],"放兔子的也可以放狗":["73.7"],"即可以互相分配":["73.7"],"我们称之为":["73.7"],"双变":["73.7"],"bivariant":["73.7"],"包装类型的表现与我们实际需要的效果是紧密关联的":["73.7"],"之前":["74.0"],"我们很有必要利用这几个问题带你走一些常见的误区":["74.0"],"让你能心无旁骛地坚定向前":["74.0"],"只不过是几乎全本的内容":["74.1"],"笑":["74.1"],"相信我":["74.1"],"这本小册中基本都是你现在或未来会需要的技能点":["74.1"],"只有":["74.1"],"compiler":["74.1","83.13","89.0","90.1"],"部分稍显复杂":["74.1"],"但我们也会讲得有趣好玩一些":["74.1"],"而对你自己来说":["74.1"],"这个平衡点其实可以非常灵活":["74.1"],"随着你的学习深入":["74.1"],"技能不断提升":["74.1"],"将会越来越渴望更多的知识":["74.1"],"那平衡点不就越来越高了":["74.1"],"无论如何记住一件事":["74.1"],"不要逼自己学习":["74.1"],"当你在某一节学习过程中感觉到容易分神时":["74.1"],"那就是时候休息了":["74.1"],"站起来活动下身体":["74.1"],"打开窗户呼吸下新鲜空气":["74.1"],"我会一直在这里等你回来":["74.1"],"是在已有一定类型编程基础后":["74.2"],"用来进一步提高水平的方式":["74.2"],"而不是你用来学习类型编程与类型系统的方式":["74.2"],"务必分清其中的因果关系":["74.2"],"markpropsasnullable":["75.1"],"markpropsasnonnullable":["75.1"],"而对于按照值类型的部分修饰":["75.1"],"比如标记所有函数类型属性为可选":["75.1"],"其实和这里是一样的思路":["75.1"],"拆分":["75.1"],"组合":["75.1"],"只不过我们此前使用基于键名裁剪的":["75.1"],"现在我们需要基于键值类型裁剪的":["75.1"],"pickbyvaluetype":["75.1"],"omitbyvaluetype":["75.1"],"而在接下来的结构工具类型进阶中":["75.1"],"我们会了解到如何":["75.1"],"基于键值类型去裁剪结构":["75.1"],"这一节介绍的属性修饰工具类型在日常开发中也是非常常用的":["75.1"],"如一个结构":["75.1"],"在被用作多个":["75.1"],"react":["75.1","83.2"],"组件的属性类型时":["75.1"],"可能存在一些属性修饰的差异":["75.1"],"此时就可以基于这些工具类型":["75.1"],"基于源头的接口结构做定制处理":["75.1"],"避免多次声明基本重复的类型结构":["75.1"],"至少需要一个":["75.2"],"不允许同时拥有":["75.2"],"做进一步展开可以看到":["75.2"],"它其实就是将声明了一个不变的原属性":["75.2"],"的其他属性的接口":["75.2"],"tmp1":["75.2"],"flatten":["75.2"],"tmp2":["75.2"],"再通过联合类型的合并":["75.2"],"这样一来":["75.2","107.45"],"就满足了":["75.2"],"至少实现":["75.2"],"这两个接口中的一个":["75.2"],"不能同时实现":["75.2"],"这两个条件":["75.2"],"如果加上游客类型实现三个互斥属性":["75.2"],"也只需要额外嵌套一层":["75.2"],"visitor":["75.2"],"联合类型会自动合并重复的部分":["75.2"],"我们还可以使用互斥类型实现绑定效果":["75.2"],"即要么同时拥有":["75.2"],"要么一个属性都没有":["75.2"],"xorstruct":["75.2"],"没有":["75.2"],"同时拥有":["75.2"],"互斥工具类型在很多实战场景下都有重要意义":["75.2"],"它在联合类型的基础上添加了属性间的互斥逻辑":["75.2"],"现在你可以让你的接口结构更加精确了":["75.2"],"除了简单粗暴地完全合并以外":["75.3"],"我们还可以实现不完全的并集":["75.3"],"即使用对象":["75.3"],"的属性类型覆盖对象":["75.3"],"中的同名属性类型":["75.3"],"不会将":["75.3"],"独特的部分":["75.3"],"合并过来":["75.3"],"override":["75.3"],"逆并集":["75.3"],"这样":["75.3","83.0","83.10","85.28"],"我们完成了从一维集合到二维集合的跨越":["75.3"],"你也可以探索更多样的情况":["75.3"],"比如两个对象各自独有部分组成的新集合":["75.3"],"即从并集中剔除掉交集":["75.3"],"就是一个很适合自己动手巩固印象的好例子":["75.3"],"前者就只想提取":["75.4"],"这样结构的内部类型":["75.4"],"后者则像在类型的层面执行了":["75.4"],"await":["75.4","84.4","87.2"],"之后的返回值类型":["75.4"],"这里也用到了":["75.4"],"伴随结构转化的例子":["75.4"],"对于":["75.4","84.3"],"内置模式匹配工具类型的进阶":["75.4"],"我们暂时只进行到这里":["75.4"],"在后续的漫谈篇中":["75.4"],"我们会不再拘束于":["75.4"],"内置":["75.4"],"而是会更新更多复杂的模式匹配工具类型":["75.4"],"在":["75.5","75.8","79.8","88.4","89.8"],"版本引入的重磅特性":["75.5"],"模板字符串类型":["75.5"],"我们会用两节的内容带你完成相关学习":["75.5"],"我们传入本次映射的单个属性组成的接口结构":["75.8"],"以及这一结构去除了":["75.8"],"的版本":["75.8"],"如果前后两个接口结构被判定为全等":["75.8"],"那就说明这一次映射的属性不是只读的":["75.8"],"中也是":["75.8"],"但我们调换了符合条件类型时的正反结果位置":["75.8"],"这个工具类型在很多情况下还有特殊的妙用":["75.8"],"不妨再试试各种类型都扔进来比一比":["75.8"],"通过这种方式":["76.1"],"我们不仅不需要再手动声明一大堆工具类型":["76.1"],"同时也获得了逻辑层面的保障":["76.1"],"它会忠实地将":["76.1"],"所有插槽中的联合类型与剩余的字符串部分进行依次的排列组合":["76.1"],"除了直接在插槽中传递联合类型":["76.1"],"通过泛型传入联合类型时同样会有分发过程":["76.1"],"sizerecord":["76.1"],"size":["76.1"],"small":["76.1","107.50"],"middle":["76.1"],"large":["76.1","107.50"],"huge":["76.1"],"unionsizerecord":["76.1"],"模板字符串类型和字符串字面量类型实在太过相似":["76.1"],"我们很容易想到它和字符串类型之间的类型兼容性是怎样的":["76.1"],"通过模板字符串类型":["76.2"],"现在我们能够进行更精确地类型描述了":["76.2"],"而作为基础类型能力":["76.2"],"模板字符串类型和其他类型工具也有着奇妙的组合作用":["76.2"],"比如索引类型和映射类型":["76.2"],"keys":["76.3","96.18"],"而重映射并不是模板字符串类型的唯一伴生伙伴":["76.3"],"为了迎接这位新成员":["76.3"],"还隆重地为它准备了一些特殊的工具类型":["76.3"],"以此让它能够快速和各位前辈大哥平起平坐":["76.3"],"你会发现":["76.4","83.7"],"在这里字符串字面量类型被作为一个字符串值一样进行处理":["76.4"],"这些工具类型通过调用了字符串的":["76.4"],"等原生方法实现":["76.4"],"而按照这个趋势来看":["76.4"],"在未来我们很有可能实现对字面量类型的更多操作":["76.4"],"甚至以后我们能直接调用":["76.4"],"lodash":["76.4","89.8","93.4"],"来处理字符串类型也说不定":["76.4"],"也正是由于目前这些实现需要在":["76.4"],"内部实现":["76.4"],"而无法通过类型编程达到":["76.4"],"在类型编程范式归类中我们并没有包括这一部分":["76.4"],"但模板字符串类型却可以和部分范式产生奇妙的化学反应":["76.4"],"比如模式匹配工具类型":["76.4"],"was":["76.5","86.39"],"转换":["76.6"],"如驼峰":["76.6"],"camelcase":["76.6"],"类型的一步步实现等":["76.6"],"除了上面基于重映射实现的结构处理":["76.8"],"我们此前也了解了基于":["76.8"],"infer":["76.8","79.12"],"来简化模式匹配类型中的结果过滤":["76.8"],"我们当然还是从最简单的部分开始":["77.0"],"advanced":["77.0"],"template":["77.0","81.12"],"startswithres2":["77.1"],"startswithres3":["77.1"],"startswithres4":["77.1"],"startswithres5":["77.1"],"基本一致":["77.1"],"只是我们需要确保":["77.1"],"在字符串的开头部分":["77.1"],"我们了解了字符串类型中":["77.1"],"系列":["77.1"],"这几个较简单的工具类型实现":["77.1"],"现在热身完毕":["77.1"],"是时候开始更复杂的部分了":["77.1"],"比如":["77.1","80.2"],"replace":["77.1","96.19"],"怎么样":["77.1","81.13"],"joinres2":["77.2"],"在进行到最后一项数组成员时":["77.2"],"我们的递归过程就应当被提前阻止":["77.2"],"这里产生一个多余的":["77.2"],"其实就是让这仅有一项的数组还进行了一次分隔符拼接":["77.2"],"因此我们也需要处理只剩下最后一项的情况":["77.2"],"joinres3":["77.2"],"看起来简单的":["77.2"],"我们却连续实现了三次才完成":["77.2"],"类型其实也是":["77.2"],"如果不提前考虑到各种情况":["77.2"],"很难注意到在最后一次递归需要的特殊处理":["77.2"],"这也是类型编程中常见的一个情景":["77.2"],"一个工具类型有时需要多次改进":["77.2"],"多种边界情况处理":["77.2"],"才能称为":["77.2"],"可用":["77.2"],"尤其是在递归的情况下":["77.2"],"在模板字符串进阶类型的最后一部分":["77.2"],"我们要来实现字符串的":["77.2"],"case":["77.2"],"这也是模板字符串类型中相对最为复杂的一部分":["77.2"],"我们基本上是在对上面的模式匹配":["77.2"],"结构转换等概念做一次全面的结合应用":["77.2"],"uppercase":["77.3"],"只是对一维字符串字面量进行的转换":["77.3"],"但由于我们上一节讲到的重映射能力":["77.3"],"它也可以被应用到对象类型层面":["77.3"],"camelcasedproperties":["77.3"],"t":["77.3"],"nested":["77.3"],"foobar":["77.3"],"foobaz":["77.3"],"nestedfoo":["77.3"],"基于此":["77.3"],"我们就完成了模板字符串工具类型的最后一步":["77.3"],"也是其集大成者":["77.3"],"其实你也可以很容易对应着实现智能版的":["77.3"],"只要按着思路划分":["77.3"],"基础工具类型确定":["77.3"],"边界情况补全这一系列路径走下来":["77.3"],"看似繁琐的模板字符串工具类型也并不可怕":["77.3"],"实战环节的难度其实要更低":["77.4"],"我们更多是在介绍语法":["77.4"],"配置项":["77.4"],"实际使用":["77.4"],"所以你完全可以好好缓解一下被类型折磨的大脑":["77.4"],"类型指令就是你最需要的工具":["78.0"],"declaration":["78.0"],"开头":["78.1"],"我们依次来介绍":["78.1"],"禁用下一行代码检查":["78.2"],"也可以使用":["78.2"],"禁用整个文件检查一样":["78.2"],"中也提供了对整个文件生效的类型指令":["78.2"],"check":["78.2"],"nocheck":["78.2"],"即禁用掉对当前文件的检查":["78.3"],"如果我们希望开启对所有":["78.3"],"文件的检查":["78.3"],"只是忽略掉其中少数呢":["78.3"],"此时我们在":["78.3"],"中启用":["78.3"],"checkjs":["78.3"],"来开启":["78.3"],"对所有包含的":["78.3"],"文件的类型检查":["78.3"],"然后使用":["78.3"],"来忽略掉其中少数的":["78.3"],"除了类型指令以外":["78.3"],"在实际项目开发中还有一个你会经常打交道的概念":["78.3"],"类型声明":["78.3"],"文件进行存储":["78.4"],"别人在使用你的代码时":["78.4"],"就能够获得这些额外的类型信息":["78.4"],"如果你在使用别人没有携带类型声明的":["78.4"],"也可以通过类型声明进行类型补全":["78.4"],"我们在后面还会了解更多":["78.4"],"我们要学习如何通过":["78.4"],"类型声明的能力":["78.4"],"让项目中的类型覆盖更加完整":["78.4"],"对于非代码文件的导入":["78.5"],"更常见的其实是":["78.5"],"css":["78.5","83.10"],"但基本语法都相似":["78.5"],"我们在后面还会见到更多":["78.5"],"通常用于为没有提供类型定义的库进行类型的补全":["78.5"],"以及为非代码文件提供基本类型定义":["78.5"],"但在实际使用中":["78.5"],"如果一个库没有内置类型定义":["78.5"],"也会提示你":["78.5"],"是否要安装":["78.5"],"这样的包":["78.5"],"那这个包又是什么":["78.5"],"cdn":["78.6","78.9"],"引入与某些监控埋点":["78.6"],"sdk":["78.6"],"的引入":["78.6"],"我们需要通过":["78.6"],"window":["78.6","86.35"],"的方式访问":["78.6"],"而类型声明很显然并不存在":["78.6"],"此时我们仍然可以通过类型声明":["78.6"],"但不再是通过":["78.6"],"包内部其实就是数个":["78.7"],"这样的声明文件":["78.7"],"而这些声明文件主要通过":["78.7"],"namespace":["78.7","78.8"],"的语法进行类型的描述":["78.7"],"我们可以通过项目内额外的声明文件":["78.7"],"来实现为非代码文件的导入":["78.7"],"或者是全局变量添加上类型声明":["78.7"],"而对于多个类型声明文件":["78.7"],"如果我们想复用某一个已定义的类型呢":["78.7"],"此时三斜线指令就该登场了":["78.7"],"那么将依赖的就是":["78.8"],"文件":["78.8"],"这三种指令的目的都是引入当前文件所依赖的其他类型声明":["78.8"],"只不过适用场景不同而已":["78.8"],"如果说三斜线指令的作用就像导入语句一样":["78.8"],"那么命名空间":["78.8"],"就像一个模块文件一样":["78.8"],"将一组强相关的逻辑收拢到一个命名空间内部":["78.8"],"它的作用是在启用了":["78.9"],"allowumdglobalaccess":["78.9"],"配置的情况下":["78.9"],"允许将这个模块作为全局变量使用":["78.9"],"也就是不导入直接使用":["78.9"],"这一特性同样也适用于通过":["78.9"],"资源导入模块时的变量类型声明":["78.9"],"除了这两处":["78.9"],"使用":["78.9","88.5","89.8"],"中还利用":["78.9"],"合并的特性":["78.9"],"在全局的命名空间中注入了一些类型":["78.9"],"global":["78.9"],"jsx":["78.9","80.8"],"element":["78.9"],"reactelement":["78.9"],"这也是为什么我们可以在全局使用":["78.9"],"作为类型标注":["78.9"],"除了类型声明中的导入":["78.9"],"三斜线指令":["78.9"],"以及类型声明中的模块":["78.9"],"命名空间以外":["78.9"],"还允许你将这些类型去导入到代码文件中":["78.9"],"shared":["78.10","80.12"],"styles":["78.10","80.12"],"module":["78.10","80.12","85.14","89.1"],"scss":["78.10","80.2","80.12"],"结合实战":["78.11"],"其实本质上也是在学习如何让你的":["78.11"],"组件也拥有可靠的类型支持":["78.11"],"vitejs":["78.13"],"plugin":["78.13"],"default":["78.13"],"plugins":["78.13"],"本节的内容主要在":["79.0"],"components":["79.0"],"两个文件夹中":["79.0"],"代表了三种不同思路的":["79.1"],"bundler":["79.1"],"分别是基于浏览器":["79.1"],"esm":["79.1","85.23"],"支持的":["79.1"],"bundleless":["79.1"],"大而全的":["79.1"],"以及零配置的":["79.1"],"我们会在扩展阅读一节了解更多":["79.1"],"或使用":["79.2"],"类型定义包与类型声明其实就是这个脚手架所进行的额外工作":["79.2"],"也是在日常开发中我们会重度依赖的部分":["79.2"],"而除了这两者以外还有":["79.2"],"json":["79.2"],"相关配置":["79.2"],"我们会在后面有专门的一节进行分析":["79.2"],"我们就开始学习如何在":["79.2"],"中优雅地使用":["79.2"],"但如果我们并不想这个组件接受":["79.3"],"正如上面这个组件并没有消费":["79.3"],"此时应该怎么做":["79.3"],"这就要说到":["79.3"],"为什么在更严格的场景下其实不推荐使用":["79.3"],"请参考扩展阅读部分":["79.3"],"的差异":["79.4"],"我们会在扩展阅读中了解":["79.4"],"component":["79.4","107.87","107.90","107.96","107.103","107.121","107.123","107.128"],"不在本节要介绍的范围中":["79.4"],"现在我们进入下一个部分":["79.4"],"看看":["79.4"],"中都有哪些泛型坑位":["79.4"],"的返回值类型":["79.6"],"state":["79.6"],"提供泛型参数":["79.7"],"因为其传入的函数往往已经确定":["79.7"],"而为":["79.7"],"提供泛型参数则要常见一些":["79.7"],"因为我们可能希望通过这种方式来约束":["79.7"],"最后的返回值":["79.7"],"实际上就是提取了":["79.8"],"中代表":["79.8"],"即状态的类型":["79.8"],"在这里即是":["79.8"],"这么一个结构":["79.8"],"中其实也应用了我们此前提到过的":["79.8"],"可辨识联合类型概念":["79.8"],"即为可辨识属性":["79.8"],"通过":["79.8","96.9"],"判断":["79.8"],"我们就能在每一个":["79.8"],"语句中获得联合类型对应分支的类型":["79.8"],"对象":["79.9"],"其接受两个泛型参数":["79.9"],"分别为":["79.9"],"的类型与此组件的属性类型":["79.9"],"中传入了":["79.9"],"以及一个返回两个方法的函数":["79.9"],"它具有两个泛型参数":["79.9"],"分别从传入的":["79.9"],"以及函数的返回值类型中进行类型推导":["79.9"],"在这里我们显式传入了与推导不一致的第二个泛型参数":["79.9"],"以此提供了额外的返回值类型检查":["79.9"],"并非常用的":["79.9"],"但在某些场景下也确实有奇效":["79.9"],"除了以上介绍的这些":["79.9"],"hooks":["79.9"],"还有":["79.9"],"usecontext":["79.9"],"useeffect":["79.9"],"等常用的":["79.9"],"但它们或是过于简单或是不存在泛型坑位":["79.9"],"这里我们就不做介绍":["79.9"],"如果你有兴趣":["79.9"],"直接阅读其类型源码即可":["79.9"],"display":["79.10"],"flex":["79.10"],"aligncontent":["79.10"],"center":["79.10","107.65"],"justifycontent":["79.10","107.65"],"p":["79.10","79.12"],"林不渡":["79.10","84.2"],"元素":["79.12"],"reactportal":["79.13"],"你可以按照自己的喜好来调整这些规范":["79.14"],"runtime":["79.15"],"等数个各司其职的声明文件":["79.15"],"这一规范的粒度并不一定能够满足你的需要":["79.15"],"但你仍然可以按照这一思路进行类型定义的梳理和妥善放置":["79.15"],"我们并不需要将所有的类型定义都专门放到这个文件夹里":["79.15"],"比如仅被组件自身消费的类型就应该使用就近原则":["79.15"],"直接和组件代码一起即可":["79.15"],"fc":["79.16"],"props":["79.16"],"项目开始改造":["79.17"],"看看是否有什么地方可以写得更优雅健壮一些":["79.17"],"在这种情况下我们并不需要通过额外的类型标注":["79.19"],"因为我们就只是简单地把一个组件挂到这个组件的属性上":["79.19"],"并不是在所有场景都能完美胜任的":["79.19"],"当然除了上面提到的缺点以外":["79.19"],"也是有着一定优点的":["79.19"],"如它还提供了":["79.19"],"等一系列合法的":["79.19"],"属性声明":["79.19"],"而我的意见则是不使用":["79.19"],"直接使用简单函数和返回值标注的方式":["79.19"],"这样一来你的函数组件就能够完全享受到作为一个函数的额外能力":["79.19"],"包括但不限于泛型等等":["79.19"],"如何进一步提升工程的约束能力":["80.0"],"下的规则集介绍":["80.0"],"ruleset":["80.0"],"src":["80.1","107.96"],"ext":["80.1"],"cache":["80.1"],"fix":["80.1"],"run":["80.1"],"即是仅检查":["80.1"],"则是检查同时尽可能修复错误":["80.1"],"这样我们就完成了基础的":["80.1"],"但在实际项目中":["80.1"],"光靠":["80.1"],"可没法确保代码质量":["80.1"],"md":["80.2","93.0","105.0"],"sass":["80.2"],"styl":["80.2"],"这段配置的大意是":["80.2"],"对于暂存区的核心代码文件":["80.2"],"先使用":["80.2"],"格式化":["80.2"],"再使用":["80.2"],"而对于其他文件":["80.2"],"统一使用":["80.2"],"现在你可以试着提交一次了":["80.2"],"加上":["80.2"],"后":["80.2","82.9","85.5"],"我们的项目约束才能说基本搞定了":["80.2"],"也可以通过":["80.2"],"m":["80.2"],"xx":["80.2"],"verify":["80.2"],"这种方式绕过去":["80.2"],"但至少现在我们有办法让大家提交的代码都一致了":["80.2"],"不用再被格式化导致的冲突折磨了":["80.2"],"但我们并不应该满足于知道如何配置":["80.2"],"也需要理解这些配置的原理":["80.2"],"以及内部都包含了什么":["80.2"],"是如何简化":["80.2"],"配置的":["80.2"],"是如何工作的":["80.2"],"在接下来":["80.2"],"我们会介绍一批":["80.2"],"下的":["80.2"],"了解它们的作用":["80.2"],"以及我们为什么需要这些规则":["80.2"],"的比较":["80.3","87.9"],"对类型标注的约束":["80.3"],"如禁止某些类型被用于进行标注":["80.3"],"以及在函数返回值处要求你显式标注类型等":["80.3"],"对能力的约束":["80.3"],"如对于仅类型导入":["80.3"],"类型声明的约束":["80.3"],"以及非空断言":["80.3"],"常量断言等功能的使用":["80.3"],"基础部分的规则多是简单的语法检查和类型检查":["80.3"],"因此我们就不做讲解":["80.3"],"接下来我们会来了解的是严格规则组内的规则":["80.3"],"我们进一步将其划分为":["80.3"],"一般严格":["80.3"],"较为严格":["80.3"],"那里一个":["80.6"],"来显式告知编译器这里是泛型语法而非一个":["80.8"],"组件":["80.8"],"类型别名":["80.9"],"的含义也意味着":["80.9"],"我们实际上是使用它来":["80.9"],"归类类型":["80.9"],"联合类型":["80.9"],"抽象类型":["80.9"],"类类型":["80.9"],"封装工具类型":["80.9"],"循环":["80.10"],"而应当使用语法更加简单的":["80.10"],"typescript":["80.11","85.16"],"ecmascript":["80.11"],"纠葛一节中":["80.11"],"我们还会详细介绍可选链与空值合并这两个语法":["80.11"],"index":["80.12","86.35"],"经过断言后的类型子集是否仅剔除了空值部分":["80.13"],"无需担心对于多种有实际意义的类型分支的联合类型误判":["80.13"],"编译结果也说明了":["80.15"],"枚举对象内部也是有作用域的":["80.15"],"优先级当然比外部作用域同名变量更高":["80.15"],"因为我们直接把鼠标悬浮上去就能看到实际应用的泛型类型":["80.18"],"就可以叫":["80.20"],"ignorescript":["80.20"],"还好用":["80.21"],"如果你一定要用":["80.21"],"也要确保用得恰当":["80.21"],"类型了":["80.22"],"到底会不会有空值的时候":["80.23"],"的理解存在着不当之处":["80.24"],"此配置会使用逆变":["80.29"],"而非协变":["80.29"],"的方式进行函数参数的检查":["80.29"],"再在后续添加成员":["80.32"],"来尽可能抹除代码中":["80.33"],"类的所有属性都有类型标注":["80.34"],"而不是仅为不存在初始值的参数":["80.34"],"属性进行标注":["80.34"],"的值类型和你自己标注的返回值类型是否一致":["80.35"],"帮助你确保最终返回的类型一定是你预期的那个类型":["80.35"],"进行比较":["80.37"],"但还是让你的类型更精确一些更好":["80.37"],"提案":["80.38"],"还能够跨越调用栈来附加错误原因传递上下文信息":["80.38"],"input":["80.39","107.118"],"来允许数字":["80.40"],"而禁止掉其他的类型":["80.40"],"你需要确保在把其他类型变量填入模板插槽中时":["80.40"],"进行一次具有实际逻辑的转化":["80.40"],"这一规则就是为了确保在所有情况下你都显式为":["80.41"],"调用传入了泛型":["80.41"],"这样一来你就能自己确定它最终的返回值类型":["80.41"],"而不是依赖类型推导了":["80.41"],"项目开发周期的工具库":["80.43"],"说不定就有你刚好在找的那个":["80.43"],"如果你还使用过其他好用的工具库":["81.0"],"欢迎在评论区留言":["81.0"],"我会随着更新不断收录更多的工具库":["81.0"],"onfailure":["81.2"],"参数":["81.2","88.4","101.6"],"来在编译过程成功与失效时执行不同的逻辑":["81.2"],"bash":["81.2"],"中文版本感觉遥遥无期":["81.6"],"的报错实在太多了":["81.6"],"它更像是":["81.7"],"类型那样的":["81.7"],"结构定义":["81.7"],"存在着值类型":["81.7"],"可选值":["81.7"],"访问性等相关信息的描述":["81.7"],"如":["81.7","83.2","84.2","89.7","89.8","107.80"],"等字段":["81.7"],"因此才能够它才能够与":["81.7"],"之间进行转换":["81.7"],"checks":["81.8"],"也是用于对类型进行单元测试":["81.8"],"yo":["81.10"],"minimum":["81.10"],"got":["81.10","83.10"],"runtypes":["81.10"],"也是运行时的类型与":["81.10"],"前者的底层依赖":["81.11"],"可以用来定制更复杂的场景":["81.11"],"的项目起手式":["81.12"],"tsx":["81.12"],"可以来感受一下":["81.12"],"零配置":["81.12"],"是什么体验":["81.12"],"一定会变得越来越好":["82.0"],"它能够将":["82.1"],"未纳入标准的语法进行降级":["82.1"],"或将标准语法按照运行时环境降级":["82.1"],"这样我们就可以放心使用未来的新语法":["82.1"],"会帮我们编译好的":["82.1"],"也支持这么个功能":["82.1"],"或者说这就是它的核心功能之一":["82.1"],"正如我们在开篇说的那样":["82.1"],"其实就是类型能力加上一些新语法":["82.1"],"而这些新语法绝大部分都来自于":["82.1"],"并且是在这些语法提案还没正式进入标准时":["82.1"],"就对其进行了支持":["82.1"],"在编译时":["82.1"],"类型标注会直接被抹除":["82.1"],"而这些新语法也会按照我们在":["82.1"],"target":["82.1"],"配置进行对应降级":["82.1"],"有哪些语法享受到了这一待遇":["82.1"],"下面我们就来聊一聊":["82.1"],"typescritp":["82.1"],"中的部分":["82.1"],"esmascript":["82.1"],"感受一下它们是不是真的如此好用":["82.1"],"就被正式吸收":["82.2"],"你现在甚至可以在浏览器控制台使用这几个语法":["82.2"],"而装饰器就是比较特殊的一位了":["82.2"],"我们会在下一节装饰器一章详细地聊聊它的演进历史":["82.2"],"我们就来讲一讲可选链":["82.2"],"空值合并以及逻辑赋值这三个语法":["82.2"],"感受一下这些语法糖到底有多甜":["82.2"],"如果":["82.3"],"的左侧发生了短路":["82.3"],"那么就会直接停止后续操作":["82.3"],"比如不会去运行并计算表达式":["82.3"],"通常可选链和空值合并搭配有奇效":["82.3"],"我们继续往下看":["82.3"],"进行处理":["82.4"],"而空值合并的语法如此近似于逻辑操作":["82.4"],"会不会有些基于逻辑操作的语法也能直接套用空值合并":["82.4"],"当然可以":["82.4"],"不然我们怎么介绍下面的逻辑赋值":["82.4"],"同样":["82.5"],"秉持着":["82.5"],"一点一点精通":["82.5"],"的思路":["82.5"],"我仍然推荐你在学习完本节后":["82.5"],"使用可选链":["82.5"],"空值合并以及短路赋值来替换部分老项目中的代码":["82.5"],"并且在未来遇到短路与默认值场景时首先考虑这三位新同学":["82.5"],"最后来写一个你自己的依赖注入容器":["82.6"],"让这些高大上的概念彻底为你所用":["82.6"],"stage1":["82.8"],"在后续直到最近的会议中":["82.9"],"都一直没有取得进一步进展":["82.9"],"原因之一即是这是两个全新的数据类型":["82.9"],"它们的实现成本对于浏览器引擎产商来说是较高的":["82.9"],"这种语法能够帮助我们更好地组织代码与逻辑块的结构":["82.10"],"但由于其毕竟带来了新的编程理念与语法":["82.10"],"目前提案进度感人":["82.10"],"其异步版本":["82.10"],"甚至还没有开始推进":["82.10"],"这里不再赘述":["82.12"],"这两个提案都代表了数据流编程的理念":["82.12"],"数据流编程":["82.12"],"dataflow":["82.12"],"programming":["82.12"],"将程序拆分为数个独立的操作单元":["82.12"],"而数据在操作单元间以有向图的形式流转":["82.12"],"程序设计关注的重点在于动态的数据":["82.12"],"想象流水线上的玩具":["82.12"],"经过一个个工人手中后":["82.12"],"一个木头架子依次被装上了四肢":["82.12"],"脑袋":["82.12"],"眼睛":["82.12"],"开关":["82.12"],"这其实就是数据流在一个个独立单元之间的流动":["82.12"],"而在数据流编程中":["82.12"],"实际上我们关注的也是如何建立这个数据流转关系":["82.12"],"包括需要存在的程序单元":["82.12"],"与程序执行的先后次序等":["82.12"],"语法降级功能不再是刚需":["82.13"],"那就只剩下类型擦除了":["82.13"],"如果这一提案能够持续推进":["82.13"],"成为语法降级的一部分":["82.13"],"甚至运行时也直接原生支持此语法":["82.13"],"那我觉得简直不要太美丽":["82.13"],"类型语法肯定是可选的":["82.13"],"所以我们还是随时可以回到无拘无束的":["82.13"],"程序执行时会先执行":["83.0"],"再用内部返回的函数作为装饰器的实际逻辑":["83.0"],"我们就可以通过入参来灵活地调整装饰器的作用":["83.0"],"我们就来学习一下":["83.0"],"中的装饰器是如何使用的":["83.0"],"它们分别有什么作用":["83.0"],"组件时代":["83.2"],"其实你会发现有许多功能也是通过装饰器实现的":["83.2"],"mobx":["83.2"],"observer":["83.2"],"observable":["83.2"],"redux":["83.2"],"connect":["83.2"],"方法装饰器的":["83.3"],"是":["83.3"],"类的原型而非类本身":["83.3"],"我们通过装饰器劫持了":["83.4"],"在执行原本的":["83.4"],"方法修改了其参数":["83.4"],"我们也可以在这里去劫持":["83.4"],"这样一来在读取这个值时":["83.4"],"会直接返回一个我们固定好的值":["83.4"],"而非其实际的值":["83.4"],"如被":["83.4"],"更新过的":["83.4"],"我们在原型对象上强行写入了属性":["83.5"],"但这种方法实际上过于":["83.5"],"hack":["83.5"],"在后面我们会了解如何通过委托的方式来为一个属性注入值":["83.5"],"思考另一个问题":["83.6"],"一个类中可以同时拥有这几种装饰器":["83.6"],"那么这些":["83.6"],"不同装饰器的执行时机与顺序是如何的":["83.6"],"这里我们主要关注应用顺序":["83.7"],"顺序大致是":["83.7"],"实例属性":["83.7"],"实例方法参数":["83.7"],"构造函数参数":["83.7"],"类":["83.7"],"好像不对":["83.7"],"不是说参数装饰器先应用吗":["83.7"],"这是因为在这个例子中":["83.7"],"我们是先定义属性和属性装饰器的":["83.7"],"因此属性装饰器会先应用":["83.7"],"如果方法在前":["83.7"],"可不就是方法参数装饰器先应用":["83.7"],"类装饰器是最后应用的":["83.7"],"如果我们在方法装饰器中标记某些信息":["83.7"],"最终的类装饰器是可以消费到":["83.7"],"并且基于此信息对类或类的实例进行某些操作的":["83.7"],"如标记为":["83.7"],"deprecated":["83.7"],"的方法":["83.7"],"我们在最终的类装饰器中可以将这些方法实现替换为一个报错":["83.7"],"而标记这些信息的方法则有很多":["83.7"],"最简单的如":["83.7"],"在全局声明一个":["83.7"],"类作为":["83.7"],"这些信息作为":["83.7"],"也是可以的":["83.7"],"后面我们会说到如何使用更好的方式实现":["83.7"],"对于属性":["83.8"],"参数装饰器来说":["83.8"],"我们通常只进行信息注册":["83.8"],"委托别人处理":["83.8"],"对于方法装饰器来说":["83.8"],"我们最多只进行方法执行前后的逻辑注入":["83.8"],"而这些过程都应当是彼此独立的":["83.8"],"这里的委托又如何实现呢":["83.8"],"这时候我们就要介绍一位新朋友了":["83.8"],"反射":["83.8"],"reflect":["83.8"],"你可能很早就认识":["83.8"],"但没怎么接触过":["83.8"],"我们的主要内容和反射并没有太大的关系":["83.9"],"下面要介绍的反射元数据才是本节的重量级角色":["83.9"],"但你仍然需要铭记反射的核心理念":["83.9"],"我们的":["83.10"],"枚举中":["83.10"],"枚举值就是":["83.10"],"的返回值":["83.10"],"因此这里直接使用即可":["83.10"],"接着基于定义在属性上的元数据校验属性类型":["83.10"],"continue":["83.10","84.3"],"枚举也是对象":["83.10"],"同样可以生效":["83.10"],"只不过也会包括键名":["83.10"],"actualtype":["83.10"],"to":["83.10","86.39","89.1"],"but":["83.10"],"最终的输出会是这样的":["83.10"],"除了这两种校验":["83.10"],"你也可以通过元数据的帮助来实现更复杂的校验逻辑":["83.10"],"minlength":["83.10"],"maxlength":["83.10"],"min":["83.10"],"max":["83.10"],"甚至":["83.10"],"email":["83.10"],"ip":["83.10"],"对属性值内容的校验":["83.10"],"思路仍然还是那么简单明了":["83.10"],"注册元数据":["83.10"],"消费元数据":["83.10"],"控制反转":["83.11"],"这实际上避免了未来可能出现的竞争与社区生态分裂问题":["83.13"],"虽然这两个版本的装饰器确实差异很大":["83.13"],"但你其实无需担心出现未来需要面对断崖式的更新":["83.13"],"目前新版装饰器的能力基本上能完全覆盖旧版所能提供的能力":["83.13"],"因此升级成本对于用户或者框架开发者来说都不会太高":["83.13"],"而如果还想继续使用旧版装饰器怎么办":["83.13"],"我猜":["83.13"],"会通过引入一个新的":["83.13"],"option":["83.13"],"来控制实际表现与编译产物":["83.13"],"员":["83.14"],"而不是仅仅只能依赖需要提前定义好的装饰器":["83.14"],"user":["84.1","84.4"],"usercontroller":["84.1","84.4"],"list":["84.1","84.4"],"async":["84.1","84.4","87.2"],"userlist":["84.1","84.4"],"post":["84.1","84.4","89.1"],"add":["84.1","84.4"],"adduser":["84.1","84.4"],"这么个路由声明意味着":["84.1"],"时会调用":["84.1"],"时则会调用":["84.1"],"学习了依赖注入之后":["84.1"],"其实我们也可以来自己实现一个装饰器路由体系":["84.1"],"code":["84.2"],"name":["84.2","86.39","89.4","95.2"],"访问":["84.2"],"来试一下":["84.2"],"成功了":["84.2"],"是不是还有点小激动":["84.2"],"你还可以试着加上同样基于装饰器的中间件":["84.2"],"拦截器等机制":["84.2"],"思路仍然是一致的":["84.2"],"注册":["84.2"],"提取":["84.2"],"组装":["84.2"],"匹配调用":["84.2"],"nest":["84.2","84.3","87.3","87.8"],"这一类框架中":["84.2"],"通常会通过完整的容器机制来进行元数据的注册与提取":["84.2"],"这一过程":["84.2"],"其实就是在你从容器中取出这个类时就已经自动完成了的":["84.2"],"我们要如何实现一个如此贴心的容器":["84.2"],"取出需要注入的类":["84.3"],"这里拿到的是已经实例化的":["84.3"],"赋值给对应的属性":["84.3"],"来试着调用":["84.3"],"会发现已经成功了":["84.3"],"每次传入字符串的实现肯定不够优雅":["84.3"],"我们在使用":["84.3"],"angular":["84.3"],"等框架时":["84.3"],"也并不会经常使用字符串作为标识符来实现依赖注入":["84.3"],"可是":["84.3"],"如果不使用字符串":["84.3"],"我们要用什么来作为标识符呢":["84.3"],"聪明的你肯定想到了":["84.3"],"可以使用内置的元数据来作为标识符":["84.3"],"比如在这种情况下":["84.3"],"我们就可以使用它的类型标注":["84.3"],"来作为标识符":["84.3"],"那接下来我们来改写上面的容器实现":["84.3"],"如何设计入参":["84.4"],"logmiddleware":["84.4"],"中间件逻辑在何时执行":["84.4"],"controller":["84.4"],"userservice":["84.4"],"middleware":["84.4"],"all":["84.4"],"create":["84.4","87.2"],"包括每一条配置的作用":["84.5"],"表现以及与它关联的配置们":["84.5"],"str":["84.7","96.19"],"bool":["84.7"],"这里比较巧妙的是":["84.7"],"由于我们只能获取到被装饰的属性名":["84.7"],"无法直接获取到其类型":["84.7"],"因此通过此前我们学习过的":["84.7"],"工具类型":["84.7"],"将这个类上所有符合类型的属性名都提取了出来":["84.7"],"作为字面量类型":["84.7"],"然后使用这一字面量类型作为类型约束":["84.7"],"正如我对这本小册的定位也包括工具书一样":["85.0"],"当你在实际项目开发遗忘了某一项具体配置的作用":["85.0"],"或者发现某一配置表现不符合预期":["85.0"],"都可以回到这里来寻找答案":["85.0"],"这一节我们主要介绍构建相关的配置":["85.0"],"cls":["85.4"],"v17":["85.5"],"前":["85.5"],"这也是在":["85.5"],"不需要再确保代码中导入了":["85.5"],"就能使用":["85.5"],"才能进行编译":["85.6"],"如果你的运行环境中存在大量的定制方法":["85.6"],"甚至对原本的内置方法做了覆盖":["85.6"],"就可以使用此配置来加载自己的类型声明":["85.6"],"最后":["85.6","87.8","88.4","89.2","89.9"],"配置会随着":["85.6"],"的版本更新而新增可用的值":["85.6"],"如在":["85.6"],"版本新增了":["85.6"],"es2022":["85.6"],"这一选项":["85.6"],"支持了":["85.6"],"at":["85.6"],"cause":["85.6"],"等新的语言特性":["85.6"],"e2e":["85.8"],"只能剔除已经被":["85.8"],"包含的文件":["85.8"],"如果你指定":["85.10"],"会导致":["85.10"],"被生成到":["85.10"],"而非":["85.10"],"配置来让":["85.11"],"将这两个相隔甚远的文件夹视为处于同一目录下":["85.11"],"这一配置并不会影响实际的产物生成":["85.11"],"它只会告诉":["85.11"],"将这两个模块视为同一层级下":["85.11"],"类型定义层面":["85.11"],"中的声明文件":["85.12"],"注意我们需要使用":["85.12"],"相对于":["85.12"],"baseurl":["85.12"],"的相对路径":["85.12"],"加载多个声明文件可能会导致内部的声明冲突":["85.12"],"所以你可能会需要":["85.12"],"配置来禁用掉对加载的类型声明的检查":["85.12"],"绝大部分情况下你不会需要":["85.13"],"作为配置值":["85.13"],"这里仅做了解即可":["85.13"],"会依次解析这些路径":["85.16"],"直到找到一个确实存在的路径":["85.16"],"选项为":["85.20"],"none":["85.20"],"amd":["85.20"],"时使用":["85.20"],"进行类型检查过程":["85.22"],"会对应地启用对":["85.23"],"的支持":["85.23"],"如果你希望使用自己的实现":["85.24"],"而非完全从":["85.24"],"就可以使用":["85.24"],"在开启时源码中仍然会使用这些辅助函数":["85.24"],"不会存在从":["85.24"],"中导入的过程":["85.24"],"此时需要你在全局命名空间下来提供同名的实现":["85.24"],"会在构建产物中引入辅助函数":["85.25"],"判断在":["85.25"],"接口存在时保留":["85.25"],"否则降级为普通的基于索引的":["85.25"],"因此你仍然需要自己引入":["85.25"],"当你同时启用了":["85.26"],"配置时":["85.26"],"编辑器会严格约束你必须这么做":["85.26"],"utils":["85.28"],"monorepo":["85.29"],"等场景下却有着奇效":["85.29"],"来生成类型文件":["85.30"],"消费":["85.31"],"分别用于定义我们的源文件与":["85.31"],"文件的根目录":["85.31"],"const":["85.32","87.2","96.8"],"secret":["85.32"],"以上这段代码不会生成对应的类型声明":["85.32"],"我也会在介绍时指出":["86.1"],"可以看到":["86.3","86.27","89.0"],"它依次判断了":["86.3"],"的情况":["86.3"],"并最后使用了全局变量来进行兜底":["86.3"],"因此你既可以导入它来使用":["86.3"],"也可以直接在全局访问它":["86.3"],"完全允许":["86.4"],"抛出一个错误":["86.4"],"默认":["86.5"],"三个值":["86.5"],"且效果也一致":["86.5"],"因此我们在下面只会对存在额外特殊情况的配置值做讲解":["86.6"],"但这时就意味着":["86.8"],"你确实希望它是一个":["86.8"],"customerror":["86.9"],"就会接着往下执行下一个":["86.11"],"而不论其条件是否匹配":["86.11"],"没有使用":["86.12"],"如果不符要求就提前返回":["86.13"],"此时如果忘记添加":["86.13"],"会导致后面的逻辑仍然错误执行":["86.13"],"语法时一定能够确定":["86.14"],"的具体类型":["86.14"],"你仍然可以使用":["86.14"],"的类型会是":["86.15"],"这样能够提醒你在对这个属性进行读写时进行一次空检查":["86.15"],"需要这么做才可以":["86.18"],"标记":["86.19"],"这些规则我们均会在接下来介绍":["86.20"],"n2":["86.21"],"实际运行将会报错":["86.22"],"下面的":["86.23"],"访问并不一定能成功":["86.23"],"但关闭了":["86.23"],"检查之后":["86.23"],"我们就不能及时发现这一点了":["86.23"],"这一三斜线指令的作用即是":["86.25"],"将此文件标记为默认库声明":["86.25"],"因此开启这一配置后":["86.25"],"编译器在处理其文件时不会再尝试引入默认库声明":["86.25"],"直接指定文件夹即可":["86.27"],"构建后的产物是这样的":["86.27"],"中声明的子项目引用也被一同构建":["86.27"],"同时这些子项目的构建产物中会有":["86.27"],"tsbuildinfo":["86.27"],"文件来缓存本次的构建信息":["86.27"],"你也可以在":["86.27"],"模式下启用监听":["86.27"],"watch":["86.27"],"此时如果你修改一个子项目":["86.27"],"会自动进行增量构建":["86.27"],"跳过没有发生变化的项目":["86.27"],"只构建那些发生了更改的部分":["86.27"],"如果你在某个项目内通过":["86.27"],"ctrl":["86.27"],"command":["86.27"],"点击的方式跳转到一个导入的实现":["86.27"],"你会发现能够直接跳转到这个实现的源码而非类型定义":["86.27"],"这同样能帮助你的开发效率":["86.27"],"up":["86.27"],"声明子项目内需要包含的文件等":["86.28"],"transpilemodule":["86.30"],"这个方法类似于":["86.30"],"不会生成声明文件":["86.30"],"只会进行单纯的语法降级":["86.30"],"这一配置会为没有默认导出的":["86.35"],"模块":["86.35"],"出默认的导出":["86.35"],"以提供更好的类型提示":["86.35"],"如以下代码":["86.35"],"handlers":["86.35"],"errorhandler":["86.35"],"onerror":["86.35"],"虽然这段代码转换后的实际逻辑没有问题":["86.35"],"但由于这里并不存在":["86.35"],"导出":["86.35","107.52"],"会导致在类型上出现一个错误":["86.35"],"配置会在这种情况下将":["86.35"],"中的代码模拟为以下的形式":["86.35"],"allhandlers":["86.35"],"然后在导入方就能够获得正确的类型提示了":["86.35"],"实际上这也是":["86.35"],"实际的构建效果":["86.35"],"但需要注意的是在":["86.35"],"配置并不会影响最终的代码生成":["86.35"],"不像":["86.35"],"那样":["86.35"],"只会对类型检查有帮助":["86.35"],"usefseventsonparentdirectory":["86.38"],"对文件":["86.38"],"目录的父文件夹使用原生事件监听":["86.38"],"等数个监听方式选择":["86.38"],"其他常用的选项则主要是用于减小监听范围的":["86.38"],"use":["86.39"],"it":["86.39"],"result":["86.39"],"successfully":["86.39"],"resolved":["86.39"],"是一个":["86.41"],"npm":["86.41"],"包":["86.41"],"orm":["86.42"],"请求链路到部署":["86.42"],"让你拥有一个完整的":["86.42"],"属于自己的":["86.42"],"服务":["86.42"],"的基本知识":["87.0"],"blog":["87.0"],"参考":["87.1","87.3"],"appmodule":["87.2"],"最终启动的入口文件":["87.2"],"在这里我们定义全局级别的应用配置":["87.2"],"nestfactory":["87.2"],"core":["87.2","89.0"],"chalk":["87.2"],"bootstrap":["87.2"],"listen":["87.2"],"项目中文件的基本功能就介绍到这里":["87.2"],"在扩展阅读部分":["87.2"],"我们还会介绍":["87.2"],"应用中两种不同的目录结构组织方式":["87.2"],"如果你感兴趣可以去读一下":["87.2"],"我们来了解本节应用中的另一个重要部分":["87.2"],"prisma":["87.2","87.8","87.9"],"我们通过":["87.3","88.4"],"它无疑更加自然也更贴近":["87.3"],"同时数据库的表结构与":["87.3"],"类型定义的生成均基于":["87.3"],"这也就保证了表结构与我们实际类型定义的同步":["87.3"],"而如果你担心":["87.3"],"生成的类型不够严谨":["87.3"],"可以翻翻看生成的":["87.3"],"如这个例子中我们只有三个实体":["87.3"],"共计":["87.3"],"个字段":["87.3"],"生成了将近":["87.3"],"行的类型定义":["87.3"],"如果你对":["87.3"],"产生了兴趣":["87.3"],"我此前写过系列文章来详细地介绍":["87.3"],"下一代":["87.3"],"不仅仅是":["87.3"],"上篇":["87.3"],"下篇":["87.3"],"的工作流程":["87.3"],"你可以参考这张图片":["87.3"],"我们要来了解如何在":["87.3"],"中去集成":["87.3"],"这一步我们不需要任何的集成包":["87.3"],"只有非常自然地导入与调用":["87.3"],"update":["87.4"],"updateinput":["87.4"],"where":["87.4"],"id":["87.4"],"heroku":["87.5","88.4"],"平台提供的部署与数据库服务":["87.5"],"这对于大部分同学来说都是首次接触":["87.5"],"都会被归类到对应业务逻辑的文件夹下":["87.7"],"每个业务逻辑拥有自己的":["87.7"],"然后再在":["87.7"],"中汇总":["87.7"],"这一方式适合存在一定规模的项目":["87.7"],"以及内部业务模块分类较多的情况":["87.7"],"此时使用基于逻辑的目录结构划分可以帮助你更好地进行模块拆分":["87.7"],"同时获得更直观的模块依赖关系":["87.7"],"模式则更加严谨":["87.8"],"适用于开发规模较大的应用":["87.8"],"一个例子是在":["87.8"],"集成包中":["87.8"],"也是注入repository实例然后再进行操作的":["87.8"],"即也属于":["87.8"],"模式":["87.8"],"使用的也是":["87.8"],"我们需要":["87.8"],"client":["87.8"],"来作为访问层":["87.8"],"可以参考下面这张图片":["87.9"],"comparison":["87.9"],"3a":["88.1"],"2f":["88.1"],"2fwww":["88.1"],"imagehub":["88.1"],"cc":["88.1"],"2fimage":["88.1"],"2fgfin6y":["88.1"],"点击安装":["88.1"],"将安装到我们的应用中":["88.1"],"数据库的链接会被以环境变量":["88.1"],"process":["88.1"],"env":["88.1"],"database":["88.1"],"url":["88.1"],"注入进来":["88.1"],"来到应用配置页面":["88.1"],"点击显示环境变量":["88.1"],"imagee38ce6a381dc9b3b":["88.1"],"有了数据库地址":["88.1"],"接下来我们就可以在本地应用里去连接到数据库了":["88.1"],"providers":["88.2"],"categoryservice":["88.2"],"tagservice":["88.2"],"现在访问":["88.2"],"http":["88.2"],"localhost":["88.2"],"会发现已经有响应了":["88.2"],"imagee102f1b42e36a82b":["88.2"],"image752c0cd8664a87c4":["88.3"],"这一命令会占据当前的端口":["88.3"],"实时展示最新的日志":["88.3"],"因此在开发阶段可以通过它来进行调试应用":["88.3"],"至此":["88.3"],"我们的应用就已经部署完毕了":["88.3"],"接下来基本上就不需要再在":["88.3"],"上进行什么配置了":["88.3"],"最后需要注意的是":["88.3"],"如果你的应用一段时间都没有任何流量":["88.3"],"会暂时停止掉这个服务":["88.3"],"并在下一次有流量访问时再启动":["88.3"],"这一过程一般耗时不会太久":["88.3"],"而如果你在本地访问数据库出现了连接失败":["88.3"],"原因也是因为其关联的应用被暂停":["88.3"],"资源被暂时回收了":["88.3"],"querybyid":["88.4"],"param":["88.4"],"parseintpipe":["88.4"],"注入":["88.4"],"由于这一解构出来的值会是字符串":["88.4"],"而我们的结构定义中":["88.4"],"为数字":["88.4"],"因此需要使用":["88.4"],"来将其转化为数字类型":["88.4"],"我们使用":["88.4"],"apifox":["88.4"],"来进行接口的调试":["88.4"],"你也可以使用任意习惯的工具":["88.4"],"部分的开发仅仅只是开始":["88.4"],"毕竟分类和标签也必不可少":["88.4"],"但授人以鱼不如授人以渔":["88.4"],"有了这一节的基础":["88.4"],"再配合":["88.4"],"事无巨细的官方文档":["88.4"],"你完全可以独立完成剩下的部分":["88.4"],"好了":["88.4"],"完成了以上代码后":["88.4"],"你可以直接运行":["88.4"],"git":["88.4"],"会自动使用最新的代码进行部署":["88.4"],"除了业务逻辑开发以外":["88.4"],"其实你也可以关注更多的功能部分":["88.4"],"中你可以找到校验":["88.4"],"中间件":["88.4"],"文件上传":["88.4"],"日志":["88.4"],"定时任务":["88.4"],"缓存":["88.4"],"限流等等功能":["88.4"],"不妨试着把这些功能都加到这个":["88.4"],"里":["88.4"],"我们将换一个方式来":["88.5"],"用":["88.5"],"其他的就不剧透啦":["88.5"],"这样的工具来进行源码的转换以外":["89.0"],"其实你也可以使用":["89.0"],"来编程式地调用":["89.0"],"并对应地配置插件":["89.0"],"预设等等":["89.0"],"在工作流程中其实有一样东西贯穿了整个过程":["89.0"],"那就是":["89.0"],"而这也是我们本节所关注的":["89.0"],"如何玩转":["89.0"],"buildcodeframeerror":["89.1"],"reassign":["89.1"],"则提供的是命令式的":["89.1"],"exports":["89.1"],"fileinfo":["89.1"],"findvariabledeclarators":["89.1"],"foo":["89.1"],"renameto":["89.1"],"tosource":["89.1"],"虽然命令式看起来很简单":["89.1"],"但却可能导致对":["89.1"],"节点的遗漏":["89.1"],"如果底层封装没有完全覆盖掉边界情况":["89.1"],"就像鱼和熊掌不可兼得一样":["89.1"],"同样属于命令式":["89.1"],"只不过它的使用风格并非链式":["89.1"],"而更像是组合式":["89.1"],"铺垫了这么多":["89.1"],"是时候请出我们本节的主角了":["89.1"],"内的":["89.2"],"枚举":["89.2"],"它描述了所有可能的":["89.2"],"结点类型":["89.2"],"拿到目标":["89.2"],"结点后":["89.2"],"我们就可以调用上面已经提供好的方法":["89.2"],"如导入声明的":["89.2"],"getmodulespecifiervalue":["89.2"],"方法可以直接获得此导入的模块名":["89.2"],"最后保存即可":["89.2"],"其实也并不能完全替代原生":["89.2"],"它并没有对":["89.2"],"block":["89.2"],"操作进行封装":["89.2"],"比如最开始我们使用":["89.2"],"创建函数的例子":["89.2"],"如果换成":["89.2"],"那么对于函数体内的逻辑它是无能为力的":["89.2"],"你要么直接写入字符串":["89.2"],"要么将这部分仍然使用原生的":["89.2"],"实现":["89.2"],"保存":["89.3"],"这个工作流程嘛":["89.3"],"而且有了":["89.3"],"的加持":["89.3"],"很多":["89.3"],"操作的难度都会下降几个级别":["89.3"],"这里我们使用的":["89.4"],"主要包括":["89.4"],"获取源码的所有导入声明":["89.4"],"源码新增导入声明语句":["89.4"],"获取导入声明的模块名":["89.4"],"或者说导入路径":["89.4"],"获取导入声明的具名导入":["89.4"],"扩展":["89.4","89.5","89.6","89.7"],"如何处理默认导入":["89.4"],"命名空间导入的形式":["89.4"],"获取源码中所有的":["89.5"],"获取":["89.5"],"声明实现的抽象类":["89.5"],"声明中的方法声明":["89.5"],"为方法声明新增装饰器":["89.5"],"试试给方法的参数也添加方法参数装饰器":["89.5"],"获取源码中所有的导入声明":["89.6"],"获取导入的模块名":["89.6"],"为导入声明插入一个具名导入":["89.6"],"修改导出语句的表达式":["89.6"],"上面我们直接将默认导出语句作为了组件":["89.6"],"然后通过修改它的表达式来实现添加":["89.6"],"不妨试试如何支持":["89.6"],"形式的组件导出":["89.6"],"使用从接口结构得到的接口名称":["89.7"],"savesync":["89.7"],"gettext":["89.7"],"我们主要使用两个":["89.7"],"在源码中新增一个接口声明":["89.7"],"为接口声明新增一个属性":["89.7"],"上面的处理逻辑并没有很好地处理掉对象类型与数组类型中的复杂情况":["89.7"],"比如数组中既有原始类型也有对象类型":["89.7"],"不妨试着完善一下这部分逻辑":["89.7"],"到达":["89.8"],"以前被再次优化一遍":["89.8"],"不妨来试一下支持这种情况":["89.8"],"以上的示例应该能帮助你领会到":["89.8"],"来进行源码检查与操作的窍门":["89.8"],"同时你可能注意到了":["89.8"],"上面的示例我们封装了不少方法":["89.8"],"getclassdeclarations":["89.8"],"getimportdeclarations":["89.8"],"这也是我比较推荐的一种方式":["89.8"],"上进一步封装":["89.8"],"让":["89.8"],"操作就像调用":["89.8"],"方法一样简单":["89.8"],"除了本节给到的操作示例":["89.9"],"你还可以根据自身的实际需要来探索更多有趣的例子":["89.9"],"试着来感受":["89.9"],"换一种方式使用":["89.9"],"的乐趣吧":["89.9"],"的规则通常只是项目维度的":["89.11"],"比如只在几个项目内要求遵守这条规则":["89.11"],"这也就意味着":["89.11"],"的规则不具备或很难具备可推广性":["89.11"],"这里再次感谢每一位同学的反馈":["90.0"],"node":["90.1"],"应用开发到":["90.1"],"开发":["90.1"],"加上此前的类型能力":["90.1"],"现在我们可以说自己身经百战了":["90.1"],"无论你正处于哪个阶段":["90.1"],"这些内容都一定能或多或少帮助到你":["90.1"],"而这就是我创作这本小册的初衷":["90.1"],"未来我可能还会有新的掘金小册面世":["90.2"],"如果这本小册让你感觉收获满满":["90.2"],"也欢迎你关注我的下一本小册":["90.2"],"感谢你的一路陪伴":["90.3"],"也期待与你的再次相见":["90.3"],"中包含的基础类型":["91.0"],"类型断言的语法这种":["91.0"],"无法使用映射类型等类型工具":["91.2"],"也就意味着在类型编程场景中我们还是应该使用":["91.2"],"特别说明了在对象扩展的情况下":["91.3"],"使用接口继承要比交叉类型的性能更好":["91.3"],"的类型层级是怎么样的":["91.6"],"的它是所有类型的子类型":["91.8"],"在条件类型中同样存在对它们的特殊逻辑":["91.9"],"请回想":["91.9"],"在条件类型中的表现":["91.9"],"同时对它们实现过程中使用到的类型工具也有较为深入的了解":["91.12"],"icon":["92.0","95.4","107.80"],"引入":["93.0"],"中查找":["93.3"],"字段是插件的路径":["93.3"],"字段是插件的样式路径":["93.3"],"path":["93.6"],"children":["93.9","93.10"],"覆盖全局的":["93.11"],"你好":["94.4","107.22"],"在这里进行自定义配置":["94.4"],"警告":["94.6","94.9","94.10"],"存储数据必须是同步的":["94.6"],"被持久化":["94.7"],"不会被持久化":["94.7"],"处理序列化":["94.8"],"反序列化":["94.8"],"并进行压缩":["94.8"],"请谨慎使用":["94.9","94.10"],"意外可能会出现":["94.9","94.10"],"输出":["94.11","101.9"],"cwd":["95.2"],"assets":["95.2"],"指定symbolid格式":["95.2"],"symbolid":["95.2"],"共享":["96.1"],"的概念":["96.1"],"l23":["96.2"],"typeof直接返回":["96.2"],"tostring返回":["96.2"],"首字母大写":["96.2"],"null是object":["96.2"],"需tostring来判断":["96.2"],"typeofi值接返回":["96.2"],"typeof能判断":["96.2"],"因此首字母小写":["96.2"],"比较特殊字符串和biginti相加":["96.3"],"biglnt转换为字符串":["96.3"],"i":["96.3","107.43"],"nan规则2":["96.3"],"undefined转换数字相加nan":["96.3"],"1规则2":["96.3"],"null转换为0":["96.3"],"2规则2":["96.3"],"true转换为1":["96.3"],"二者相加为2":["96.3"],"错误不能把biglnt和number类型直接混合相加":["96.3"],"规则3":["96.3"],"字符串拼接":["96.3"],"的转换规则":["96.3"],"如果部署了":["96.3"],"方法优先调用再返回":["96.3"],"调用":["96.3"],"如果转换为基础类型则返回":["96.3"],"如果都没有返回基础类型会报错":["96.3"],"prop":["96.5"],"hasownproperty":["96.5"],"innumerable":["96.6"],"enumerable":["96.6"],"不可枚举的属性":["96.6"],"loop":["96.6"],"设置":["96.6"],"成循环引用的属性":["96.6"],"20240116111129673":["96.6"],"的继承":["96.8"],"但是如果想深入了解":["96.8"],"语法糖是怎么实现的":["96.8"],"就得深入研究":["96.8"],"的底层逻辑":["96.8"],"person":["96.8"],"原型方法":["96.8"],"即person":["96.8"],"下面可以简写为getname":["96.8"],"gamer":["96.8"],"子类中存在构造函数":["96.8"],"则需要再使用":["96.8"],"之前首先调用super":["96.8"],"super":["96.8"],"asuna":["96.8"],"成功访问到父类的方法":["96.8"],"单个数组":["96.9"],"方法功能":["96.9"],"函数调用改变":["96.9"],"返回结果":["96.9"],"直接执行的":["96.9"],"直接执行":["96.9"],"返回待执行的函数":["96.9"],"底层实现":["96.9"],"间接调用":["96.9"],"就具备了实现能在外部访问某个函数内部变量的功能":["96.11"],"和当前函数的作用域":["96.13"],"因此可以输出全局的变量":["96.13"],"replacer":["96.14"],"第三个参数用来控制结果字符串里面的间距":["96.14"],"repeat":["96.16"],"必须指定返回值":["96.16"],"否则返回":["96.16"],"20240117112411958":["96.16"],"find":["96.18"],"findindex":["96.18"],"stringify":["96.19"],"g":["96.19"],"parse":["96.19"],"slice":["96.23"],"排序算法":["96.23"],"时间复杂度":["96.23"],"空间复杂度":["96.23"],"稳定性":["96.23"],"平方":["96.23"],"稳定":["96.23"],"logn":["96.23"],"不稳定":["96.23"],"采用中位数作为哨兵元素":["96.24"],"每隔":["96.24"],"个元素挑出一个元素放到一个新数组中":["96.24"],"然后对它排序":["96.24"],"找到中间位置的数依次作为中位数":["96.24"],"就是这个盒子的高度":["97.2"],"border":["97.3"],"margin":["97.3"],"padding":["97.3"],"0000":["97.4"],"后者覆盖前者":["97.4"],"transform":["97.6"],"translate":["97.6"],"asp":["97.7"],"position":["97.8"],"的值":["97.8","107.82"],"absolute":["97.8"],"fixed":["97.8"],"生效":["97.11"],"四个都可以生效":["97.11"],"重置样式库":["97.13"],"都会造成维护问题":["97.14"],"样式改变":["97.15"],"换皮肤":["97.15"],"会继承父元素的":["97.16"],"设置的元素的后代元素不会继承不透明属性":["97.16"],"样式布局上也有作用":["97.17"],"正好是":["97.22"],"iphone6":["97.22"],"的尺寸":["97.22"],"我们要把":["97.22"],"的尺寸作为基准点":["97.22"],"把某元素转化成块元素":["99.1"],"独占一行":["99.1"],"后加载":["99.2"],"表示标签内字符重要":["99.3"],"更多地用在字体图标":["99.3"],"更多地用在术语":["99.3"],"生物":["99.3"],"医药":["99.3"],"属性来描述这张图是什么内容或者关键词":["99.4"],"具有更新的体积":["99.5"],"兼容性不是特别好":["99.5"],"去处理":["99.6"],"谁先加载完谁先行":["101.1"],"的原始值":["101.3"],"转为数值时为":["101.3"],"还比较类型":["101.4"],"变量提升":["101.6"],"111b":["101.9"],"构造函数原型中找":["101.11"],"对象上一层原型中找":["101.11"],"输出结果":["101.18"],"返回的是一个新的数组":["101.27"],"该方法会改变原数组":["101.28"],"helloworld":["101.34"],"最多的字符是a":["101.35"],"次数是16":["101.35"],"alert":["101.39"],"内存泄漏会出现在低版本的":["101.40"],"其他浏览器不会出现这个问题":["101.40"],"原型链的最顶端是":["101.41"],"有多个参数需要挨个写":["101.49"],"行":["101.51"],"不能超过":["101.53"],"5m":["101.53"],"根据不同的浏览器存储的大小是不同的":["101.53"],"px":["101.54"],"声明的变量有自身的作用域":["101.55"],"匹配到第一个就返回":["101.66"],"如果当前组件没有依赖关系":["103.2"],"那么放在那个生命周期中请求都是可以的":["103.2"],"拿不到":["103.3"],"nexttick":["103.4"],"mounted":["103.6","103.8"],"初始化的时候从上一次的历史开始播放":["103.9"],"子组件可以直接修改父组件的数据":["103.11"],"依赖注入":["103.11"],"父组件":["103.11"],"vitepress":["106.0"],"开始安装":["107.2"],"等待几十秒后":["107.2"],"finish":["107.2"],"完成安装":["107.2"],"settings":["107.3"],"在appearance":["107.3"],"behavior":["107.3"],"appearance的":["107.3"],"theme":["107.3"],"中可选择主题":["107.3"],"项目结构相对复杂":["107.4"],"先简单了解即可":["107.4"],"随之后序学习的深入再逐步为大家介绍":["107.4"],"即可看到预览效果":["107.6"],"ide":["107.7"],"在右上角的设备列表中选择刚刚创建的模拟器":["107.7"],"默认已经选中":["107.7"],"点击运行按钮":["107.7"],"查看模拟器":["107.7"],"按照要求完成注册":["107.8"],"登录即可":["107.8"],"登录成功后":["107.8"],"再次点击运行按钮":["107.8"],"即可将应用运行到真机":["107.8"],"鸿蒙应用开发语言":["107.8"],"因此三者的关系如下图所示":["107.9"],"点击new":["107.13"],"file":["107.13"],"注意":["107.13","107.82"],"文件的后缀为":["107.13"],"之后就可以编写":["107.13"],"代码并运行了":["107.13"],"num":["107.32"],"张三":["107.34"],"李四":["107.34"],"等等":["107.34"],"years":["107.36"],"old":["107.36"],"introduce":["107.37"],"调用父类构造器对继承自父类的属性进行初始化":["107.39"],"在子类中可以使用":["107.39"],"关键字访问继承自父类的属性和方法":["107.39"],"关键字访问父类定义的方法":["107.39"],"修饰的属性或方法是公有的":["107.40"],"可以在任何地方被访问到":["107.40"],"默认所有的属性和方法都是":["107.40"],"am":["107.43"],"之后创建的订单就可以使用":["107.45"],"这个支付方式了":["107.45"],"等概念都可以使用枚举类型定义":["107.48"],"向左移动":["107.49"],"向右移动":["107.49"],"red":["107.50"],"0xff0000":["107.50"],"green":["107.50","107.98"],"0x00ff00":["107.50"],"0x0000ff":["107.50"],"fontsize":["107.50"],"medium":["107.50"],"extralarge":["107.50"],"moduleb":["107.55"],"说明":["107.58"],"用于声明该变量为状态变量":["107.58"],"flexalign":["107.65"],"除去每个组件的专有事件":["107.67"],"还有各组件都支持的通用事件":["107.67"],"通用事件也可通过":["107.67"],"如下图所示":["107.69"],"我们前边所编写的每个页面就相当于是组件树的根节点":["107.69"],"装饰器的作用就是标识该组件为组件树的根节点":["107.69"],"也就是一个页面的入口组件":["107.69"],"light":["107.70","107.107"],"playandpausepage":["107.73"],"fruitpage":["107.76"],"也就是所有元素的key都发生了变化":["107.77"],"ui":["107.77"],"界面更新时需要为每个元素都重新创建组件对象":["107.77"],"即便原有的元素没有发生变化也无法复用之前的组件":["107.77"],"这样一来就导致了性能浪费":["107.77"],"此时我们就可以考虑提供第三个参数":["107.77"],"如下":["107.77"],"常用组件":["107.77"],"须使用":["107.80"],"的返回值也是resource类型":["107.80"],"因此其也可以直接作为":["107.80"],"指的是图片的":["107.80"],"像素位图":["107.80"],"其通常是一个二维数组":["107.80"],"数组中的每个元素对应着图片中的一个像素":["107.80"],"其包含了该像素的颜色等信息":["107.80"],"像素位图主要用于图片编辑的场景":["107.80"],"无需指定具体版本":["107.82"],"系统会自动根据所处环境选择相应版本":["107.82"],"例如上述的":["107.82"],"可通过":["107.82"],"引用":["107.82"],"的值可通过":["107.82"],"attribute":["107.83","107.84","107.89","107.90","107.91","107.123"],"solution":["107.83","107.84","107.87","107.89","107.90","107.91","107.92","107.93","107.96","107.107"],"imageobjectfit":["107.83"],"parameter":["107.87","107.96","107.103","107.110","107.121"],"textparameterpage":["107.87"],"text":["107.89","107.90","107.91"],"fontsizepage":["107.89"],"pages":["107.90","107.96","107.103","107.121","107.123","107.128"],"fontweightpage":["107.90"],"textalignpage":["107.92"],"textoverflowpage":["107.93"],"main":["107.96"],"ets":["107.96","107.128"],"buttonparameter":["107.96"],"buttonattributepage":["107.99"],"event":["107.100","107.107"],"buttoneventpage":["107.100"],"toggleparameter":["107.103"],"toggleattributepage":["107.106"],"textinputparameter":["107.110"],"纯数字输入模式":["107.112"],"效果如下":["107.114"],"textinputattribute":["107.115"],"为最新内容":["107.117"],"textinputevent":["107.118"],"progressparameter":["107.121"],"progress":["107.123"],"progressstyle":["107.123"],"progresscolor":["107.124"],"dialog":["107.128"],"toastpage":["107.128"],"alertdialogpage":["107.130"],"actionsheetpage":["107.133"],"timepickerdialog":["107.136"],"时间滑动选择器弹窗":["107.136"],"customdialogpage":["107.139"],"模块就是通过函数作用域":["109.1"],"把变量和函数进行隔离":["109.1"],"转化成全局作用域":["110.7"],"ontrack":["113.14"],"ontrigger":["113.14"],"调试侦听器的依赖":["113.14"],"参考调试侦听器":["113.14"],"模板语法都会被保留并按原样渲染":["114.6"],"最常见的用例就是显示原始双大括号标签及内容":["114.6"],"onclick2":["115.4"],"changeage":["121.3"],"修改年龄":["121.3"],"showtel":["121.3"],"查看联系方式":["121.3"],"不是响应式的":["121.4"],"是响应式的":["121.4"],"深层次":["121.5"],"层级不深":["121.7"],"都可以":["121.7"],"且层级较深":["121.7"],"推荐使用":["121.7"],"changegender":["121.8"],"修改性别":["121.8"]}]'},t={"0.0":{t:"# 语言基础",p:"",l:"InterviewJS/js.html",a:"语言基础"},"0.1":{t:"语法",p:"",l:"InterviewJS/js.html#语法",a:"语法"},"0.2":{t:"区分大小写",p:"ECMAScript 中一切都是区分大小写的。无论是变量、函数名还是操作符，都区分大小写。换句话说。变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一 ...",l:"InterviewJS/js.html#区分大小写",a:"区分大小写"},"0.3":{t:"标识符",p:`所谓标识符，就是变量、函数、属性或者函数参数的名称。标识符可以由一个或多个下列字符组成：
第一个字符必须是一个字母、下划线(_)或美元符号($)；
剩下的其他字符可以是字母、下划线、美元符号或数字；
 ...`,l:"InterviewJS/js.html#标识符",a:"标识符"},"0.4":{t:"注释",p:`ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。
单行注释以两个斜杠字符(//)开头，如
// 单行注释

块注释以一个斜杠和一个星号(/*)开头，以它们的反向组合(*/)结尾。 ...`,l:"InterviewJS/js.html#注释",a:"注释"},"0.5":{t:"严格模式",p:"ECMAScript 5 新增了严格模式的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。 ...",l:"InterviewJS/js.html#严格模式",a:"严格模式"},"0.6":{t:"关键字和保留字",p:"",l:"InterviewJS/js.html#关键字和保留字",a:"关键字和保留字"},"0.7":{t:"关键字",p:`break 	do		in		typeof		case		else		instanceof
var		catch		export		new		void		class		extends
return		 ...`,l:"InterviewJS/js.html#关键字",a:"关键字"},"0.8":{t:"保留字",p:`ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束， 或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。
`,l:"InterviewJS/js.html#保留字",a:"保留字"},"0.9":{t:"始终保留",p:`enum

`,l:"InterviewJS/js.html#始终保留",a:"始终保留"},"0.10":{t:"严格模式下保留",p:`implements		interface		let		package		protected
private		public		static

`,l:"InterviewJS/js.html#严格模式下保留",a:"严格模式下保留"},"0.11":{t:"模块代码中保留",p:`await

`,l:"InterviewJS/js.html#模块代码中保留",a:"模块代码中保留"},"0.12":{t:"变量",p:"ECMAScript 中有 3 个关键字可以声明变量：var、const 和let。其中var在 ECMAScript 的所有版本中都可以使用，而const和let只能在 ECMAScript 6 及 ...",l:"InterviewJS/js.html#变量",a:"变量"},"0.13":{t:"var 关键字",p:`要定义变量，可以使用 var 操作符（注意var是一个关键字），后跟变量名（即标识符）
var message
var message = 'hi'
message = 'hi' // 合法，但不推荐 ...`,l:"InterviewJS/js.html#var-关键字",a:"var-关键字"},"0.14":{t:"var 声明作用域",p:`使用var操作符定义的变量会成为包含它的函数的局部变量。比如，使用var在一个函数内部定义了一个变量，就意味着该变量将在函数退出时被销毁
function test() {
  var message ...`,l:"InterviewJS/js.html#var-声明作用域",a:"var-声明作用域"},"0.15":{t:"var 声明提升",p:`使用var时，下面的代码不会报错。这是因为使用了这个关键字声明的变量会自动提升到函数的作用域顶部：
function foo() {
  console.log(age)
  var age = 26 ...`,l:"InterviewJS/js.html#var-声明提升",a:"var-声明提升"},"0.16":{t:"let 声明",p:`let和var的作用差不多，但是有着非常重要的区别。最明显的区别就是，let声明的范围是块作用域，而var声明的范围是函数作用域。
if (true) {
  var name = 'Matt'
   ...`,l:"InterviewJS/js.html#let-声明",a:"let-声明"},"0.17":{t:"1. 暂时性死区",p:`let与var的另一个重要区别，就是let声明的变量不会在作用域中被提升。
// name 会被提升
console.log(name) // undefined
var name = 'Matt'
 ...`,l:"InterviewJS/js.html#_1-暂时性死区",a:"_1-暂时性死区"},"0.18":{t:"2. 全局声明",p:`与var关键字不同，使用 let在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)
var name = 'Matt'
console.log(window.name ...`,l:"InterviewJS/js.html#_2-全局声明",a:"_2-全局声明"},"0.19":{t:"3. 条件声明",p:`因为 let是块级作用域，所以不可能检查前面是否声明过同名变量，同时也就不可能在没有声明的情况下去声明它，因此不能依赖条件声明模式
`,l:"InterviewJS/js.html#_3-条件声明",a:"_3-条件声明"},"0.20":{t:"for 循环中的 let",p:`在let出现之前，for循环定义的迭代变量会渗透到循环体外部。改用let之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部
for (var i = 0; i &lt; 5; ++ ...`,l:"InterviewJS/js.html#for-循环中的-let",a:"for-循环中的-let"},"0.21":{t:"const 声明",p:`const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误
const age = 26
age = 36 // Typ ...`,l:"InterviewJS/js.html#const-声明",a:"const-声明"},"0.22":{t:"声明风格及最佳实践",p:`
不使用 var
const 优先，let 次之

`,l:"InterviewJS/js.html#声明风格及最佳实践",a:"声明风格及最佳实践"},"0.23":{t:"数据类型",p:`ECMAScript 有两大数据类型
基本数据类型(原始数据类型)：Undefined、Null、Boolean、Number、String、Symbol
复杂数据类型：Object
`,l:"InterviewJS/js.html#数据类型",a:"数据类型"},"0.24":{t:"typeof 操作符",p:`因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 会返回下列字符串之一：

&quot;unde ...`,l:"InterviewJS/js.html#typeof-操作符",a:"typeof-操作符"},"0.25":{t:"Undefined 类型",p:`Undefined 类型只有一个值，就是特殊值undefined。当 var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值
注意：包含 undefined值的变量跟未定义变 ...`,l:"InterviewJS/js.html#undefined-类型",a:"undefined-类型"},"0.26":{t:"Null 类型",p:`Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给 typeof传一个null会返回&quot;object&quot;的原因。
在定义一个将来要保存对象值 ...`,l:"InterviewJS/js.html#null-类型",a:"null-类型"},"0.27":{t:"Boolean 类型",p:`Boolean类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true和false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。
注意：布尔值字面量 ...`,l:"InterviewJS/js.html#boolean-类型",a:"boolean-类型"},"0.28":{t:"布尔值和不同类型之间的转换规则",p:`


数据类型
转换为 true 的值
转换为 false 的值




Boolean
true
false


String
非空字符串
&quot;&quot;(空字符串)


Number
非 ...`,l:"InterviewJS/js.html#布尔值和不同类型之间的转换规则",a:"布尔值和不同类型之间的转换规则"},"0.29":{t:"Number 类型",p:`Number类型使用 IEEE 754格式表示正式和浮点数(在某些语言中也叫双精度值)、不同的数值类型相应地也有不同的数值字面量格式。
`,l:"InterviewJS/js.html#number-类型",a:"number-类型"},"0.30":{t:"数值字面量格式",p:`十进制： 直接写出来即可
八进制： 对于八进制字面量，第一个数字必须是零(0)，然后是相应的八进制数字(0-7)。如果字面量中包含的数字超出了应有的范围，就回忽略前缀的 0，后面的数字被当做十进制
十 ...`,l:"InterviewJS/js.html#数值字面量格式",a:"数值字面量格式"},"0.31":{t:"浮点值",p:`要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。
let floatNumber1 = 1.1
let floatNumber2 = 0 ...`,l:"InterviewJS/js.html#浮点值",a:"浮点值"},"0.32":{t:"值的范围",p:"ECMAScript可以保存的最小数值保存在Number.MIN_VALUE中，这个值多数浏览器是5e-324，可以保存的最小数值保存在Number.MAX_VALUE中，这个值多数浏览器是1.797 ...",l:"InterviewJS/js.html#值的范围",a:"值的范围"},"0.33":{t:"NaN",p:"有一个特殊的值叫&quot;NaN&quot;，意思是&quot;不是数值&quot;(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。在 ECMAScript 中， ...",l:"InterviewJS/js.html#nan",a:"nan"},"0.34":{t:"数值转换",p:`有 3 个函数可以将非数值转换为数值：Number()、parseInt()、parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转化为数值。
Numb ...`,l:"InterviewJS/js.html#数值转换",a:"数值转换"},"0.35":{t:"String 类型",p:"String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(&quot;)、单引号(')或反引号(`)标示。必须成对出现，否则会导致语法错误。\n",l:"InterviewJS/js.html#string-类型",a:"string-类型"},"0.36":{t:"字符字面量",p:`字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符



字面量
含义




\\n
换行


\\t
制表


\\b
退格


\\r
回车


\\f
换页


\\\\
反斜杠()

 ...`,l:"InterviewJS/js.html#字符字面量",a:"字符字面量"},"0.37":{t:"字符串的特点",p:`字符串是不可变的，意思就是一旦创建，他们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。
`,l:"InterviewJS/js.html#字符串的特点",a:"字符串的特点"},"0.38":{t:"转换为字符串",p:`有两种方式将一个值转换为字符串。一个是toString()，一个是直接在后面加空串&quot;&quot;
数值调用toString()时，可以传入一个参数作为底数，默认情况下返回的是十进制
`,l:"InterviewJS/js.html#转换为字符串",a:"转换为字符串"},"0.39":{t:"模板字面量",p:`ECMAScript 6新增了模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以夸行定义字符串。
let str = \`first line
second line\`
 ...`,l:"InterviewJS/js.html#模板字面量",a:"模板字面量"},"0.40":{t:"字符串插值",p:"模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个 值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的 是字符串 ...",l:"InterviewJS/js.html#字符串插值",a:"字符串插值"},"0.41":{t:"模板字面量标签函数",p:`模板字面量也支持定义标签函数(tag function)，而通过标签函数可以自定义插值行为。标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。
标签函数本身是一个常规函数，通过前缀到模板 ...`,l:"InterviewJS/js.html#模板字面量标签函数",a:"模板字面量标签函数"},"0.42":{t:"原始字符串",p:`使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数:
`,l:"InterviewJS/js.html#原始字符串",a:"原始字符串"},"0.43":{t:"Symbol 类型",p:`Symbol(符号)是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的风险。
`,l:"InterviewJS/js.html#symbol-类型",a:"symbol-类型"},"0.44":{t:"符号的基本使用",p:`符号需要使用Symbol()函数初始化，因为符号本身是基本类型，所以typeof操作符对符号返回symbol
let symbol = Symbol()

注意： Symbol()函数不能与 new  ...`,l:"InterviewJS/js.html#符号的基本使用",a:"符号的基本使用"},"0.45":{t:"使用全局符号注册表",p:`如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。
Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全 ...`,l:"InterviewJS/js.html#使用全局符号注册表",a:"使用全局符号注册表"},"0.46":{t:"使用符号作为属性",p:"凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 Object.defineProperty()/Object.defineProperties()定义的属性。对象字 ...",l:"InterviewJS/js.html#使用符号作为属性",a:"使用符号作为属性"},"0.47":{t:"常用内置符号",p:"ECMAScript 6 也引入了一批常用内置符号(well-known symbol)，用于暴露语言内部行为，开发者 可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串 ...",l:"InterviewJS/js.html#常用内置符号",a:"常用内置符号"},"0.48":{t:"Symbol.asyncIterator",p:"",l:"InterviewJS/js.html#symbol-asynciterator",a:"symbol-asynciterator"},"0.49":{t:"Symbol.hasInstance",p:"",l:"InterviewJS/js.html#symbol-hasinstance",a:"symbol-hasinstance"},"0.50":{t:"Symbol.isConcatSpreadable",p:"",l:"InterviewJS/js.html#symbol-isconcatspreadable",a:"symbol-isconcatspreadable"},"0.51":{t:"Symbol.iterator",p:"",l:"InterviewJS/js.html#symbol-iterator",a:"symbol-iterator"},"0.52":{t:"Symbol.match",p:"",l:"InterviewJS/js.html#symbol-match",a:"symbol-match"},"0.53":{t:"Symbol.replace",p:"",l:"InterviewJS/js.html#symbol-replace",a:"symbol-replace"},"0.54":{t:"Symbol.search",p:"",l:"InterviewJS/js.html#symbol-search",a:"symbol-search"},"0.55":{t:"Symbol.species",p:"",l:"InterviewJS/js.html#symbol-species",a:"symbol-species"},"0.56":{t:"Symbol.split",p:"",l:"InterviewJS/js.html#symbol-split",a:"symbol-split"},"0.57":{t:"Symbol.toPrimitive",p:"",l:"InterviewJS/js.html#symbol-toprimitive",a:"symbol-toprimitive"},"0.58":{t:"Symbol.toStringTag",p:"",l:"InterviewJS/js.html#symbol-tostringtag",a:"symbol-tostringtag"},"0.59":{t:"Symbol.unscopables",p:`80 页
`,l:"InterviewJS/js.html#symbol-unscopables",a:"symbol-unscopables"},"0.60":{t:"Object 类型",p:`每个 Object 实例都有如下属性和方法：

constructor：用于创建当前对象的函数。
hasOwnProperty(propertyName)：用于判断当前对象实例(不是原型)上是否存在给 ...`,l:"InterviewJS/js.html#object-类型",a:"object-类型"},"0.61":{t:"操作符",p:"",l:"InterviewJS/js.html#操作符",a:"操作符"},"0.62":{t:"一元操作符",p:`只操作一个值的操作符叫一元操作符(unary operator)。一元操作符是 ECMAScript 中最简单的操作符。
`,l:"InterviewJS/js.html#一元操作符",a:"一元操作符"},"0.63":{t:"递增/递减操作符",p:`递增和递减操作符有两个版本：前缀版和后缀版。
两个版本的区别是后缀版的递增和递减在语句被求值后才发生。
这 2 对操作符可以用作于任何值，意思就是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。 ...`,l:"InterviewJS/js.html#递增-递减操作符",a:"递增-递减操作符"},"0.64":{t:"一元加和减",p:`一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号(+)表示，放在变量前头，对数值没有任何影响。
一元减由一个减号(-)表示，放在变 ...`,l:"InterviewJS/js.html#一元加和减",a:"一元加和减"},"0.65":{t:"位操作符",p:`正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位(称为第 0 位)表示 20，第二位表示 21，依此类推。
负值以一种称为二补数(或补码)的二进制编码存储。一个数值的二补数通 ...`,l:"InterviewJS/js.html#位操作符",a:"位操作符"},"0.66":{t:"按位非",p:`按位非操作符用波浪符(~)表示，它的作用是返回数值的一补数。
let num1 = 25 // 二进制00000000000000000000000000011001
let num2 = ~num1 ...`,l:"InterviewJS/js.html#按位非",a:"按位非"},"0.67":{t:"按位与",p:`按位与操作符用和号(&amp;)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作。



第一个数值的位
第二个数值的位
结果




 ...`,l:"InterviewJS/js.html#按位与",a:"按位与"},"0.68":{t:"按位或",p:`按位或操作符用管道符(|)表示，同样有两个操作数。按位或遵循如下真值表:



第一个数值的位
第二个数值的位
结果




1
1
1


1
0



0
1
1


0
0
0



按位异或
 ...`,l:"InterviewJS/js.html#按位或",a:"按位或"},"0.69":{t:"左移",p:`左移操作符用两个小于号(&lt;&lt;)表示，会按照指定的位数将数值的所有位向左移动。
`,l:"InterviewJS/js.html#左移",a:"左移"},"0.70":{t:"有符号右移",p:`有符号右移由两个大于号(&gt;&gt;)表示，会将数值的所有 32 位都向右移，同时保留符号(正或负)。 有符号右移实际上是左移的逆运算。
`,l:"InterviewJS/js.html#有符号右移",a:"有符号右移"},"0.71":{t:"无符号右移",p:`无符号右移用 3 个大于号表示(&gt;&gt;&gt;)，会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。
对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会 ...`,l:"InterviewJS/js.html#无符号右移",a:"无符号右移"},"0.72":{t:"布尔操作符",p:"",l:"InterviewJS/js.html#布尔操作符",a:"布尔操作符"},"0.73":{t:"逻辑非",p:`逻辑非操作符由一个叹号(!)表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布 尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。
逻辑非操作 ...`,l:"InterviewJS/js.html#逻辑非",a:"逻辑非"},"0.74":{t:"逻辑与",p:`逻辑与操作符由两个和号(&amp;&amp;)表示，应用到两个值。
逻辑与操作符遵循如下真值表



第一个操作数
第二个操作数
结果




true
true
true


true
false
 ...`,l:"InterviewJS/js.html#逻辑与",a:"逻辑与"},"0.75":{t:"逻辑或",p:`逻辑或操作符由两个管道符(||)表示
逻辑或操作符遵循如下真值表



第一个操作数
第二个操作数
结果




true
true
true


true
false
true


false
tr ...`,l:"InterviewJS/js.html#逻辑或",a:"逻辑或"},"0.76":{t:"乘性操作符",p:`ECMAScript 定义了 3 个乘性操作符:乘法、除法和取模
`,l:"InterviewJS/js.html#乘性操作符",a:"乘性操作符"},"0.77":{t:"乘法操作符",p:`乘法操作符由一个星号(*)表示，可以用于计算两个数值的乘积。
特殊值处理

如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 E ...`,l:"InterviewJS/js.html#乘法操作符",a:"乘法操作符"},"0.78":{t:"除法运算符",p:`除法操作符由一个斜杠(/)表示，可以用于计算第一个操作数除以第二个操作数的商
特殊值处理

如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负 ...`,l:"InterviewJS/js.html#除法运算符",a:"除法运算符"},"0.79":{t:"取模运算符",p:`取模(余数)操作符由一个百分比符号(%)表示
特殊值处理

如果操作数是数值，则执行常规除法运算，返回余数。
如果被除数是无限值，除数是有限值，则返回 NaN。
如果被除数是有限值，除数是 0，则返回 ...`,l:"InterviewJS/js.html#取模运算符",a:"取模运算符"},"0.80":{t:"指数操作符",p:`ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**
不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作
let square ...`,l:"InterviewJS/js.html#指数操作符",a:"指数操作符"},"0.81":{t:"加性操作符",p:`加性操作符，即加法和减法操作符
`,l:"InterviewJS/js.html#加性操作符",a:"加性操作符"},"0.82":{t:"加法操作符",p:`加法操作符(+)用于求两个数的和
两个操作数都是数值执行规则

如果有任一操作数是 NaN，则返回 NaN;
如果是 Infinity 加 Infinity，则返回 Infinity;
如果是-Inf ...`,l:"InterviewJS/js.html#加法操作符",a:"加法操作符"},"0.83":{t:"减法操作符",p:`减法操作符(-)也是使用很频繁的一种操作符。
计算规则

如果两个操作数都是数值，则执行数学减法运算并返回结果。
如果有任一操作数是 NaN，则返回 NaN。
如果是 Infinity 减 Infin ...`,l:"InterviewJS/js.html#减法操作符",a:"减法操作符"},"0.84":{t:"关系操作符",p:`关系操作符执行比较两个值的操作，包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)
执行规则

如果操作数都是数值，则执行数值比较。
如果操作数都是字符串，则逐个比 ...`,l:"InterviewJS/js.html#关系操作符",a:"关系操作符"},"0.85":{t:"相等操作符",p:`第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换
`,l:"InterviewJS/js.html#相等操作符",a:"相等操作符"},"0.86":{t:"等于和不等于",p:"ECMAScript 中的等于操作符用两个等于号(==)表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号(!=)表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进 ...",l:"InterviewJS/js.html#等于和不等于",a:"等于和不等于"},"0.87":{t:"全等和不全等",p:`全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号(===)表示，只有两个操作数在不转换的前提下相等才返回 true
不全等操作符用一个叹号和两 ...`,l:"InterviewJS/js.html#全等和不全等",a:"全等和不全等"},"0.88":{t:"条件操作符",p:` variable = boolean_expression ? true_value : false_value;

上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expressi ...`,l:"InterviewJS/js.html#条件操作符",a:"条件操作符"},"0.89":{t:"赋值操作符",p:`简单赋值用等于号(=)表示，将右手边的值赋给左手边的变量
复合赋值操作符

乘后赋值(*=)
除后赋值(/=)
取模后赋值(%=)
加后赋值(+=)
减后赋值(-=)
左移后赋值(&lt;&lt;=) ...`,l:"InterviewJS/js.html#赋值操作符",a:"赋值操作符"},"0.90":{t:"逗号操作符",p:`逗号操作符可以用来在一条语句中执行多个操作，如下所示:
let num1 = 1,
  num2 = 2,
  num3 = 3

也可以使用逗号操作符来辅助 赋值。在赋值时使用逗号操作符分隔值，最终 ...`,l:"InterviewJS/js.html#逗号操作符",a:"逗号操作符"},"0.91":{t:"语句(后续整理)",p:`P98
`,l:"InterviewJS/js.html#语句-后续整理",a:"语句-后续整理"},"1.0":{t:"# 1. 谈谈你对 Vue 的理解？",p:`官方：Vue是一套用于构架用户界面的渐进式框架，Vue 的核心库只关注视图层
!image-20240313101558411
`,l:"InterviewVue/01.谈谈你对Vue的理解.html",a:"_1-谈谈你对-vue-的理解"},"1.1":{t:"1.1 声明式框架",p:`Vue 的核心特点，用起来简单。那我们就有必要知道命令式和声明式的区别

早在 JQ 的时代，编写的代码都是命令式的，命令式框架重要特点就是关注过程
声明式框架更加关注结果。命令式的代码封装到了 Vu ...`,l:"InterviewVue/01.谈谈你对Vue的理解.html#_1-1-声明式框架",a:"_1-1-声明式框架"},"1.2":{t:"1.2 MVVM 模式",p:`说起 mvvm，就要知道另一个东西叫 MVC。为什么要有这些模式呢？
目的：职责划分、分层管理
!image-20240313103948553

对于前端而言就是如何将数据同步到页面上，也就是借鉴后 ...`,l:"InterviewVue/01.谈谈你对Vue的理解.html#_1-2-mvvm-模式",a:"_1-2-mvvm-模式"},"1.3":{t:"1.3 采用虚拟 DOM",p:`传统更新页面，拼接一个完整的字符串 innerHTML 全部重新渲染，添加虚拟 DOM 后，可以比较新旧虚拟节点，找到变化再进行更新。虚拟 DOM 就是一个对象，用来描述真实 DOM 的
github ...`,l:"InterviewVue/01.谈谈你对Vue的理解.html#_1-3-采用虚拟-dom",a:"_1-3-采用虚拟-dom"},"1.4":{t:"1.4 区分编译(打包)时和运行(浏览器)时",p:`
Vue 的渲染核心就是调用渲染(render)方法将虚拟 DOM 渲染成真实 DOM(缺点就是虚拟 DOM 编写麻烦)
专门写个编译时可以将模板编译成虚拟 DOM(在构建的时候进行编译性能更高，不需 ...`,l:"InterviewVue/01.谈谈你对Vue的理解.html#_1-4-区分编译-打包-时和运行-浏览器-时",a:"_1-4-区分编译-打包-时和运行-浏览器-时"},"1.5":{t:"1.5 组件化",p:`实现高内聚、低耦合、单向数据流

组件化开发能大幅提高应用开发效率、测试性、复用性等；
降低更新范围，只重新渲染变化的组件

`,l:"InterviewVue/01.谈谈你对Vue的理解.html#_1-5-组件化",a:"_1-5-组件化"},"2.0":{t:"# 2. 谈谈你对 SPA 的理解",p:"",l:"InterviewVue/02.谈谈你对spa的理解.html",a:"_2-谈谈你对-spa-的理解"},"2.1":{t:"1.1 理解基本概念",p:`
SPA(Single Page Application)单页应用，默认情况下我们编写 Vue、React 都只有一个 html 页面，并且提供一个挂载点，最终打包后会在此页面中引入对应的资源。(页面 ...`,l:"InterviewVue/02.谈谈你对spa的理解.html#_1-1-理解基本概念",a:"_1-1-理解基本概念"},"2.2":{t:"1.2 优缺点",p:`



单页面应用 SPA
多页面应用 MPA




组成
一个主页面和页面组件
多个完整的页面


刷新方式
局部刷新
整页刷新


SEO 搜索引擎优化
无法实现
容易实现


页面切换
速度快 ...`,l:"InterviewVue/02.谈谈你对spa的理解.html#_1-2-优缺点",a:"_1-2-优缺点"},"2.3":{t:"1.3 解决方案",p:`
静态页面预渲染(Static Site Generation)SSG，在构建时生成完整的 html 页面。(就是在打包的时候，先将页面放到浏览器中运行一下，将 HTML 保存起来)，仅适合静态页面网 ...`,l:"InterviewVue/02.谈谈你对spa的理解.html#_1-3-解决方案",a:"_1-3-解决方案"},"3.0":{t:"# 3.Vue为什么需要虚拟DOM.md",p:"",l:"InterviewVue/03.Vue为什么需要虚拟DOM.html",a:"_3-vue为什么需要虚拟dom-md"},"3.1":{t:"1.1 基本概念",p:`
基本所有框架都引入了虚拟 DOM 来对真实的 DOM 进行抽象，也就是现在大家所熟知的 VNode 和 VDOM


Virtual DOM 就是用 js 对象来描述真实 DOM，是对真实 DOM  ...`,l:"InterviewVue/03.Vue为什么需要虚拟DOM.html#_1-1-基本概念",a:"_1-1-基本概念"},"3.2":{t:"1.2补充：VDOM 是如何生成的",p:`
在 vue 中我们常常回味组件编写模板- template
这个模板会被编译器编译为渲染函数 - Render
在接下来的挂载过程中会调用 render 函数，返回的对象就是虚拟 DOM
会在后续的 ...`,l:"InterviewVue/03.Vue为什么需要虚拟DOM.html#_1-2补充-vdom-是如何生成的",a:"_1-2补充-vdom-是如何生成的"},"3.3":{t:"1.3 再次补充：VDOM 如何做 diff",p:`
挂载过程结束后，会记录第一次生成的 VDOM - oldVNode
当响应式数据发生变化时，将会引起组件刷新 render，此时就会生成新的 VDOM - newVNode
使用 oldVNode  ...`,l:"InterviewVue/03.Vue为什么需要虚拟DOM.html#_1-3-再次补充-vdom-如何做-diff",a:"_1-3-再次补充-vdom-如何做-diff"},"4.0":{t:"# 4. 谈谈对 Vue 组件化的理解",p:`
WebComponent组件化的核心组成：模板、属性、事件、插槽、生命周期

组件化好处：高聚合、可重用、可组合

组件化开发能大幅提高应用的开发效率、测试性、复用性等
降低更新范围，只重新渲染变化 ...`,l:"InterviewVue/04.谈谈对Vue组件化的理解.html",a:"_4-谈谈对-vue-组件化的理解"},"4.1":{t:"补充：",p:`
vue 中的每一个组件都有一个渲染函数 watcher、effect
数据是响应式的，数据变化后执行 watcher 或者 effect
组件要合理的划分，如果不拆分组件，那更新的时候整个页面都要重 ...`,l:"InterviewVue/04.谈谈对Vue组件化的理解.html#补充",a:"补充"},"5.0":{t:"# 5.既然 Vue 通过数据劫持可以精确探测数据变化，为什么还要虚拟 DOM 进行 diff 检测差异？",p:"Vue 内部设计原因导致。vue 设计的是每个组件一个 watcher(渲染 watcher)，没有采用一个属性对应一个 watcher，这样会导致大量 watcher 的产生而且看浪费内存，如果粒度 ...",l:"InterviewVue/05.为什么需要虚拟DOM进行diff检测差异.html",a:"_5-既然-vue-通过数据劫持可以精确探测数据变化-为什么还要虚拟-dom-进行-diff-检测差异"},"6.0":{t:"# 6.请说一下你对响应式的理解.md",p:"",l:"InterviewVue/06.请说一下你对响应式的理解.html",a:"_6-请说一下你对响应式的理解-md"},"6.1":{t:"1.1 如何实现响应式数据",p:"数组和对象类型当值变化时如何劫持到。对象内部通过 defineReactive 方法，使用Object.defineProperty将属性进行劫持(只会劫持已经存在的属性)，数组则是通过重写数组的方法 ...",l:"InterviewVue/06.请说一下你对响应式的理解.html#_1-1-如何实现响应式数据",a:"_1-1-如何实现响应式数据"},"6.2":{t:"1.2 Vue2 处理缺陷",p:`
在 Vue2 的时候使用 defineProperty来进行数据的劫持，需要对属性进行重写添加 getter 及 setter 性能差
当新增属性和删除属性时无法边控变化。需要通过$set、$del ...`,l:"InterviewVue/06.请说一下你对响应式的理解.html#_1-2-vue2-处理缺陷",a:"_1-2-vue2-处理缺陷"},"6.3":{t:"1.3 Vue2 与 Vue3 实现对比",p:`Vue2
let obj = { name: 'jw', age: 18 }
function observer (data) {
    if (typeof data !== 'object' | ...`,l:"InterviewVue/06.请说一下你对响应式的理解.html#_1-3-vue2-与-vue3-实现对比",a:"_1-3-vue2-与-vue3-实现对比"},"7.0":{t:"# 7. Vue 中如何检测数组变化",p:"",l:"InterviewVue/07.Vue中如何检测数组变化.html",a:"_7-vue-中如何检测数组变化"},"7.1":{t:"1.1 实现数组劫持",p:`
数组考虑性能的原因没有用defineProperty对数组的每一项进行拦截，而是选择重写数组(push、shift、pop、splice、unshift、sort、reverse)方法
数组中如果是 ...`,l:"InterviewVue/07.Vue中如何检测数组变化.html#_1-1-实现数组劫持",a:"_1-1-实现数组劫持"},"7.2":{t:"1.2 数组的缺点",p:`
数组的索引和长度变化是无法监控的

`,l:"InterviewVue/07.Vue中如何检测数组变化.html#_1-2-数组的缺点",a:"_1-2-数组的缺点"},"8.0":{t:"# 8.Vue 中如何进行依赖收集",p:"",l:"InterviewVue/08.Vue 中如何进行依赖收集.html",a:"_8-vue-中如何进行依赖收集"},"8.1":{t:"1.1 依赖收集流程",p:`
每个属性都拥有自己的 dep 属性，存放它所依赖的 watcher，当属性变化后会通知自己对应的 watcher 去更新
默认在初始化时会调用 render 函数，此时会触发属性依赖收集 dep.d ...`,l:"InterviewVue/08.Vue 中如何进行依赖收集.html#_1-1-依赖收集流程",a:"_1-1-依赖收集流程"},"8.2":{t:"1.2 Vue3 依赖收集",p:`
Vue3 中会通过 Map 结构将属性和 effect 映射起来
默认在初始化时会调用 render 函数，此时会触发依赖收集 track
当属性发生修改时会找对应的 effect 列表依次执行tr ...`,l:"InterviewVue/08.Vue 中如何进行依赖收集.html#_1-2-vue3-依赖收集",a:"_1-2-vue3-依赖收集"},"9.0":{t:"# 9. Vue.set方法是如何实现的",p:`Vue不允许在已经创建的实例上动态添加新的响应式属性
export function set (target, key, val) {
    // 1. 是开发环境 target 没定义或者是基础类 ...`,l:"InterviewVue/09.Vue.set方法是如何实现的.html",a:"_9-vue-set方法是如何实现的"},"10.0":{t:"# 10.v-if和 v-show的怎么理解",p:"",l:"InterviewVue/10.v-if和 v-show的优先级.html",a:"_10-v-if和-v-show的怎么理解"},"10.1":{t:"1.1 基本概念",p:`
v-if 如果条件不成立不会渲染当前指令所在节点的 DOM 元素
v-show 只是切换当前 dom 的显示或者隐藏

`,l:"InterviewVue/10.v-if和 v-show的优先级.html#_1-1-基本概念",a:"_1-1-基本概念"},"10.2":{t:"1.2 效果展示",p:`Vue Template Explorer (vuejs.org)
Vue Template Explorer (vuejs.org)
`,l:"InterviewVue/10.v-if和 v-show的优先级.html#_1-2-效果展示",a:"_1-2-效果展示"},"10.3":{t:"1.3 如何选择",p:`
v-if可以阻断内部代码是否执行，如果条件不成立不会执行内部逻辑
如果页面逻辑在第一次加载的时候已经被确认后续不会频繁更改则采用 v-if

`,l:"InterviewVue/10.v-if和 v-show的优先级.html#_1-3-如何选择",a:"_1-3-如何选择"},"11.0":{t:"# 11. Watch&computed",p:`Vue2中有三种 watcher(渲染 watcher、计算属性 watcher、用户 watcher)
Vue3 中有三种 effect(渲染 effect、计算属性 effect、用户 effec ...`,l:"InterviewVue/11.watch&computed.html",a:"_11-watch-computed"},"11.1":{t:"1.1 computed",p:`
计算属性仅当用户取值时才会执行对应的方法
computed属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重新执行。
计算属性可以简化模板中的复杂表达式
计算属性中不支持异步逻辑
c ...`,l:"InterviewVue/11.watch&computed.html#_1-1-computed",a:"_1-1-computed"},"11.2":{t:"1.2 watch",p:`watch 则是监控值的变化，当值发生变化时调用对应的回调函数。经常用于监控某个值的变化，进行一些操作。(异步要注意静态问题)

Vue3提供了 onCleanUp 函数，让用户方便使用也解决了清理问 ...`,l:"InterviewVue/11.watch&computed.html#_1-2-watch",a:"_1-2-watch"},"11.3":{t:"1.3 源码剖析",p:"",l:"InterviewVue/11.watch&computed.html#_1-3-源码剖析",a:"_1-3-源码剖析"},"12.0":{t:"# 解释 ref 和 reactive 区别？",p:"",l:"InterviewVue/12.解释 ref和reactive区别.html",a:"解释-ref-和-reactive-区别"},"12.1":{t:"1.1 基本概念",p:`ref 和 reactive 是 Vue3 数据响应式中非常重要的两个概念

reactive 用于处理对象类型的数据响应。底层采用的是 new Proxy()
ref 通常用于处理单值的响应式，re ...`,l:"InterviewVue/12.解释 ref和reactive区别.html#_1-1-基本概念",a:"_1-1-基本概念"},"12.2":{t:"1.2 源码实现",p:"",l:"InterviewVue/12.解释 ref和reactive区别.html#_1-2-源码实现",a:"_1-2-源码实现"},"13.0":{t:"# 13.watch 和 watchEffect 的区别",p:`
watchEffect 立即运行一个函数，然后被动地追踪它的依赖，当这些依赖改变时重新执行该函数
watch 侦测一个或多个响应式数据源并在数据源变化时调用一个回调函数。

const effect ...`,l:"InterviewVue/13.watch和watchEffect的区别.html",a:"_13-watch-和-watcheffect-的区别"},"14.0":{t:"#  如何将 template 转化成 render 函数",p:`Vue 中含有模板编译的功能，它的主要作用是将用户编写的 template 编译为 js 中可执行的 render 函数

将 template 模板转换成 ast 语法树- parseHTML
将静 ...`,l:"InterviewVue/14.如何将template转化成render函数.html",a:"如何将-template-转化成-render-函数"},"15.0":{t:"# 15. new Vue()这个过程中究竟做了什么",p:`
在 new Vue 的时候，内部会进行初始化操作
内部会初始化组件绑定的事件，初始化组件的父子关系$parent $children $root
初始化响应式数据 data、computed、wat ...`,l:"InterviewVue/15.new Vue()这个过程中究竟做了什么.html",a:"_15-new-vue-这个过程中究竟做了什么"},"16.0":{t:"# 16. Vue.observable 你有了解过吗.md",p:`Vue2.6 新增的一个 API，用于讲一个数据变成响应式的
在父子组件通信时，可以使用 eventBus 或者使用状态管理工具，但是功能不复杂的时候，我们可以考虑使用Vue.observable
`,l:"InterviewVue/16.Vue.observable你有了解过吗.html",a:"_16-vue-observable-你有了解过吗-md"},"17.0":{t:"# 17. v-if 和 v-for 哪个优先级更高",p:`v-for 和 v-if 避免在同一个标签中使用，如果遇到需要同事使用时可以考虑写成计算属性的方式。
&lt;!--应当避免这种写法 --&gt;
&lt;li v-for=&quot;i in ar ...`,l:"InterviewVue/17.v-if和v-for哪个优先级更高.html",a:"_17-v-if-和-v-for-哪个优先级更高"},"18.0":{t:"# 18. 生命周期有哪些",p:"",l:"InterviewVue/18.生命周期有哪些.html",a:"_18-生命周期有哪些"},"18.1":{t:"1.1 Vue2 中的生命周期",p:`主要的生命周期：创建前后、挂载前后、更新前后、销毁前后

beforeCreate 初始化父子关系及事件，数据观测(data Observer)之前被调用，用此方法一般编写插件的时候会用到
creat ...`,l:"InterviewVue/18.生命周期有哪些.html#_1-1-vue2-中的生命周期",a:"_1-1-vue2-中的生命周期"},"18.2":{t:"1.2 V2 和 V3 中的生命周期对比",p:`


生命周期 V2
生命周期 V3
描述




beforeCreate
beforeCreate
组件实例被创建之初


created
created
组件实例已经完全创建


beforeM ...`,l:"InterviewVue/18.生命周期有哪些.html#_1-2-v2-和-v3-中的生命周期对比",a:"_1-2-v2-和-v3-中的生命周期对比"},"19.0":{t:"# 19. Vue 中 diff 算法原理",p:"",l:"InterviewVue/19.Vue中diff算法原理.html",a:"_19-vue-中-diff-算法原理"},"19.1":{t:"1.1 Diff 概念",p:`vue 基于虚拟 DOM 做更新。diff 的核心就比较两个虚拟节点的差异。Vue 的 diff 算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式 + 双指针的方式进行比较。
`,l:"InterviewVue/19.Vue中diff算法原理.html#_1-1-diff-概念",a:"_1-1-diff-概念"},"19.2":{t:"1.2 Diff 比较流程",p:`
先比较是否是相同节点 key tag
相同节点比较属性，并复用老节点(将老的虚拟 DOM 复用给新的虚拟节点 DOM)
比较儿子节点，考虑老节点和新节点儿子的情况

老的没儿子，现在有儿子。直接插入 ...`,l:"InterviewVue/19.Vue中diff算法原理.html#_1-2-diff-比较流程",a:"_1-2-diff-比较流程"},"20.0":{t:"# 20. 请说明 Vue 中 key 的作用和原理，谈谈你对它的理解",p:"",l:"InterviewVue/20.请说明Vue中key的作用和原理.html",a:"_20-请说明-vue-中-key-的作用和原理-谈谈你对它的理解"},"20.1":{t:"1.1 key 的概念",p:`
key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNode。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能地尝试就地 ...`,l:"InterviewVue/20.请说明Vue中key的作用和原理.html#_1-1-key-的概念",a:"_1-1-key-的概念"},"20.2":{t:"1.2 key 的作用",p:`
Vue 在 patch 过程中通过 key 可以判断两个虚拟节点是否是相同节点。(可以复用老节点)
无 key 会导致更新的时候出问题
尽量不要采用索引作为 key

!image-20240314 ...`,l:"InterviewVue/20.请说明Vue中key的作用和原理.html#_1-2-key-的作用",a:"_1-2-key-的作用"},"21.0":{t:"# 21.Vue.use 是干什么的",p:"",l:"InterviewVue/21.Vue.use是干什么的.html",a:"_21-vue-use-是干什么的"},"21.1":{t:"1.1 use 概念",p:"安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入，这样插件中就 ...",l:"InterviewVue/21.Vue.use是干什么的.html#_1-1-use-概念",a:"_1-1-use-概念"},"21.2":{t:"1.2 插件的功能",p:`
添加全局指令、全局过滤器、全局组件
通过全局混入来添加一些组件选项
添加 vue 实例方法，通过把它们添加到 vue.prototype 上实现

`,l:"InterviewVue/21.Vue.use是干什么的.html#_1-2-插件的功能",a:"_1-2-插件的功能"},"21.3":{t:"1.3 实现原理",p:`Vue.use = function (plugin: Function | Object) {
  // 插件缓存
  const installedPlugins =
    this._inst ...`,l:"InterviewVue/21.Vue.use是干什么的.html#_1-3-实现原理",a:"_1-3-实现原理"},"22.0":{t:"# 22. Vue.extend 方法的作用",p:"",l:"InterviewVue/22.Vue.extend方法的作用.html",a:"_22-vue-extend-方法的作用"},"22.1":{t:"1.1 Vue.extend 概念",p:`使用基础 Vue 构造器，创建一个&quot;子类&quot;。参数是一个包含组件选项的对象。
data 选项是特例，需要注意 - 在 Vue.extend()中它必须是函数
var profile  ...`,l:"InterviewVue/22.Vue.extend方法的作用.html#_1-1-vue-extend-概念",a:"_1-1-vue-extend-概念"},"22.2":{t:"1.2 分析",p:`
所有的组件创建时都会调用 Vue.extend()方法进行创建。
有了此方法我们可以用于手动挂载组件。
后端存储的字符串模板我们可以通过 Vue.extend 方法将其进行渲染，但是需要引入编译时。 ...`,l:"InterviewVue/22.Vue.extend方法的作用.html#_1-2-分析",a:"_1-2-分析"},"23.0":{t:"# 23.Vue 组件 data 为什么必须是一个函数",p:`
根实例对象 data 可以是对象也可以是函数&quot;单例&quot;，不会产生数据污染的情况
组件实例对象 data 必须是函数，目的是为了防止多个组件实例对象之间共用一个 data，产生数据污 ...`,l:"InterviewVue/23.Vue组件data为什么必须是一个函数.html",a:"_23-vue-组件-data-为什么必须是一个函数"},"24.0":{t:"# 24. 函数组件的优势",p:"函数式组件的特性：无状态、无生命周期、无 this，但是性能高。正常组件是一个类继承了 Vue，函数式组件就是普通的函数，没有 new 的过程。最终就是将返回的虚拟 DOM 变成真实 DOM 替换对应 ...",l:"InterviewVue/24.函数组件的优势.html",a:"_24-函数组件的优势"},"25.0":{t:"# 25. Vue 的过滤器了解吗？过滤器的使用场景",p:`过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解成纯函数。
{{ message | filterA(&quot;arg1&quot;,&quot;ar ...`,l:"InterviewVue/25.Vue的过滤器了解吗？过滤器的使用场景.html",a:"_25-vue-的过滤器了解吗-过滤器的使用场景"},"26.0":{t:"# 26. v-once 的使用场景有哪些",p:"",l:"InterviewVue/26.v-once的使用场景有哪些.html",a:"_26-v-once-的使用场景有哪些"},"26.1":{t:"1.1 v-once 概念",p:`v-once 是 Vue 的内置指令，只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能
`,l:"InterviewVue/26.v-once的使用场景有哪些.html#_1-1-v-once-概念",a:"_1-1-v-once-概念"},"26.2":{t:"1.2 v-once 使用场景",p:`&lt;!-- 单个元素 --&gt;
&lt;span v-once&gt; This will never change: {{ msg }}&lt;/span&gt;
&lt;!-- 有子元素  ...`,l:"InterviewVue/26.v-once的使用场景有哪些.html#_1-2-v-once-使用场景",a:"_1-2-v-once-使用场景"},"27.0":{t:"# 27. Vue.mixin的使用场景和原理",p:"",l:"InterviewVue/27.Vue.mixin的原理和使用场景.html",a:"_27-vue-mixin的使用场景和原理"},"27.1":{t:"1.1 Vue.mixin 概念",p:`mixin可以用来扩展组件，将公共逻辑进行抽离。在需要该逻辑时进行“混入”，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件中的数据冲突，会采用“就近原则”以组件的数据为准、

mixin ...`,l:"InterviewVue/27.Vue.mixin的原理和使用场景.html#_1-1-vue-mixin-概念",a:"_1-1-vue-mixin-概念"},"27.2":{t:"1.2 混入方式",p:`在Vue中我们可以局部混入跟全局混入。一般情况下全局混入用于编写组件。局部混入用于复用逻辑。
`,l:"InterviewVue/27.Vue.mixin的原理和使用场景.html#_1-2-混入方式",a:"_1-2-混入方式"},"27.3":{t:"1.3 mixin合并策略",p:`核心就是：对象的合并处理

props、methods、inject、computed同名时会被替换
data会被合并
生命周期和watch方法会被合并成队列
components、directive ...`,l:"InterviewVue/27.Vue.mixin的原理和使用场景.html#_1-3-mixin合并策略",a:"_1-3-mixin合并策略"},"28.0":{t:"# 28. Vue 中的 slot 是怎样实现的？什么时候使用它？",p:"",l:"InterviewVue/28.Vue中的slot是怎样实现的？什么时候使用它.html",a:"_28-vue-中的-slot-是怎样实现的-什么时候使用它"},"28.1":{t:"1.1 什么是插槽？",p:`插槽设计来源于 Web Components 规范草案，利用slot进行占位，在使用组件时，组件标签内部的内容会分发到对应的 slot 中。
`,l:"InterviewVue/28.Vue中的slot是怎样实现的？什么时候使用它.html#_1-1-什么是插槽",a:"_1-1-什么是插槽"},"28.2":{t:"1.2 什么时候使用它？",p:`通过插槽可以让用户更好地对组件进行扩展和定制化。可以通过具名插槽指定渲染的位置。常用的组件例如：弹窗组件、布局组件、表格组件、树组件……
`,l:"InterviewVue/28.Vue中的slot是怎样实现的？什么时候使用它.html#_1-2-什么时候使用它",a:"_1-2-什么时候使用它"},"28.3":{t:"1.3 插槽的分类和原理",p:`

默认插槽


具名插槽
\`&lt;div&gt;
  &lt;slot name=&quot;title&quot;&gt;&lt;/slot&gt;
  &lt;slot name=&quot; ...`,l:"InterviewVue/28.Vue中的slot是怎样实现的？什么时候使用它.html#_1-3-插槽的分类和原理",a:"_1-3-插槽的分类和原理"},"29.0":{t:"# 29. 说说你对双向绑定的理解，以及它的实现原理",p:"",l:"InterviewVue/29.说说你对双向绑定的理解，以及它的实现原理.html",a:"_29-说说你对双向绑定的理解-以及它的实现原理"},"29.1":{t:"1.1 双向绑定的概念",p:"vue 中双向绑定靠的是指令 v-model，可以绑定一个动态值到视图上，同时修改视图能改变数据对应的值(能修改的视图就是表单组件) 经常会听到一句话：v-model 是 value 和 input  ...",l:"InterviewVue/29.说说你对双向绑定的理解，以及它的实现原理.html#_1-1-双向绑定的概念",a:"_1-1-双向绑定的概念"},"29.2":{t:"1.2 表单元素的 v-model",p:`内部会根据标签的不同解析出不同的语法。并且这里有&quot;额外&quot;的处理逻辑

例如 文本框会被解析成 value + input 事件，会解决中文输入问题
例如 复选框会被解析成 chec ...`,l:"InterviewVue/29.说说你对双向绑定的理解，以及它的实现原理.html#_1-2-表单元素的-v-model",a:"_1-2-表单元素的-v-model"},"29.3":{t:"1.3 组件中的 v-model",p:`组件上的v-model默认会利用名为 value的 prop 和名为input的事件。对于组件而言，v-model 就是value + input 的语法糖。可用于组件中的数据的双向绑定。
名字也可以 ...`,l:"InterviewVue/29.说说你对双向绑定的理解，以及它的实现原理.html#_1-3-组件中的-v-model",a:"_1-3-组件中的-v-model"},"30.0":{t:"# 30. Vue 中 .sync 修饰符的作用？",p:"在有些情况下，我们可能需要对一个 prop 进行&quot;双向绑定&quot;，这时可以使用.sync 来实现。v-model 默认只能双向绑定一个属性，这里就可以通过.sync修饰符绑定多个属性。 ...",l:"InterviewVue/30.Vue 中.sync修饰符的作用？.html",a:"_30-vue-中-sync-修饰符的作用"},"31.0":{t:"# 30. Vue 中递归组件的理解",p:`&lt;el-menu&gt;
  &lt;el-menu-item&gt;根 1&lt;/el-menu-item&gt;
  &lt;el-submenu&gt;
    &lt;template ...`,l:"InterviewVue/31.Vue 中递归组件的理解.html",a:"_30-vue-中递归组件的理解"},"31.1":{t:"1.1 模板递归",p:`&lt;el-menu&gt;
  &lt;template v-for=&quot;item in data&quot;&gt;
    &lt;resub :data=&quot;item&quo ...`,l:"InterviewVue/31.Vue 中递归组件的理解.html#_1-1-模板递归",a:"_1-1-模板递归"},"31.2":{t:"1.2 渲染函数递归",p:`render(){
  let renderChildren = (data)=&gt;{
    return data.map((child)=&gt;{
      return child.c ...`,l:"InterviewVue/31.Vue 中递归组件的理解.html#_1-2-渲染函数递归",a:"_1-2-渲染函数递归"},"32.0":{t:"# 32.组件中写 name 属性有哪些好处和作用？",p:`
增加 name 选择会在components属性中增加组件本身，实现组件的递归调用
可以表示组件的具体名称，方便调试和查找对应组件
$children.filter(item=&gt;item.$o ...`,l:"InterviewVue/32.组件中写 name 选项有哪些好处及作用.html",a:"_32-组件中写-name-属性有哪些好处和作用"},"33.0":{t:"# 33. Vue 常见的修饰符有哪些？有什么应用场景",p:`
表单修饰符 lazy、trim、number
事件修饰符 stop、prevent、self、once、capture、passive、native
鼠标按键修饰符 left、right、middl ...`,l:"InterviewVue/33.Vue 常见的修饰符有哪些，有什么应用场景.html",a:"_33-vue-常见的修饰符有哪些-有什么应用场景"},"34.0":{t:"# 34. Vue 中异步组件的作用和原理",p:"",l:"InterviewVue/34.Vue中异步组件的作用和原理.html",a:"_34-vue-中异步组件的作用和原理"},"34.1":{t:"1.1 异步组件概念",p:`Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。推荐的做法是将异步组件和 webpack 的 code-solitting 功能一起配合使用。
`,l:"InterviewVue/34.Vue中异步组件的作用和原理.html#_1-1-异步组件概念",a:"_1-1-异步组件概念"},"34.2":{t:"1.2 异步组件的写法",p:`

回调写法
{
  components: {
    &quot;my-component&quot;: (resolve, reject) =&gt; {
      setTimeout(fu ...`,l:"InterviewVue/34.Vue中异步组件的作用和原理.html#_1-2-异步组件的写法",a:"_1-2-异步组件的写法"},"34.3":{t:"1.3 异步组件原理",p:`
默认渲染异步占位符节点
组件加载完毕后调用 $forceUpdate 强制更新，渲染加载完毕后的组件

`,l:"InterviewVue/34.Vue中异步组件的作用和原理.html#_1-3-异步组件原理",a:"_1-3-异步组件原理"},"35.0":{t:"# 35. 说说你对 nextTick 的理解？",p:"",l:"InterviewVue/35.说说你对 nextTick 的理解.html",a:"_35-说说你对-nexttick-的理解"},"35.1":{t:"1.1 nextTick 概念",p:`
Vue 中视图更新是异步的，使用 nextTick 方法可以保证用户定义的逻辑在更新之后执行
可用于获取更新后的 DOM，多次调用 nextTick 会被合并。

&lt;template&gt;
 ...`,l:"InterviewVue/35.说说你对 nextTick 的理解.html#_1-1-nexttick-概念",a:"_1-1-nexttick-概念"},"36.0":{t:"# 36. keep-alive 平时在哪里使用",p:"",l:"InterviewVue/36.keep-alive平时在哪里使用.html",a:"_36-keep-alive-平时在哪里使用"},"36.1":{t:"1.1 概念",p:`keep-alive 是 vue 中的内置组件，能在组件切换过程中会缓存组件的实例，而不是销毁他们。在组建再次重新激活时可以通过缓存的实例拿到之前渲染的 DOM 进行渲染，无需重新生成节点。
`,l:"InterviewVue/36.keep-alive平时在哪里使用.html#_1-1-概念",a:"_1-1-概念"},"36.2":{t:"1.2 使用场景",p:`动态组件可以采用keep-alive进行缓存
&lt;keep-alive :include=&quot;whiteList&quot; :exclude=&quot;blackList&quot;  ...`,l:"InterviewVue/36.keep-alive平时在哪里使用.html#_1-2-使用场景",a:"_1-2-使用场景"},"36.3":{t:"1.3 原理",p:`export default {
    name:'keep-alive',
    abstract:true, // 不会放到对应的lifecycle
    props:{
        i ...`,l:"InterviewVue/36.keep-alive平时在哪里使用.html#_1-3-原理",a:"_1-3-原理"},"36.4":{t:"1.4 keep-alive中数据更新问题",p:`beforeRouteEnter: 在与 vue-router 的项目，每次进入路由的时候，都会执行beforeRouteEnter
beforeRouteEnter(to, from, next){ ...`,l:"InterviewVue/36.keep-alive平时在哪里使用.html#_1-4-keep-alive中数据更新问题",a:"_1-4-keep-alive中数据更新问题"},"37.0":{t:"# 37. 自定义指令的使用场景",p:"",l:"InterviewVue/37.自定义指令的应用场景.html",a:"_37-自定义指令的使用场景"},"37.1":{t:"1.1 指令的概念",p:`vue 除了内置指令之外，同时 Vue 也允许用户注册自定义指令来对 Vue 进行扩展。指令的目的在于可以将操作 DOM 的逻辑进行复用。
`,l:"InterviewVue/37.自定义指令的应用场景.html#_1-1-指令的概念",a:"_1-1-指令的概念"},"37.2":{t:"1.2 指令的生命周期",p:`
bind: 只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。
inserted: 被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。
update:  ...`,l:"InterviewVue/37.自定义指令的应用场景.html#_1-2-指令的生命周期",a:"_1-2-指令的生命周期"},"37.3":{t:"1.3 常见的指令编写",p:`

图片懒加载 v-lazy


防抖 v-debounce


按钮权限 v-has


拖拽指令 v-draggable 、mousemove、mouseup、mousedown、dragente ...`,l:"InterviewVue/37.自定义指令的应用场景.html#_1-3-常见的指令编写",a:"_1-3-常见的指令编写"},"38.0":{t:"# 38. Vue 中使用了哪些设计模式",p:`
单例模式 - 单例模式就是整个程序有且仅有一个实例 Vuex 中的 store
工厂模式 - 传入参数即可创建实例(createElement)
发布订阅模式 - 订阅者把自己想订阅的事件注册到调度 ...`,l:"InterviewVue/38.Vue 中使用了哪些设计模式.html",a:"_38-vue-中使用了哪些设计模式"},"39.0":{t:"# 39. Vue 中的性能优化有哪些",p:`
数据层级不宜过深，合理设置响应式数据
通过Object.freeze()方法冻结属性
使用数据时，缓存值的结果，不频繁取值
合理设置 key 属性
v-show 和 v-if 的选取
控制组件力粒度 ...`,l:"InterviewVue/39.Vue 中的性能优化有哪些.html",a:"_39-vue-中的性能优化有哪些"},"40.0":{t:"# 40. 单页应用首屏加载速度慢的怎么解决？",p:`
使用路由懒加载、异步组件，实现组件拆分，减少入口文件体积大小(优化体验骨架屏)
抽离公共代码，采用splitChunks进行代码分割。
组件加载采用按需加载的方式。
静态资源缓存，采用 HTTP 缓 ...`,l:"InterviewVue/40.单页应用首屏加载慢的怎么解决.html",a:"_40-单页应用首屏加载速度慢的怎么解决"},"41.0":{t:"# 41. Vue 项目中你是如何解决跨域的呢？",p:`跨域是浏览器同源策略导致的，这个是浏览器的行为(协议、主机名、端口的不同都会导致跨域问题)。服务端和服务端之间进行通信是没有跨域问题的。跨域的实现方案有很多种。不过一般常用的就那么几中

CORS(C ...`,l:"InterviewVue/41.Vue 项目中你是如何解决跨域的呢.html",a:"_41-vue-项目中你是如何解决跨域的呢"},"42.0":{t:"# 42. Vue 项目中有封装过 axios 吗？主要是封装哪方面的？",p:`
设置请求超时时间
根据项目环境设置请求路径
设置拦截请求，自动添加 Token
设置响应拦截，对响应的状态码或者数据进行格式化
增添请求队列，实现 loading 效果
维护取消请求 token，在 ...`,l:"InterviewVue/42.Vue 项目中有封装过 axios 吗？主要是封装哪方面的？.html",a:"_42-vue-项目中有封装过-axios-吗-主要是封装哪方面的"},"43.0":{t:"# 43.Vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？",p:"",l:"InterviewVue/43.Vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？.html",a:"_43-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做"},"43.1":{t:"1.1 常见权限控制",p:`
登录鉴权：用户登录后返回 token，前端将 token 保存到本地，作为用户登录的凭证，每次发送请求时会携带 token，后端会对 token 进行验证。当页面刷新时我们可以使用token 来获得 ...`,l:"InterviewVue/43.Vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？.html#_1-1-常见权限控制",a:"_1-1-常见权限控制"},"44.0":{t:"# 44.Vue-Router 有几种钩子函数，具体是什么及执行流程是怎样的？",p:`
导航被触发
在失活的组件调用 beforeRouteLeave守卫
调用全局的 beforeEach 守卫
在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)
在路由配置里调用 ...`,l:"InterviewVue/44.Vue-Router 有几种钩子函数，具体是什么及执行流程是怎样的？.html",a:"_44-vue-router-有几种钩子函数-具体是什么及执行流程是怎样的"},"45.0":{t:"# 45. Vue-Router 几种模式的区别",p:`
Vue-Router 有三种模式 hash、history、abstract
abstract 模式是在不支持浏览器 API 环境使用，不依赖于浏览器历史
hash 模式：hash + popSta ...`,l:"InterviewVue/45.Vue-Router 几种模式的区别.html",a:"_45-vue-router-几种模式的区别"},"46.0":{t:"# 46.Vue 项目本地开发完后部署到服务器后报 404 是什么原因呢",p:`history 模式刷新时会向服务器发起请求，服务端无法响应到对应的资源，所以会出现 404 问题
`,l:"InterviewVue/46.Vue 项目本地开发完后部署到服务器后报 404 是什么原因呢.html",a:"_46-vue-项目本地开发完后部署到服务器后报-404-是什么原因呢"},"47.0":{t:"# 47. 谈谈你对 vuex 的个人理解",p:"",l:"InterviewVue/47.谈谈你对 vuex 的个人理解.html",a:"_47-谈谈你对-vuex-的个人理解"},"47.1":{t:"1.1 概念",p:`
vuex 是一个专门为 Vue.js 应用程序开发的状态管理模式，采用集中存储管理应用的所有组件的状态。核心就是解决数据的共享。
以相应的规则保证状态以一种可预测的方式发生变化。

!vuex
`,l:"InterviewVue/47.谈谈你对 vuex 的个人理解.html#_1-1-概念",a:"_1-1-概念"},"47.2":{t:"1.2 状态修改",p:`
组件中 commit() -&gt; mutation -&gt;修改状态
组件中 dispatch() -&gt; action(为了解决接口的复用问题，封装公共的逻辑) -&gt; commit ...`,l:"InterviewVue/47.谈谈你对 vuex 的个人理解.html#_1-2-状态修改",a:"_1-2-状态修改"},"47.3":{t:"1.3 缺点",p:`Vuex 中 store 只有一份，复杂的数据需要依赖于模块。Vuex 状态是一个树状结构，最终会将模块的状态挂载到根模块上。

模块和状态的名字冲突
数据不够扁平化，调用的时候过长
更改状态 mut ...`,l:"InterviewVue/47.谈谈你对 vuex 的个人理解.html#_1-3-缺点",a:"_1-3-缺点"},"47.4":{t:"1.4 原理",p:`对于 Vuex3 核心就是通过 new Vue()创建了一个 Vue 实例，进行数据共享。
对于 Vuex4 核心就是通过创建一个响应式对象进行数据共享reactive()
`,l:"InterviewVue/47.谈谈你对 vuex 的个人理解.html#_1-4-原理",a:"_1-4-原理"},"48.0":{t:"# 48.如何监听 vuex 中数据的变化",p:`
通过 watch 监控 vuex 中状态变化。
通过 store.subscribe 监控状态变化。

`,l:"InterviewVue/48.如何监听 vuex 中数据的变化.html",a:"_48-如何监听-vuex-中数据的变化"},"49.0":{t:"# 49.页面刷新后 vuex 的数据丢失怎么解决",p:`
每次获取数据前检测 Vuex 数据是否存在，不存在则发请求重新拉去数据，存储到 Vuex 中
采用 Vuex 持久化插件，将数据存储到 localStorage 或者 sessionStorage  ...`,l:"InterviewVue/49.页面刷新后 vuex 的数据丢失怎么解决.html",a:"_49-页面刷新后-vuex-的数据丢失怎么解决"},"50.0":{t:"# 50.mutation 和 action 的区别",p:`
在 action 中可以处理异步逻辑，可以获取数据后将结果提交给 mutation，mutation 中则是修改 state
在 action 中可以多次进行 commit 操作，包括 action ...`,l:"InterviewVue/50.mutation 和 action 的区别.html",a:"_50-mutation-和-action-的区别"},"51.0":{t:"# 51.有使用过 vuex 的 module 吗？在什么情况下会使用",p:`使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
Vuex 允许我们将 store 分割成模块(module)。每个模块拥有自己的  ...`,l:"InterviewVue/51.有使用过 vuex 的 module 吗？在什么情况下会使用.html",a:"_51-有使用过-vuex-的-module-吗-在什么情况下会使用"},"52.0":{t:"# 52.Vue3 中 CompositionAPI 的优势是？",p:`
在 Vue2 中采用的是 OptionsAPI，用户提供的 data、props、methods、computed、watch 等属性(用户编写复杂业务逻辑会出现反复横跳的问题)
Vue2 中所有的 ...`,l:"InterviewVue/52.Vue3中 CompositionAPI 的优势是？.html",a:"_52-vue3-中-compositionapi-的优势是"},"53.0":{t:"# 53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？",p:`
Vue3.0 更注重模块上的拆分，在 2.0 中无法单独使用的模块，需要引入完整的 Vuejs(例如只想使用响应式部分，但是需要引入完整的 Vuejs)，Vue3 中的模块之间耦合度低，模块可以独立 ...`,l:"InterviewVue/53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？.html",a:"_53-vue3-有了解过吗-能说说跟-vue2-的区别吗"},"54.0":{t:"# 54. Vue 项目中的错误如何处理的",p:"",l:"InterviewVue/54.Vue 项目中的错误如何处理的.html",a:"_54-vue-项目中的错误如何处理的"},"54.1":{t:"1.1 errorCapture 钩子",p:`可以捕获来自后代组件的错误，如果全局的 config.errorHandler 被定义，所有的错误仍会发送给它，因此这些错误仍然会向单一的分析服务的地方进行汇报

父组件(errorCapture)  ...`,l:"InterviewVue/54.Vue 项目中的错误如何处理的.html#_1-1-errorcapture-钩子",a:"_1-1-errorcapture-钩子"},"54.2":{t:"1.2 全局设置错误处理",p:`如果在组件渲染时出现运行错误，错误将会被传递至全局 Vue.config.errorHandler 配置函数
Vue.config.errorHandler = (err, vm, info) =&g ...`,l:"InterviewVue/54.Vue 项目中的错误如何处理的.html#_1-2-全局设置错误处理",a:"_1-2-全局设置错误处理"},"54.3":{t:"1.3 接口异常处理",p:`instance.interceptors.response.use(
    (res) =&gt; {
        return res.data
    },
    (err) =&gt; ...`,l:"InterviewVue/54.Vue 项目中的错误如何处理的.html#_1-3-接口异常处理",a:"_1-3-接口异常处理"},"55.0":{t:"# 55.Vue3 中模板编译优化",p:"",l:"InterviewVue/55.Vue3 中模板编译优化.html",a:"_55-vue3-中模板编译优化"},"55.1":{t:"1.1 PatchFlags 优化",p:`Diff 算法无法避免新旧虚拟DOM 中无用的比较操作，通过 patchFlags 来标记动态内容，可以实现快速 diff 算法。
&lt;div&gt;
  &lt;h1&gt;Hello Jian ...`,l:"InterviewVue/55.Vue3 中模板编译优化.html#_1-1-patchflags-优化",a:"_1-1-patchflags-优化"},"55.2":{t:"1.2 BlockTree",p:`为什么我们还要提出 blockTree 的概念？只有 block 不就挺好的么？问题出在 block 在收集动态节点时是忽略虚拟 DOM 树层级的
&lt;div&gt;
  &lt;p v-if=& ...`,l:"InterviewVue/55.Vue3 中模板编译优化.html#_1-2-blocktree",a:"_1-2-blocktree"},"55.3":{t:"不稳定结构",p:`所谓的不稳定结构就是 DOM 树的结构可能会发生变化。不稳定结构有哪些呢？(v-if/v-for/fragment)
`,l:"InterviewVue/55.Vue3 中模板编译优化.html#不稳定结构",a:"不稳定结构"},"55.4":{t:"v-if",p:`&lt;div&gt;
  &lt;p v-if=&quot;flag&quot;&gt;
    &lt;span&gt;{{ a }}&lt;/span&gt;
  &lt;/p&gt;
  &l ...`,l:"InterviewVue/55.Vue3 中模板编译优化.html#v-if",a:"v-if"},"55.5":{t:"v-for",p:`随着 v-for 变量的变化也会导致虚拟DOM 树变得不稳定
&lt;div&gt;
  &lt;div v-for=&quot;item in fruits&quot; &gt;
    {{ it ...`,l:"InterviewVue/55.Vue3 中模板编译优化.html#v-for",a:"v-for"},"55.6":{t:"稳定 Fragment",p:"",l:"InterviewVue/55.Vue3 中模板编译优化.html#稳定-fragment",a:"稳定-fragment"},"56.0":{t:"# 什么是 JavaScript",p:"",l:"JavaScript/第1章-什么是 JavaScript.html",a:"什么是-javascript"},"56.1":{t:"JavaScript 是什么",p:`虽然 JavaScript 和 ECMAScript 基本上是同义词, 但是 JavaScript 远远不限于 ECMA-262 所定义的那样
完整的 JavaScript 包含以下几个部分

核心( ...`,l:"JavaScript/第1章-什么是 JavaScript.html#javascript-是什么",a:"javascript-是什么"},"56.2":{t:"JavaScript 实现",p:"",l:"JavaScript/第1章-什么是 JavaScript.html#javascript-实现",a:"javascript-实现"},"56.3":{t:"ECMAScript",p:`在基本层面上, ECMA-262 描述 JavaScript 包含如下几个部分
语法、类型、语句、关键字、保留字、操作符、全局对象
`,l:"JavaScript/第1章-什么是 JavaScript.html#ecmascript",a:"ecmascript"},"56.4":{t:"DOM",p:`文档对象模型(Document Object Model)是一个应用编程接口(API), 用于在 HTML 中使用扩展的 XML。
`,l:"JavaScript/第1章-什么是 JavaScript.html#dom",a:"dom"},"56.5":{t:"DOM 级别",p:`DOMLevel1 由 DOM Core 和 DOM HTML 组成。 前者提供了一中映射 XML 文档，从而方便访问和操作文档任意部分的方式；后者扩展了前者并增加了特定于 HTML 的对象和方法。
 ...`,l:"JavaScript/第1章-什么是 JavaScript.html#dom-级别",a:"dom-级别"},"56.6":{t:"BOM",p:`IE3 和 Netscape Navigator 3 提供的浏览器对象模型（BOM）API，用于支持访问和操作浏览器的窗口。
BOM 主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定 ...`,l:"JavaScript/第1章-什么是 JavaScript.html#bom",a:"bom"},"56.7":{t:"JavaScript 的不同版本",p:"",l:"JavaScript/第1章-什么是 JavaScript.html#javascript-的不同版本",a:"javascript-的不同版本"},"57.0":{t:"# HTML 中的 JavaScript",p:"",l:"JavaScript/第2章-HTML 中的 JavaScript.html",a:"html-中的-javascript"},"57.1":{t:"\\<Script\\> 元素",p:`script 元素有下列 8 个属性

async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效
charset：可选。使用 src 属 ...`,l:"JavaScript/第2章-HTML 中的 JavaScript.html#script-元素",a:"script-元素"},"58.0":{t:"# 语言基础",p:"",l:"JavaScript/第3章-语言基础.html",a:"语言基础"},"58.1":{t:"语法",p:"",l:"JavaScript/第3章-语言基础.html#语法",a:"语法"},"58.2":{t:"区分大小写",p:"ECMAScript 中一切都是区分大小写的。无论是变量、函数名还是操作符，都区分大小写。换句话说。变量 test 和变量 Test 是两个不同的变量。类似地，typeof 不能作为函数名，因为它是一 ...",l:"JavaScript/第3章-语言基础.html#区分大小写",a:"区分大小写"},"58.3":{t:"标识符",p:`所谓标识符，就是变量、函数、属性或者函数参数的名称。标识符可以由一个或多个下列字符组成：
第一个字符必须是一个字母、下划线(_)或美元符号($)；
剩下的其他字符可以是字母、下划线、美元符号或数字；
 ...`,l:"JavaScript/第3章-语言基础.html#标识符",a:"标识符"},"58.4":{t:"注释",p:`ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。
单行注释以两个斜杠字符(//)开头，如
// 单行注释

块注释以一个斜杠和一个星号(/*)开头，以它们的反向组合(*/)结尾。 ...`,l:"JavaScript/第3章-语言基础.html#注释",a:"注释"},"58.5":{t:"严格模式",p:"ECMAScript 5 新增了严格模式的概念。严格模式是一种不同的 JavaScript 解析和执行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。 ...",l:"JavaScript/第3章-语言基础.html#严格模式",a:"严格模式"},"58.6":{t:"关键字和保留字",p:"",l:"JavaScript/第3章-语言基础.html#关键字和保留字",a:"关键字和保留字"},"58.7":{t:"关键字",p:`break 	do		in		typeof		case		else		instanceof
var		catch		export		new		void		class		extends
return		 ...`,l:"JavaScript/第3章-语言基础.html#关键字",a:"关键字"},"58.8":{t:"保留字",p:`ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束， 或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。
`,l:"JavaScript/第3章-语言基础.html#保留字",a:"保留字"},"58.9":{t:"始终保留",p:`enum

`,l:"JavaScript/第3章-语言基础.html#始终保留",a:"始终保留"},"58.10":{t:"严格模式下保留",p:`implements		interface		let		package		protected
private		public		static

`,l:"JavaScript/第3章-语言基础.html#严格模式下保留",a:"严格模式下保留"},"58.11":{t:"模块代码中保留",p:`await

`,l:"JavaScript/第3章-语言基础.html#模块代码中保留",a:"模块代码中保留"},"58.12":{t:"变量",p:"ECMAScript 中有 3 个关键字可以声明变量：var、const 和let。其中var在 ECMAScript 的所有版本中都可以使用，而const和let只能在 ECMAScript 6 及 ...",l:"JavaScript/第3章-语言基础.html#变量",a:"变量"},"58.13":{t:"var 关键字",p:`要定义变量，可以使用 var 操作符（注意var是一个关键字），后跟变量名（即标识符）
var message
var message = 'hi'
message = 'hi' // 合法，但不推荐 ...`,l:"JavaScript/第3章-语言基础.html#var-关键字",a:"var-关键字"},"58.14":{t:"var 声明作用域",p:`使用var操作符定义的变量会成为包含它的函数的局部变量。比如，使用var在一个函数内部定义了一个变量，就意味着该变量将在函数退出时被销毁
function test() {
  var message ...`,l:"JavaScript/第3章-语言基础.html#var-声明作用域",a:"var-声明作用域"},"58.15":{t:"var 声明提升",p:`使用var时，下面的代码不会报错。这是因为使用了这个关键字声明的变量会自动提升到函数的作用域顶部：
function foo() {
  console.log(age)
  var age = 26 ...`,l:"JavaScript/第3章-语言基础.html#var-声明提升",a:"var-声明提升"},"58.16":{t:"let 声明",p:`let和var的作用差不多，但是有着非常重要的区别。最明显的区别就是，let声明的范围是块作用域，而var声明的范围是函数作用域。
if (true) {
  var name = 'Matt'
   ...`,l:"JavaScript/第3章-语言基础.html#let-声明",a:"let-声明"},"58.17":{t:"1. 暂时性死区",p:`let与var的另一个重要区别，就是let声明的变量不会在作用域中被提升。
// name 会被提升
console.log(name) // undefined
var name = 'Matt'
 ...`,l:"JavaScript/第3章-语言基础.html#_1-暂时性死区",a:"_1-暂时性死区"},"58.18":{t:"2. 全局声明",p:`与var关键字不同，使用 let在全局作用域中声明的变量不会成为 window 对象的属性(var 声明的变量则会)
var name = 'Matt'
console.log(window.name ...`,l:"JavaScript/第3章-语言基础.html#_2-全局声明",a:"_2-全局声明"},"58.19":{t:"3. 条件声明",p:`因为 let是块级作用域，所以不可能检查前面是否声明过同名变量，同时也就不可能在没有声明的情况下去声明它，因此不能依赖条件声明模式
`,l:"JavaScript/第3章-语言基础.html#_3-条件声明",a:"_3-条件声明"},"58.20":{t:"for 循环中的 let",p:`在let出现之前，for循环定义的迭代变量会渗透到循环体外部。改用let之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部
for (var i = 0; i &lt; 5; ++ ...`,l:"JavaScript/第3章-语言基础.html#for-循环中的-let",a:"for-循环中的-let"},"58.21":{t:"const 声明",p:`const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误
const age = 26
age = 36 // Typ ...`,l:"JavaScript/第3章-语言基础.html#const-声明",a:"const-声明"},"58.22":{t:"声明风格及最佳实践",p:`
不使用 var
const 优先，let 次之

`,l:"JavaScript/第3章-语言基础.html#声明风格及最佳实践",a:"声明风格及最佳实践"},"58.23":{t:"数据类型",p:`ECMAScript 有两大数据类型
基本数据类型(原始数据类型)：Undefined、Null、Boolean、Number、String、Symbol
复杂数据类型：Object
`,l:"JavaScript/第3章-语言基础.html#数据类型",a:"数据类型"},"58.24":{t:"typeof 操作符",p:`因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 会返回下列字符串之一：

&quot;unde ...`,l:"JavaScript/第3章-语言基础.html#typeof-操作符",a:"typeof-操作符"},"58.25":{t:"Undefined 类型",p:`Undefined 类型只有一个值，就是特殊值undefined。当 var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值
注意：包含 undefined值的变量跟未定义变 ...`,l:"JavaScript/第3章-语言基础.html#undefined-类型",a:"undefined-类型"},"58.26":{t:"Null 类型",p:`Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给 typeof传一个null会返回&quot;object&quot;的原因。
在定义一个将来要保存对象值 ...`,l:"JavaScript/第3章-语言基础.html#null-类型",a:"null-类型"},"58.27":{t:"Boolean 类型",p:`Boolean类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：true和false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。
注意：布尔值字面量 ...`,l:"JavaScript/第3章-语言基础.html#boolean-类型",a:"boolean-类型"},"58.28":{t:"布尔值和不同类型之间的转换规则",p:`


数据类型
转换为 true 的值
转换为 false 的值




Boolean
true
false


String
非空字符串
&quot;&quot;(空字符串)


Number
非 ...`,l:"JavaScript/第3章-语言基础.html#布尔值和不同类型之间的转换规则",a:"布尔值和不同类型之间的转换规则"},"58.29":{t:"Number 类型",p:`Number类型使用 IEEE 754格式表示正式和浮点数(在某些语言中也叫双精度值)、不同的数值类型相应地也有不同的数值字面量格式。
`,l:"JavaScript/第3章-语言基础.html#number-类型",a:"number-类型"},"58.30":{t:"数值字面量格式",p:`十进制： 直接写出来即可
八进制： 对于八进制字面量，第一个数字必须是零(0)，然后是相应的八进制数字(0-7)。如果字面量中包含的数字超出了应有的范围，就回忽略前缀的 0，后面的数字被当做十进制
十 ...`,l:"JavaScript/第3章-语言基础.html#数值字面量格式",a:"数值字面量格式"},"58.31":{t:"浮点值",p:`要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。
let floatNumber1 = 1.1
let floatNumber2 = 0 ...`,l:"JavaScript/第3章-语言基础.html#浮点值",a:"浮点值"},"58.32":{t:"值的范围",p:"ECMAScript可以保存的最小数值保存在Number.MIN_VALUE中，这个值多数浏览器是5e-324，可以保存的最小数值保存在Number.MAX_VALUE中，这个值多数浏览器是1.797 ...",l:"JavaScript/第3章-语言基础.html#值的范围",a:"值的范围"},"58.33":{t:"NaN",p:"有一个特殊的值叫&quot;NaN&quot;，意思是&quot;不是数值&quot;(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。在 ECMAScript 中， ...",l:"JavaScript/第3章-语言基础.html#nan",a:"nan"},"58.34":{t:"数值转换",p:`有 3 个函数可以将非数值转换为数值：Number()、parseInt()、parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转化为数值。
Numb ...`,l:"JavaScript/第3章-语言基础.html#数值转换",a:"数值转换"},"58.35":{t:"String 类型",p:"String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(&quot;)、单引号(')或反引号(`)标示。必须成对出现，否则会导致语法错误。\n",l:"JavaScript/第3章-语言基础.html#string-类型",a:"string-类型"},"58.36":{t:"字符字面量",p:`字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符



字面量
含义




\\n
换行


\\t
制表


\\b
退格


\\r
回车


\\f
换页


\\\\
反斜杠()

 ...`,l:"JavaScript/第3章-语言基础.html#字符字面量",a:"字符字面量"},"58.37":{t:"字符串的特点",p:`字符串是不可变的，意思就是一旦创建，他们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。
`,l:"JavaScript/第3章-语言基础.html#字符串的特点",a:"字符串的特点"},"58.38":{t:"转换为字符串",p:`有两种方式将一个值转换为字符串。一个是toString()，一个是直接在后面加空串&quot;&quot;
数值调用toString()时，可以传入一个参数作为底数，默认情况下返回的是十进制
`,l:"JavaScript/第3章-语言基础.html#转换为字符串",a:"转换为字符串"},"58.39":{t:"模板字面量",p:`ECMAScript 6新增了模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以夸行定义字符串。
let str = \`first line
second line\`
 ...`,l:"JavaScript/第3章-语言基础.html#模板字面量",a:"模板字面量"},"58.40":{t:"字符串插值",p:"模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个 值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的 是字符串 ...",l:"JavaScript/第3章-语言基础.html#字符串插值",a:"字符串插值"},"58.41":{t:"模板字面量标签函数",p:`模板字面量也支持定义标签函数(tag function)，而通过标签函数可以自定义插值行为。标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。
标签函数本身是一个常规函数，通过前缀到模板 ...`,l:"JavaScript/第3章-语言基础.html#模板字面量标签函数",a:"模板字面量标签函数"},"58.42":{t:"原始字符串",p:`使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数:
`,l:"JavaScript/第3章-语言基础.html#原始字符串",a:"原始字符串"},"58.43":{t:"Symbol 类型",p:`Symbol(符号)是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的风险。
`,l:"JavaScript/第3章-语言基础.html#symbol-类型",a:"symbol-类型"},"58.44":{t:"符号的基本使用",p:`符号需要使用Symbol()函数初始化，因为符号本身是基本类型，所以typeof操作符对符号返回symbol
let symbol = Symbol()

注意： Symbol()函数不能与 new  ...`,l:"JavaScript/第3章-语言基础.html#符号的基本使用",a:"符号的基本使用"},"58.45":{t:"使用全局符号注册表",p:`如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。
Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全 ...`,l:"JavaScript/第3章-语言基础.html#使用全局符号注册表",a:"使用全局符号注册表"},"58.46":{t:"使用符号作为属性",p:"凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 Object.defineProperty()/Object.defineProperties()定义的属性。对象字 ...",l:"JavaScript/第3章-语言基础.html#使用符号作为属性",a:"使用符号作为属性"},"58.47":{t:"常用内置符号",p:"ECMAScript 6 也引入了一批常用内置符号(well-known symbol)，用于暴露语言内部行为，开发者 可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串 ...",l:"JavaScript/第3章-语言基础.html#常用内置符号",a:"常用内置符号"},"58.48":{t:"Symbol.asyncIterator",p:"",l:"JavaScript/第3章-语言基础.html#symbol-asynciterator",a:"symbol-asynciterator"},"58.49":{t:"Symbol.hasInstance",p:"",l:"JavaScript/第3章-语言基础.html#symbol-hasinstance",a:"symbol-hasinstance"},"58.50":{t:"Symbol.isConcatSpreadable",p:"",l:"JavaScript/第3章-语言基础.html#symbol-isconcatspreadable",a:"symbol-isconcatspreadable"},"58.51":{t:"Symbol.iterator",p:"",l:"JavaScript/第3章-语言基础.html#symbol-iterator",a:"symbol-iterator"},"58.52":{t:"Symbol.match",p:"",l:"JavaScript/第3章-语言基础.html#symbol-match",a:"symbol-match"},"58.53":{t:"Symbol.replace",p:"",l:"JavaScript/第3章-语言基础.html#symbol-replace",a:"symbol-replace"},"58.54":{t:"Symbol.search",p:"",l:"JavaScript/第3章-语言基础.html#symbol-search",a:"symbol-search"},"58.55":{t:"Symbol.species",p:"",l:"JavaScript/第3章-语言基础.html#symbol-species",a:"symbol-species"},"58.56":{t:"Symbol.split",p:"",l:"JavaScript/第3章-语言基础.html#symbol-split",a:"symbol-split"},"58.57":{t:"Symbol.toPrimitive",p:"",l:"JavaScript/第3章-语言基础.html#symbol-toprimitive",a:"symbol-toprimitive"},"58.58":{t:"Symbol.toStringTag",p:"",l:"JavaScript/第3章-语言基础.html#symbol-tostringtag",a:"symbol-tostringtag"},"58.59":{t:"Symbol.unscopables",p:`80 页
`,l:"JavaScript/第3章-语言基础.html#symbol-unscopables",a:"symbol-unscopables"},"58.60":{t:"Object 类型",p:`每个 Object 实例都有如下属性和方法：

constructor：用于创建当前对象的函数。
hasOwnProperty(propertyName)：用于判断当前对象实例(不是原型)上是否存在给 ...`,l:"JavaScript/第3章-语言基础.html#object-类型",a:"object-类型"},"58.61":{t:"操作符",p:"",l:"JavaScript/第3章-语言基础.html#操作符",a:"操作符"},"58.62":{t:"一元操作符",p:`只操作一个值的操作符叫一元操作符(unary operator)。一元操作符是 ECMAScript 中最简单的操作符。
`,l:"JavaScript/第3章-语言基础.html#一元操作符",a:"一元操作符"},"58.63":{t:"递增/递减操作符",p:`递增和递减操作符有两个版本：前缀版和后缀版。
两个版本的区别是后缀版的递增和递减在语句被求值后才发生。
这 2 对操作符可以用作于任何值，意思就是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。 ...`,l:"JavaScript/第3章-语言基础.html#递增-递减操作符",a:"递增-递减操作符"},"58.64":{t:"一元加和减",p:`一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号(+)表示，放在变量前头，对数值没有任何影响。
一元减由一个减号(-)表示，放在变 ...`,l:"JavaScript/第3章-语言基础.html#一元加和减",a:"一元加和减"},"58.65":{t:"位操作符",p:`正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位(称为第 0 位)表示 20，第二位表示 21，依此类推。
负值以一种称为二补数(或补码)的二进制编码存储。一个数值的二补数通 ...`,l:"JavaScript/第3章-语言基础.html#位操作符",a:"位操作符"},"58.66":{t:"按位非",p:`按位非操作符用波浪符(~)表示，它的作用是返回数值的一补数。
let num1 = 25 // 二进制00000000000000000000000000011001
let num2 = ~num1 ...`,l:"JavaScript/第3章-语言基础.html#按位非",a:"按位非"},"58.67":{t:"按位与",p:`按位与操作符用和号(&amp;)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作。



第一个数值的位
第二个数值的位
结果




 ...`,l:"JavaScript/第3章-语言基础.html#按位与",a:"按位与"},"58.68":{t:"按位或",p:`按位或操作符用管道符(|)表示，同样有两个操作数。按位或遵循如下真值表:



第一个数值的位
第二个数值的位
结果




1
1
1


1
0



0
1
1


0
0
0



按位异或
 ...`,l:"JavaScript/第3章-语言基础.html#按位或",a:"按位或"},"58.69":{t:"左移",p:`左移操作符用两个小于号(&lt;&lt;)表示，会按照指定的位数将数值的所有位向左移动。
`,l:"JavaScript/第3章-语言基础.html#左移",a:"左移"},"58.70":{t:"有符号右移",p:`有符号右移由两个大于号(&gt;&gt;)表示，会将数值的所有 32 位都向右移，同时保留符号(正或负)。 有符号右移实际上是左移的逆运算。
`,l:"JavaScript/第3章-语言基础.html#有符号右移",a:"有符号右移"},"58.71":{t:"无符号右移",p:`无符号右移用 3 个大于号表示(&gt;&gt;&gt;)，会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。
对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会 ...`,l:"JavaScript/第3章-语言基础.html#无符号右移",a:"无符号右移"},"58.72":{t:"布尔操作符",p:"",l:"JavaScript/第3章-语言基础.html#布尔操作符",a:"布尔操作符"},"58.73":{t:"逻辑非",p:`逻辑非操作符由一个叹号(!)表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布 尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。
逻辑非操作 ...`,l:"JavaScript/第3章-语言基础.html#逻辑非",a:"逻辑非"},"58.74":{t:"逻辑与",p:`逻辑与操作符由两个和号(&amp;&amp;)表示，应用到两个值。
逻辑与操作符遵循如下真值表



第一个操作数
第二个操作数
结果




true
true
true


true
false
 ...`,l:"JavaScript/第3章-语言基础.html#逻辑与",a:"逻辑与"},"58.75":{t:"逻辑或",p:`逻辑或操作符由两个管道符(||)表示
逻辑或操作符遵循如下真值表



第一个操作数
第二个操作数
结果




true
true
true


true
false
true


false
tr ...`,l:"JavaScript/第3章-语言基础.html#逻辑或",a:"逻辑或"},"58.76":{t:"乘性操作符",p:`ECMAScript 定义了 3 个乘性操作符:乘法、除法和取模
`,l:"JavaScript/第3章-语言基础.html#乘性操作符",a:"乘性操作符"},"58.77":{t:"乘法操作符",p:`乘法操作符由一个星号(*)表示，可以用于计算两个数值的乘积。
特殊值处理
1. 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ...`,l:"JavaScript/第3章-语言基础.html#乘法操作符",a:"乘法操作符"},"58.78":{t:"除法运算符",p:`除法操作符由一个斜杠(/)表示，可以用于计算第一个操作数除以第二个操作数的商
特殊值处理
1. 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得 ...`,l:"JavaScript/第3章-语言基础.html#除法运算符",a:"除法运算符"},"58.79":{t:"取模运算符",p:`取模(余数)操作符由一个百分比符号(%)表示
特殊值处理

如果操作数是数值，则执行常规除法运算，返回余数。
如果被除数是无限值，除数是有限值，则返回 NaN。
如果被除数是有限值，除数是 0，则返回 ...`,l:"JavaScript/第3章-语言基础.html#取模运算符",a:"取模运算符"},"58.80":{t:"指数操作符",p:`ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**
不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作
let square ...`,l:"JavaScript/第3章-语言基础.html#指数操作符",a:"指数操作符"},"58.81":{t:"加性操作符",p:`加性操作符，即加法和减法操作符
`,l:"JavaScript/第3章-语言基础.html#加性操作符",a:"加性操作符"},"58.82":{t:"加法操作符",p:`加法操作符(+)用于求两个数的和
两个操作数都是数值执行规则

如果有任一操作数是 NaN，则返回 NaN;
如果是 Infinity 加 Infinity，则返回 Infinity;
如果是-Inf ...`,l:"JavaScript/第3章-语言基础.html#加法操作符",a:"加法操作符"},"58.83":{t:"减法操作符",p:`减法操作符(-)也是使用很频繁的一种操作符。
计算规则

如果两个操作数都是数值，则执行数学减法运算并返回结果。
如果有任一操作数是 NaN，则返回 NaN。
如果是 Infinity 减 Infin ...`,l:"JavaScript/第3章-语言基础.html#减法操作符",a:"减法操作符"},"58.84":{t:"关系操作符",p:`关系操作符执行比较两个值的操作，包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)
执行规则

如果操作数都是数值，则执行数值比较。
如果操作数都是字符串，则逐个比 ...`,l:"JavaScript/第3章-语言基础.html#关系操作符",a:"关系操作符"},"58.85":{t:"相等操作符",p:`第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换
`,l:"JavaScript/第3章-语言基础.html#相等操作符",a:"相等操作符"},"58.86":{t:"等于和不等于",p:"ECMAScript 中的等于操作符用两个等于号(==)表示，如果操作数相等，则会返回 true。不等于操作符用叹号和等于号(!=)表示，如果两个操作数不相等，则会返回 true。这两个操作符都会先进 ...",l:"JavaScript/第3章-语言基础.html#等于和不等于",a:"等于和不等于"},"58.87":{t:"全等和不全等",p:`全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号(===)表示，只有两个操作数在不转换的前提下相等才返回 true
不全等操作符用一个叹号和两 ...`,l:"JavaScript/第3章-语言基础.html#全等和不全等",a:"全等和不全等"},"58.88":{t:"条件操作符",p:` variable = boolean_expression ? true_value : false_value;

上面的代码执行了条件赋值操作，即根据条件表达式 boolean_expressi ...`,l:"JavaScript/第3章-语言基础.html#条件操作符",a:"条件操作符"},"58.89":{t:"赋值操作符",p:`简单赋值用等于号(=)表示，将右手边的值赋给左手边的变量
复合赋值操作符

乘后赋值(*=)
除后赋值(/=)
取模后赋值(%=)
加后赋值(+=)
减后赋值(-=)
左移后赋值(&lt;&lt;=) ...`,l:"JavaScript/第3章-语言基础.html#赋值操作符",a:"赋值操作符"},"58.90":{t:"逗号操作符",p:`逗号操作符可以用来在一条语句中执行多个操作，如下所示:
let num1 = 1,
  num2 = 2,
  num3 = 3

也可以使用逗号操作符来辅助 赋值。在赋值时使用逗号操作符分隔值，最终 ...`,l:"JavaScript/第3章-语言基础.html#逗号操作符",a:"逗号操作符"},"58.91":{t:"语句(后续整理)",p:`P98
`,l:"JavaScript/第3章-语言基础.html#语句-后续整理",a:"语句-后续整理"},"59.0":{t:"最近，软件开发设计公司 The Software House 针对 2022 年前端市场状态的调查显示，84% 的受访者都在使用 TypeScript，43% 的受访者甚至认为 TypeScript 将超越 JavaScript 成为前端开发的主要语言。",p:"无论 TypeScript 是否会超越 JavaScript，可以肯定的是，TypeScript 已被开发人员普遍接受，和 ES6 语法以及前端框架一起，被视为前端开发领域的基础工具。但是，关于 Ty ...",l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html",a:"最近-软件开发设计公司-the-software-house-针对-2022-年前端市场状态的调查显示-84-的受访者都在使用-typescript-43-的受访者甚至认为-typescript-将超越-javascript-成为前端开发的主要语言。"},"59.1":{t:"为什么说 TypeScript 可能超越 JavaScript？",p:"我们知道，JavaScript 一直以灵活性著称。在实际开发时，我们不需要确定一个变量的类型，就能直接访问可能并不存在的属性，所以无需为每一步操作都定义类型。在小型项目中，这种灵活性可以有效提高开发效 ...",l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#为什么说-typescript-可能超越-javascript",a:"为什么说-typescript-可能超越-javascript"},"59.2":{t:"如何系统学习 TypeScript？",p:"随着越来越多的前端开发者开始尝试学习和使用 TypeScript，理论上 TypeScript 应该已经完全取代 JavaScript 了，但实际上并没有。一方面，就像我们前面所说，项目规模较小或部分 ...",l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#如何系统学习-typescript",a:"如何系统学习-typescript"},"59.3":{t:"这门课程是如何设计的？",p:`按照我们上面讲到的学习路径，这门课程也将分为类型能力篇、语法篇和工程实践篇。从下图中也能看出，我们会将重点更多地放在类型部分。
!img
我们会从 TypeScript 的类型基础开始学习，然后到泛型 ...`,l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#这门课程是如何设计的",a:"这门课程是如何设计的"},"59.4":{t:"写在最后",p:`无论你处于哪个阶段，只要想开始学习 TypeScript，这门课程就是适合你的。只要你沿着课程中给出的路线，完成这一路上的各种任务，就一定能从新手成功迈向高级玩家。
同时我也希望，你可以把它当作一本备 ...`,l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#写在最后",a:"写在最后"},"59.5":{t:" ",p:"",l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#",a:""},"59.6":{t:"课程中的代码",p:`
小册中的所有代码都会存放在 TypeScript-Tiny-Book 这个仓库里，基于 Monorepo 架构来隔离了各个不同部分的示例代码，同时在每一节也会给出对应代码的地址。

`,l:"TypeScript/01.开篇：用正确的方式学习 TypeScript.html#课程中的代码",a:"课程中的代码"},"60.0":{t:"在正式开始小册的学习前，我们还有一件事要做，那就是搭建 TypeScript 的开发环境。一个舒适、便捷且顺手的开发环境，不仅能大大提高学习效率，也会对我们日常的开发工作有很大帮助。",p:"这一节我们就来介绍 VS Code 下的 TypeScript 环境搭建：插件以及配置项。对于 TS 文件的执行，我们会介绍 ts-node、ts-node-dev 等工具，帮助你快速验证 TS 代码 ...",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html",a:"在正式开始小册的学习前-我们还有一件事要做-那就是搭建-typescript-的开发环境。一个舒适、便捷且顺手的开发环境-不仅能大大提高学习效率-也会对我们日常的开发工作有很大帮助。"},"60.1":{t:"VS Code 配置与插件",p:"VS Code 本身就是由 TypeScript 编写的，因此它对 TypeScript 有着非常全面的支持，包括类型检查、补全等功能，我们需要的两个 TS 插件都来自于社区，这两个插件分别提供了类型 ...",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#vs-code-配置与插件",a:"vs-code-配置与插件"},"60.2":{t:"其他插件",p:`除了 TS 强相关的插件与配置，还有一些额外的、能提升你学习效率的插件，你可以依据自己的喜好进行添加，以下的插件列表将会不定期进行更新。


ErrorLens，这一插件能够把你的 VS Code 底 ...`,l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#其他插件",a:"其他插件"},"60.3":{t:"Playground：懒人福音",p:`如果你只是想拥有一个简单的环境，能写 TypeScript，能检查错误，能快速地调整 tsconfig，那官方提供的 Playground 一定能满足你的需求。
!img
你可以在这里编写 TS 代码 ...`,l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#playground-懒人福音",a:"playground-懒人福音"},"60.4":{t:"TS 文件的快速执行：ts-node 与 ts-node-dev",p:"当然，如果你主要是想执行 TypeScript 文件，就像 node index.js 这样快速地验证代码逻辑，这个时候你就需要 ts-node 以及 ts-node-dev 这一类工具了。它们能直接 ...",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#ts-文件的快速执行-ts-node-与-ts-node-dev",a:"ts-文件的快速执行-ts-node-与-ts-node-dev"},"60.5":{t:"更方便的类型兼容性检查",p:`某些时候，我们在进行类型比较时，需要使用一个具有具体类型的变量与一个类型进行赋值操作，比如下面这个例子中：
interface Foo {
  name: string;
  age: number; ...`,l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#更方便的类型兼容性检查",a:"更方便的类型兼容性检查"},"60.6":{t:"总结",p:"在这一节中，我们主要了解了 TypeScript 开发环境的搭建，包括了 VS Code 的配置、插件，使用 Playground 作为一个简易又强大的临时编辑器，以及如何使用 ts-node 与 t ...",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#总结",a:"总结"},"60.7":{t:"扩展阅读",p:"",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#扩展阅读",a:"扩展阅读"},"60.8":{t:"require extension",p:"我们知道，node 中最早使用的是 CommonJs 与 require 来进行模块的导入，除了 .js 文件的导入以外，node 中还支持以扩展的形式来提供自定义扩展名的模块加载机制，这也是 ts- ...",l:"TypeScript/02.工欲善其事：打造最舒适的 TypeScript 开发环境.html#require-extension",a:"require-extension"},"61.0":{t:"通常来说，学习一件新事物的较好方式是和你已掌握的做对比，通过二者之间通用的概念帮你快速熟悉新的事物。比如，在掌握了 Vue 以后再去学习 React，对于组件通信、状态管理、插槽等这些二者共有的概念，你会感到非常熟悉。同样的，这一章我们会从 JavaScript 的既有概念开始学习，详细讲解 TypeScript 所有原始类型、数组以及对象的类型标注，让你能快速对 TypeScript 的功能、语法有一个基础认知。",p:`这一章会包含几乎所有与原始类型、对象类型、数组等强相关的知识点，这么设计主要是因为它们之间的内容环环相扣，而且也不难，放在一起能帮助你一次性建立相对完整的知识体系。
如果你已经对这一章的知识点有基本了 ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html",a:"通常来说-学习一件新事物的较好方式是和你已掌握的做对比-通过二者之间通用的概念帮你快速熟悉新的事物。比如-在掌握了-vue-以后再去学习-react-对于组件通信、状态管理、插槽等这些二者共有的概念-你会感到非常熟悉。同样的-这一章我们会从-javascript-的既有概念开始学习-详细讲解-typescript-所有原始类型、数组以及对象的类型标注-让你能快速对-typescript-的功能、语法有一个基础认知。"},"61.1":{t:"原始类型的类型标注",p:"首先，我们来看 JavaScript的内置原始类型。除了最常见的 number / string / boolean / null / undefined， ECMAScript 2015（ES6）、 ...",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#原始类型的类型标注",a:"原始类型的类型标注"},"61.2":{t:"null 与 undefined",p:"在 JavaScript 中，null 与 undefined 分别表示“这里有值，但是个空值”和“这里没有值”。而在 TypeScript 中，null 与 undefined 类型都是有具体意义的 ...",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#null-与-undefined",a:"null-与-undefined"},"61.3":{t:"void",p:`你是否看到过以下的 JavaScript 代码呢？
&lt;a href=&quot;javascript:void(0)&quot;&gt;清除缓存&lt;/a&gt;

这里的 void(0) 等 ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#void",a:"void"},"61.4":{t:"数组的类型标注",p:`数组同样是我们最常用的类型之一，在 TypeScript 中有两种方式来声明一个数组类型：
const arr1: string[] = [];

const arr2: Array&lt;strin ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#数组的类型标注",a:"数组的类型标注"},"61.5":{t:"对象的类型标注",p:"作为 JavaScript 中使用最频繁的数据结构，对象的类型标注是我们本节要重点关注的部分。接下来我们会学习如何在 TypeScript 中声明对象、修饰对象属性，以及了解可能存在的使用误区。这些内 ...",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#对象的类型标注",a:"对象的类型标注"},"61.6":{t:"修饰接口属性",p:`类似于上面的元组可选，在接口结构中同样通过 ? 来标记一个属性为可选：
interface IDescription {
  name: string;
  age: number;
  male?: ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#修饰接口属性",a:"修饰接口属性"},"61.7":{t:"type 与 interface",p:"我也知道，很多同学更喜欢用 type（Type Alias，类型别名）来代替接口结构描述对象，而我更推荐的方式是，interface 用来描述对象、类的结构，而类型别名用来将一个函数签名、一组联合类型 ...",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#type-与-interface",a:"type-与-interface"},"61.8":{t:"object、Object 以及 ",p:`object、Object 以及{}（一个空对象）这三者的使用可能也会让部分同学感到困惑，所以我也专门解释下。
首先是 Object 的使用。被 JavaScript 原型链折磨过的同学应该记得，原型 ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#",a:""},"61.9":{t:"总结与预告",p:`这一节，我们一起学习了 TypeScript 中原始类型、对象类型、数组（元组）的类型标注，以及对数组的只读、对象类型属性的访问性修饰。这里的知识其实可以分为两类：

与 JavaScript 概念基 ...`,l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#总结与预告",a:"总结与预告"},"61.10":{t:"扩展阅读",p:"",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#扩展阅读",a:"扩展阅读"},"61.11":{t:"unique symbol",p:"Symbol 在 JavaScript 中代表着一个唯一的值类型，它类似于字符串类型，可以作为对象的属性名，并用于避免错误修改 对象 / Class 内部属性的情况。而在 TypeScript 中，s ...",l:"TypeScript/03.进入类型的世界：理解原始类型与对象类型.html#unique-symbol",a:"unique-symbol"},"62.0":{t:"> 了解了原始类型与对象类型以后，我们已经能完成简单场景的类型标注了。但这还远远不够，我们还可以让这些类型标注更精确一些。比如，有一个接口结构，它描述了响应的消息结构：",p:`
interface IRes {
  code: number;
  status: string;
  data: any;
}

在大多数情况下，这里的 code 与 status 实际值会来自 ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html",a:"了解了原始类型与对象类型以后-我们已经能完成简单场景的类型标注了。但这还远远不够-我们还可以让这些类型标注更精确一些。比如-有一个接口结构-它描述了响应的消息结构"},"62.1":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.2":{t:"字面量类型与联合类型",p:`
我们可以使用联合类型加上字面量类型，把上面的例子改写成这样：
interface Res {
  code: 10000 | 10001 | 50000;
  status: &quot;succe ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#字面量类型与联合类型",a:"字面量类型与联合类型"},"62.3":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.4":{t:"字面量类型",p:`
最开始你可能觉得很神奇，&quot;success&quot; 不是一个值吗？为什么它也可以作为类型？在 TypeScript 中，这叫做字面量类型（Literal Types），它代表着比原始类型 ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#字面量类型",a:"字面量类型"},"62.5":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.6":{t:"联合类型",p:`
而联合类型你可以理解为，它代表了一组类型的可用集合，只要最终赋值的类型属于联合类型的成员之一，就可以认为符合这个联合类型。联合类型对其成员并没有任何限制，除了上面这样对同一类型字面量的联合，我们还可 ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#联合类型",a:"联合类型"},"62.7":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.8":{t:"对象字面量类型",p:`
类似的，对象字面量类型就是一个对象类型的值。当然，这也就意味着这个对象的值全都为字面量值：
interface Tmp {
  obj: {
    name: &quot;linbudu&quot ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#对象字面量类型",a:"对象字面量类型"},"62.9":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.10":{t:"枚举",p:`
枚举并不是 JavaScript 中原生的概念，在其他语言中它都是老朋友了（Java、C#、Swift 等）。目前也已经存在给 JavaScript（ECMAScript）引入枚举支持的 propo ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#枚举",a:"枚举"},"62.11":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.12":{t:"常量枚举",p:`
常量枚举和枚举相似，只是其声明多了一个 const：
const enum Items {
  Foo,
  Bar,
  Baz
}

const fooValue = Items.Foo; // ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#常量枚举",a:"常量枚举"},"62.13":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.14":{t:"总结与预告",p:`
在这一节中，我们了解了字面量类型和枚举的使用，包括字面量类型的分类，与联合类型的结合使用，以及枚举与其编译产物等等。
对于字面量类型，我们可以使用它来提供更精确的类型标注。比如，你可以将如用户类型与 ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#总结与预告",a:"总结与预告"},"62.15":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.16":{t:"扩展阅读",p:`
`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#扩展阅读",a:"扩展阅读"},"62.17":{t:" ",p:"",l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#",a:""},"62.18":{t:"类型控制流分析中的字面量类型",p:`
除了手动声明字面量类型以外，实际上 TypeScript 也会在某些情况下将变量类型推导为字面量类型，看这个例子：
!image.png
!image.png
你会发现，使用 const 声明的变量 ...`,l:"TypeScript/04.掌握字面量类型与枚举，让你的类型再精确一些.html#类型控制流分析中的字面量类型",a:"类型控制流分析中的字面量类型"},"63.0":{t:"在前面的入门环节中，我们了解了日常开发中最常用的、基础的变量类型标注，包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友：**函数**。函数能够帮助我们进一步抽离与封装代码逻辑，所以掌握函数类型必不可少。如果说函数代表着面向过程的编程，那么 Class 则代表着面向对象的编程，而它也是 ES6 新特性的重要一部分———我们终于可以和各种花式继承告别了。",p:"这一节，我们会介绍函数与 Class 的类型标注，以及一些在 TypeScript 中独有或相比 JavaScript 更加完全的概念，如重载与面向对象的编程等。函数部分，我们主要关注其参数类型、返回 ...",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html",a:"在前面的入门环节中-我们了解了日常开发中最常用的、基础的变量类型标注-包括原始类型、对象类型、字面量类型与枚举类型。而实际开发中还有一个重要的朋友-函数-。函数能够帮助我们进一步抽离与封装代码逻辑-所以掌握函数类型必不可少。如果说函数代表着面向过程的编程-那么-class-则代表着面向对象的编程-而它也是-es6-新特性的重要一部分———我们终于可以和各种花式继承告别了。"},"63.1":{t:"函数",p:"",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#函数",a:"函数"},"63.2":{t:"函数的类型签名",p:`如果说变量的类型是描述了这个变量的值类型，那么函数的类型就是描述了函数入参类型与函数返回值类型，它们同样使用:的语法进行类型标注。我们直接看最简单的例子：
function foo(name: str ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#函数的类型签名",a:"函数的类型签名"},"63.3":{t:"void 类型",p:`在 TypeScript 中，一个没有返回值（即没有调用 return 语句）的函数，其返回类型应当被标记为 void 而不是 undefined，即使它实际的值是 undefined。
// 没有调 ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#void-类型",a:"void-类型"},"63.4":{t:"可选参数与 rest 参数",p:"在很多时候，我们会希望函数的参数可以更灵活，比如它不一定全都必传，当你不传入参数时函数会使用此参数的默认值。正如在对象类型中我们使用 ? 描述一个可选属性一样，在函数类型中我们也使用 ? 描述一个可选 ...",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#可选参数与-rest-参数",a:"可选参数与-rest-参数"},"63.5":{t:"重载",p:`在某些逻辑较复杂的情况下，函数可能有多组入参类型和返回值类型：
function func(foo: number, bar?: boolean): string | number {
  if (b ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#重载",a:"重载"},"63.6":{t:"异步函数、Generator 函数等类型签名",p:`对于异步函数、Generator 函数、异步 Generator 函数的类型签名，其参数签名基本一致，而返回值类型则稍微有些区别：
async function asyncFunc(): Promis ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#异步函数、generator-函数等类型签名",a:"异步函数、generator-函数等类型签名"},"63.7":{t:"Class",p:"",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#class",a:"class"},"63.8":{t:"类与类成员的类型签名",p:"一个函数的主要结构即是参数、逻辑和返回值，对于逻辑的类型标注其实就是对普通代码的标注，所以我们只介绍了对参数以及返回值地类型标注。而到了 Class 中其实也一样，它的主要结构只有构造函数、属性、方法 ...",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#类与类成员的类型签名",a:"类与类成员的类型签名"},"63.9":{t:"修饰符",p:"在 TypeScript 中我们能够为 Class 成员添加这些修饰符：public / private / protected / readonly。除 readonly 以外，其他三位都属于访问性 ...",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#修饰符",a:"修饰符"},"63.10":{t:"静态成员",p:`在 TypeScript 中，你可以使用 static 关键字来标识一个成员为静态成员：
class Foo {
  static staticHandler() { }

  public inst ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#静态成员",a:"静态成员"},"63.11":{t:"继承、实现、抽象类",p:`既然说到 Class，那就一定离不开继承。与 JavaScript 一样，TypeScript 中也使用 extends 关键字来实现继承：
class Base { }

class Derived ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#继承、实现、抽象类",a:"继承、实现、抽象类"},"63.12":{t:"总结与预告",p:"在这一节，我们了解了 TypeScript 中的函数与类，它们分别代表了面向过程与面向对象的编程理念。对于函数，我们着重了解其结构体的类型，即参数类型（可选参数与剩余参数）与返回值类型的标注。而对于类 ...",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#总结与预告",a:"总结与预告"},"63.13":{t:"扩展阅读",p:"",l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#扩展阅读",a:"扩展阅读"},"63.14":{t:"私有构造函数",p:`上面说到，我们通常不会对类的构造函数进行访问性修饰，如果我们一定要试试呢？
class Foo {
  private constructor() { }
}

看起来好像没什么问题，但是当你想要实例 ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#私有构造函数",a:"私有构造函数"},"63.15":{t:"SOLID 原则",p:`SOLID 原则是面向对象编程中的基本原则，它包括以下这些五项基本原则。
S，单一功能原则，一个类应该仅具有一种职责，这也意味着只存在一种原因使得需要修改类的代码。如对于一个数据实体的操作，其读操作和 ...`,l:"TypeScript/05.函数与 Class 中的类型：详解函数重载与面向对象.html#solid-原则",a:"solid-原则"},"64.0":{t:"此前我们学习基础类型标注、字面量类型与枚举、函数与 Class 等概念时，实际上一直在用 JavaScript 的概念来进行映射，或者说这可以看作是 JavaScript 代码到 TypeScript 代码的第一步迁移。而这一节，我们要学习的则是，**如何使用 TypeScript 提供的内置类型在类型世界里获得更好的编程体验**。",p:"首先是内置的可用于标注的类型，包括 any、unknown 与 never，加上这一部分我们就掌握了 TypeScript 中所有的内置类型标注。然后是类型断言这一重要能力，我们会介绍它的正确使用场景 ...",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html",a:"此前我们学习基础类型标注、字面量类型与枚举、函数与-class-等概念时-实际上一直在用-javascript-的概念来进行映射-或者说这可以看作是-javascript-代码到-typescript-代码的第一步迁移。而这一节-我们要学习的则是-如何使用-typescript-提供的内置类型在类型世界里获得更好的编程体验-。"},"64.1":{t:"内置类型：any 、unknown 与 never",p:"有些时候，我们的 TS 代码并不需要十分精确严格的类型标注。比如 console.log 方法就能够接受任意类型的参数，不管你是数组、字符串、对象或是其他的，统统来者不拒。那么，我们难道要把所有类型用 ...",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#内置类型-any-、unknown-与-never",a:"内置类型-any-、unknown-与-never"},"64.2":{t:"虚无的 never 类型",p:`是不是有点不好理解？我们看一个联合类型的例子就能 get 到一些了。
type UnionWithNever = &quot;linbudu&quot; | 599 | true | void | n ...`,l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#虚无的-never-类型",a:"虚无的-never-类型"},"64.3":{t:"类型断言：警告编译器不准报错",p:"类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新指定类型的操作，它的基本语法是 as NewType，你可以将 any / un ...",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#类型断言-警告编译器不准报错",a:"类型断言-警告编译器不准报错"},"64.4":{t:"双重断言",p:`如果在使用类型断言时，原类型与断言类型之间差异过大，也就是指鹿为马太过离谱，离谱到了指鹿为霸王龙的程度，TypeScript 会给你一个类型报错：
const str: string = &quot; ...`,l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#双重断言",a:"双重断言"},"64.5":{t:"非空断言",p:"非空断言其实是类型断言的简化，它使用 ! 语法，即 obj!.func()!.prop 的形式标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型），比如这个例子： ...",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#非空断言",a:"非空断言"},"64.6":{t:"总结与预告",p:"在这一节中，我们学习了 TypeScript 中的内置类型 any、unknown 与 never，包括它们的类型兼容性表现与使用场景。而在另外一部分类型断言中，我们了解了类型断言的基本使用，以及结合 ...",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#总结与预告",a:"总结与预告"},"64.7":{t:"扩展阅读",p:"",l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#扩展阅读",a:"扩展阅读"},"64.8":{t:"类型层级初探",p:`这一节的知识点其实都和 TypeScript 的类型层级有所关联，我们会在后面的类型系统部分有专门一节进行详细地讲述，这里只做简单地描述来供有兴趣的同学提前了解。
前面我们已经说到，any 与 unk ...`,l:"TypeScript/06.探秘内置类型：any、unknown、never 与类型断言.html#类型层级初探",a:"类型层级初探"},"65.0":{t:"上一节，我们了解了 TypeScript 中的内置类型 any、unknown 与 never，也提到这些内置类型实际上是最基础的“积木”。那想要利用好这些“积木”，我们还需要一些实用的类型工具。它们就像是锤子、锯子和斧子，有了它们的帮助，我们甚至可以拼装出摩天大楼！",p:`在实际的类型编程中，为了满足各种需求下的类型定义，我们通常会结合使用这些类型工具。因此，我们一定要清楚这些类型工具各自的使用方法和功能。
所以，接下来我们会用两节课的时间来聊聊这些类型工具。类型工具顾 ...`,l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html",a:"上一节-我们了解了-typescript-中的内置类型-any、unknown-与-never-也提到这些内置类型实际上是最基础的-积木-。那想要利用好这些-积木-我们还需要一些实用的类型工具。它们就像是锤子、锯子和斧子-有了它们的帮助-我们甚至可以拼装出摩天大楼"},"65.1":{t:"类型别名",p:`类型别名可以说是 TypeScript 类型编程中最重要的一个功能，从一个简单的函数类型别名，到让你眼花缭乱的类型体操，都离不开类型别名。虽然很重要，但它的使用却并不复杂：
type A = stri ...`,l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#类型别名",a:"类型别名"},"65.2":{t:"联合类型与交叉类型",p:`在原始类型与对象类型一节，我们了解了联合类型。但实际上，联合类型还有一个和它有点像的孪生兄弟：交叉类型。它和联合类型的使用位置一样，只不过符号是&amp;，即按位与运算符。
实际上，正如联合类型的符号 ...`,l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#联合类型与交叉类型",a:"联合类型与交叉类型"},"65.3":{t:"索引类型",p:"索引类型指的不是某一个特定的类型工具，它其实包含三个部分：索引签名类型、索引类型查询与索引类型访问。目前很多社区的学习教程并没有这一点进行说明，实际上这三者都是独立的类型工具。唯一共同点是，它们都通过 ...",l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#索引类型",a:"索引类型"},"65.4":{t:"索引签名类型",p:`索引签名类型主要指的是在接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：
interface AllStringTypes {
  [key: string]: string;
} ...`,l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#索引签名类型",a:"索引签名类型"},"65.5":{t:"索引类型查询",p:"刚才我们已经提到了索引类型查询，也就是 keyof 操作符。严谨地说，它可以将对象中的所有键转换为对应字面量类型，然后再组合成联合类型。注意，这里并不会将数字类型的键名转换为字符串类型字面量，而是仍然 ...",l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#索引类型查询",a:"索引类型查询"},"65.6":{t:"索引类型访问",p:"在 JavaScript 中我们可以通过 obj[expression] 的方式来动态访问一个对象属性（即计算属性），expression 表达式会先被执行，然后使用返回值来访问属性。而 TypeSc ...",l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#索引类型访问",a:"索引类型访问"},"65.7":{t:"映射类型：类型编程的第一步",p:"不同于索引类型包含好几个部分，映射类型指的就是一个确切的类型工具。看到映射这个词你应该能联想到 JavaScript 中数组的 map 方法，实际上也是如此，映射类型的主要作用即是基于键名映射到键值类 ...",l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#映射类型-类型编程的第一步",a:"映射类型-类型编程的第一步"},"65.8":{t:"总结与预告",p:`这一节，我们认识了类型工具中的类型别名、联合类型、索引类型以及映射类型。这些工具代表了类型工具中用于创建新类型的部分，但它们实现创建的方式却五花八门，以下这张表格概括了它们的实现方式与常见搭配



 ...`,l:"TypeScript/07.类型编程好帮手：TypeScript 类型工具（上）.html#总结与预告",a:"总结与预告"},"66.0":{t:"上一节我们主要了解了类型别名、联合类型与交叉类型、索引类型与映射类型这几样类型工具。在大部分时候，这些类型工具的作用是**基于已有的类型去创建出新的类型**，即类型工具的重要作用之一。",p:`而除了类型的创建以外，类型的安全保障同样属于类型工具的能力之一，我们本节要介绍的就是两个主要用于类型安全的类型工具：类型查询操作符与类型守卫。

本节代码见：Internal Type Tools

`,l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html",a:"上一节我们主要了解了类型别名、联合类型与交叉类型、索引类型与映射类型这几样类型工具。在大部分时候-这些类型工具的作用是-基于已有的类型去创建出新的类型-即类型工具的重要作用之一。"},"66.1":{t:"类型查询操作符：熟悉又陌生的 typeof",p:"TypeScript 存在两种功能不同的 typeof 操作符。我们最常见的一种 typeof 操作符就是 JavaScript 中，用于检查变量类型的 typeof ，它会返回 &quot;stri ...",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#类型查询操作符-熟悉又陌生的-typeof",a:"类型查询操作符-熟悉又陌生的-typeof"},"66.2":{t:"类型守卫",p:`TypeScript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑不断尝试收窄类型，这一能力称之为类型的控制流分析（也可以简单理解为类型推导）。
这么说有点抽象，我们可以想象有一条河流，它从上 ...`,l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#类型守卫",a:"类型守卫"},"66.3":{t:"基于 in 与 instanceof 的类型保护",p:"in 操作符 并不是 TypeScript 中新增的概念，而是 JavaScript 中已有的部分，它可以通过 key in object 的方式来判断 key 是否存在于 object 或其原型链上 ...",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#基于-in-与-instanceof-的类型保护",a:"基于-in-与-instanceof-的类型保护"},"66.4":{t:"类型断言守卫",p:`如果你写过测试用例或者使用过 NodeJs 的 assert 模块，那对断言这个概念应该不陌生：
import assert from 'assert';

let name: any = 'linb ...`,l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#类型断言守卫",a:"类型断言守卫"},"66.5":{t:"总结与预告",p:"在这一节，我们学习了一批新的类型工具，包括操作符 keyof、typeof，属于类型语法的交叉类型、索引类型（的三个部分）、映射类型、类型守卫等等。对这些工具的学习能够更好的帮助你更好的理解“类型编程 ...",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#总结与预告",a:"总结与预告"},"66.6":{t:"扩展阅读",p:"",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#扩展阅读",a:"扩展阅读"},"66.7":{t:"接口的合并",p:"在交叉类型一节中，你可能会注意到，接口和类型别名都能直接使用交叉类型。但除此以外，接口还能够使用继承进行合并，在继承时子接口可以声明同名属性，但并不能覆盖掉父接口中的此属性。子接口中的属性类型需要能够 ...",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#接口的合并",a:"接口的合并"},"66.8":{t:"更强大的可辨识联合类型分析",p:"类型控制流分析其实是一直在不断增强的，在 4.5、4.6、4.7 版本中都有或多或少的场景增强。而这里说的增强，其实就包括了对可辨识联合类型的分析能力。比如下面这个例子在此前（4.6 版本以前）的 T ...",l:"TypeScript/08.类型编程好帮手：TypeScript 类型工具（下）.html#更强大的可辨识联合类型分析",a:"更强大的可辨识联合类型分析"},"67.0":{t:"从这一节开始，我们正式进入到「类型编程进阶篇」的学习。能来到这里意味着你已经对 TypeScript 比较熟悉，甚至开始爱不释手了。但也意味着课程难度有所提升，知识变得更加复杂了。不过，你也不必担心，我会和你一起将思维调整到类型的频道，去认识这些类型世界的新朋友们！",p:"如果说 TypeScript 是一门对类型进行编程的语言，那么泛型就是这门语言里的（函数）参数。这一节，我们就来了解 TypeScript 中无处不在的泛型，以及它在类型别名、对象类型、函数与 Cla ...",l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html",a:"从这一节开始-我们正式进入到「类型编程进阶篇」的学习。能来到这里意味着你已经对-typescript-比较熟悉-甚至开始爱不释手了。但也意味着课程难度有所提升-知识变得更加复杂了。不过-你也不必担心-我会和你一起将思维调整到类型的频道-去认识这些类型世界的新朋友们"},"67.1":{t:"类型别名中的泛型",p:`在类型工具学习中，我们已经接触过类型别名中的泛型，比如类型别名如果声明了泛型坑位，那其实就等价于一个接受参数的函数：
type Factory&lt;T&gt; = T | number | stri ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#类型别名中的泛型",a:"类型别名中的泛型"},"67.2":{t:"泛型约束与默认值",p:`像函数可以声明一个参数的默认值一样，泛型同样有着默认值的设定，比如：
type Factory&lt;T = boolean&gt; = T | number | string;

这样在你调用时就可 ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#泛型约束与默认值",a:"泛型约束与默认值"},"67.3":{t:"多泛型关联",p:`我们不仅可以同时传入多个泛型参数，还可以让这几个泛型参数之间也存在联系。我们可以先看一个简单的场景，条件类型下的多泛型参数：
type Conditional&lt;Type, Condition,  ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#多泛型关联",a:"多泛型关联"},"67.4":{t:"对象类型中的泛型",p:`由于泛型提供了对类型结构的复用能力，我们也经常在对象类型结构中使用泛型。最常见的一个例子应该还是响应类型结构的泛型处理：
interface IRes&lt;TData = unknown&gt; { ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#对象类型中的泛型",a:"对象类型中的泛型"},"67.5":{t:"函数中的泛型",p:`假设我们有这么一个函数，它可以接受多个类型的参数并进行对应处理，比如：

对于字符串，返回部分截取；
对于数字，返回它的 n 倍；
对于对象，修改它的属性并返回。

这个时候，我们要如何对函数进行类型 ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#函数中的泛型",a:"函数中的泛型"},"67.6":{t:"Class 中的泛型",p:"Class 中的泛型和函数中的泛型非常类似，只不过函数中泛型参数的消费方是参数和返回值类型，Class 中的泛型消费方则是属性、方法、乃至装饰器等。同时 Class 内的方法还可以再声明自己独有的泛型 ...",l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#class-中的泛型",a:"class-中的泛型"},"67.7":{t:"内置方法中的泛型",p:`TypeScript 中为非常多的内置对象都预留了泛型坑位，如 Promise 中
function p() {
  return new Promise&lt;boolean&gt;((resolv ...`,l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#内置方法中的泛型",a:"内置方法中的泛型"},"67.8":{t:"总结与预告",p:"在这一节，我们学习了类型编程中的“函数参数”，感受到了泛型与类型别名一同使用时，真的就像一个接收输入再输出结果的函数一样，这样来看是不是泛型就好理解多了？但还没完，我们紧接着了解了泛型的本质：基于调用 ...",l:"TypeScript/09.类型编程基石：TypeScript 中无处不在的泛型.html#总结与预告",a:"总结与预告"},"68.0":{t:"在 TypeScript 中，你可能遇见过以下这样“看起来不太对，但竟然能正常运行”的代码：",p:`class Cat {
  eat() { }
}

class Dog {
  eat() { }
}

function feedCat(cat: Cat) { }

feedCat(new Do ...`,l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html",a:"在-typescript-中-你可能遇见过以下这样-看起来不太对-但竟然能正常运行-的代码"},"68.1":{t:"结构化类型系统",p:`首先回到我们开头提出的问题，如果我们为 Cat 类新增一个独特的方法，这个时候的表现才是符合预期的，即我们只能用真实的 Cat 类来进行调用：
class Cat {
  meow() { }
  e ...`,l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#结构化类型系统",a:"结构化类型系统"},"68.2":{t:"标称类型系统",p:`标称类型系统（Nominal Typing System）要求，两个可兼容的类型，其名称必须是完全一致的，比如以下代码：
type USD = number;
type CNY = number;

 ...`,l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#标称类型系统",a:"标称类型系统"},"68.3":{t:"在 TypeScript 中模拟标称类型系统",p:"再看一遍这句话：类型的重要意义之一是限制了数据的可用操作与实际意义。这往往是通过类型附带的额外信息来实现的（类似于元数据），要在 TypeScript 中实现，其实我们也只需要为类型额外附加元数据即可 ...",l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#在-typescript-中模拟标称类型系统",a:"在-typescript-中模拟标称类型系统"},"68.4":{t:"总结与预告",p:"在这一节中，我们了解了 TypeScript 的结构化类型系统是基于类型结构进行比较的，而标称类型系统是基于类型名来进行比较的。以及在 TypeScript 中，如何通过为类型附加信息的方式，从类型层 ...",l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#总结与预告",a:"总结与预告"},"68.5":{t:"扩展阅读",p:"",l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#扩展阅读",a:"扩展阅读"},"68.6":{t:"类型、类型系统与类型检查",p:`对于类型、类型系统、类型检查，你可以认为它们是不同的概念。

类型：限制了数据的可用操作、意义、允许的值的集合，总的来说就是访问限制与赋值限制。在 TypeScript 中即是原始类型、对象类型、函数 ...`,l:"TypeScript/10.结构化类型系统：类型兼容性判断的幕后.html#类型、类型系统与类型检查",a:"类型、类型系统与类型检查"},"69.0":{t:"如果说类型系统是 TypeScript 中的重要基础知识，那么类型层级就是类型系统中的重要概念之一。对于没有类型语言经验学习的同学，说类型层级是最重要的基础概念也不为过。",p:"类型层级一方面能帮助我们明确各种类型的层级与兼容性，而兼容性问题往往就是许多类型错误产生的原因。另一方面，类型层级也是我们后续学习条件类型必不可少的前置知识。我也建议你能同时学习这两篇内容，遇到不理解 ...",l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html",a:"如果说类型系统是-typescript-中的重要基础知识-那么类型层级就是类型系统中的重要概念之一。对于没有类型语言经验学习的同学-说类型层级是最重要的基础概念也不为过。"},"69.1":{t:"判断类型兼容性的方式",p:`在开始前，我们需要先了解一下如何直观地判断两个类型的兼容性。本节中我们主要使用条件类型来判断类型兼容性，类似这样：
type Result = 'linbudu' extends string ? 1 ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#判断类型兼容性的方式",a:"判断类型兼容性的方式"},"69.2":{t:"从原始类型开始",p:`了解了类型兼容性判断的方式后，我们就可以开始探讨类型层级了。首先，我们从原始类型、对象类型（后文统称为基础类型）和它们对应的字面量类型开始。
type Result1 = &quot;linbudu& ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#从原始类型开始",a:"从原始类型开始"},"69.3":{t:"向上探索，直到穹顶之上",p:"",l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#向上探索-直到穹顶之上",a:"向上探索-直到穹顶之上"},"69.4":{t:"联合类型",p:`我们之前讲过，在联合类型中，只需要符合其中一个类型，我们就可以认为实现了这个联合类型，用条件类型表达是这样的：
type Result7 = 1 extends 1 | 2 | 3 ? 1 : 2;  ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#联合类型",a:"联合类型"},"69.5":{t:"装箱类型",p:"在「原始类型与对象类型」一节中，我们已经讲到了 JavaScript 中装箱对象 String 在 TypeScript 中的体现： String 类型，以及在原型链顶端傲视群雄的 Object 对象 ...",l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#装箱类型",a:"装箱类型"},"69.6":{t:"Top Type",p:"再往上，我们就到达了类型层级的顶端（是不是很快），这里只有 any 和 unknown 这两兄弟。我们在探秘内置类型：any、unknown 与 never 一节中已经了解，any 与 unknown ...",l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#top-type",a:"top-type"},"69.7":{t:"向下探索，直到万物虚无",p:`向下地探索其实就简单多了，首先我们能确认一定有个 never 类型，因为它代表了“虚无”的类型，一个根本不存在的类型。对于这样的类型，它会是任何类型的子类型，当然也包括字面量类型：
type Resu ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#向下探索-直到万物虚无",a:"向下探索-直到万物虚无"},"69.8":{t:"类型层级链",p:`结合我们上面得到的结论，可以书写出这样一条类型层级链：
type TypeChain = never extends 'linbudu'
  ? 'linbudu' extends 'linbudu' ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#类型层级链",a:"类型层级链"},"69.9":{t:"其他比较场景",p:`除了我们上面提到的类型比较，其实还存在着一些比较情况，我们稍作补充。


对于基类和派生类，通常情况下派生类会完全保留基类的结构，而只是自己新增新的属性与方法。在结构化类型的比较下，其类型自然会存在子 ...`,l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#其他比较场景",a:"其他比较场景"},"69.10":{t:"总结与预告",p:"在这一节，我们从一个原始类型开始构造类型层级链，向上触及了 Top Type，向下也见到了 Bottom Type。而在构造过程中，除了父子类型，我们还了解了联合类型的子类型判定、基于结构化类型系统的 ...",l:"TypeScript/11.类型系统层级：从 Top Type 到 Bottom Type.html#总结与预告",a:"总结与预告"},"70.0":{t:"在完成类型层级一节的学习后，这一节学习条件类型对你来说已经没有什么困难了，因为你已经完全理解了它的判断逻辑！那我们直接开始这一节的学习吧！",p:`
本节代码见：Conditional Types

`,l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html",a:"在完成类型层级一节的学习后-这一节学习条件类型对你来说已经没有什么困难了-因为你已经完全理解了它的判断逻辑-那我们直接开始这一节的学习吧"},"70.1":{t:"条件类型基础",p:`条件类型的语法类似于我们平时常用的三元表达式，它的基本语法如下（伪代码）：
ValueA === ValueB ? Result1 : Result2;
TypeA extends TypeB ? R ...`,l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html#条件类型基础",a:"条件类型基础"},"70.2":{t:"infer 关键字",p:"在上面的例子中，假如我们不再比较填充的函数类型是否是 (...args: any[]) =&gt; string 的子类型，而是要拿到其返回值类型呢？或者说，我们希望拿到填充的类型信息的一部分，而不是 ...",l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html#infer-关键字",a:"infer-关键字"},"70.3":{t:"分布式条件类型",p:"分布式条件类型听起来真的很高级，但这里和分布式和分布式服务并不是一回事。分布式条件类型（*Distributive Conditional Type*），也称条件类型的分布式特性，只不过是条件类型在满 ...",l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html#分布式条件类型",a:"分布式条件类型"},"70.4":{t:"总结与预告",p:"在这一节，我们详细地解读了条件类型这一重要类型工具的使用方式、使用场景、分布式特性以及 infer 关键字。对于条件类型最核心的部分，即 extends 所代表的类型兼容性，由于在上一节我们已经了解了 ...",l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html#总结与预告",a:"总结与预告"},"70.5":{t:"扩展阅读：IsAny 与 IsUnknown",p:`上面我们通过比较 hack 的手段得到了 IsNever，那你一定会想是否能实现 IsAny 与 IsUnknown ？当然可以，只不过它们的实现稍微复杂一些，并且并不完全依赖分布式条件类型。
首先是 ...`,l:"TypeScript/12.类型里的逻辑运算：条件类型与 infer.html#扩展阅读-isany-与-isunknown",a:"扩展阅读-isany-与-isunknown"},"71.0":{t:"在很多时候，工具类型其实都被妖魔化了。它仿佛是武林中人人追捧的武功秘籍，修炼难度极其苛刻，掌握它就能立刻类型编程功力大涨，成为武林盟主傲世群雄。然而，这是非常错误的想法。",p:"首先，工具类型学起来不难，它的概念也不复杂。很多同学觉得难，是因为还没完全熟悉所有类型工具，对类型系统还懵懵懂懂的情况下，就直接一头扎进各种复杂的类型编程源码中去。其实只要我们熟悉了类型工具的使用，了 ...",l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html",a:"在很多时候-工具类型其实都被妖魔化了。它仿佛是武林中人人追捧的武功秘籍-修炼难度极其苛刻-掌握它就能立刻类型编程功力大涨-成为武林盟主傲世群雄。然而-这是非常错误的想法。"},"71.1":{t:"工具类型的分类",p:`内置的工具类型按照类型操作的不同，其实也可以大致划分为这么几类：

对属性的修饰，包括对象属性和数组元素的可选/必选、只读/可写。我们将这一类统称为属性修饰工具类型。
对既有类型的裁剪、拼接、转换等， ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#工具类型的分类",a:"工具类型的分类"},"71.2":{t:"属性修饰工具类型",p:`这一部分的工具类型主要使用属性修饰、映射类型与索引类型相关（索引类型签名、索引类型访问、索引类型查询均有使用，因此这里直接用索引类型指代）。
在内置工具类型中，访问性修饰工具类型包括以下三位：
typ ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#属性修饰工具类型",a:"属性修饰工具类型"},"71.3":{t:"思考",p:`现在我们了解了 Partial、Readonly 这一类属性修饰的工具类型，不妨想想它们是否能满足我们的需要？假设场景逐渐开始变得复杂，比如以下这些情况：

现在的属性修饰是浅层的，如果我想将嵌套在里 ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#思考",a:"思考"},"71.4":{t:"结构工具类型",p:`这一部分的工具类型主要使用条件类型以及映射类型、索引类型。
结构工具类型其实又可以分为两类，结构声明和结构处理。
结构声明工具类型即快速声明一个结构，比如内置类型中的 Record：
type Rec ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#结构工具类型",a:"结构工具类型"},"71.5":{t:"思考",p:`
Pick 和 Omit 是基于键名的，如果我们需要基于键值类型呢？比如仅对函数类型的属性？
除了将一个对象结构拆分为多个子结构外，对这些子结构的互斥处理也是结构工具类型需要解决的问题之一。互斥处理指 ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#思考",a:"思考"},"71.6":{t:"集合工具类型",p:`这一部分的工具类型主要使用条件类型、条件类型分布式特性。
在开始集合类型前，我们不妨先聊一聊数学中的集合概念。对于两个集合来说，通常存在交集、并集、差集、补集这么几种情况，用图表示是这样的：
!img ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#集合工具类型",a:"集合工具类型"},"71.7":{t:"思考",p:`
目前为止我们的集合类型都停留在一维的层面，即联合类型之间的集合运算。如果现在我们要处理对象类型结构的集合运算呢？
在处理对象类型结构运算时，可能存在不同的需求，比如合并时，我们可能希望保留原属性或替 ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#思考",a:"思考"},"71.8":{t:"模式匹配工具类型",p:`这一部分的工具类型主要使用条件类型与 infer 关键字。
在条件类型一节中我们已经差不多了解了 infer 关键字的使用，而更严格地说 infer 其实代表了一种 模式匹配（pattern matc ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#模式匹配工具类型",a:"模式匹配工具类型"},"71.9":{t:"思考",p:`
infer 和条件类型的搭配看起来会有奇效，比如在哪些场景？比如随着条件类型的嵌套每个分支会提取不同位置的 infer ？
infer 在某些特殊位置下应该如何处理？比如上面我们写了第一个参数类型， ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#思考",a:"思考"},"71.10":{t:"总结与预告",p:"在这一节，我们对 TypeScript 内置的工具类型进行了全面地讲解，从它们的原理、使用的类型操作、使用场景，到对它们进行扩展的可能方向。在学习完毕本节内容以后，你可能会发现某些工具类型很好地解决了 ...",l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#总结与预告",a:"总结与预告"},"71.11":{t:"扩展阅读",p:"",l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#扩展阅读",a:"扩展阅读"},"71.12":{t:"infer 约束",p:`在某些时候，我们可能对 infer 提取的类型值有些要求，比如我只想要数组第一个为字符串的成员，如果第一个成员不是字符串，那我就不要了。
先写一个提取数组第一个成员的工具类型：
type FirstA ...`,l:"TypeScript/13.内置工具类型基础：别再妖魔化工具类型了！.html#infer-约束",a:"infer-约束"},"72.0":{t:"TypeScript 拥有非常强大的类型推导能力，不仅会在你声明一个变量时自动推导其类型，也会基于函数内部逻辑自动推导其返回值类型，还会在你使用 typeof 、instanceof 等工具时自动地收窄类型（可辨识联合类型）等等。这些类型推导其实有一个共同点：**它们的推导依赖开发者的输入**，比如变量声明、函数逻辑、类型保护都需要开发者的输入。实际上， TypeScript 中还存在着另一种类型推导，它默默无闻却又无处不在，它就是这一节的主角：**上下文类型（Contextual Typing）**。",p:"这一节的内容比较短，因为上下文类型并不是一个多复杂、多庞大的概念（不涉及实现源码的情况下），但在实际开发中，我们经常会受益于上下文类型的推导能力，只不过你可能不知道背后是它得作用。学完这一节，以后感受 ...",l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html",a:"typescript-拥有非常强大的类型推导能力-不仅会在你声明一个变量时自动推导其类型-也会基于函数内部逻辑自动推导其返回值类型-还会在你使用-typeof-、instanceof-等工具时自动地收窄类型-可辨识联合类型-等等。这些类型推导其实有一个共同点-它们的推导依赖开发者的输入-比如变量声明、函数逻辑、类型保护都需要开发者的输入。实际上-typescript-中还存在着另一种类型推导-它默默无闻却又无处不在-它就是这一节的主角-上下文类型-contextual-typing-。"},"72.1":{t:"无处不在的上下文类型",p:`首先举一个最常见的例子：
window.onerror = (event, source, line, col, err) =&gt; {};

在这个例子里，虽然我们并没有为 onerror 的各个 ...`,l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html#无处不在的上下文类型",a:"无处不在的上下文类型"},"72.2":{t:"void 返回值类型下的特殊情况",p:`我们前面说到，上下文类型同样会推导并约束函数的返回值类型，但存在这么个特殊的情况，当内置函数类型的返回值类型为 void 时：
type CustomHandler = (name: string,  ...`,l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html#void-返回值类型下的特殊情况",a:"void-返回值类型下的特殊情况"},"72.3":{t:"总结与预告",p:`在这一节里，我们学习了上下文类型这“另一个方向”的类型推导，了解了它是基于位置进行类型匹配的，以及上下文类型中 void 类型返回值的特殊情况。
这一节比较轻松对吧？那在下一节，我们会学习一个稍微复杂 ...`,l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html#总结与预告",a:"总结与预告"},"72.4":{t:"扩展阅读",p:"",l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html#扩展阅读",a:"扩展阅读"},"72.5":{t:"将更少参数的函数赋值给具有更多参数的函数类型",p:`在上面的例子中，我们看到了这么一段代码：
const arr: number[] = [];
const list: number[] = [1, 2, 3];

list.forEach((item ...`,l:"TypeScript/14.反方向类型推导：用好上下文相关类型.html#将更少参数的函数赋值给具有更多参数的函数类型",a:"将更少参数的函数赋值给具有更多参数的函数类型"},"73.0":{t:"在 全面梳理类型系统的层级关系：从 Top Type 到 Bottom Type 一节中，我们分析了 TypeScript 类型系统自下而上的层级，比较了原始类型、联合类型、对象类型、内置类型等的层级关系。但是，如果你使用过 TypeScript 很容易就会想到，我们好像漏了一点什么：**函数类型有类型层级吗？** 如果有，它的类型层级又是怎么样的？比如，下面这几个函数类型之间的兼容性如何？",p:`type FooFunc = () =&gt; string;
type BarFunc = () =&gt; &quot;literal types&quot;;
type BazFunc = (i ...`,l:"TypeScript/15.数类型：协变与逆变的比较.html",a:"在-全面梳理类型系统的层级关系-从-top-type-到-bottom-type-一节中-我们分析了-typescript-类型系统自下而上的层级-比较了原始类型、联合类型、对象类型、内置类型等的层级关系。但是-如果你使用过-typescript-很容易就会想到-我们好像漏了一点什么-函数类型有类型层级吗-如果有-它的类型层级又是怎么样的-比如-下面这几个函数类型之间的兼容性如何"},"73.1":{t:"如何比较函数的签名类型？",p:`首先要明确的是，我们不会使用函数类型去和其他类型（如对象类型）比较，因为这并没有意义，本文中只会对两个函数类型进行比较。
来看示例，给出三个具有层级关系的类，分别代表动物、狗、柯基。
class An ...`,l:"TypeScript/15.数类型：协变与逆变的比较.html#如何比较函数的签名类型",a:"如何比较函数的签名类型"},"73.2":{t:"协变与逆变",p:"我们上一节得到的结论是，考虑 Corgi ≼ Dog ≼ Animal，当有函数类型 Dog -&gt; Dog，仅有 (Animal → Corgi) ≼ (Dog → Dog) 成立（即能被视作此 ...",l:"TypeScript/15.数类型：协变与逆变的比较.html#协变与逆变",a:"协变与逆变"},"73.3":{t:"TSConfig 中的 StrictFunctionTypes",p:"如果你曾经翻过 tsconfig 配置，你可能会注意到 strictFunctionTypes 这一项配置，但它在文档中的描述其实相对简略了些：在比较两个函数类型是否兼容时，将对函数参数进行更严格的检 ...",l:"TypeScript/15.数类型：协变与逆变的比较.html#tsconfig-中的-strictfunctiontypes",a:"tsconfig-中的-strictfunctiontypes"},"73.4":{t:"总结与预告",p:"在这一节，我们学习了 TypeScript 函数类型的兼容性比较，这应该带给了你一些新的启发：原来不只是原始类型、联合类型、对象类型等可以比较，函数类型之间同样是能够比较的。而对我们开头提出的，如何对 ...",l:"TypeScript/15.数类型：协变与逆变的比较.html#总结与预告",a:"总结与预告"},"73.5":{t:"扩展阅读",p:"",l:"TypeScript/15.数类型：协变与逆变的比较.html#扩展阅读",a:"扩展阅读"},"73.6":{t:"联合类型与兄弟类型下的比较",p:"在上面我们只关注了显式的父子类型关系，实际上在类型层级中还有隐式的父子类型关系（联合类型）以及兄弟类型（同一基类的两个派生类）。对于隐式的父子类型其可以仍然沿用显式的父子类型协变与逆变判断，但对于兄弟 ...",l:"TypeScript/15.数类型：协变与逆变的比较.html#联合类型与兄弟类型下的比较",a:"联合类型与兄弟类型下的比较"},"73.7":{t:"非函数签名包装类型的变换",p:"我们在最开始一直以函数体作为包装类型来作为协变与逆变的转变前提，后面虽然提到了使用数组的作为包装类型（Dog[]）的，但只是一笔带过，重点还是在函数体方面。现在，如果我们就是就是要考虑类似数组这种包装 ...",l:"TypeScript/15.数类型：协变与逆变的比较.html#非函数签名包装类型的变换",a:"非函数签名包装类型的变换"},"74.0":{t:"在学习 TypeScript 时，很多同学可能会遇到这些疑惑：",p:`
这些额外的类型代码，以及类型编程，对实际项目开发的帮助在哪里？我真的需要精通它们吗？
这些工具类型看起来真的好烧脑，并且它们并不能让我的网页运行得更快，让我的 Node 服务并发更高，让我的网页 P ...`,l:"TypeScript/16.了解类型编程与类型体操的意义，找到平衡点.html",a:"在学习-typescript-时-很多同学可能会遇到这些疑惑"},"74.1":{t:"从类型编程到类型体操",p:"你可能会注意到，上面我用了“类型编程”和“类型体操”这两个不同的词。这是因为我通常把 TS 中的类型操作分为这两类。对于类型编程，它是对实际开发中真的有帮助的类型操作，下限非常之低，比如其实我们就是简 ...",l:"TypeScript/16.了解类型编程与类型体操的意义，找到平衡点.html#从类型编程到类型体操",a:"从类型编程到类型体操"},"74.2":{t:"Type Challenges",p:"最后，我们再来说下如何进一步进阶类型编程能力。Type Challenge 是 antfu （Vue 团队成员，以及 Vite、Vitest、Nuxt 等知名开源项目的团队成员或作者）的作品，其中搜集 ...",l:"TypeScript/16.了解类型编程与类型体操的意义，找到平衡点.html#type-challenges",a:"type-challenges"},"75.0":{t:"此前，我们已经了解了 TypeScript 中内置工具类型的实现原理，以及它们的扩展方向。这一节，我们会在这些基础上逐一实现这些扩展方向。",p:`需要说明的是，本节中的工具类型会更加复杂和烧脑一些，你需要确保已经完全掌握了这一节前的绝大部分知识再来学习本节内容。如果在学习过程中发现有知识点的缺失，可以先回到前面的章节复习、巩固，再学不迟。
另外 ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html",a:"此前-我们已经了解了-typescript-中内置工具类型的实现原理-以及它们的扩展方向。这一节-我们会在这些基础上逐一实现这些扩展方向。"},"75.1":{t:"属性修饰进阶",p:`在内置工具类型一节中，对属性修饰工具类型的进阶主要分为这么几个方向：

深层的属性修饰；
基于已知属性的部分修饰，以及基于属性类型的部分修饰。

首先是深层属性修饰，还记得我们在 infer 关键字一 ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#属性修饰进阶",a:"属性修饰进阶"},"75.2":{t:"结构工具类型进阶",p:`前面对结构工具类型主要给出了两个进阶方向：

基于键值类型的 Pick 与 Omit；
子结构的互斥处理。

首先是基于键值类型的 Pick 与 Omit，我们就称之为 PickByValueType ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#结构工具类型进阶",a:"结构工具类型进阶"},"75.3":{t:"集合工具类型进阶",p:`在集合工具类型中我们给到的进阶方向，其实就是从一维原始类型集合，扩展二维的对象类型，在对象类型之间进行交并补差集的运算，以及对同名属性的各种处理情况。
对于对象类型的交并补差集，我们仍然沿用“降级”的 ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#集合工具类型进阶",a:"集合工具类型进阶"},"75.4":{t:"模式匹配工具类型进阶",p:`在内置工具类型一节中，我们对模式匹配工具类型的进阶方向其实只有深层嵌套这么一种，特殊位置的 infer 处理其实大部分时候也是通过深层嵌套实现，比如此前我们实现了提取函数的首个参数类型：
type F ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#模式匹配工具类型进阶",a:"模式匹配工具类型进阶"},"75.5":{t:"总结与预告",p:"这一节我们了解了属性修饰、结构、集合、模式匹配这四大类的工具类型进阶，也通过这些进阶类型了解到了常用的类型编程方式，如对一个对象结构拆分为多个子结构再分别处理，将复杂类型降维到基础类型再逐个击破，以及 ...",l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#总结与预告",a:"总结与预告"},"75.6":{t:"扩展阅读",p:"",l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#扩展阅读",a:"扩展阅读"},"75.7":{t:"RequiredKeys、OptionalKeys",p:`在属性修饰工具类型中我们只实现了 FunctionKeys，它的实现相对简单，因为只需要判断类型即可。那如果，我们要获取一个接口中所有可选或必选的属性呢？现在没法通过类型判断，要怎么去收集属性？
这一 ...`,l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#requiredkeys、optionalkeys",a:"requiredkeys、optionalkeys"},"75.8":{t:"MutableKeys、ImmutableKeys",p:"MutableKeys 和 ImmutableKeys 则要更加复杂一些，因为 readonly 修饰符无法简单地通过结构化类型比较，我们需要一个能对只读这一特性进行判断的辅助工具类型，直接看例子再讲 ...",l:"TypeScript/17.内置工具类型进阶：类型编程进阶.html#mutablekeys、immutablekeys",a:"mutablekeys、immutablekeys"},"76.0":{t:"上一节，我们对内置工具类型的进阶方向进行了实现，它们中的部分工具类型确实相对烧脑和难以理解。这一节，我们稍作驻足，放慢节奏，来学习 TypeScript 的一个特殊存在：**模板字符串类型**。",p:"此前我们已经学习了泛型相关的概念，知道它的表现就像 JavaScript 中的函数参数一样，接受一组参数，处理，然后返回一个新的值。而模板字符串类型，其实也完全可以映射到 JavaScript 中的概 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html",a:"上一节-我们对内置工具类型的进阶方向进行了实现-它们中的部分工具类型确实相对烧脑和难以理解。这一节-我们稍作驻足-放慢节奏-来学习-typescript-的一个特殊存在-模板字符串类型-。"},"76.1":{t:"模板字符串类型的基础使用",p:`我们来看一个最简单的使用例子：
type World = 'World';

// &quot;Hello World&quot;
type Greeting = \`Hello \${World}\`;
 ...`,l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#模板字符串类型的基础使用",a:"模板字符串类型的基础使用"},"76.2":{t:"模板字符串类型的类型表现",p:"实际上，由于模板字符串类型最终的产物还是字符串字面量类型，因此只要插槽位置的类型匹配，字符串字面量类型就可以被认为是模板字符串类型的子类型，比如我们上面的版本号：\ndeclare let v1: `$ ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#模板字符串类型的类型表现",a:"模板字符串类型的类型表现"},"76.3":{t:"结合索引类型与映射类型",p:"说到模板字符串插槽中传入联合类型的自动分发特性时，你可能会想到我们此前接触的一个能够生成联合类型的工具：索引类型查询操作符 keyof。基于 keyof + 模板字符串类型，我们可以基于已有的对象类型 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#结合索引类型与映射类型",a:"结合索引类型与映射类型"},"76.4":{t:"专用工具类型",p:"这些工具类型专用于字符串字面量类型，包括 Uppercase、Lowercase、Capitalize 与 Uncapitalize，看名字就能知道它们的作用：字符串大写、字符串小写、首字母大写与首字 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#专用工具类型",a:"专用工具类型"},"76.5":{t:"模板字符串类型与模式匹配",p:"模式匹配工具类型的核心理念就是对符合约束的某个类型结构，提取其某一个位置的类型，比如函数结构中的参数与返回值类型。而如果我们将一个字符串类型视为一个结构，就能够在其中也应用模式匹配相关的能力，而我们此 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#模板字符串类型与模式匹配",a:"模板字符串类型与模式匹配"},"76.6":{t:"总结与预告",p:"在这一节，我们学习了一个新的内置类型能力：模板字符串类型。它既是内置类型，也是内置类型工具，还包括了专用的工具类型等。在实际应用中，由于其灵活性与自动分发联合能力等能力，我们可以用它来进行大量字面量类 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#总结与预告",a:"总结与预告"},"76.7":{t:"扩展阅读",p:"",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#扩展阅读",a:"扩展阅读"},"76.8":{t:"基于重映射的 PickByValueType",p:"我们在这一节了解了重映射这一能力，它使得我们可以在映射类型中去修改映射后的键名，而如果映射后的键名变成了 never ，那么这个属性将不会出现在最终的接口结构中。也就是说，我们也可以基于重映射来实现结 ...",l:"TypeScript/18.基础类型新成员：模板字符串类型入门.html#基于重映射的-pickbyvaluetype",a:"基于重映射的-pickbyvaluetype"},"77.0":{t:"上一节，我们了解了模板字符串类型的基础内容，它与数个类型工具的协作，以及将作为本节核心内容的，**模板字符串类型与模式匹配产生的化学反应**。",p:"我们还是照例先复习一下，如何在模板插槽中使用 infer 关键字：\ntype ReverseName&lt;Str extends string&gt; =\n  Str extends `${infe ...",l:"TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html",a:"上一节-我们了解了模板字符串类型的基础内容-它与数个类型工具的协作-以及将作为本节核心内容的-模板字符串类型与模式匹配产生的化学反应-。"},"77.1":{t:"从最简单的模式匹配说起：Trim、Includes 等",p:"最简单的模式匹配只有一层条件类型语句，也就意味着我们不需要对模式匹配的结果做结构转换等操作。对比到字符串类型变量的方法，也就是 trim（trimLeft、trimRight）、includes、st ...",l:"TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html#从最简单的模式匹配说起-trim、includes-等",a:"从最简单的模式匹配说起-trim、includes-等"},"77.2":{t:"结构转换：Replace、Split 与 Join",p:"看起来 Replace 好像是挺复杂的实现？但仔细想想它和 Include 其实没有啥区别，Include 判断是否能将字符串字面量划分为目标部分与其他部分，那 Replace 不是只需要将目标部分替 ...",l:"TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html#结构转换-replace、split-与-join",a:"结构转换-replace、split-与-join"},"77.3":{t:"最后一步：Case 转换",p:"在上一节，我们已经了解了 TypeScript 内置的 Lowercase、Capitalize 等工具类型，知道它们是在内部实现的层面支持了字符串值的变换。其实基于这些工具类型，我们完全可以实现几乎 ...",l:"TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html#最后一步-case-转换",a:"最后一步-case-转换"},"77.4":{t:"总结与预告",p:"这一节，我们完成了模板字符串类型的进阶学习，仿照着 JavaScript 中字符串变量的方法实现了 Trim、Include、Replace、Split 以及 Case 转换等工具类型。这些类型虽然在 ...",l:"TypeScript/19.类型编程新范式：模板字符串工具类型进阶.html#总结与预告",a:"总结与预告"},"78.0":{t:"我们已经结束了 TypeScript 类型能力的学习，这一节将进入 TypeScript 的实战应用篇。实战篇主要包括了工程能力、框架集成、ECMAScript 语法、TSConfig 解析以及 Node API 开发这五个部分。",p:"在这一节，我们主要介绍 TypeScript 的工程能力基础，包括类型指令、类型声明、命名空间这么几个部分。这些概念不仅可以帮助你了解到 TypeScript 工程能力的核心理念，也是接下来实战篇内容 ...",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html",a:"我们已经结束了-typescript-类型能力的学习-这一节将进入-typescript-的实战应用篇。实战篇主要包括了工程能力、框架集成、ecmascript-语法、tsconfig-解析以及-node-api-开发这五个部分。"},"78.1":{t:"类型检查指令",p:"在前端世界的许多工具中，其实都提供了 行内注释（Inline Comments） 的能力，用于支持在某一处特定代码使用特殊的配置来覆盖掉全局配置。最常见的即是 ESLint 与 Prettier 提供 ...",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#类型检查指令",a:"类型检查指令"},"78.2":{t:"ts-ignore 与 ts-expect-error",p:`ts-ignore 应该是使用最为广泛的一个类型指令了，它的作用就是直接禁用掉对下一行代码的类型检查：
// @ts-ignore
const name: string = 599;

基本上所有的类 ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#ts-ignore-与-ts-expect-error",a:"ts-ignore-与-ts-expect-error"},"78.3":{t:"ts-check 与 ts-nocheck",p:`我们首先来看 ts-nocheck ，你可以把它理解为一个作用于整个文件的 ignore 指令，使用了 ts-nocheck 指令的 TS 文件将不再接受类型检查：
// @ts-nocheck 以下 ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#ts-check-与-ts-nocheck",a:"ts-check-与-ts-nocheck"},"78.4":{t:"类型声明",p:`在此前我们其实就已经接触到了类型声明，它实际上就是 declare 语法：
declare var f1: () =&gt; void;

declare interface Foo {
  prop ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#类型声明",a:"类型声明"},"78.5":{t:"让类型定义全面覆盖你的项目",p:`在开始学习下面的内容前，不妨先想想你是否遇到过这么几个场景？

想要使用一个 npm 包，但它发布的时间太早，根本没有携带类型定义，于是你的项目里就出现了这么一处没有被类型覆盖的地方。
你想要在代码里 ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#让类型定义全面覆盖你的项目",a:"让类型定义全面覆盖你的项目"},"78.6":{t:"DefinitelyTyped",p:"简单来说，@types/ 开头的这一类 npm 包均属于 DefinitelyTyped ，它是 TypeScript 维护的，专用于为社区存在的无类型定义的 JavaScript 库添加类型支持，常 ...",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#definitelytyped",a:"definitelytyped"},"78.7":{t:"扩展已有的类型定义",p:`对全局变量的声明，还是以 window 为例，实际上我们如果 Ctrl + 点击代码中的 window，会发现它已经有类型声明了：
declare var window: Window &amp; t ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#扩展已有的类型定义",a:"扩展已有的类型定义"},"78.8":{t:"三斜线指令",p:"三斜线指令就像是声明文件中的导入语句一样，它的作用就是声明当前的文件依赖的其他类型声明。而这里的“其他类型声明”包括了 TS 内置类型声明（lib.d.ts）、三方库的类型声明以及你自己提供的类型声明 ...",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#三斜线指令",a:"三斜线指令"},"78.9":{t:"命名空间",p:`假设一个场景，我们的项目里需要接入多个平台的支付 SDK，最开始只有微信支付和支付宝：
class WeChatPaySDK {}

class ALiPaySDK {}

然后又多了美团支付、虚拟货 ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#命名空间",a:"命名空间"},"78.10":{t:"仅类型导入",p:`在 TypeScript 中，当我们导入一个类型时其实并不需要额外的操作，和导入一个实际值是完全一样的：
// foo.ts
export const Foo = () =&gt; {};

expo ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#仅类型导入",a:"仅类型导入"},"78.11":{t:"总结与预告",p:`在这一节，我们主要了解了 TypeScript 在工程层面的基础能力，包括类型指令、类型声明、命名空间三个部分。
类型声明相关的能力几乎是所有规模的工程都会使用到的（你总会遇到没有提供类型定义的库吧） ...`,l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#总结与预告",a:"总结与预告"},"78.12":{t:"扩展阅读",p:"",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#扩展阅读",a:"扩展阅读"},"78.13":{t:"通过 JSDoc 在 JS 文件中获得类型提示",p:"在上面我们提到了可以在 JS 文件中通过 JSDoc 来标注变量类型，而既然有了类型标注，那么自然也能享受到像 TS 文件中一样的类型提示了。但这里我们需要使用更强大一些的 JSDoc 能力：在 @t ...",l:"TypeScript/20.工程层面的类型能力：类型声明、类型指令与命名空间.html#通过-jsdoc-在-js-文件中获得类型提示",a:"通过-jsdoc-在-js-文件中获得类型提示"},"79.0":{t:"这一节我们要介绍的是 React 项目中的 TypeScript 集成，React 和 TypeScript 能进行非常紧密而自然的协作，毕竟 tsx 文件本质上也是一个 ts 文件，因此可以直接享受到 TypeScript 的类型检查能力。也因此，在 React 中使用 TypeScript 并没有非常复杂的地方，我们主要关注三个方面：**组件声明**、**泛型坑位**与**内置类型定义**，对于 React + TypeScript 的工程规范，我们也会简要介绍。",p:"组件声明指的是我们声明一个 React 组件的方式。如何结合 TypeScript 来进行组件属性、返回元素的有效性检查？这些组件声明方式都存在哪些特殊用法？需要注意的是，我们只会介绍函数式组件相关， ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html",a:"这一节我们要介绍的是-react-项目中的-typescript-集成-react-和-typescript-能进行非常紧密而自然的协作-毕竟-tsx-文件本质上也是一个-ts-文件-因此可以直接享受到-typescript-的类型检查能力。也因此-在-react-中使用-typescript-并没有非常复杂的地方-我们主要关注三个方面-组件声明-、-泛型坑位-与-内置类型定义-对于-react-typescript-的工程规范-我们也会简要介绍。"},"79.1":{t:"项目初始化",p:`这里我们使用 Vite 来进行项目搭建，在终端输入以下代码：
npx create-vite

输入项目名，选择 react-ts 模板即可。最终的项目结构是这样的：
├── index.html
├ ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#项目初始化",a:"项目初始化"},"79.2":{t:"项目配置",p:`先不急着开始，我们先观察基于 Vite 创建的初始项目里都包含了哪些配置。
首先是依赖，可以看到在 devDependencies 中包含了 @types/react 与 @types/react-d ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#项目配置",a:"项目配置"},"79.3":{t:"组件声明",p:`首先我们来想想，在 React 中如何声明一个（函数）组件。最简单的方式肯定是直接声明一个函数：
const Container = () =&gt; {
  return &lt;p&gt;林不渡！ ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#组件声明",a:"组件声明"},"79.4":{t:"组件泛型",p:`使用简单函数和使用 FC 的重要差异之一就在于，使用 FC 时你无法再使用组件泛型。组件泛型即指，为你的组件属性再次添加一个泛型，比如这样：
import { PropsWithChildren }  ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#组件泛型",a:"组件泛型"},"79.5":{t:"泛型坑位",p:`常见的泛型坑位主要还是来自于日常使用最多的 Hooks，我们一个个来看。
`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#泛型坑位",a:"泛型坑位"},"79.6":{t:"useState",p:`首先是 useState，可以由输入值隐式推导或者显式传入泛型：
const Container = () =&gt; {
  // 推导为 string 类型
  const [state1, se ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#usestate",a:"usestate"},"79.7":{t:"useCallback 与 useMemo",p:`然后是 useCallback 与 useMemo，它们的泛型参数分别表示包裹的函数和计算产物，使用方式类似，也分为隐式推导与显式提供两种：
const Container = () =&gt; {
 ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#usecallback-与-usememo",a:"usecallback-与-usememo"},"79.8":{t:"useReducer",p:"useReducer 可以被视为更复杂一些的 useState，它们关注的都是数据的变化。不同的是 useReducer 中只能由 reducer 按照特定的 action 来修改数据，但 useSt ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#usereducer",a:"usereducer"},"79.9":{t:"useRef 与 useImperativeHandle",p:`useRef 的常见使用场景主要包括两种，存储一个 DOM 元素引用和持久化保存一个值。这两者情况对应的类型其实也是不同的：
const Container = () =&gt; {
  const  ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#useref-与-useimperativehandle",a:"useref-与-useimperativehandle"},"79.10":{t:"内置类型定义",p:"除了上面介绍的泛型坑位以外，在 React 中想要用好 TypeScript 的另一个关键因素就是使用 @types/react 提供的类型定义，最常见的就是事件类型，比如输入框值变化时的 Chang ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#内置类型定义",a:"内置类型定义"},"79.11":{t:"其他内置类型",p:`还有一部分内置类型并不是日常开发中常用的，而是仅在组件库开发等场景时才会使用到，这里我们也做简单地介绍。
`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#其他内置类型",a:"其他内置类型"},"79.12":{t:"ComponentProps",p:"当你基于原生 HTML 元素去封装组件时，通常会需要将这个原生元素的所有 HTML 属性都保留下来作为组件的属性，此时你肯定不能一个个声明所有属性，那么就可以使用 ComponentProps 来提取 ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#componentprops",a:"componentprops"},"79.13":{t:"ReactElement 与 ReactNode",p:`在前面的例子中你可能注意到了 ReactElement 与 ReactNode 这两个类型：
type PropsWithChildren&lt;P&gt; = P &amp; { children? ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#reactelement-与-reactnode",a:"reactelement-与-reactnode"},"79.14":{t:"其他工程实践",p:"介绍了上面的项目配置与组件声明、泛型坑位相关内容以后，我们其实已经基本了解了 React 项目中使用 TypeScript 的注意事项。然而，还有一些概念涉及到项目的规范部分，我们在这里统一进行讲解。 ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#其他工程实践",a:"其他工程实践"},"79.15":{t:"项目中的类型声明文件",p:"在实际应用中使用 TypeScript 进行开发时，我们往往需要大量的类型代码，而如何存放这些类型代码，其实就需要预先有一个明确的规范。目前我使用的方式是，在项目中使用一个专门的文件夹存放类型代码，其 ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#项目中的类型声明文件",a:"项目中的类型声明文件"},"79.16":{t:"组件与组件类型",p:"在 React 父子组件中一个常见的场景是，父组件导入各个子组件，传递属性时会进行额外的数据处理，其结果的类型被这多个子组件共享，而这个类型又仅被父子组件消费，不应当放在全局的类型定义中。此时我推荐的 ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#组件与组件类型",a:"组件与组件类型"},"79.17":{t:"总结与预告",p:"在这一节中，我们了解了 React 与 TypeScript 结合使用的方式，包括了项目的基础配置、组件声明方式及其优劣、Hooks 中的泛型坑位以及内置类型等等。这些概念其实本质上还是来自于 Typ ...",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#总结与预告",a:"总结与预告"},"79.18":{t:"扩展阅读",p:"",l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#扩展阅读",a:"扩展阅读"},"79.19":{t:"FC 并不是完美的",p:`在前面组件声明部分我们已经了解了使用函数声明组件，以及使用 FC 声明组件的两种形式，也明确了主要差异：

函数声明组件需要额外的返回值类型标注（JSX.Element）才能校验组件合法，并且可以再使 ...`,l:"TypeScript/21.在 React 中愉快地使用 TypeScript：内置类型与泛型坑位.html#fc-并不是完美的",a:"fc-并不是完美的"},"80.0":{t:"关于 ESLint 是什么，我想应该没有过多介绍的必要，即使你没有主动了解过它，也一定被动接触过。它带给你的印象并不一定很好，有可能是满屏的红色波浪线，也可能是成千上万条的报错输出。但你可能也很享受经过 ESLint 检查与格式化后工工整整的代码，那简直叫一个赏心悦目。",p:"对于 ESLint ，我认为它就是现代前端工程必备的一样工具，无论是简单的寥寥几行配置，还是精心挑选了最适合自己或者团队风格的规则集，它都是不可缺少的一环。ESLint 的作用其实可以划分为两个部分： ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html",a:"关于-eslint-是什么-我想应该没有过多介绍的必要-即使你没有主动了解过它-也一定被动接触过。它带给你的印象并不一定很好-有可能是满屏的红色波浪线-也可能是成千上万条的报错输出。但你可能也很享受经过-eslint-检查与格式化后工工整整的代码-那简直叫一个赏心悦目。"},"80.1":{t:"基本的 ESLint 配置",p:`最简单的方式就是通过 ESLint 自带的初始化功能，然后回答一系列问题即可。
npx eslint --init
npm init @eslint/config

!img
如果你选择了使用 Typ ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#基本的-eslint-配置",a:"基本的-eslint-配置"},"80.2":{t:"配置 Prettier 与 Git Hooks",p:"通常在实际项目开发时，我们并不会仅仅使用 ESLint，还有一系列辅助的工具。比如我们可以同时使用 Prettier 与 ESLint，以及使用 Git Hooks 与 Lint Staged 确保项 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#配置-prettier-与-git-hooks",a:"配置-prettier-与-git-hooks"},"80.3":{t:"TypeScript 下的 ESLint 规则集推荐",p:"在前面我们只是介绍了如何配置 ESLint 相关的工程，还没有具体介绍 TypeScript 下应使用哪些 ESLint 规则。为了帮助你更好地挑选适用于自己需要的规则，接下来我们会来介绍一批推荐使用 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#typescript-下的-eslint-规则集推荐",a:"typescript-下的-eslint-规则集推荐"},"80.4":{t:"一般严格组",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#一般严格组",a:"一般严格组"},"80.5":{t:"语法统一约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#语法统一约束",a:"语法统一约束"},"80.6":{t:"array-type",p:"TypeScript 中同时支持使用 Array&lt;T&gt; 与 T[] 两种方式声明数组类型，此规则约束项目中对这两种数组类型声明的使用，包括仅使用 Array&lt;T&gt; 或 T[]  ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#array-type",a:"array-type"},"80.7":{t:"await-thenable",p:"只允许对异步函数、Promise、PromiseLike 使用 await 调用（也就是实现了 Thenable 接口，存在 then 方法的对象），可以避免无意义的 await 调用，同时还能帮助你 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#await-thenable",a:"await-thenable"},"80.8":{t:"consistent-type-assertions",p:`TypeScript 支持通过 as 与 &lt;&gt; 两种不同的语法进行类型断言，如：
const foo = {} as Foo;
const foo = &lt;Foo&gt;{};

co ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#consistent-type-assertions",a:"consistent-type-assertions"},"80.9":{t:"consistent-type-definitions",p:"TypeScript 支持通过 type 与 interface 声明对象类型，此规则可将其收束到统一的声明方式，即仅使用其中的一种。先说我是怎么做的，在绝大部分场景下，使用 interface 来声 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#consistent-type-definitions",a:"consistent-type-definitions"},"80.10":{t:"prefer-for-of",p:`在你使用 for 循环遍历数组时，如果索引仅仅用来访问数组成员，则应该替换为 for...of：
// ×
for (let i = 0; i &lt; arr.length; i++) {
  co ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-for-of",a:"prefer-for-of"},"80.11":{t:"prefer-nullish-coalescing 与 prefer-optional-chain",p:"使用 ?? 而不是 ||，使用 a?.b 而不是 a &amp;&amp; a.b。这是因为，逻辑或 || 会将 0 与 &quot;&quot; 视为 false 而导致错误地应用默认值，而 ??  ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-nullish-coalescing-与-prefer-optional-chain",a:"prefer-nullish-coalescing-与-prefer-optional-chain"},"80.12":{t:"consistent-type-imports",p:`约束使用 import type {} 进行类型的导入，如：
// √
import type { CompilerOptions } from 'typescript';

// x
import  ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#consistent-type-imports",a:"consistent-type-imports"},"80.13":{t:"non-nullable-type-assertion-style",p:`此规则要求在类型断言仅起到去空值作用，如将 string | undefined 类型断言为 string时，将其替换为非空断言 !
const foo:string | undefined = &q ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#non-nullable-type-assertion-style",a:"non-nullable-type-assertion-style"},"80.14":{t:"promise-function-async",p:`返回 Promise 的函数必须被标记为 async。当你的函数显式返回了一个 Promise，就说明它应当是一个异步过程，就应当被标记为 async。
`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#promise-function-async",a:"promise-function-async"},"80.15":{t:"prefer-literal-enum-member",p:"对于枚举成员值，只允许使用普通字符串、数字、null、正则，而不允许变量复制、模板字符串等需要计算的操作。虽然 TypeScript 是允许使用各种合法表达式作为枚举成员的，但由于枚举的编译结果拥有自 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-literal-enum-member",a:"prefer-literal-enum-member"},"80.16":{t:"prefer-as-const",p:`对于常量断言，使用 as const 而不是 &lt;const&gt;，这一点类似于上面约束类型断言语法的 consistent-type-assertions 规则。
`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-as-const",a:"prefer-as-const"},"80.17":{t:"类型约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#类型约束",a:"类型约束"},"80.18":{t:"no-unnecessary-type-arguments",p:`不允许与默认值一致的泛型参数，如：
function foo&lt;T = number&gt;() {}
foo&lt;number&gt;();

与默认值一致的泛型参数是没有意义的，因为我们直接 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-unnecessary-type-arguments",a:"no-unnecessary-type-arguments"},"80.19":{t:"能力约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#能力约束",a:"能力约束"},"80.20":{t:"ban-ts-comment",p:`禁止 @ts- 指令的使用，或者允许其在提供了说明的情况下被使用，如：
// @ts-expect-error 这里的类型太复杂，日后补上
// @ts-nocheck 未完成迁移的文件

此规则推荐 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#ban-ts-comment",a:"ban-ts-comment"},"80.21":{t:"prefer-ts-expect-error",p:`使用 @ts-expect-error 而不是 @ts-ignore。
在类型声明与类型指令一节我们已经了解到， @ts-ignore 与 @ts-expect-error 二者的区别主要在于，前者是 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-ts-expect-error",a:"prefer-ts-expect-error"},"80.22":{t:"no-extra-non-null-assertion",p:`不允许额外的重复非空断言：
// x
function foo(bar: number | undefined) {
  const bar: number = bar!!!;
}

额外的非空断言是 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-extra-non-null-assertion",a:"no-extra-non-null-assertion"},"80.23":{t:"no-non-null-asserted-nullish-coalescing",p:`不允许非空断言与空值合并同时使用，如 bar! ?? tmp。
非空断言可以用于移除掉一个类型中的 null 与 undefined，而空值合并则在左侧值为 null 或 undefined 时应用一 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-non-null-asserted-nullish-coalescing",a:"no-non-null-asserted-nullish-coalescing"},"80.24":{t:"no-non-null-asserted-optional-chain",p:`不允许非空断言与可选链同时使用，如 foo?.bar!。和上一条规则类似，属于非常有害的结合使用方式。同时这也意味着，你对 ! ?? ?. 的理解存在着不当之处。
`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-non-null-asserted-optional-chain",a:"no-non-null-asserted-optional-chain"},"80.25":{t:"no-unnecessary-type-assertion",p:`不允许与实际值一致的类型断言，如：const foo = 'foo' as string。类似于不允许默认值一致的泛型，这条规则的目的也是减少不必要的类型代码。
`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-unnecessary-type-assertion",a:"no-unnecessary-type-assertion"},"80.26":{t:"no-unnecessary-type-constraint",p:"不允许与默认约束一致的泛型约束，如：interface FooAny&lt;T extends any&gt; {}。仍然是出于简化代码的考虑，在 TS 3.9 版本以后，对于未指定的泛型约束，默认使 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-unnecessary-type-constraint",a:"no-unnecessary-type-constraint"},"80.27":{t:"较为严格组",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#较为严格组",a:"较为严格组"},"80.28":{t:"语法统一约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#语法统一约束",a:"语法统一约束"},"80.29":{t:"method-signature-style",p:`方法签名的声明方式有 method 与 property 两种，区别如下：
// method
interface T1 {
  func(arg: string): number;
}

// pr ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#method-signature-style",a:"method-signature-style"},"80.30":{t:"类型约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#类型约束",a:"类型约束"},"80.31":{t:"ban-types",p:`禁止部分值被作为类型标注，此规则能够对每一种被禁用的类型提供特定的说明来在触发此规则报错时给到良好的提示。
这条规则常见的场景是禁用 {}、Function、object 这些类型。

使用 {} 会 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#ban-types",a:"ban-types"},"80.32":{t:"no-empty-interface",p:`不允许定义空的接口，可配置为允许单继承下的空接口：
// x
interface Foo {}

// √
interface Foo extends Bar {}

没有父类型的空接口实际上就等于  ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-empty-interface",a:"no-empty-interface"},"80.33":{t:"no-explicit-any",p:`不允许显式的 any 类型。
此前我们已经了解过 any 类型的弊端，甚至 TypeScript 专门引入了 unknown 类型来尝试堵上一些口子。然而即使这样，很多场景下考虑到成本，我们还是会使用 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-explicit-any",a:"no-explicit-any"},"80.34":{t:"no-inferrable-types",p:`不允许不必要的类型标注，但可配置为允许类的属性成员、函数的属性成员进行额外标注。
const foo: string = &quot;linbudu&quot;;

class Foo {
	prop ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-inferrable-types",a:"no-inferrable-types"},"80.35":{t:"explicit-module-boundary-types",p:`函数与类方法的返回值需要被显式指定，而不是依赖类型推导，如：
const foo = (): Foo =&gt; {}

通过显式指定返回值类型，我们可以直观区分函数的功能，如是否携带副作用，以及是否 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#explicit-module-boundary-types",a:"explicit-module-boundary-types"},"80.36":{t:"能力约束",p:"",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#能力约束",a:"能力约束"},"80.37":{t:"no-unnecessary-boolean-literal-compare",p:`不允许对布尔类型变量的 === 比较，如：
declare const someCondition: boolean;
if (someCondition === true) {
}

首先，记住我们 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-unnecessary-boolean-literal-compare",a:"no-unnecessary-boolean-literal-compare"},"80.38":{t:"no-throw-literal",p:`不允许直接 throw 一个字符串如：throw 'err'，只能抛出 Error 或基于 Error 派生类的实例，如：throw new Error('Oops!')。
抛出的 Error 实例能 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#no-throw-literal",a:"no-throw-literal"},"80.39":{t:"switch-exhaustiveness-check",p:`switch 的判定变量为联合类型时，其每一个类型分支都需要被处理。如：
type PossibleTypes = 'linbudu' | 'qiongxin' | 'developer';

let ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#switch-exhaustiveness-check",a:"switch-exhaustiveness-check"},"80.40":{t:"restrict-template-expressions",p:`模板字符串中的计算表达式其返回值必须是字符串，此规则可以被配置为允许数字、布尔值、可能为 null 的值以及正则表达式，或者你也可以允许任意的值，但这样这条规则就形同虚设了。
在模板表达式中，非字符串 ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#restrict-template-expressions",a:"restrict-template-expressions"},"80.41":{t:"prefer-reduce-type-parameter",p:`我们在泛型一节中曾经介绍过数组 reduce 方法的各种重载，比如下面这种：
const arr: number[] = [1, 2, 3];

// 报错：不能将 number 类型的值赋值给 ne ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#prefer-reduce-type-parameter",a:"prefer-reduce-type-parameter"},"80.42":{t:"triple-slash-reference",p:`这一规则的目的在于禁止你使用三斜线指令，而是使用 import 来进行类型的导入。正如我们上一节所了解的那样：
// × 不推荐使用
/// &lt;reference types=&quot;vit ...`,l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#triple-slash-reference",a:"triple-slash-reference"},"80.43":{t:"总结与预告",p:"在这一节，我们学习了 TypeScript 下的 ESLint 配置，以及为了实现更好约束引入的 Prettier 与 Git Hooks。实际上，它们就是你开始提升自己代码质量的第一步，也是团队协作 ...",l:"TypeScript/22.让 ESLint 来约束你的 TypeScript 代码：配置与规则集介绍.html#总结与预告",a:"总结与预告"},"81.0":{t:"在前面两节，我们了解了 TypeScript 在 React 与 ESLint 中的集成，而在实际项目开发时，我们还会接触许多与 TypeScript 相关的工具。如果按照作用场景来进行划分，这些工具大致可以划分为开发、校验、构建、类型四类。在这一节我们将介绍一批 TypeScript 工具库，讲解它们的基本使用，你可以在这里查找是否有符合你需求的工具。",p:"本节的定位类似于 GitHub 上的 awesome-xxx 系列，我们更多是在简单介绍工具的作用与使用场景，不会有深入的讲解与分析。同时，本节的内容会持续更新，如果你还使用过其他好用的工具库，欢迎在 ...",l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html",a:"在前面两节-我们了解了-typescript-在-react-与-eslint-中的集成-而在实际项目开发时-我们还会接触许多与-typescript-相关的工具。如果按照作用场景来进行划分-这些工具大致可以划分为开发、校验、构建、类型四类。在这一节我们将介绍一批-typescript-工具库-讲解它们的基本使用-你可以在这里查找是否有符合你需求的工具。"},"81.1":{t:"开发阶段",p:`这一部分的工具主要在项目开发阶段使用。
`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#开发阶段",a:"开发阶段"},"81.2":{t:"项目开发",p:`

ts-node 与 ts-node-dev：我们在环境搭建一节中已经介绍过，用于直接执行 .ts 文件。其中 ts-node-dev 基于 ts-node 和 node-dev（类似于 nodem ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#项目开发",a:"项目开发"},"81.3":{t:" ",p:"",l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#",a:""},"81.4":{t:"启动 tsc --watch，然后在成功时执行编译产物",p:`tsc-watch --onSuccess &quot;node ./dist/server.js&quot;
`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#启动-tsc-watch-然后在成功时执行编译产物",a:"启动-tsc-watch-然后在成功时执行编译产物"},"81.5":{t:" ",p:"",l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#",a:""},"81.6":{t:"在失败时执行",p:`tsc-watch --onFailure &quot;echo 'Beep! Compilation Failed'&quot;

- esno，antfu 的作品。核心能力同样是执行 .ts 文件 ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#在失败时执行",a:"在失败时执行"},"81.7":{t:"代码生成",p:`

typescript-json-schema，从 TypeScript 代码生成 JSON Schema，如以下代码：
export interface Shape {
    /**
      ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#代码生成",a:"代码生成"},"81.8":{t:"类型相关",p:`以下工具库主要针对类型，包括提供通用工具类型与对工具类型进行测试。

type-fest，不用多介绍了，目前 star 最多下载量最高的工具类型库，Sindre Sorhus 的作品，同时也是个人认为 ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#类型相关",a:"类型相关"},"81.9":{t:"校验阶段",p:`以下这些工具通常用于在项目逻辑中进行具有实际逻辑的校验（而不同于 tsd 仅在类型层面）。
`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#校验阶段",a:"校验阶段"},"81.10":{t:"逻辑校验",p:`

zod，核心优势在于与 TypeScript 的集成，如能从 Schema 中直接提取出类型：
import { z } from &quot;zod&quot;;

const User = z ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#逻辑校验",a:"逻辑校验"},"81.11":{t:"类型覆盖检查",p:`
typescript-coverage-report，检查你的项目中类型的覆盖率，如果你希望项目的代码质量更高，可以使用这个工具来检查类型的覆盖程度，从我个人使用经验来看，大概 95% 左右就是一个 ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#类型覆盖检查",a:"类型覆盖检查"},"81.12":{t:"构建阶段",p:`以下工具主要在构建阶段起作用。

ESBuild，应该无需过多介绍。需要注意的是 ESBuild 和 TypeScript Compiler 还是存在一些构建层面的差异，比如 ESBuild 无法编译 ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#构建阶段",a:"构建阶段"},"81.13":{t:"总结与预告",p:`这一节我们汇总了各个场景下的 TypeScript 工具库，就像开头所说，本节的内容会持续更新，如果你还使用过其它让你赞不绝口的工具库，欢迎在评论区或答疑群提交给我。
下一节，我们会来了解一个对你来说 ...`,l:"TypeScript/23.全链路 TypeScript 工具库，找到适合你的工具.html#总结与预告",a:"总结与预告"},"82.0":{t:"这一节，我们来讲解 TypeScript 与 ECMAScript 之间的关系。",p:"首先，我们来理清经常看到的 ES / ECMAScript / TC39 等等概念到底是个啥。然后，一起看看 TypeScript 都提前实现了哪些 ECMAScript 语法，它们怎么用，到底有多好 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html",a:"这一节-我们来讲解-typescript-与-ecmascript-之间的关系。"},"82.1":{t:"ECMAScript 与 TC39",p:"首先是 ECMAScript 这个单词，虽然 JavaScript 和 Java 没有关系，但 ECMAScript 和 ECMA （正确发音近似于诶可码（Script））确实是有关系的。ECMA 的 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#ecmascript-与-tc39",a:"ecmascript-与-tc39"},"82.2":{t:"TypeScript 中的 ECMAScript 语法",p:`目前在 TypeScript 中，已经合入的 ECMAScript 语法主要有这么几个：

可选链 Optional Chainning，即 ?. 语法。
空值合并 Nullish Coalescin ...`,l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#typescript-中的-ecmascript-语法",a:"typescript-中的-ecmascript-语法"},"82.3":{t:"可选链 Optional Chainning",p:"在 JavaScript 中，如果访问一个嵌套多层的属性，为了避免出现 Cannot read property of undefined 这样的错误，我们通常会使用逻辑与 &amp;&amp; 语法 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#可选链-optional-chainning",a:"可选链-optional-chainning"},"82.4":{t:"空值合并 Nullish Coalescing",p:`如果说可选链是为了取代逻辑与（&amp;&amp;），那么空值合并就是为了取代逻辑或（||）。而逻辑或的主要使用场景之一就是提供默认值，如：
const foo = someValue || fall ...`,l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#空值合并-nullish-coalescing",a:"空值合并-nullish-coalescing"},"82.5":{t:"逻辑赋值 Logical Assignment",p:`实际上，逻辑赋值是在复合赋值的基础上演进而来（或者说关系一致）的，都是将一个操作符和赋值符号结合在一起。比如我们最常见的复合赋值：
a = a + b;
a += b;

a = a - b;
a - ...`,l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#逻辑赋值-logical-assignment",a:"逻辑赋值-logical-assignment"},"82.6":{t:"总结与预告",p:"这一节，我们了解了让人傻傻分不清楚的 ECMAScript、TypeScript、TC39 等概念之间的联系与实际意义，认识了三位对你来说或许是首次见面的新朋友：可选链、空值合并以及短路赋值。从现在开 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#总结与预告",a:"总结与预告"},"82.7":{t:"扩展阅读",p:"",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#扩展阅读",a:"扩展阅读"},"82.8":{t:"演进中的 TC39 提案",p:"除了我们上面讲到的可选链、空值合并，以及大家都至少听说过的装饰器以外，还有许多演进中的 TC39 提案，我们可以简单归类为语法糖、新的内置方法、新的 API等。在了解完本篇的核心内容以后，我们不妨来瞅 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#演进中的-tc39-提案",a:"演进中的-tc39-提案"},"82.9":{t:"Record 和 Tuple：内置的不可变数据类型（Stage 2）",p:`Record 与 Tuple 为 JavaScript 中引入了两个新的原始数据类型，分别对应到对象与数组（差异仅仅是声明时多了个 #）：
// Record
const proposal = #{
 ...`,l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#record-和-tuple-内置的不可变数据类型-stage-2",a:"record-和-tuple-内置的不可变数据类型-stage-2"},"82.10":{t:"面向表达式的 Do Expression 与 Throw Expression（Stage 1）",p:`在 TC39 中，有相当一部分提案实际上有着函数式编程的理念背景，很难说这对 JavaScript 开发者来说是否是刚需，但它们确实能带给你另一种截然不同的编程范式。
这一提案的理念背景是函数式编程中 ...`,l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#面向表达式的-do-expression-与-throw-expression-stage-1",a:"面向表达式的-do-expression-与-throw-expression-stage-1"},"82.11":{t:"响应式编程与Observable（Stage 1）",p:"如果你了解过 RxJs，那么肯定马上就 get 到了这个提案想要干啥。proposal-observable 这一提案尝试引入原生的 Observable 支持，你可以简单理解为这是用于处理较复杂异步 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#响应式编程与observable-stage-1",a:"响应式编程与observable-stage-1"},"82.12":{t:"函数式理念的进一步发展",p:"如果你对面向表达式的语法感到兴趣，那么我想下面这几个函数式操作符相关的提案也会引起你的关注。如果你想详细了解它们的使用与差异，可以阅读笔者此前的文章：你应该了解的 ECMAScript 函数操作符相关 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#函数式理念的进一步发展",a:"函数式理念的进一步发展"},"82.13":{t:"TC39 中的类型提案",p:"在 2022 年 3 月会议中，由 TypeScript 团队推进的 Type Annotations 也成功进入到 Stage1，这一提案的目的是引入和 TypeScript 中一样，会在编译时被擦 ...",l:"TypeScript/24.说说 TypeScript 和 ECMAScript 之间那些事儿.html#tc39-中的类型提案",a:"tc39-中的类型提案"},"83.0":{t:"上一节我们了解了 TypeScript 与 ECMAScript 的关系，以及可选链与空值合并这两个 TypeScript 中的 ECMAScript 提案。其实，还有一个 ECMAScript 提案也已经成为 TypeScript 中相当重要的一部分，它就是装饰器。",p:"装饰器语法在 Python、Java 等语言中都能见到，但在 JavaScript 中并没有被大量使用。一方面是因为，装饰器其实还不能被称为 JavaScript 的一部分，另一方面则是它对应用场景有 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html",a:"上一节我们了解了-typescript-与-ecmascript-的关系-以及可选链与空值合并这两个-typescript-中的-ecmascript-提案。其实-还有一个-ecmascript-提案也已经成为-typescript-中相当重要的一部分-它就是装饰器。"},"83.1":{t:"装饰器大起底",p:"TypeScript 中的装饰器可以分为类装饰器、方法装饰器、访问符装饰器、属性装饰器以及参数装饰器五种，最常见的主要还是类装饰器、方法装饰器以及属性装饰器。接下来，我们会依次介绍这几种装饰器的具体使 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#装饰器大起底",a:"装饰器大起底"},"83.2":{t:"类装饰器",p:"类装饰器是直接作用在类上的装饰器，它在执行时的入参只有一个，那就是这个类本身（而不是类的原型对象）。因此，我们可以通过类装饰器来覆盖类的属性与方法，如果你在类装饰器中返回一个新的类，它甚至可以篡改掉整 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#类装饰器",a:"类装饰器"},"83.3":{t:"方法装饰器",p:"方法装饰器的入参包括类的原型、方法名以及方法的属性描述符（PropertyDescriptor），而通过属性描述符你可以控制这个方法的内部实现（即 value）、可变性（即 writable）等信息。 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#方法装饰器",a:"方法装饰器"},"83.4":{t:"访问符装饰器",p:"访问符装饰器并不常见，甚至访问符对于部分同学来说也是陌生的，但它其实就是 get value(){} 与 set value(v)=&gt;{} 这样的方法，其中 getter 在你访问这个属性 va ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#访问符装饰器",a:"访问符装饰器"},"83.5":{t:"属性装饰器",p:`属性装饰器在独立使用时能力非常有限，它的入参只有类的原型与属性名称，返回值会被忽略，但你仍然可以通过直接在类的原型上赋值来修改属性：
class Foo {
  @ModifyNickName()
  ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#属性装饰器",a:"属性装饰器"},"83.6":{t:"参数装饰器",p:`参数装饰器包括了构造函数的参数装饰器与方法的参数装饰器，它的入参包括类的原型、参数名与参数在函数参数中的索引值（即第几个参数），如果只是单独使用，它的作用同样非常有限。
class Foo {
  h ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#参数装饰器",a:"参数装饰器"},"83.7":{t:"装饰器的执行机制",p:`装饰器的执行机制中主要包括执行时机、执行原理以及执行顺序这三个概念。
首先是执行时机，还记得我们在最开始说的吗？装饰器的本质就是一个函数，因此只要在类上定义了它，即使不去实例化这个类或者读取静态成员， ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#装饰器的执行机制",a:"装饰器的执行机制"},"83.8":{t:"多个同类装饰器的执行顺序",p:`另外，我们也可以使用多个同种装饰器，比如一个类上可以有好多个类装饰器：
@Deprecated()
@User()
@Internal
@Provide()
class Foo {}

这种情况下，这 ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#多个同类装饰器的执行顺序",a:"多个同类装饰器的执行顺序"},"83.9":{t:"反射 Reflect",p:`Reflect 在 ES6 中被首次引入，它主要是为了配合 Proxy 保留一份方法原始的实现逻辑，如以下来自阮一峰老师的 ES6 标准入门中 Reflect 一节的代码：
Proxy(target, ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#反射-reflect",a:"反射-reflect"},"83.10":{t:"反射元数据 Reflect Metadata",p:"不同于反射，反射元数据（Reflect Metadata） 这一提案虽然同样很早就被提出，但至今都未真正的成为 ECMAScript 的一部分，原因在于元数据和装饰器提案的联系非常紧密，随着装饰器提案 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#反射元数据-reflect-metadata",a:"反射元数据-reflect-metadata"},"83.11":{t:"总结与预告",p:"这一节，我们了解了装饰器的基本概念，包括 TypeScript 中的五种装饰器，以及这些装饰器的入参、使用场景、执行顺序等等。另外我们还掌握了反射元数据的使用，目前看起来它好像并没有什么特别之处？那么 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#总结与预告",a:"总结与预告"},"83.12":{t:"扩展阅读",p:"",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#扩展阅读",a:"扩展阅读"},"83.13":{t:"装饰器的坎坷进历程",p:`正如我们在开头提到的，装饰器从被作为一个提案提出开始，很是经历了一番风雨，下面我们就来具体介绍一下它到底都经历了些什么。
首先需要明确的是，目前 JavaScript（ECMAScript）中的装饰器 ...`,l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#装饰器的坎坷进历程",a:"装饰器的坎坷进历程"},"83.14":{t:"Reflect.decorate",p:"如果你去观察了装饰器的编译代码，会发现 __decorate 方法中有一段代码是检查 Reflect.decorate 方法是否存在。这一方法其实也来自于 Reflect Metadata，见 L11 ...",l:"TypeScript/25.装饰器与反射元数据：了解装饰器基本原理与应用.html#reflect-decorate",a:"reflect-decorate"},"84.0":{t:"上一节学习了装饰器与反射元数据的基本使用后，这一节我们将在其基础上来了解**控制反转**、**依赖注入**等概念，我们会使用装饰器配合反射元数据实现这一设计模式，以及实现基于装饰器的路由体系与一个简单的控制反转容器。",p:`
本节代码见：Decorators

`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html",a:"上一节学习了装饰器与反射元数据的基本使用后-这一节我们将在其基础上来了解-控制反转-、-依赖注入-等概念-我们会使用装饰器配合反射元数据实现这一设计模式-以及实现基于装饰器的路由体系与一个简单的控制反转容器。"},"84.1":{t:"控制反转与依赖注入",p:`控制反转即 Inversion of Control，它是面向对象编程中的一种设计模式，可以用来很好地解耦代码。

由于控制反转出现的时间较晚，因而没有被包括在四人组的设计模式一书当中，但它仍然是一种 ...`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#控制反转与依赖注入",a:"控制反转与依赖注入"},"84.2":{t:"基于依赖注入的路由实现",p:`
本节的代码是我最初在深入浅出 TypeScript 一书中学习到的内容，个人认为非常适合用于加深对依赖注入的理解，因此在其基础上进一步完善后，作为本节的实例代码。

我们的最终目的就是实现上面基于装 ...`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#基于依赖注入的路由实现",a:"基于依赖注入的路由实现"},"84.3":{t:"实现一个简易 IoC 容器",p:`实现一个简单的 IoC 容器可以很好地帮助我们总结装饰器、依赖注入、元数据的相关知识，以及理解“控制反转”的本质。
关于这个容器，我们最终想实现的使用方式是这样的：
@Provide()
class  ...`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#实现一个简易-ioc-容器",a:"实现一个简易-ioc-容器"},"84.4":{t:"基于内置元数据实现",p:`其实最难的一部分我们已经解决了，即如何存储并对应地进行注入，现在要做的不过是升级优化一下，支持在不传入标识符时使用内置元数据作为标识符。首先对 Provide 和 Inject 做改造：
functi ...`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#基于内置元数据实现",a:"基于内置元数据实现"},"84.5":{t:"总结与预告",p:"在这两节，我们花了相当长的篇幅对装饰器相关的概念与实际应用进行了一次彻底介绍。从装饰器语法到不同类型装饰器的使用，再到反射、反射元数据，最后到控制反转与依赖注入，以及简单的 IoC 路由与 IoC 容 ...",l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#总结与预告",a:"总结与预告"},"84.6":{t:"扩展阅读",p:"",l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#扩展阅读",a:"扩展阅读"},"84.7":{t:"类型严格的装饰器",p:`在这一节的代码中，我们并没有特别关注类型的严格性。实际上装饰器的类型定义也是如此：
declare type ClassDecorator = &lt;TFunction extends Functi ...`,l:"TypeScript/26.控制反转与依赖注入：基于装饰器的依赖注入实现.html#类型严格的装饰器",a:"类型严格的装饰器"},"85.0":{t:"在前面的内容中，我们已经学习了 TypeScript 在工程中的许多实践，包括类型声明、TypeScript 与 React、ESLint 的结合使用以及装饰器等。这些实践更像是上层建筑，默认是在一个已经基本配置完环境的 TypeScript 项目中进行的。这一节，我们深入下层基础，来了解 TypeScript 工程中最基础的一部分：TSConfig 配置。",p:`为什么选择现在才讲配置呢？因为在前面的工程实践中，我们并不需要自己去修改 TSConfig，脚手架已经帮我们处理好了。有了实践经验，再来讲解讲解这些配置效果会更好。
为了避免罗列配置这种填鸭式教学，我 ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html",a:"在前面的内容中-我们已经学习了-typescript-在工程中的许多实践-包括类型声明、typescript-与-react、eslint-的结合使用以及装饰器等。这些实践更像是上层建筑-默认是在一个已经基本配置完环境的-typescript-项目中进行的。这一节-我们深入下层基础-来了解-typescript-工程中最基础的一部分-tsconfig-配置。"},"85.1":{t:"构建相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建相关",a:"构建相关"},"85.2":{t:"构建源码相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建源码相关",a:"构建源码相关"},"85.3":{t:"特殊语法相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#特殊语法相关",a:"特殊语法相关"},"85.4":{t:"experimentalDecorators 与 emitDecoratorMetadata",p:"这两个选项都和装饰器有关，其中 experimentalDecorators 选项用于启用装饰器的 @ 语法，而 emitDecoratorMetadata 配置则影响装饰器实际运行时的元数据相关逻辑 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#experimentaldecorators-与-emitdecoratormetadata",a:"experimentaldecorators-与-emitdecoratormetadata"},"85.5":{t:"jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource",p:"这部分配置主要涉及 jsx(tsx) 相关的语法特性。其中，jsx 配置将直接影响 JSX 组件的构建表现，常见的主要有 react （将 JSX 组件转换为对 React.createElement ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#jsx、jsxfactory、jsxfragmentfactory-与-jsximportsource",a:"jsx、jsxfactory、jsxfragmentfactory-与-jsximportsource"},"85.6":{t:"target 与 lib、noLib",p:"target 配置决定了你的构建代码使用的语法，常用值包括 es5、es6、es2018、es2021、esnext（基于目前的 TypeScript 版本所支持的最新版本） 等等。某些来自于更高版本 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#target-与-lib、nolib",a:"target-与-lib、nolib"},"85.7":{t:"构建解析相关",p:`这部分配置主要控制源码解析，包括从何处开始收集要构建的文件，如何解析别名路径等等。
`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建解析相关",a:"构建解析相关"},"85.8":{t:"files、include 与 exclude",p:`这三个选项决定了将被包括到本次编译的代码文件。使用 files 我们可以描述本次包含的所有文件，但不能使用 src 或者 src/* 这种方式，每个值都需要是完整的文件路径，适合在小型项目时使用：
{ ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#files、include-与-exclude",a:"files、include-与-exclude"},"85.9":{t:"baseUrl",p:`这一配置可以定义文件进行解析的根目录，它通常会是一个相对路径，然后配合 tsconfig.json 所在的路径来确定根目录的位置。
project
├── out.ts
├── src
├──── c ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#baseurl",a:"baseurl"},"85.10":{t:"rootDir",p:`rootDir 配置决定了项目文件的根目录，默认情况下它是项目内包括的所有 .ts 文件的最长公共路径，这里有几处需要注意：

包括指的是 include 或 files 中包括的 .ts 文件，这些 ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#rootdir",a:"rootdir"},"85.11":{t:"rootDirs",p:`rootDirs 就是复数版本的 rootDir，它接收一组值，并且会将这些值均视为平级的根目录：
{
  &quot;compilerOptions&quot;: {
    &quot;rootD ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#rootdirs",a:"rootdirs"},"85.12":{t:"types 与 typeRoots",p:"默认情况下，TypeScript 会加载 node_modules/@types/ 下的所有声明文件，包括嵌套的 ../../node_modules/@types 路径，这么做可以让你更方便地使用第 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#types-与-typeroots",a:"types-与-typeroots"},"85.13":{t:"moduleResolution",p:`这一配置指定了模块的解析策略，可以配置为 node 或者 classic ，其中 node 为默认值，而 classic 主要作向后兼容用，基本不推荐使用。
首先来看 node 解析模式，从名字也能看 ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#moduleresolution",a:"moduleresolution"},"85.14":{t:"moduleSuffixes",p:`此配置在 4.7 版本被引入，类似于 moduleResolution ，它同样影响对模块的解析策略，但仅影响模块的后缀名部分。如以下配置：
{
    &quot;compilerOptions&q ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#modulesuffixes",a:"modulesuffixes"},"85.15":{t:"noResolve",p:`默认情况下， TypeScript 会将你代码中导入的文件也解析为程序的一部分，包括 import 导入和三斜线指令的导入，你可以通过禁用这一配置来阻止这个解析过程。
需要注意的是，虽然导入过程被禁用 ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#noresolve",a:"noresolve"},"85.16":{t:"paths",p:`paths 类似于 Webpack 中的 alias，允许你通过 @/utils 或类似的方式来简化导入路径，它的配置方式是这样的：
{
  &quot;compilerOptions&quot;:  ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#paths",a:"paths"},"85.17":{t:"resolveJsonModule",p:`启用了这一配置后，你就可以直接导入 Json 文件，并对导入内容获得完整的基于实际 Json 内容的类型推导。
{
    &quot;repo&quot;: &quot;TypeScript&quo ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#resolvejsonmodule",a:"resolvejsonmodule"},"85.18":{t:"构建产物相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建产物相关",a:"构建产物相关"},"85.19":{t:"构建输出相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建输出相关",a:"构建输出相关"},"85.20":{t:"outDir 与 outFile",p:`这两个选项决定了构建产物的输出文件。其中 outDir 配置的值将包括所有的构建产物，通常情况下会按照原本的目录结构存放：
src
├── core
├──── handler.ts
└── inde ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#outdir-与-outfile",a:"outdir-与-outfile"},"85.21":{t:"preserveConstEnums",p:`在字面量类型与枚举一节中了解过，常量枚举会在编译时被抹除，对其成员的引用会直接使用原本的值来替换。这一配置项可以改变此行为，让常量枚举也像普通枚举那样被编译为一个运行时存在的对象。
`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#preserveconstenums",a:"preserveconstenums"},"85.22":{t:"noEmit 与 noEmitOnError",p:"这两个选项主要控制最终是否将构建产物实际写入文件系统中，其中 noEmit 开启时将不会写入，但仍然会执行构建过程，因此也就包括了类型检查、语法检查与实际构建过程。而 noEmitOnError 则仅 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#noemit-与-noemitonerror",a:"noemit-与-noemitonerror"},"85.23":{t:"module",p:"这一配置控制最终 JavaScript 产物使用的模块标准，常见的包括 CommonJs、ES6、ESNext 以及 NodeNext 等（实际的值也可以是全小写的形式）。另外也支持 AMD、UMD、 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#module",a:"module"},"85.24":{t:"importHelpers 与 noEmitHelpers",p:`由于 TypeScript 在编译时除了抹除类型，还需要基于 target 进行语法降级，这一功能往往需要一些辅助函数，将新语法转换为旧语法的实现， 如 async 函数。
在同样能实现语法降级的 B ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#importhelpers-与-noemithelpers",a:"importhelpers-与-noemithelpers"},"85.25":{t:"downlevelIteration",p:`ES6 新增了 for...of 循环，它可以用于循环遍历所有部署了 [Symbol.iterator] 接口的数据结构，如数组、Set、Map，甚至还包括字符串。
在默认情况下，如果 target  ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#downleveliteration",a:"downleveliteration"},"85.26":{t:"importsNotUsedAsValues 与 preserveValueImports",p:"默认情况下，TypeScript 就在编译时去抹除仅类型导入（import type），但如果你希望保留这些类型导入语句，可以通过更改 importsNotUsedAsValues 配置的值来改变其行 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#importsnotusedasvalues-与-preservevalueimports",a:"importsnotusedasvalues-与-preservevalueimports"},"85.27":{t:"声明文件相关",p:"",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#声明文件相关",a:"声明文件相关"},"85.28":{t:"declaration、declarationDir",p:"这两个选项主要控制声明文件的输出，其中 declaration 接受一个布尔值，即是否产生声明文件。而 declarationDir 控制写入声明文件的路径，默认情况下声明文件会和构建代码文件在一个位 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#declaration、declarationdir",a:"declaration、declarationdir"},"85.29":{t:"declarationMap",p:`declarationMap 选项会为声明文件也生成 source map，这样你就可以从 .d.ts 直接映射回原本的 .ts 文件了。
在使用第三方库时，如果你点击一个来自第三方库的变量，会发现跳 ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#declarationmap",a:"declarationmap"},"85.30":{t:"emitDeclarationOnly",p:`此配置会让最终构建结果只包含构建出的声明文件（.d.ts），而不会包含 .js 文件。类似于 noEmit 选项，你可以使用其他构建器比如 swc 来构建代码文件，而只使用 tsc 来生成类型文件。
`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#emitdeclarationonly",a:"emitdeclarationonly"},"85.31":{t:"Source Map 相关",p:`以下配置均和 Source Map 有关，我们就放在一起介绍了。

sourceMap 与 inlineSourceMap 有些类似于 Webpack 中的 devtool 配置，控制是生成 .map ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#source-map-相关",a:"source-map-相关"},"85.32":{t:"构建产物代码格式化配置",p:`以下选项主要控制产物代码中的代码格式化，或者说代码风格相关，我们就放在一起介绍了。


newLine，指定文件的结尾使用 CRLF 还是 LF 换行风格。其中 CRLF 其实就是 Carriage  ...`,l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#构建产物代码格式化配置",a:"构建产物代码格式化配置"},"85.33":{t:"总结与预告",p:"这一节我们介绍了构建相关的配置，其中主要的概念包括如何配置你的输入与输出，以及如何启用特殊的语法等。这些配置通常通常不会频繁发生变化（除了 lib 可能会需要动态调整），而是在有特殊的需要时再对应地进 ...",l:"TypeScript/27.TSConfig 全解（上）：构建相关配置.html#总结与预告",a:"总结与预告"},"86.0":{t:"上一节我们介绍了构建相关的 TSConfig 配置，包括源码相关、解析相关、产物相关等几个部分，这一节我们会接着来介绍类型检查与工程相关的 TSConfig。",p:`
本节代码见：Project References

`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html",a:"上一节我们介绍了构建相关的-tsconfig-配置-包括源码相关、解析相关、产物相关等几个部分-这一节我们会接着来介绍类型检查与工程相关的-tsconfig。"},"86.1":{t:"检查相关",p:"这部分的配置主要控制对源码中语法与类型检查的严格程度，这也是导致 TypeScript 项目下限与上限差异巨大的主要原因，检查全开与全关下的 TypeScript 简直就是两门不同的语言。但并不是说检 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#检查相关",a:"检查相关"},"86.2":{t:"允许类",p:`这一部分的配置关注的语法通常是有害的，且默认情况下为禁用或者给出警告，因此需要显式通过配置来允许这些有害语法，它们的名称均为 allowXXX 这种形式。
`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#允许类",a:"允许类"},"86.3":{t:"allowUmdGlobalAccess",p:"这一配置会允许你直接使用 UMD 格式的模块而不需要先导入，比如你通过 CDN 引入或是任何方式来确保全局一定会有这个变量。而 UMD 格式其实就是通用模块规范，兼容了 AMD 与 CommonJs（ ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#allowumdglobalaccess",a:"allowumdglobalaccess"},"86.4":{t:"allowUnreachableCode",p:"Unreachable Code 通常指的是无法执行到的代码，也称 Dead Code，常见的 Unreachable Code 包括 return 语句、throw 语句以及 process.exi ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#allowunreachablecode",a:"allowunreachablecode"},"86.5":{t:"allowUnusedLabels",p:`Label 并不是我们经常会接触的概念，它的语法大致是这样：
someLabel:
	statement

statement 语句会被标记为 someLabel ，然后在别的地方你就可以用 some ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#allowunusedlabels",a:"allowunusedlabels"},"86.6":{t:"禁止类",p:`这部分配置的关注点其实除了类型，也包括实际的代码逻辑，它们主要关注未被妥善处理的逻辑代码与无类型信息（手动标注与自动推导均无）的部分。另外，部分代码逻辑检查实际上 ESLint 也可以提供。
这部分配 ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#禁止类",a:"禁止类"},"86.7":{t:"类型检查",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#类型检查",a:"类型检查"},"86.8":{t:"noImplicitAny",p:`在你没有为变量或参数指定类型，同时 TypeScript 也无法自动推导其类型时，这里变量的类型就会被推导为 any。而推导为 any 类型就意味着丧失了类型检查：
function fn(s) {
 ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#noimplicitany",a:"noimplicitany"},"86.9":{t:"useUnknownInCatchVariables",p:"启用此配置后，try/catch 语句中 catch 的 error 类型会被更改为 unknown （否则是 any 类型）。这样可以在类型层面确保在 catch 语句中对 error 进行更妥当的 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#useunknownincatchvariables",a:"useunknownincatchvariables"},"86.10":{t:"逻辑检查",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#逻辑检查",a:"逻辑检查"},"86.11":{t:"noFallthroughCasesInSwitch",p:"这一配置确保在你的 switch case 语句中不会存在连续执行多个 case 语句的情况。注意，连续执行指的是某一个 case 中自己执行了专属逻辑后，由于没有 break / return 语句 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#nofallthroughcasesinswitch",a:"nofallthroughcasesinswitch"},"86.12":{t:"noImplicitOverride",p:`在函数与 Class 一节我们有讲到，在派生类继承于基类时，通常我们不希望去覆盖基类已有的方法（SOLID 原则），这样可以确保在任何需要基类的地方，我们都可以放心地传入一个派生类。
在真的需要覆盖基 ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#noimplicitoverride",a:"noimplicitoverride"},"86.13":{t:"noImplicitReturns",p:`这一配置会确保所有返回值类型中不包含 undefined 的函数，在其内部所有的执行路径上都需要有 return 语句：
// 函数缺少结束 return 语句，返回类型不包括 &quot;undef ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#noimplicitreturns",a:"noimplicitreturns"},"86.14":{t:"noImplicitThis",p:"JavaScript 代码中，我们其实经常见到 this，this 的指向也一直是一个很烦人的问题。虽然在 ES6 占据主导地位的今天，我们通常只会在 Class 内部使用 this，TypeScri ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#noimplicitthis",a:"noimplicitthis"},"86.15":{t:"noPropertyAccessFromIndexSignature 与 noUncheckedIndexedAccess",p:`在索引类型一节我们知道，可以通过索引签名类型来声明一个仅确定键值类型而不确定具体属性的接口：
interface AllStringTypes {
  name: string;
  [key: st ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#nopropertyaccessfromindexsignature-与-nouncheckedindexedaccess",a:"nopropertyaccessfromindexsignature-与-nouncheckedindexedaccess"},"86.16":{t:"noUnusedLocals 与 noUnusedParameters",p:`是否允许存在声明但未使用的变量和函数参数，就像 ESLint 一样，这里就不做介绍了。
`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#nounusedlocals-与-nounusedparameters",a:"nounusedlocals-与-nounusedparameters"},"86.17":{t:"严格检查",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#严格检查",a:"严格检查"},"86.18":{t:"exactOptionalPropertyTypes",p:`这一配置会使得 TypeScript 对可选属性（即使用 ? 修饰的属性）启用更严格检查，如以下这个例子：
interface ITheme {
  prefer?: &quot;dark&quot; ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#exactoptionalpropertytypes",a:"exactoptionalpropertytypes"},"86.19":{t:"alwaysStrict",p:"还记得 ES5 中的严格模式吗？这一配置就是它在 TS 中的体现，alwaysStrict 配置会使得 TS 对所有文件使用严格模式进行检查（表现在会禁用掉一部分语法），同时生成的 js 文件开头也会 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#alwaysstrict",a:"alwaysstrict"},"86.20":{t:"strict",p:`strict 其实是一组规则的开关，开启 strict 会默认将这些规则全部启用，包括：

alwaysStrict、useUnknownInCatchVariables
noFallthroughC ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#strict",a:"strict"},"86.21":{t:"strictBindCallApply",p:"JavaScript 中可以通过 bind、call、apply 来改变一个函数的 this 指向，绝大部分情况下即使改变了 this 指向，函数的入参也应当是不变的。这条配置会确保在使用 bind、 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#strictbindcallapply",a:"strictbindcallapply"},"86.22":{t:"strictFunctionTypes",p:`对函数类型启用更严格的检查，即我们在函数类型比较一节中讲到的，对参数类型启用逆变检查。
function fn(x: string) {
  console.log('Hello, ' + x.toL ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#strictfunctiontypes",a:"strictfunctiontypes"},"86.23":{t:"strictNullChecks",p:`这是在任何规模项目内都应该开启的一条规则。在这条规则关闭的情况下，null 和 undefined 会被隐式地视为任何类型的子类型，还记得我们前面的例子吗？
// 以下两个仅在关闭 strictNul ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#strictnullchecks",a:"strictnullchecks"},"86.24":{t:"strictPropertyInitialization",p:`这一配置要求 Class 中的所有属性都需要存在一个初始值，无论是在声明时就提供还是在构造函数中初始化。
class Foo {
  prop1: number = 599;
  prop2: num ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#strictpropertyinitialization",a:"strictpropertyinitialization"},"86.25":{t:"skipLibCheck 与 skipDefaultLibCheck",p:"默认情况下，TypeScript 会对加载的类型声明文件也进行检查，包括内置的 lib.d.ts 系列与 @types/ 下的声明文件。在某些时候，这些声明文件可能存在冲突，比如两个不同来源的声明文件 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#skiplibcheck-与-skipdefaultlibcheck",a:"skiplibcheck-与-skipdefaultlibcheck"},"86.26":{t:"工程相关",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#工程相关",a:"工程相关"},"86.27":{t:"Project References",p:"Project References 这一配置使得你可以将整个工程拆分成多个部分，比如你的 UI 部分、Hooks 部分以及主应用等等。这一功能和 Monorepo 非常相似，但它并不需要各个子项目拥 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#project-references",a:"project-references"},"86.28":{t:"composite",p:"composite 属于 compilerOptions 内部的配置，在 Project References 的被引用子项目 tsconfig.json 中必须为启用状态，它通过一系列额外的配置项， ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#composite",a:"composite"},"86.29":{t:"兼容性",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#兼容性",a:"兼容性"},"86.30":{t:"isolatedModules",p:"我们常常提到的，构建过程会使用 TypeScript 配合其他构建器，如 ESBuild、SWC、Babel 等。通常在这个过程中，类型相关的检查会完全交由 TypeScript 处理，因为这些构建器 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#isolatedmodules",a:"isolatedmodules"},"86.31":{t:"JavaScript 相关",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#javascript-相关",a:"javascript-相关"},"86.32":{t:"allowJs",p:`只有在开启此配置后，你才能在 .ts 文件中去导入 .js / .jsx 文件。
`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#allowjs",a:"allowjs"},"86.33":{t:"checkJs",p:"checkJs 通常用于配合 allowJs 使用，为 .js 文件提供尽可能全面的类型检查。我们在类型指令一节学习过 @ts-check 指令，这一配置就相当于为所有 JavaScript 文件标注 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#checkjs",a:"checkjs"},"86.34":{t:"模块相关",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#模块相关",a:"模块相关"},"86.35":{t:"esModuleInterop 与 allowSyntheticDefaultImports",p:`这两个配置主要还是为了解决 ES Module 和 CommonJS 之间的兼容性问题。
通常情况下，ESM 调用 ESM，CJS 调用 CJS，都不会有问题。但如果是 ESM 调用 CJS ，就可能 ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#esmoduleinterop-与-allowsyntheticdefaultimports",a:"esmoduleinterop-与-allowsyntheticdefaultimports"},"86.36":{t:"编译器相关",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#编译器相关",a:"编译器相关"},"86.37":{t:"incremental",p:"incremental 配置将启用增量构建，在每次编译时首先 diff 出发生变更的文件，仅对这些文件进行构建，然后将新的编译信息通过 .tsbuildinfo 存储起来。你可以使用 tsBuildI ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#incremental",a:"incremental"},"86.38":{t:"watch 相关",p:"我们可以通过 tsc --watch 来启动一个监听模式的 tsc，它会在代码文件发生变化（同样会对 node_modules 文件夹的变化进行监听，但只到文件夹级别）时重新进行编译。通常我们会搭配  ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#watch-相关",a:"watch-相关"},"86.39":{t:"编译器检查",p:"这里的配置主要用于检查编译器的工作情况，或者在你需要进行编译器性能优化时使用，它们会生成编译器工作的分析报告，包括本次编译包含了哪些文件，以及各个编译阶段（I/O、Type Checking 等）的耗 ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#编译器检查",a:"编译器检查"},"86.40":{t:"其它工程相关",p:"",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#其它工程相关",a:"其它工程相关"},"86.41":{t:"extends",p:`这一配置可以类比到 ESLint 配置中的 extends，作用就是复用已有的文件，在这里即是一个已存在的 TSConfig 配置文件。其作用包括在 Monorepo 下统一各个子项目的基础配置：
/ ...`,l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#extends",a:"extends"},"86.42":{t:"总结与预告",p:"在这一节，我们了解了检查相关和工程相关的 TSConfig ，其中有些配置涉及前端领域的其他知识，如在 esModuleInterop 中，我们了解了 ESM 与 CJS 之间调用的问题，以及 Typ ...",l:"TypeScript/28.TSConfig 全解（下）：检查相关、工程相关配置.html#总结与预告",a:"总结与预告"},"87.0":{t:"在这一节，我们会使用 TypeScript 来开发一个 Node API，并将它部署在服务器上。技术选型方面，我们使用 NestJs 作为框架，Prisma 作为 ORM，Heroku 作为部署平台与数据库提供商。",p:`需要说明的是，我们要开发的 API 并不会十分完善。一方面，过多的 CRUD 代码并没有教学意义。另一方面，如果要完整开发一个生产可用的 API ，可能还需要再写一本小册才行。
那你可能会问，上面说的 ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html",a:"在这一节-我们会使用-typescript-来开发一个-node-api-并将它部署在服务器上。技术选型方面-我们使用-nestjs-作为框架-prisma-作为-orm-heroku-作为部署平台与数据库提供商。"},"87.1":{t:"Heroku 环境配置",p:`在正式开始前，我们不妨提前配置好 Heroku 的环境，因为这一步耗时比较久，我们可以让它在一边安装，先开始下面的学习。
在终端运行以下命令：
# 适用于 Mac，需要安装 HomeBrew
brew ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#heroku-环境配置",a:"heroku-环境配置"},"87.2":{t:"NestJS 基础",p:`接下来，我们来了解 NestJs 的基础概念。
NestJs 是一个 NodeJs 框架，它和 Express、Koa、Egg 的主要区别其实就两点，应用风格与框架能力。
我们先来说应用风格。Nest ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#nestjs-基础",a:"nestjs-基础"},"87.3":{t:"Prisma 基础",p:"Prisma 是一个“比较特殊”的 ORM，为什么这么说呢？我们知道，ORM 库（Object-Relational Mapping），其实就是编程语言到 SQL 的映射，也就是说，我们无需学习 SQ ...",l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#prisma-基础",a:"prisma-基础"},"87.4":{t:"在 NestJs 中集成 Prisma",p:`在 NestJs 中集成 Prisma 其实也非常简单，秉持着模块化的理念，我们将 Prisma 相关的逻辑单独放到一个模块中。
新建 prisma.service.ts：
import {
  In ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#在-nestjs-中集成-prisma",a:"在-nestjs-中集成-prisma"},"87.5":{t:"总结与预告",p:"这一节我们学习了 NestJs 框架与 Prisma ORM 的基础概念与使用方式，以及在 NestJs 中集成 Prisma 的方法。相比于其它同类型框架，它们都有着决定性的优势，如 NestJs  ...",l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#总结与预告",a:"总结与预告"},"87.6":{t:"扩展阅读",p:"",l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#扩展阅读",a:"扩展阅读"},"87.7":{t:"NestJs 应用目录结构的不同组织方式",p:`前面我们介绍了 Controller、Service 等文件的基本功能，除此以外，NestJs 应用中其实存在着两种不同的文件组织风格：按功能与按逻辑进行拆分。
按功能进行拆分，即我们本节的应用使用的 ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#nestjs-应用目录结构的不同组织方式",a:"nestjs-应用目录结构的不同组织方式"},"87.8":{t:"Data Mapper 与 Active Record",p:"即使你此前已经有过 ORM 的实践经验，还有两个概念可能是你未了解过的，即 Data Mapper 与 Active Record 。TypeORM的简介中提到，TypeORM supports bo ...",l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#data-mapper-与-active-record",a:"data-mapper-与-active-record"},"87.9":{t:"ORM 与 QueryBuilder",p:`ORM 并不是唯一一种让我们可以不用写 SQL 就能操作数据库的方式，同时它也不是最贴近 SQL 的方式。
Query Builder 就是这另外一种使用方式，它和 ORM 一样，通过编程语言书写，但 ...`,l:"TypeScript/29.基于 Prisma + NestJs 的 Node API ：前置知识储备.html#orm-与-querybuilder",a:"orm-与-querybuilder"},"88.0":{t:"同时，上一节最开始安装的环境应该差不多了，那我们就来接着了解一下 Heroku 的打开方式。",p:`
本节代码见：Blog API

`,l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html",a:"同时-上一节最开始安装的环境应该差不多了-那我们就来接着了解一下-heroku-的打开方式。"},"88.1":{t:"Heroku 初体验",p:"前端社区有非常多的免费云服务，它们的作用各不相同，但基本上能找到所有你需要的。比如 Surge 提供了快捷的静态页面部署，Vercel 提供了与 git 服务集成支持的静态页面部署、页面指标统计以及免 ...",l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html#heroku-初体验",a:"heroku-初体验"},"88.2":{t:"连接到 Heroku 数据库",p:`首先，在你本地的 .env 文件中修改 DATABASE_URL：
DATABASE_URL=&quot;postgres://...&quot;

执行命令：
prisma db push

这一命 ...`,l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html#连接到-heroku-数据库",a:"连接到-heroku-数据库"},"88.3":{t:"初次部署",p:`万事俱备，我们现在可以把应用部署到 Heroku 上了。但也别太急，我们的应用还需要进行一些额外的配置才能在 Heroku 上正常的工作。
首先是更改应用的端口号，Heroku 在部署这个应用时，会随 ...`,l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html#初次部署",a:"初次部署"},"88.4":{t:"API 开发",p:"终于到了 API 开发环节，但这一部分的内容反倒最简短。我们并不会把每一个实体（文章、标签、分类）的方法都实现完，因为如果你已经有过类似的开发经验，那这些内容对你来说意义不大，而如果你此前并无相关开发 ...",l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html#api-开发",a:"api-开发"},"88.5":{t:"总结与预告",p:"通过这两节的学习，我们从 0 开发并部署了一个 Node API 到 Heroku 平台上。如果你此前未接触过 Nest 和 Prisma ，那最大的收获其实是学习了目前功能最全面的 NodeJs 框 ...",l:"TypeScript/30.基于 Prisma + NestJs 的 Node API ：项目开发与基于 Heroku 部署.html#总结与预告",a:"总结与预告"},"89.0":{t:"前置知识：Babel 的基本工作流程",p:`在本节的最开始，我有必要郑重说明下，我本身并不是科班出身，没有系统学习过编译原理，以下涉及编译原理的概念大部分来自于在社区的学习所得，也欢迎你指出其中的错误，我将认真对待并修正。

本节原本是被作为短 ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html",a:"前置知识-babel-的基本工作流程"},"89.1":{t:"使用 TypeScript Compiler API",p:"编译处理 TypeScript 代码，我们其实仍然可以使用 Babel，但实际上 TypeScript 本身就将几乎所有 Compiler API 都暴露了出来，也就是说如果你希望更贴近 tsc 的行 ...",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#使用-typescript-compiler-api",a:"使用-typescript-compiler-api"},"89.2":{t:"使用 ts-morph",p:`上面的例子看下来，可能有部分同学已经被劝退了，这一堆眼花缭乱的 API，我咋知道啥时候该用哪个，难道还要先从头学一遍编译原理？
当然不，你可以永远相信 JavaScript 社区。为了简化 TypeS ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#使用-ts-morph",a:"使用-ts-morph"},"89.3":{t:"AST Checker 与 CodeMod",p:`了解了 ts-morph 的基本使用，接下来我们就通过几个具有实际意义的示例进一步掌握它。这些示例基本都是我遇见过的实际场景，如果不通过 AST 操作，就需要自己手动一个个处理。
这些操作其实可以分为 ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#ast-checker-与-codemod",a:"ast-checker-与-codemod"},"89.4":{t:"示例：导入语句",p:"许多场景的 AST 操作中，其实都会涉及对导入语句的处理。比如 CodeMod 会将你旧版本的导入更新为新版本的导入，或者更换导入语句的导入路径（模块名），而在某些工程场景下，AST Checker  ...",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#示例-导入语句",a:"示例-导入语句"},"89.5":{t:"示例：添加装饰器",p:`在装饰器一节我们说到，可以使用方法装饰器来测量一个方法的调用耗时，但一个一个加未免太过麻烦，更好的方式是通过 AST 来批量处理目标 Class 的目标方法：
abstract class Handl ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#示例-添加装饰器",a:"示例-添加装饰器"},"89.6":{t:"示例：添加 memo",p:`为 React 组件添加 memo 是一个常见的优化手段，我们是否可以通过 AST 操作来批量为组件添加 memo ？
我们的源码是这样的：
import { useState } from 'rea ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#示例-添加-memo",a:"示例-添加-memo"},"89.7":{t:"示例：JSON 转类型定义",p:`这个例子可能是最最刚需的一个了，把后端响应的 JSON 放进去，就得到了 TypeScript 的类型定义。
我们输入的 json 是这样的：
{
  &quot;name&quot;: &quot; ...`,l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#示例-json-转类型定义",a:"示例-json-转类型定义"},"89.8":{t:"示例：基于 JSDoc 的任务过期检测",p:"很多时候，我们可能会写一些存在过期时效的代码，比如紧急更新、临时 bugfix 等，如果在规模较为庞大的代码库中，很可能你写完就忘记这个方法只是临时方法了。这个示例中，我们会使用 JSDoc 的形式来 ...",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#示例-基于-jsdoc-的任务过期检测",a:"示例-基于-jsdoc-的任务过期检测"},"89.9":{t:"总结",p:"在这一节，我们主要学习了如何使用 TypeScript 的 Compiler API 和 ts-morph 来对 TS 源码进行操作，就像数据库的 CRUD 一样，对源码的常见操作其实也可以被归类为检 ...",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#总结",a:"总结"},"89.10":{t:"扩展阅读",p:"",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#扩展阅读",a:"扩展阅读"},"89.11":{t:"AST Checker 与 ESLint",p:"在上面的介绍中，听起来 AST Checker 和 ESLint 很相似，都是检查代码是否符合规则，并且 ESLint 也是通过 AST 来进行检查，如 AST Explorer 中使用 TypeSc ...",l:"TypeScript/31.玩转 TypeScript AST：AST Checker 与 CodeMod.html#ast-checker-与-eslint",a:"ast-checker-与-eslint"},"90.0":{t:"在本节开始前，我想先感谢每一位读者，感谢你们的肯定与支持，也希望小册中的内容能够让你收获明显的成长。",p:`这本小册是我的第一本小册，肯定还存在许多不足之处，比如错别字、示例代码的呈现以及内容的组织方面等等，幸运的是我拥有许多耐心细致的读者帮我“捉虫”，我也会在发现这些问题时第一时间改正。
从上线到现在，我 ...`,l:"TypeScript/32.感谢相伴：是结束，也是开始.html",a:"在本节开始前-我想先感谢每一位读者-感谢你们的肯定与支持-也希望小册中的内容能够让你收获明显的成长。"},"90.1":{t:"是结束",p:`天下没有不散的筵席，小册的正文内容就到这里结束了，不妨让我们再回顾下这一路我们都学习了什么。
类型基础部分（1 - 5 节），作为入门阶段到进阶阶段之间的过渡，在这里我们在入门的基础上，按照小册的节奏 ...`,l:"TypeScript/32.感谢相伴：是结束，也是开始.html#是结束",a:"是结束"},"90.2":{t:"也是开始",p:`虽然到这里，小册的正文内容已经划上句点，但这本小册还没有完全结束。我们还会有数节漫谈篇内容作为番外。
漫谈篇的内容不会包含任何新的 TypeScript 知识点，你只需要读过一遍就能理解并化为己用，不 ...`,l:"TypeScript/32.感谢相伴：是结束，也是开始.html#也是开始",a:"也是开始"},"90.3":{t:"致谢",p:`最后，这本小册之所以能成功面世，离不开许多人在这个过程中的帮助。在此，我想再次向他们致以最诚挚的谢意。
感谢掘金小编的一路跟随与耐心审校，在这本小册中学习到的写作经验也是我的重要收获之一。
感谢 寻找 ...`,l:"TypeScript/32.感谢相伴：是结束，也是开始.html#致谢",a:"致谢"},"91.0":{t:"TypeScript 在前端领域的重要性正在不断提升，那么很自然地，面试过程中对 TypeScript 技能的考察也会逐渐上升到和 Vue / React 技能一样的地位。",p:`那么，如果 TypeScript 在面试中出现，它又会变成什么样子？首先你可以放心的是，面试中大概率不会出现超出这本小册的知识难度，如果出现了，那可能说明这场面试比较奇妙...
在这一节中，我们会来聊 ...`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html",a:"typescript-在前端领域的重要性正在不断提升-那么很自然地-面试过程中对-typescript-技能的考察也会逐渐上升到和-vue-react-技能一样的地位。"},"91.1":{t:"interface 与 type 异同点",p:`这可能是最经典的一道 TS 面试题了，因此这里我们放在第一个知识点来讲解。
`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#interface-与-type-异同点",a:"interface-与-type-异同点"},"91.2":{t:"及格线",p:`不论如何，以下这些概念是你需要基本了解的，否则很容易被怀疑是否真的深入使用过 TypeScript 。

在对象扩展情况下，interface 使用 extends 关键字，而 type 使用交叉类型 ...`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#及格线",a:"及格线"},"91.3":{t:"优秀回答",p:"只是回答这些概念定义显得过于枯燥，而且很容易被认为像是在背书，因此你可以穿插自己在工程中的实践， 比如小册中提过的，使用 interface 来定义对象类型，使用类型别名来处理函数签名、联合类型、工具 ...",l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#优秀回答",a:"优秀回答"},"91.4":{t:"类型兼容性比较",p:"这一问题主要考察你是否了解 TypeScript 类型系统的基本工作原理，以及使用的深入程度。因为通常来说，只有具有一定经验的使用者才会开始了解类型兼容性的相关规则，而了解这部分规则也就意味着你至少能 ...",l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#类型兼容性比较",a:"类型兼容性比较"},"91.5":{t:"及格线",p:"TypeScript 使用鸭子类型，也即结构化类型系统进行类型兼容性的比较，即对于两个属性完全一致的类型，就认为它们属于同一种类型。而对于 A 类型、A + B 类型，认为后者属于前者的子类型。另外  ...",l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#及格线",a:"及格线"},"91.6":{t:"优秀回答",p:`能回答出上面这些内容已经不错了，但你可是阅读完了这本小册的同学，怎么能轻易止步。如果想进一步升华回答，还可以从以下方面进行扩展。

结构化类型系统到标称类型系统，你可以表达你不仅了解结构化类型系统，还 ...`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#优秀回答",a:"优秀回答"},"91.7":{t:"any、unknown 与 never",p:`这一部分主要考察你对内置 Top Type、Bottom Type 的理解，属于相对少见的考察，因此通常也不会要求过高。
`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#any、unknown-与-never",a:"any、unknown-与-never"},"91.8":{t:"及格线",p:"具体内容已经在小册中详细描述，这里只做简单叙述。any 与 unknown 在 TypeScript 类型层级中属于最顶层的 Top Type，也就意味所有类型都是它俩的子类型。而 never 则相反 ...",l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#及格线",a:"及格线"},"91.9":{t:"优秀回答",p:`面试的重要原则之一就是 WHY，在回答一个知识点的同时，如果能把这个知识点背后的存在原因也讲述清楚，很难不让面试官暗暗点头为你折服，因此你可以考虑从以下这么几个角度出发来进行扩展。

为什么需要 To ...`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#优秀回答",a:"优秀回答"},"91.10":{t:"工具类型实现",p:`这一部分有可能需要你进行手写，但对于完成了整本小册阅读的你来说，肯定不是难事，这一部分就不做过多叙述了。
`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#工具类型实现",a:"工具类型实现"},"91.11":{t:"及格线",p:`比较简单的工具类型手写可能包括 Partial（Require）、Pick（Omit）、ReturnType（ParameterType），小册中均已介绍了相关实现与原理，这里就不再赘述。
`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#及格线",a:"及格线"},"91.12":{t:"优秀回答",p:`在完成手写的基础上，其实你也可以主动进行扩展。

我不仅能写出这些基础实现，还能写出其在实际应用场景中的增强版，比如 DeepPartial 与 MarkAsPartial，PickByType 与  ...`,l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#优秀回答",a:"优秀回答"},"91.13":{t:"总结",p:"这一节我们专项学习了几个可能在面试中被作为高频考点的 TypeScript 知识点，至于它们为什么会高频出现，其实也是有原因的，相比其它部分知识，这些考点难度适中，又能很少地筛选掉没有实际使用经验的候 ...",l:"TypeScript/33.漫谈篇：面试中的 TypeScript.html#总结",a:"总结"},"92.0":{t:"扩展路由的Meta",p:`

项目根目录下创建 typing.d.ts 文件


加入以下内容
import 'vue-router'

declare module 'vue-router' {
  interface Ro ...`,l:"Vue+TS/TS 扩展路由meta.html",a:"扩展路由的meta"},"93.0":{t:"<!--",p:`
@Date: 2024-06-07 10:43:54
@LastEditTime: 2024-06-07 11:03:38
@Description:
@FilePath: /xuchp.githu ...`,l:"Vue插件/CDN 引入.html",a:""},"93.1":{t:"CDN 引入",p:"",l:"Vue插件/CDN 引入.html#cdn-引入",a:"cdn-引入"},"93.2":{t:"安装",p:`下载 yarn
yarn add vite-plugin-cdn-import -D

or npm
npm install vite-plugin-cdn-import -D

`,l:"Vue插件/CDN 引入.html#安装",a:"安装"},"93.3":{t:"基本用法",p:`// vite.config.js
import cdn from 'vite-plugin-cdn-import'

export default {
  plugins: [
    cdn({
 ...`,l:"Vue插件/CDN 引入.html#基本用法",a:"基本用法"},"93.4":{t:"预设的 npm 包",p:`
react
react-dom
react-router-dom
antd
vue
vue2
vue-router
vue-router@3
moment
dayjs
axios
lodash

`,l:"Vue插件/CDN 引入.html#预设的-npm-包",a:"预设的-npm-包"},"93.5":{t:"参数",p:"",l:"Vue插件/CDN 引入.html#参数",a:"参数"},"93.6":{t:"prodUrl",p:`可选, 全局 prodUrl 属性, 生成 CND 文件路径的模板 url。

类型

{
    prodUrl?: string
}


默认值: https://cdn.jsdelivr.net ...`,l:"Vue插件/CDN 引入.html#produrl",a:"produrl"},"93.7":{t:"modules",p:`external 模块配置

类型

type GetModuleFunc = (prodUrl: string) =&gt; Module
{
    modules: (Module | Modu ...`,l:"Vue插件/CDN 引入.html#modules",a:"modules"},"93.8":{t:"enableInDevMode",p:`是否在开发模式中启用
类型: boolean
默认值：false

vite2, vite3 请确保开发模式 process.env.NODE_ENV === 'development'

`,l:"Vue插件/CDN 引入.html#enableindevmode",a:"enableindevmode"},"93.9":{t:"generateScriptTag",p:`自定义生成的 script 标签

类型

generateScriptTag?: (
    name: string,
    scriptUrl: string,
) =&gt; Omit&lt ...`,l:"Vue插件/CDN 引入.html#generatescripttag",a:"generatescripttag"},"93.10":{t:"generateCssLinkTag",p:`自定义生成 css link 标签

类型

generateCssLinkTag?: (
    name: string,
    cssUrl: string,
) =&gt; Omit&lt; ...`,l:"Vue插件/CDN 引入.html#generatecsslinktag",a:"generatecsslinktag"},"93.11":{t:"module 配置",p:`


name
Description
Type




name
需要 CDN 加速的包名称
string


alias
名称的别名，例如“react-dom/client”是“react-dom ...`,l:"Vue插件/CDN 引入.html#module-配置",a:"module-配置"},"93.12":{t:"其他的 CDN prodUrl 地址",p:`


Name
pordUrl




unpkg
//unpkg.com/{name}@{version}/{path}


cdnjs
//cdnjs.cloudflare.com/ajax/li ...`,l:"Vue插件/CDN 引入.html#其他的-cdn-produrl-地址",a:"其他的-cdn-produrl-地址"},"94.0":{t:"Pinia 缓存持久化",p:"",l:"Vue插件/Pinia 缓存持久化.html",a:"pinia-缓存持久化"},"94.1":{t:"一、安装 pinia-plugin-persistedstate",p:`
pnpm : pnpm i pinia-plugin-persistedstate
npm : npm i pinia-plugin-persistedstate
yarn : yarn add p ...`,l:"Vue插件/Pinia 缓存持久化.html#一、安装-pinia-plugin-persistedstate",a:"一、安装-pinia-plugin-persistedstate"},"94.2":{t:"二、在 main.ts 中添加",p:`import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedsta ...`,l:"Vue插件/Pinia 缓存持久化.html#二、在-main-ts-中添加",a:"二、在-main-ts-中添加"},"94.3":{t:"三、在仓库中添加配置项",p:`defineStore 的第二个参数中配置{persist:true}来开启数据持久化
import { defineStore } from 'pinia'

export const useSto ...`,l:"Vue插件/Pinia 缓存持久化.html#三、在仓库中添加配置项",a:"三、在仓库中添加配置项"},"94.4":{t:"四、配置",p:`该插件的默认配置如下:

使用 localStorage 进行存储
store.$id 作为 storage 默认的 key
使用 JSON.stringify/JSON.parse 进行序列化/反序 ...`,l:"Vue插件/Pinia 缓存持久化.html#四、配置",a:"四、配置"},"94.5":{t:"key",p:`
类型：string
默认值：store.$id

Key 用于引用 storage 中的数据
import { defineStore } from 'pinia'

export const us ...`,l:"Vue插件/Pinia 缓存持久化.html#key",a:"key"},"94.6":{t:"storage",p:`
类型：StorageLike
默认值：localStorage

将数据持久化到 storage 中，必须具有 getItem: (key: string) =&gt; string | null  ...`,l:"Vue插件/Pinia 缓存持久化.html#storage",a:"storage"},"94.7":{t:"paths",p:`
类型：string[]
默认值：undefined

用于指定 state 中哪些数据需要被持久化。[] 表示不持久化任何状态，undefined 或 null 表示持久化整个 state。
imp ...`,l:"Vue插件/Pinia 缓存持久化.html#paths",a:"paths"},"94.8":{t:"serializer",p:`
类型：Serializer
默认值：JSON.stringify/JSON.parse

该配置能够指定持久化时所使用的序列化方法，以及恢复 Store 时的反序列化方法。另外，必须具有 seria ...`,l:"Vue插件/Pinia 缓存持久化.html#serializer",a:"serializer"},"94.9":{t:"beforeRestore",p:`
类型：(context: PiniaPluginContext) =&gt; void
默认值：undefined

该 hook 将在从 storage 中恢复数据之前触发，并且它可以访问整个 P ...`,l:"Vue插件/Pinia 缓存持久化.html#beforerestore",a:"beforerestore"},"94.10":{t:"afterRestore",p:`
类型：(context: PiniaPluginContext) =&gt; void
默认值：undefined

该 hook 将在从 storage 中恢复数据之后触发，并且它可以访问整个 P ...`,l:"Vue插件/Pinia 缓存持久化.html#afterrestore",a:"afterrestore"},"94.11":{t:"debug",p:`
类型：boolean
默认值：false

当设置为 true 时，持久化/恢复 Store 时可能发生的任何错误都将使用 console.error 输出。
`,l:"Vue插件/Pinia 缓存持久化.html#debug",a:"debug"},"95.0":{t:"批量导入 SVG",p:"",l:"Vue插件/批量导入svg.html",a:"批量导入-svg"},"95.1":{t:"一-安装插件",p:`npm i vite-plugin-svg-icons -D
// 或者
yarn add vite-plugin-svg-icons -D

`,l:"Vue插件/批量导入svg.html#一-安装插件",a:"一-安装插件"},"95.2":{t:"二、在 vite.config.ts 中配置",p:`iconDirs:iconDirs 是保存 svg 图片的文件夹，可以填写多个
&lt;img src=&quot;https://raw.githubusercontent.com/xuchp/ty ...`,l:"Vue插件/批量导入svg.html#二、在-vite-config-ts-中配置",a:"二、在-vite-config-ts-中配置"},"95.3":{t:"三、封装 svg 组件",p:`&lt;template&gt;
  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use  ...`,l:"Vue插件/批量导入svg.html#三、封装-svg-组件",a:"三、封装-svg-组件"},"95.4":{t:"四、配置全局组件并引入插件",p:`import { type App } from 'vue'
import SvgIcon from '@/components/SvgIcon/index.vue' // svg component ...`,l:"Vue插件/批量导入svg.html#四、配置全局组件并引入插件",a:"四、配置全局组件并引入插件"},"95.5":{t:"五、在 main.ts 中引入",p:`import { useSvgIcon } from '@/icons'
useSvgIcon(app)


`,l:"Vue插件/批量导入svg.html#五、在-main-ts-中引入",a:"五、在-main-ts-中引入"},"96.0":{t:"数据类型",p:"",l:"basic/JavaScript 核心原理精讲.html",a:"数据类型"},"96.1":{t:"数据类型分类",p:"基础数据类型：Undefined、Null、Boolean、String、Number、Symbol、BigInt引用数据类型： Object(Array、RegExp、Date、Math、Funct ...",l:"basic/JavaScript 核心原理精讲.html#数据类型分类",a:"数据类型分类"},"96.2":{t:"数据类型检测",p:`

typeof


instanceof
typeof 和 instanceof 的差异

instanceof 可以准确地判断复杂引用数据的类型，但是不能正确判断基础数据类型
而 typeof 也 ...`,l:"basic/JavaScript 核心原理精讲.html#数据类型检测",a:"数据类型检测"},"96.3":{t:"数据类型转换",p:`

强制类型转换
Number()、parseInt()、parseFloat()、toString()、String()、Boolean()


隐式类型转换

逻辑运算符&amp;&amp;、|| ...`,l:"basic/JavaScript 核心原理精讲.html#数据类型转换",a:"数据类型转换"},"96.4":{t:"浅拷贝和深拷贝",p:"",l:"basic/JavaScript 核心原理精讲.html#浅拷贝和深拷贝",a:"浅拷贝和深拷贝"},"96.5":{t:"浅拷贝",p:"浅拷贝： 自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象，但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了 ...",l:"basic/JavaScript 核心原理精讲.html#浅拷贝",a:"浅拷贝"},"96.6":{t:"深拷贝",p:`浅拷贝只是创建了一个新的对象，复制了原有对象的基本类型的值。
对于复杂引用数据类型，其在堆内存中完全开辟了一块内存地址，并将原有的对象完全复制过来存放。
深拷贝原理
将一个对象从内存中完整地拷贝出来一 ...`,l:"basic/JavaScript 核心原理精讲.html#深拷贝",a:"深拷贝"},"96.7":{t:"继承",p:`继承是面向对象的，使用这种方式我们可以更好地复用以前的开发代码，缩短开发的周期、提升开发效率
继承可以使得子类别具有父类的各种方法和属性
`,l:"basic/JavaScript 核心原理精讲.html#继承",a:"继承"},"96.8":{t:"常见的实现继承的方法",p:`一、原型链继承
原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例

每一个构造函数都有一个原型对象
原型对象又包含一个指向构造函数的指针
而实例则包含一个原型对象的指针

funct ...`,l:"basic/JavaScript 核心原理精讲.html#常见的实现继承的方法",a:"常见的实现继承的方法"},"96.9":{t:"如何实现 new、apply、call、bind 的底层逻辑",p:`JavaScript 中的 apply、call 和 bind 方法是前端代码开发中相当重要的概念，并且与 this 的指向密切相关
new 原理介绍
new 关键词的主要作用，就是指向一个构造函数， ...`,l:"basic/JavaScript 核心原理精讲.html#如何实现-new、apply、call、bind-的底层逻辑",a:"如何实现-new、apply、call、bind-的底层逻辑"},"96.10":{t:"闭包",p:`JavaScript 的作用域： 指变量能够被访问到的范围
`,l:"basic/JavaScript 核心原理精讲.html#闭包",a:"闭包"},"96.11":{t:"闭包的定义",p:`红宝书： 闭包是指有权访问另外一个函数作用域中的变量的函数
MDN： 一个函数和对其周围状态的引用捆绑在一起(或者说函数被引用包围)，这样的组合就是闭包。也就是说，闭包让你可以在一个内层函数访问到起外 ...`,l:"basic/JavaScript 核心原理精讲.html#闭包的定义",a:"闭包的定义"},"96.12":{t:"闭包产生的原因",p:`作用域链的基本概念： 当访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去腹肌作用域查找，直到找到该变量或者不存在父级作用域中。
闭包产生的本质就是当前环境中存在指向父级作用域的引用 ...`,l:"basic/JavaScript 核心原理精讲.html#闭包产生的原因",a:"闭包产生的原因"},"96.13":{t:"闭包的表现形式",p:`
返回一个函数
在定时器、时间监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包
作为函数参数传递的形式
IIFE(立即执行函数)，创建了闭包，保存 ...`,l:"basic/JavaScript 核心原理精讲.html#闭包的表现形式",a:"闭包的表现形式"},"96.14":{t:"JSON.stringify",p:`JSON.stringify是日常开发中经常用到的 JSON 对象中的方法
JSON.parse
JSON.parse 方法用来解析 JSON 字符串，构造有字符串描述的 JavaScript 值或对 ...`,l:"basic/JavaScript 核心原理精讲.html#json-stringify",a:"json-stringify"},"96.15":{t:"数组",p:"",l:"basic/JavaScript 核心原理精讲.html#数组",a:"数组"},"96.16":{t:"Array 的构造器",p:`Array 构造器用于创建一个新的数组，通常推荐使用对象字面量的方式创建一个数组
new Array
new Array(arg1,arg2...)参数长度为 0 或长度大于等于 2 时，传入的参数将 ...`,l:"basic/JavaScript 核心原理精讲.html#array-的构造器",a:"array-的构造器"},"96.17":{t:"Array 的判断",p:`Array.isArray
用来判断一个变量是否为数组类型
`,l:"basic/JavaScript 核心原理精讲.html#array-的判断",a:"array-的判断"},"96.18":{t:"Array 的方法",p:"改变自身的方法：pop、push、reverse、shift、sort、splice、unshift、以及两个 ES6 新增的方法 copyWithin 和 fill不改变自身的方法：concat、j ...",l:"basic/JavaScript 核心原理精讲.html#array-的方法",a:"array-的方法"},"96.19":{t:"数组扁平化",p:`数组的扁平化其实就是讲一个嵌套多层的数组 array(嵌套可以是任何层数)转化为只有一层的数组
扁平化实现方法


普通的递归实现
通过循环递归的方式，一项一项地去遍历，如果每一项还是数组，那么就继续 ...`,l:"basic/JavaScript 核心原理精讲.html#数组扁平化",a:"数组扁平化"},"96.20":{t:" ",p:"",l:"basic/JavaScript 核心原理精讲.html#",a:""},"96.21":{t:"数组排序",p:`时间复杂度： 说的更多地是通过 O(nlogn)以及 O(n)等来衡量，其实大多数时候我们对此并未建立形象的认知
空间复杂度： 对一个算法在运行过程中临时占用存储空间大小的度量
`,l:"basic/JavaScript 核心原理精讲.html#数组排序",a:"数组排序"},"96.22":{t:" ",p:"",l:"basic/JavaScript 核心原理精讲.html#",a:""},"96.23":{t:"排序分类",p:`比较类排序： 通过比较来决定元素之间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也成为非线性时间比较类排序。
非比较类排序： 不通过比较来决定元素之间的相对次序，它可以突破基于比较排序的时 ...`,l:"basic/JavaScript 核心原理精讲.html#排序分类",a:"排序分类"},"96.24":{t:"sort 排序",p:`通过 sort 方法也可以实现数组的排序，默认排序顺序是先将元素转换为字符串，然后再进行排序
语法是arr.sort([compareFunction])
compareFunction

如果 co ...`,l:"basic/JavaScript 核心原理精讲.html#sort-排序",a:"sort-排序"},"97.0":{t:"# CSS",p:"",l:"basic/css.html",a:"css"},"97.1":{t:"介绍一下 CSS 的盒子模型",p:`CSS 的盒子模型有哪些:标准盒子模型、IE 盒子模型
CSS 盒子模型的区别
	标准盒子模型:	margin、border、padding、content
	IE 盒子模型: margin、cont ...`,l:"basic/css.html#介绍一下-css-的盒子模型",a:"介绍一下-css-的盒子模型"},"97.2":{t:"line-height 和 height 的区别?",p:`line-height: 是每一行文字的高, 如果文字换行,则整个盒子的高度会增大(行数*行高)
height: 是一个死值, 就是这个盒子的高度。

`,l:"basic/css.html#line-height-和-height-的区别",a:"line-height-和-height-的区别"},"97.3":{t:"CSS 选字符有哪些？哪些属性可以继承？",p:`CSS 选择符:
通配(*)
id 选择器(#)
类选择器(.)
标签选择器(div p h1)
相邻选择器(+)
后代(子元素)选择器(ul li)
子元素选择器(&gt;)
属性选择器(a[hre ...`,l:"basic/css.html#css-选字符有哪些-哪些属性可以继承",a:"css-选字符有哪些-哪些属性可以继承"},"97.4":{t:"CSS 优先算法如何计算？",p:`优先级比较:!important &gt; 内联样式 &gt; id &gt; class &gt; 标签 &gt; 通配

CSS 权重计算:
第一: 内联样式 style 	权重值:1000
第二 ...`,l:"basic/css.html#css-优先算法如何计算",a:"css-优先算法如何计算"},"97.5":{t:"用 CSS 画一个三角形?",p:`用边框画(border)
&lt;html&gt;
  &lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;

 ...`,l:"basic/css.html#用-css-画一个三角形",a:"用-css-画一个三角形"},"97.6":{t:"一个盒子不给宽度和高度如何实现水平垂直居中?",p:`&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;
&lt;/di ...`,l:"basic/css.html#一个盒子不给宽度和高度如何实现水平垂直居中",a:"一个盒子不给宽度和高度如何实现水平垂直居中"},"97.7":{t:"display 有哪些值？说说他们的作用？",p:`


值
描述




none
此元素不会被显示


block
此元素将显示为块元素, 此元素前后会带有换行符


inline
默认, 此元素会被显示为内联元素, 元素前后没有换行符


inl ...`,l:"basic/css.html#display-有哪些值-说说他们的作用",a:"display-有哪些值-说说他们的作用"},"97.8":{t:"对 BFC(块级格式化上下文:Block Formatting Context)的理解？",p:`BFC 就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

了解 BFC： 块级格式化上下文
BFC 的原则：一个元素具有 BFC，那么内部元素再怎么弄，都不会影响到外面的元素
如 ...`,l:"basic/css.html#对-bfc-块级格式化上下文-block-formatting-context-的理解",a:"对-bfc-块级格式化上下文-block-formatting-context-的理解"},"97.9":{t:"清除浮动有哪些方式?",p:`方式一：触发 BFC
overflow: hidden

方式二：创建一个盒子，添加样式
div {
  clear: both;
}

方式三：创建一个虚拟标签 after（最常用）
div:aft ...`,l:"basic/css.html#清除浮动有哪些方式",a:"清除浮动有哪些方式"},"97.10":{t:"在网页中应该使用奇数还是偶数的字体大小？为什么呢？",p:`偶数。让文字在浏览器上表现的更好看

说明：UI 给前端设计图一般都是偶数，这样不管是布局也好，转换 px 也好，方便一点

`,l:"basic/css.html#在网页中应该使用奇数还是偶数的字体大小-为什么呢",a:"在网页中应该使用奇数还是偶数的字体大小-为什么呢"},"97.11":{t:"position 有几种定位？分别是根据什么定位的？",p:`
static：默认值，没有定位
fixed：固定定位，相对于浏览器窗口进行定位
relative：相对定位，相对于自身定位，不脱离文档流
absolute：绝对定位，相对于第一个有 relative ...`,l:"basic/css.html#position-有几种定位-分别是根据什么定位的",a:"position-有几种定位-分别是根据什么定位的"},"97.12":{t:"写一个左中右布局占满屏幕，其中左右两块固定 200px，中间自适应宽，要求先加载中间块，请写出结构及样式。",p:`双飞翼布局
&lt;html&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&q ...`,l:"basic/css.html#写一个左中右布局占满屏幕-其中左右两块固定-200px-中间自适应宽-要求先加载中间块-请写出结构及样式。",a:"写一个左中右布局占满屏幕-其中左右两块固定-200px-中间自适应宽-要求先加载中间块-请写出结构及样式。"},"97.13":{t:"什么是 CSS reset？",p:`reset.css 是一个 css 文件，用来重置 css 样式。
Normalize.css 为了增强跨浏览器渲染的一致性，我们使用了 normalize.css，这是由 Nicolas Galla ...`,l:"basic/css.html#什么是-css-reset",a:"什么是-css-reset"},"97.14":{t:"css sprite 是什么？有什么优缺点？",p:`

是什么
把多个小图标合并成一张大图片，又称精灵图


优缺点
优点：减少了 http 请求的次数，提升了性能
缺点：维护比较差（例如图片位置进行调整或者内容宽高修改，都会造成维护问题）


`,l:"basic/css.html#css-sprite-是什么-有什么优缺点",a:"css-sprite-是什么-有什么优缺点"},"97.15":{t:"display:none 和 visibility:hidden 的区别？",p:`


区别
display:none
visibility:hidden




占用位置区别
是不占位置的
虽然隐藏了，但是占用位置


重绘和回流的问题
重绘并回流
只重绘不回流




产生回流 ...`,l:"basic/css.html#display-none-和-visibility-hidden-的区别",a:"display-none-和-visibility-hidden-的区别"},"97.16":{t:"opacity 和 rgba 的区别？",p:`共同性：实现透明效果



区别
opacity
rgba




取值范围
取值范围 0-1 之间，0 表示完全透明，1 表示不透明
R 表示红色，G 表示绿色，B 表示蓝色，取值可以在正整数或者百 ...`,l:"basic/css.html#opacity-和-rgba-的区别",a:"opacity-和-rgba-的区别"},"97.17":{t:"::before 和 :after 中双冒号和单冒号有什么区别?解释一下这两个伪元素的作用?",p:`

区别
一个冒号(:)是伪类, 两个冒号(::)是伪元素	====&gt;是为了做区分


是什么?作用
before 在元素之前、 after 在元素之后
作用: 清除浮动、样式布局上也有作用

 ...`,l:"basic/css.html#before-和-after-中双冒号和单冒号有什么区别-解释一下这两个伪元素的作用",a:"before-和-after-中双冒号和单冒号有什么区别-解释一下这两个伪元素的作用"},"97.18":{t:"怎么让 chrome 支持小于 12px 的文字",p:`Chorme 浏览器默认字体大小是 16px, 每个浏览器默认字体大小不一定一样
解决办法:
{
  --webkit-transform: scale(0.75)
}

`,l:"basic/css.html#怎么让-chrome-支持小于-12px-的文字",a:"怎么让-chrome-支持小于-12px-的文字"},"97.19":{t:"rem 和 em 的 区别",p:`相对于 font-size
em 是针对于父元素的 font-size
rem 是针对于根(html)元素的 font-size
`,l:"basic/css.html#rem-和-em-的-区别",a:"rem-和-em-的-区别"},"97.20":{t:"webkit 表单输入框 placeholder 的颜色值能改变吗",p:`input::-webkit-input-placeholder{
  color: red
}

`,l:"basic/css.html#webkit-表单输入框-placeholder-的颜色值能改变吗",a:"webkit-表单输入框-placeholder-的颜色值能改变吗"},"97.21":{t:"响应式",p:`

是什么?
一个 URL 可以响应多端


语法结构
@media only screen and (max-width: 1000px){
  
}

only: 可以排除不支持媒体查询的浏览器
 ...`,l:"basic/css.html#响应式",a:"响应式"},"97.22":{t:"布局方案",p:`

什么情况下采用响应式布局?
数据不是特别多, 用户量不是特别大, 纯展示类的项目适合响应式布局
例如: 公司的官网, 专题页面
特别追求性能的项目,不太适合响应式, 因为如果添加了很多的响应式,  ...`,l:"basic/css.html#布局方案",a:"布局方案"},"99.0":{t:"# HTML",p:"",l:"basic/html.html",a:"html"},"99.1":{t:"行内元素有哪些?块级元素有哪些?空(void)元素有哪些?",p:`行内元素:span img input......
块级元素:div footer header section p h1-h6...
空元素:br hr...

元素之间的转换问题
通过 displ ...`,l:"basic/html.html#行内元素有哪些-块级元素有哪些-空-void-元素有哪些",a:"行内元素有哪些-块级元素有哪些-空-void-元素有哪些"},"99.2":{t:"页面导入样式时, 使用 link 和@import 有什么区别?",p:`
区别一: link 现有, 后有@import, 所以在兼容性上 link 比@import 好
区别二: link 和@import 加载顺序有区别。浏览器先加载标签 link, 后加载@impo ...`,l:"basic/html.html#页面导入样式时-使用-link-和-import-有什么区别",a:"页面导入样式时-使用-link-和-import-有什么区别"},"99.3":{t:"title 和 h1 的区别?b 和 strong 的区别?i 和 em 的区别?",p:`title 和 h1 的区别:
定义:
title:title 概括了网站信息, 可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
h1:文章主题内容, 告诉蜘蛛我们的网站内容最主要是什么
区别: ...`,l:"basic/html.html#title-和-h1-的区别-b-和-strong-的区别-i-和-em-的区别",a:"title-和-h1-的区别-b-和-strong-的区别-i-和-em-的区别"},"99.4":{t:"img 标签的 title 和 alt 有什么区别?",p:`
区别一
title: 鼠标移入到图片显示的值
alt: 图片无法加载时显示的值
区别二
在 SEO 的层面上, 蜘蛛抓取不到图片的内容, 所以前端在写 img 标签的时候,为了增加 SEO 效果要加 ...`,l:"basic/html.html#img-标签的-title-和-alt-有什么区别",a:"img-标签的-title-和-alt-有什么区别"},"99.5":{t:"png、jpg、gif 这些图片格式解释一下, 分别什么时候用?",p:`
png: 无损压缩, 尺寸体积要比 jpg/jpeg 的大。适合做小图标
jpg: 采用压缩算法, 有一点失真, 比 png 体积小。适合做 banner 等中大图片
gif: 一般是做动图的。
w ...`,l:"basic/html.html#png、jpg、gif-这些图片格式解释一下-分别什么时候用",a:"png、jpg、gif-这些图片格式解释一下-分别什么时候用"},"99.6":{t:"什么是语义化标签",p:`header、footer、section 等

易读性和维护性更好
SEO 成分会更好, 蜘蛛抓取更好
IE8 不兼容 HTML5 标签的.解决:可以通过 html5shiv.js 去处理


`,l:"basic/html.html#什么是语义化标签",a:"什么是语义化标签"},"100.0":{t:"# iOS 兼容问题",p:"",l:"basic/iOS 兼容问题.html",a:"ios-兼容问题"},"100.1":{t:"如何关闭 iOS 键盘首字母自动大小写",p:` &lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt;

`,l:"basic/iOS 兼容问题.html#如何关闭-ios-键盘首字母自动大小写",a:"如何关闭-ios-键盘首字母自动大小写"},"100.2":{t:"iOS 系统中元素被触摸时产生的半透明遮罩怎么去掉",p:`a, button, input, textarea {
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

`,l:"basic/iOS 兼容问题.html#ios-系统中元素被触摸时产生的半透明遮罩怎么去掉",a:"ios-系统中元素被触摸时产生的半透明遮罩怎么去掉"},"100.3":{t:"禁止 iOS 长按时不触发系统的菜单,禁止 iOS&android 长按时下载图片",p:"",l:"basic/iOS 兼容问题.html#禁止-ios-长按时不触发系统的菜单-禁止-ios-android-长按时下载图片",a:"禁止-ios-长按时不触发系统的菜单-禁止-ios-android-长按时下载图片"},"100.4":{t:"禁止 iOS 长按触发系统菜单",p:`html, body {
  touch-callout: none;
  -webkit-touch-callout: none;
}

`,l:"basic/iOS 兼容问题.html#禁止-ios-长按触发系统菜单",a:"禁止-ios-长按触发系统菜单"},"100.5":{t:"禁止下载图片",p:`img {
  user-select: none;
  -webkit-user-select: none;
}

`,l:"basic/iOS 兼容问题.html#禁止下载图片",a:"禁止下载图片"},"100.6":{t:"禁止 iOS 和 android 用户选中文字",p:`text, textarea {
  user-select: none;
  -webkit-user-select: none;
}

`,l:"basic/iOS 兼容问题.html#禁止-ios-和-android-用户选中文字",a:"禁止-ios-和-android-用户选中文字"},"101.0":{t:"# JS",p:"",l:"basic/js.html",a:"js"},"101.1":{t:"延迟加载 JS 有哪些方式？",p:`延迟加载: async defer
例如&lt;script async type=&quot;text/javascript&quot; src=&quot;*.js&quot;/&gt;
defe ...`,l:"basic/js.html#延迟加载-js-有哪些方式",a:"延迟加载-js-有哪些方式"},"101.2":{t:"JS 数据类型有哪些？",p:`基本类型: string、number、boolean、undefined、null、 symbol、bigint
引用类型: object
字符串和其他类型相加, 变成链接的形式
NaN 是一个数值 ...`,l:"basic/js.html#js-数据类型有哪些",a:"js-数据类型有哪些"},"101.3":{t:"null 和 undefined 的区别",p:`
作者在设计 js 时先设计的 null(原因: 最初设计 js 的时候借鉴了 java 语言）
null 会被隐式转化成 0, 很不容易发现错误
现有 null 后有 undefined, 出来 u ...`,l:"basic/js.html#null-和-undefined-的区别",a:"null-和-undefined-的区别"},"101.4":{t:"== 和 === 有什么不同",p:`== : 比较的是值
string == number || boolean || number...都会隐式转换
通过 valueOf 转换(valueOf() 方法通常由 JavaScript 在 ...`,l:"basic/js.html#和-有什么不同",a:"和-有什么不同"},"101.5":{t:"JS 微任务和宏任务",p:`

js 是单线程的语言


js 代码执行流程: 同步执行完 =&gt; 事件循环
同步执行完了, 才会执行事件循环的内容
进入事件循环: 请求、定时器、事件......


事件循环包含【宏任务、 ...`,l:"basic/js.html#js-微任务和宏任务",a:"js-微任务和宏任务"},"101.6":{t:"JS 作用域",p:`
除了函数外, JS 没有块级作用域。
作用域链: 内部可以访问外部的变量, 但是外部不能访问内部的变量
注意: 如果内部有, 优先查找内部; 如果内部没有就查找外部的
注意声明变量是用 var 还是 ...`,l:"basic/js.html#js-作用域",a:"js-作用域"},"101.7":{t:"面试的时候怎么看？",p:`
本层作用域有没有此变量【注意变量提升】
注意: JS 除了函数外没有块级作用域
普通声明函数是不看写函数的顺序的

`,l:"basic/js.html#面试的时候怎么看",a:"面试的时候怎么看"},"101.8":{t:"考题 1",p:`function c() {
  var b = 1
  function a() {
    console.log(b) // undefined
    var b = 2
    consol ...`,l:"basic/js.html#考题-1",a:"考题-1"},"101.9":{t:"考题二",p:`var name = 'a'
;(function () {
  if (typeof name == 'undefined') {
    var name = 'b'
    console.lo ...`,l:"basic/js.html#考题二",a:"考题二"},"101.10":{t:"考题三",p:`function fun(a) {
  var a = 10
  function a() {}
  console.log(a)
}
fun(100)

输出:  10

`,l:"basic/js.html#考题三",a:"考题三"},"101.11":{t:"JS 对象",p:`JS 对象注意点:


对象是通过 new 操作符构建出来的, 所以对象之间不相等(除了引用外)


对象注意: 引用类型


对象的 key 都是字符串类型


对象如何找属性|方法
查找规则: 现 ...`,l:"basic/js.html#js-对象",a:"js-对象"},"101.12":{t:"考题一",p:`console.log([1, 2, 3] === [1, 2, 3]) // false

`,l:"basic/js.html#考题一",a:"考题一"},"101.13":{t:"考题二",p:`var obj1 = {
  a: 'hello'
}
var obj2 = obj1
obj2.a = 'world'
console.log(obj1) // {a:'world'}
;(func ...`,l:"basic/js.html#考题二",a:"考题二"},"101.14":{t:"考题三",p:`var a = {}
var b = {
  key: 'a'
}
var c = {
  key: 'c'
}
a[b] = '123'
a[c] = '456'
console.log(a[b]) ...`,l:"basic/js.html#考题三",a:"考题三"},"101.15":{t:"JS 作用域+this 指向+原型考题",p:"",l:"basic/js.html#js-作用域-this-指向-原型考题",a:"js-作用域-this-指向-原型考题"},"101.16":{t:"考题一",p:`function Foo() {
  getName = function () {
    console.log(1)
  }
  return this
}
Foo.getName = func ...`,l:"basic/js.html#考题一",a:"考题一"},"101.17":{t:"考题二",p:`var o = {
  a: 10,
  b: {
    fn: function () {
      console.log(this.a)
      console.log(this)
   ...`,l:"basic/js.html#考题二",a:"考题二"},"101.18":{t:"考题三",p:`window.name = 'ByteDance'
function A() {
  this.name = 123
}
A.prototype.getA = function () {
  cons ...`,l:"basic/js.html#考题三",a:"考题三"},"101.19":{t:"考题四",p:`var length = 10
function fn() {
  return this.length + 1
}
var obj = {
  length: 5,
  test1: functio ...`,l:"basic/js.html#考题四",a:"考题四"},"101.20":{t:"JS 判断变量是不是数组, 你能写出哪些方法",p:"",l:"basic/js.html#js-判断变量是不是数组-你能写出哪些方法",a:"js-判断变量是不是数组-你能写出哪些方法"},"101.21":{t:"方式一: isArray 判断",p:`var arr = [1,2,3]
console.log(Array.isArray(arr))

`,l:"basic/js.html#方式一-isarray-判断",a:"方式一-isarray-判断"},"101.22":{t:"方式二: instanceof",p:`var arr = [1, 2, 3]
console.log(arr instanceof Array)

`,l:"basic/js.html#方式二-instanceof",a:"方式二-instanceof"},"101.23":{t:"方式三: 原型 prototype",p:`var arr = [1, 2, 3]
console.log(Object.prototype.toString.call(arr).indexOf('Array') &gt; -1)

`,l:"basic/js.html#方式三-原型-prototype",a:"方式三-原型-prototype"},"101.24":{t:"方式四: isPrototypeOf 判断",p:`var arr = [1, 2, 3]
console.log(Array.prototype.isPrototypeOf(arr))

`,l:"basic/js.html#方式四-isprototypeof-判断",a:"方式四-isprototypeof-判断"},"101.25":{t:"方式五: constructor",p:`var arr = [1, 2, 3]
console.log(arr.constructor.toString().indexOf('Array') &gt; -1)

`,l:"basic/js.html#方式五-constructor",a:"方式五-constructor"},"101.26":{t:"slice 是干嘛的?splice 是否会改变原数组?",p:"",l:"basic/js.html#slice-是干嘛的-splice-是否会改变原数组",a:"slice-是干嘛的-splice-是否会改变原数组"},"101.27":{t:"slice",p:`slice 是来截取的
slice(start?: number, end?: number): T[];

参数可以写 slice(3), slice(1,3), slice(-3)...返回的是一 ...`,l:"basic/js.html#slice",a:"slice"},"101.28":{t:"splice",p:`splice(start: number, deleteCount?: number): T[];
splice(start: number, deleteCount: number, ...item ...`,l:"basic/js.html#splice",a:"splice"},"101.29":{t:"JS 数组去重",p:"",l:"basic/js.html#js-数组去重",a:"js-数组去重"},"101.30":{t:"方式一: new Set",p:`var arr = [1, 2, 3, 4, 5, 1, 3]
function unique(arr) {
  return [...new Set(arr)]
}
console.log(uniq ...`,l:"basic/js.html#方式一-new-set",a:"方式一-new-set"},"101.31":{t:"方式二: indexOf",p:`var arr = [1, 2, 3, 4, 5, 1, 3]
function unique(arr) {
  var newArr = []
  for (var i = 0; i &lt; ar ...`,l:"basic/js.html#方式二-indexof",a:"方式二-indexof"},"101.32":{t:"方式三: sort",p:`var arr = [1, 2, 3, 4, 5, 1, 3]
function unique(arr) {
  arr = arr.sort()
  var newArr = []
  for (v ...`,l:"basic/js.html#方式三-sort",a:"方式三-sort"},"101.33":{t:"找出多维数组最大值",p:`var arr = [
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 857, 1]
]
functio ...`,l:"basic/js.html#找出多维数组最大值",a:"找出多维数组最大值"},"101.34":{t:"给字符串新增方法实现功能",p:`String.prototype.addPrefix = function (str) {
  return str + this
}
console.log('world'.addPrefix('h ...`,l:"basic/js.html#给字符串新增方法实现功能",a:"给字符串新增方法实现功能"},"101.35":{t:"找出字符串出现最多次数的字符以及次数",p:`var s = 'aaaaaaabbbbbbcccccbbbbaaaaaabbbbbcccaaa'
function getMost(str) {
  var obj = {}
  for (var  ...`,l:"basic/js.html#找出字符串出现最多次数的字符以及次数",a:"找出字符串出现最多次数的字符以及次数"},"101.36":{t:"new 操作符具体做了什么?",p:`
创建了一个空的对象
将空对象的原型指向于构造函数的原型
将空对象作为构造函数的上下文(改变 this 指向)
对构造函数有返回值的处理判断

`,l:"basic/js.html#new-操作符具体做了什么",a:"new-操作符具体做了什么"},"101.37":{t:"闭包",p:"",l:"basic/js.html#闭包",a:"闭包"},"101.38":{t:"1. 闭包是什么",p:`闭包是一个函数加上到创建函数的作用域的连接, 闭包&quot;关闭&quot;了函数的自由变量
`,l:"basic/js.html#_1-闭包是什么",a:"_1-闭包是什么"},"101.39":{t:"2. 闭包可以解决什么问题(闭包的优点)",p:`

内部函数可以访问到外部函数的局部变量


闭包可以解决的问题
var lis = document.getElementsByTagName('li')
for (var i = 0; i &lt ...`,l:"basic/js.html#_2-闭包可以解决什么问题-闭包的优点",a:"_2-闭包可以解决什么问题-闭包的优点"},"101.40":{t:"3. 闭包的缺点",p:`
变量会驻留在内存中, 造成内存损耗问题。


解决: 把闭包的函数设置为 null

var lis = document.getElementsByTagName('li')
for (var i ...`,l:"basic/js.html#_3-闭包的缺点",a:"_3-闭包的缺点"},"101.41":{t:"原型链",p:`
原型可以解决什么问题

对象共享属性和共享方法


谁有原型
函数拥有 prototype
对象拥有__proto__


对象查找属性或者方法的顺序
查找规则: 现在对象本身找 -&gt; 构造函 ...`,l:"basic/js.html#原型链",a:"原型链"},"101.42":{t:"JS 继承有哪些方式",p:"",l:"basic/js.html#js-继承有哪些方式",a:"js-继承有哪些方式"},"101.43":{t:"方式一: ES6",p:`class Parent {
  constructor() {
    this.age = 18
  }
}
class Child extends Parent {
  constructor( ...`,l:"basic/js.html#方式一-es6",a:"方式一-es6"},"101.44":{t:"方式二: 原型链继承",p:`function Parent() {
  this.age = 20
}
function Child() {
  this.name = '张三'
}
Child.prototype = new  ...`,l:"basic/js.html#方式二-原型链继承",a:"方式二-原型链继承"},"101.45":{t:"方式三: 借用构造函数",p:`function Parent() {
  this.age = 20
}
function Child() {
  Parent.call(this)
  this.name = '张三'
}
le ...`,l:"basic/js.html#方式三-借用构造函数",a:"方式三-借用构造函数"},"101.46":{t:"方式四: 组合式继承",p:`function Parent() {
  this.age = 20
}
function Child() {
  Parent.call(this)
  this.name = '张三'
}

C ...`,l:"basic/js.html#方式四-组合式继承",a:"方式四-组合式继承"},"101.47":{t:"说一下 call、apply、bind 的区别?",p:"",l:"basic/js.html#说一下-call、apply、bind-的区别",a:"说一下-call、apply、bind-的区别"},"101.48":{t:"共同点:",p:`功能一致, 可以改变 this 指向
语法: 函数.call()、函数.apply()、函数.bind()
`,l:"basic/js.html#共同点",a:"共同点"},"101.49":{t:"区别:",p:`
返回不同: call 和 apply 可以立即执行; bind 不会立即执行, 因为 bind 返回的是一个函数, 所以需要加()执行
参数不同: apply 第二个参数是数组; call 和 bi ...`,l:"basic/js.html#区别",a:"区别"},"101.50":{t:"场景:",p:`用 apply 的情况
var arr = [1, 2, 6, 54, 33, 246]
console.log(Math.max(null, arr))

用 bind 的情况
// btn 和 h ...`,l:"basic/js.html#场景",a:"场景"},"101.51":{t:"sort 背后的原理是什么?",p:`V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort, 数量小于 10 的数组使用 InsertionSort,比 10 大的数组则使用 QuickSort
 ...`,l:"basic/js.html#sort-背后的原理是什么",a:"sort-背后的原理是什么"},"101.52":{t:"深拷贝和浅拷贝",p:`共同点:复制


浅拷贝: 只复制引用, 而未复制真正的值
var arr1 = [1, 2, 3]
var arr2 = arr1

var obj1 = {
  a: 1,
  b: 2
}
va ...`,l:"basic/js.html#深拷贝和浅拷贝",a:"深拷贝和浅拷贝"},"101.53":{t:"localStorage、sessionStorage、cookie 的区别",p:`共同点: 在客户端存放数据
区别:


数据存放有效期
sessionStorage: 仅在当前浏览器窗口关闭之前有效[浏览器关了就没了]
localStorage: 始终有效, 窗口或者浏览器关闭了 ...`,l:"basic/js.html#localstorage、sessionstorage、cookie-的区别",a:"localstorage、sessionstorage、cookie-的区别"},"101.54":{t:"自适应",p:`淘宝无限适配移动端 + 布局单位使用 rem
window.addEventListener('resize', setRemUnit)
function setRemUnit () {
    le ...`,l:"basic/js.html#自适应",a:"自适应"},"101.55":{t:"var、let、const 的区别",p:`var、let、const共同点: 都是可以声明变量的
区别一:
​	var 具有变量提升的机制
​	let 和 const 没有变量提升的机制
区别二:
​	var 可以多次声明同一个变量
​	le ...`,l:"basic/js.html#var、let、const-的区别",a:"var、let、const-的区别"},"101.56":{t:"作用域考题",p:"",l:"basic/js.html#作用域考题",a:"作用域考题"},"101.57":{t:"考题一: let 和 const 没有变量提升性",p:`console.log(str) // undefined
var str = '你好'

console.log(num) // 报错
let num = 10

`,l:"basic/js.html#考题一-let-和-const-没有变量提升性",a:"考题一-let-和-const-没有变量提升性"},"101.58":{t:"考题二:var 没有自身作用域",p:`function demo () {
    var n = 2
    if (true) {
        var n = 1
    }
    console.log(n);  // 1 
 ...`,l:"basic/js.html#考题二-var-没有自身作用域",a:"考题二-var-没有自身作用域"},"101.59":{t:"考题三",p:`const obj = { a: 1 }
obj = 1111;  // 报错
obj.a = 1111 // 不报错

`,l:"basic/js.html#考题三",a:"考题三"},"101.60":{t:"将下列对象进行合并",p:`const a = {
    a: 1,
    b: 4
}
const b = {
    b: 2,
    c: 3
}

`,l:"basic/js.html#将下列对象进行合并",a:"将下列对象进行合并"},"101.61":{t:"方式一: Object.assign()",p:`let obj1 = Object.assign(a, b)
console.log(obj1);

`,l:"basic/js.html#方式一-object-assign",a:"方式一-object-assign"},"101.62":{t:"方式二:解构",p:`let obj1 = { ...a, ...b }
console.log(obj1);

`,l:"basic/js.html#方式二-解构",a:"方式二-解构"},"101.63":{t:"方式三: 自定义",p:`function extend (target, source) {
    for (var key in source) {
        target[key] = source[key]
  ...`,l:"basic/js.html#方式三-自定义",a:"方式三-自定义"},"101.64":{t:"箭头函数和普通函数有什么区别?",p:`

this 指向的问题
箭头函数中的 this 是在箭头函数定义时就确定的, 而且是不能修改的(call、apply、bind)
**** 箭头函数的 this 指向定义时候外层第一个普通函数的 t ...`,l:"basic/js.html#箭头函数和普通函数有什么区别",a:"箭头函数和普通函数有什么区别"},"101.65":{t:"Promise 的几种状态",p:`有三种状态
pending(进行中)
fulfilled(已成功)
rejected(已失败)
`,l:"basic/js.html#promise-的几种状态",a:"promise-的几种状态"},"101.66":{t:"find 和 filter 的区别",p:`区别一:返回的内容不同
​	filter: 返回的是数组
​	find: 返回的是具体的内容
区别二:
​	filter: 返回整体(每一个匹配到的都返回)
​	find: 匹配到第一个就返回
`,l:"basic/js.html#find-和-filter-的区别",a:"find-和-filter-的区别"},"101.67":{t:"some 和 every 的区别",p:`some: 如果有一项匹配,则返回 true
every: 全部匹配才会返回 true
`,l:"basic/js.html#some-和-every-的区别",a:"some-和-every-的区别"},"102.0":{t:"Tstststst",p:"",l:"basic/ts.html",a:"tstststst"},"103.0":{t:"# 一、Vue2 篇",p:"",l:"basic/vue.html",a:"一、vue2-篇"},"103.1":{t:"1. 关于生命周期",p:"",l:"basic/vue.html#_1-关于生命周期",a:"_1-关于生命周期"},"103.2":{t:"1.1 生命周期有哪些？发送请求在 created 还是 mounted ？",p:`Vue2.x 系统自带有8个
beforeCreated
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destorye ...`,l:"basic/vue.html#_1-1-生命周期有哪些-发送请求在-created-还是-mounted",a:"_1-1-生命周期有哪些-发送请求在-created-还是-mounted"},"103.3":{t:"1.2 为什么发送请求不在 beforeCreate 里？beforeCreate 和 created 有什么区别？",p:`为什么发送请求不在 beforeCreate 里
因为:如果请求是在 methods 中封装好的,在 beforeCreate 调用的时候, beforeCreate 阶段是拿不到 methods 里 ...`,l:"basic/vue.html#_1-2-为什么发送请求不在-beforecreate-里-beforecreate-和-created-有什么区别",a:"_1-2-为什么发送请求不在-beforecreate-里-beforecreate-和-created-有什么区别"},"103.4":{t:"1.3 在created 中如何获取 dom",p:`1. 只要写异步代码，获取 dom 是在异步中获取的，就可以了
   例如 setTimeout(),请求,Promise.xxx()等等...
2. 使用 Vue 系统内置的 this.$nextT ...`,l:"basic/vue.html#_1-3-在created-中如何获取-dom",a:"_1-3-在created-中如何获取-dom"},"103.5":{t:"1.4一旦进入组件会执行哪些生命周期？",p:`beforeCreated
created
beforeMount
mounted

`,l:"basic/vue.html#_1-4一旦进入组件会执行哪些生命周期",a:"_1-4一旦进入组件会执行哪些生命周期"},"103.6":{t:"1.5 第二次或者第 N 次进入组件会执行哪些生命周期？",p:`如果当前组件加入了 keep-alive,只会执行一个生命周期
activated

如果没有加入 keep-alive
beforeCreated
created
beforeMount
mount ...`,l:"basic/vue.html#_1-5-第二次或者第-n-次进入组件会执行哪些生命周期",a:"_1-5-第二次或者第-n-次进入组件会执行哪些生命周期"},"103.7":{t:"1.6 父组件引入子组件，那么生命周期执行的顺序是？",p:`父：beforeCreated、created、beforeMount
子：beforeCreated、created、beforeMount、mounted
父：mounted

`,l:"basic/vue.html#_1-6-父组件引入子组件-那么生命周期执行的顺序是",a:"_1-6-父组件引入子组件-那么生命周期执行的顺序是"},"103.8":{t:"1.7 加入 keep-alive 会执行哪些生命周期",p:`如果使用了 keep-alive 组件,当前的组件会额外新增 2 个生命周期(系统 8+ 2)
activated
deactivated

如果当前组价加入了 keep-alive,第一次进入这个组 ...`,l:"basic/vue.html#_1-7-加入-keep-alive-会执行哪些生命周期",a:"_1-7-加入-keep-alive-会执行哪些生命周期"},"103.9":{t:"1.8 你在什么情况下用过哪些生命周期？说一说生命周期的使用场景",p:`created		===&gt; 单组件请求
mounted		===&gt; 同步可以获取 dom,如果子组件请求后父组件请求
activated	===&gt; 判断 id 是否相等,如果不相同发 ...`,l:"basic/vue.html#_1-8-你在什么情况下用过哪些生命周期-说一说生命周期的使用场景",a:"_1-8-你在什么情况下用过哪些生命周期-说一说生命周期的使用场景"},"103.10":{t:"2.关于组件",p:"",l:"basic/vue.html#_2-关于组件",a:"_2-关于组件"},"103.11":{t:"2.1 组件传值(通信)的方式",p:`父传后代(后代拿到了父的数据)
1. 父组件引入子组件,绑定数据 
			&lt;List :str1=&quot;str1&quot;&gt;&lt;/List&gt;
		子组件通过 props  ...`,l:"basic/vue.html#_2-1-组件传值-通信-的方式",a:"_2-1-组件传值-通信-的方式"},"103.12":{t:"6.2 vue 单向绑定",p:`双向绑定: v-model
单向绑定: v-bind

`,l:"basic/vue.html#_6-2-vue-单向绑定",a:"_6-2-vue-单向绑定"},"103.13":{t:"6.3 v-if 和 v-for 的优先级",p:`vue2 中, v-for 的优先级大于 v-if
Vue3 中, v-if 的优先级大于 v-for

`,l:"basic/vue.html#_6-3-v-if-和-v-for-的优先级",a:"_6-3-v-if-和-v-for-的优先级"},"103.14":{t:"7. 关于原理",p:"",l:"basic/vue.html#_7-关于原理",a:"_7-关于原理"},"103.15":{t:"7.1 $nextTick 原理",p:`微任务:Promise.then  setImmediate MutationObserver
宏任务:setTimeout
$nextTick(callback){
	return new Prom ...`,l:"basic/vue.html#_7-1-nexttick-原理",a:"_7-1-nexttick-原理"},"103.16":{t:"7.2",p:"",l:"basic/vue.html#_7-2",a:"_7-2"},"104.0":{t:"# webpack",p:"",l:"basic/webpack.html",a:"webpack"},"104.1":{t:"webpack 插件",p:"",l:"basic/webpack.html#webpack-插件",a:"webpack-插件"},"105.0":{t:"<!--",p:`
@Date: 2023-12-22 10:35:10
@LastEditTime: 2023-12-22 10:36:43
@Description:
@FilePath: /blog/api-ex ...`,l:"examples/api-examples.html",a:""},"106.0":{t:"# Markdown Extension Examples",p:`This page demonstrates some of the built-in markdown extensions provided by VitePress.
`,l:"examples/markdown-examples.html",a:"markdown-extension-examples"},"106.1":{t:"Syntax Highlighting",p:"VitePress provides Syntax Highlighting powered by Shikiji, with additional features like line-highli ...",l:"examples/markdown-examples.html#syntax-highlighting",a:"syntax-highlighting"},"106.2":{t:"Custom Containers",p:`Input
::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
 ...`,l:"examples/markdown-examples.html#custom-containers",a:"custom-containers"},"106.3":{t:"More",p:`Check out the documentation for the full list of markdown extensions.
`,l:"examples/markdown-examples.html#more",a:"more"},"107.0":{t:"!image.png",p:`1. 鸿蒙应用开发快速体验
`,l:"harmonyOS/入门.html",a:"image-png"},"107.1":{t:"1.1. 准备开发环境",p:"",l:"harmonyOS/入门.html#_1-1-准备开发环境",a:"_1-1-准备开发环境"},"107.2":{t:"1.1.1. 安装 IDE",p:"鸿蒙应用开发需要使用配套的 IDE——HUAWEI DevEco Studio。 DevEco Studio基于 IntelliJ IDEA Community（IDEA 社区版）构建，为鸿蒙应用提供 ...",l:"harmonyOS/入门.html#_1-1-1-安装-ide",a:"_1-1-1-安装-ide"},"107.3":{t:"1.1.2. 配置 IDE",p:`安装完成后，可按以下步骤完成初始化配置

双击桌面快捷方式，启动DevEco Studio

!img

阅读各项条款，点击Agree表示同意

!img

初次启动会出现如下设置向导，首先需要为no ...`,l:"harmonyOS/入门.html#_1-1-2-配置-ide",a:"_1-1-2-配置-ide"},"107.4":{t:"1.2. 创建项目",p:`下面我们创建第一个鸿蒙应用项目

点击Create Project

!img

选择项目模版，此处选择第一个Empty Ability即可。

!img

配置项目

可能需要调整的配置项如下，其余 ...`,l:"harmonyOS/入门.html#_1-2-创建项目",a:"_1-2-创建项目"},"107.5":{t:"1.3. 运行项目",p:`DevEco Studio提供了多种方式用于运行项目，包括预览、模拟器和真机运行。下面逐一演示
`,l:"harmonyOS/入门.html#_1-3-运行项目",a:"_1-3-运行项目"},"107.6":{t:"1.3.1. Preview 预览",p:"Previewer预览用于查看应用的 UI 界面效果，方便随时调整界面 UI 布局。只需打开需要预览的页面文件，例如下图中的Index.ets，然后点击 IDE 右侧的Perviewer即可看到预览效 ...",l:"harmonyOS/入门.html#_1-3-1-preview-预览",a:"_1-3-1-preview-预览"},"107.7":{t:"1.3.2. 模拟器运行",p:`Previewer预览器主要用于查看界面 UI 效果，如需对项目进行更加深入的测试，可以使用模拟器运行项目。初次使用需要先安装模拟器，安装步骤如下

点击Tools菜单下的Device Manager ...`,l:"harmonyOS/入门.html#_1-3-2-模拟器运行",a:"_1-3-2-模拟器运行"},"107.8":{t:"1.3.3. 真机运行",p:`使用模拟器运行应用时，会占用电脑较多的资源，并且有些功能无法进行测试。当模拟器不满足要求时，可选择真机运行。真机运行的步骤如下

准备一台装有Harmony OS系统的手机，系统版本最好为4.0.0及 ...`,l:"harmonyOS/入门.html#_1-3-3-真机运行",a:"_1-3-3-真机运行"},"107.9":{t:"2.1. 概述",p:"HarmonyOS 应用的主要开发语言是 ArkTS，它由 TypeScript（简称 TS）扩展而来，在继承 TypeScript 语法的基础上进行了一系列优化，使开发者能够以更简洁、更自然的方式开 ...",l:"harmonyOS/入门.html#_2-1-概述",a:"_2-1-概述"},"107.10":{t:"2.2. TypeScript 快速入门",p:"",l:"harmonyOS/入门.html#_2-2-typescript-快速入门",a:"_2-2-typescript-快速入门"},"107.11":{t:"2.2.1. 运行环境说明",p:"",l:"harmonyOS/入门.html#_2-2-1-运行环境说明",a:"_2-2-1-运行环境说明"},"107.12":{t:"2.2.1.1. 线上 Playground",p:`TypeScript 提供了一个线上的 Playground 供练习使用，地址为https://www.typescriptlang.org/zh/play。
!img
`,l:"harmonyOS/入门.html#_2-2-1-1-线上-playground",a:"_2-2-1-1-线上-playground"},"107.13":{t:"2.2.1.2. 本地运行环境",p:`除去线上的运行环境，我们也可以在本地搭建一个 TS 的运行环境。

安装 VSCode 编辑器

VSCode是一款轻量级、开源且功能丰富的集成开发环境（IDE），支持多种编程语言，具有强大的插件系统 ...`,l:"harmonyOS/入门.html#_2-2-1-2-本地运行环境",a:"_2-2-1-2-本地运行环境"},"107.14":{t:"2.2.2. 声明",p:"",l:"harmonyOS/入门.html#_2-2-2-声明",a:"_2-2-2-声明"},"107.15":{t:"2.2.2.1. 变量声明",p:`!img
`,l:"harmonyOS/入门.html#_2-2-2-1-变量声明",a:"_2-2-2-1-变量声明"},"107.16":{t:"2.2.2.2. 常量声明",p:`let用于声明变量，而const用于声明常量，两者的区别是变量在赋值后可以修改，而常量在赋值后便不能再修改。
const b: number = 200

`,l:"harmonyOS/入门.html#_2-2-2-2-常量声明",a:"_2-2-2-2-常量声明"},"107.17":{t:"2.2.2.3. 类型推断",p:`如果一个变量或常量的声明包含了初始值，TS 便可以根据初始值进行类型推断，此时我们就可以不显式指定其类型，例如
let c = 60
console.log(typeof c) //number

`,l:"harmonyOS/入门.html#_2-2-2-3-类型推断",a:"_2-2-2-3-类型推断"},"107.18":{t:"2.2.3. 常用数据类型",p:"",l:"harmonyOS/入门.html#_2-2-3-常用数据类型",a:"_2-2-3-常用数据类型"},"107.19":{t:"2.2.3.1. number",p:"number`表示数字，包括整数和浮点数，例如： `100`、`-33` 、`2.5`、`-3.9\nlet a :number = 100\nlet b :number = -33\nlet c :num ...",l:"harmonyOS/入门.html#_2-2-3-1-number",a:"_2-2-3-1-number"},"107.20":{t:"2.2.3.2. string",p:"string`表示字符串，例如： `你好`、`hello\nlet a:string = '你好'\nlet b:string = 'hello'\n\n",l:"harmonyOS/入门.html#_2-2-3-2-string",a:"_2-2-3-2-string"},"107.21":{t:"2.2.3.3. boolean",p:"boolean`表示布尔值，可选值为：`true`、`false\nlet isOpen:boolean = true\nlet isDone:boolean = false\n\n",l:"harmonyOS/入门.html#_2-2-3-3-boolean",a:"_2-2-3-3-boolean"},"107.22":{t:"2.2.3.4. 数组",p:`数组类型定义由两部分组成，元素类型[]，例如number[]表示数字数组，string[]表示字符串数组，数组类型的变量可由数组字面量——[item1,item2,item3]进行初始化。
let a ...`,l:"harmonyOS/入门.html#_2-2-3-4-数组",a:"_2-2-3-4-数组"},"107.23":{t:"2.2.3.5. 对象",p:"在 TS 中，对象（object）是一种一系列由属性名称和属性值组成的数据结构，例如姓名:'张三', 年龄:10, 性别:'男'。对象类型的声明需要包含所有属性的名称及类型，例如{name: stri ...",l:"harmonyOS/入门.html#_2-2-3-5-对象",a:"_2-2-3-5-对象"},"107.24":{t:"2.2.4. 函数",p:"",l:"harmonyOS/入门.html#_2-2-4-函数",a:"_2-2-4-函数"},"107.25":{t:"2.2.4.1. 函数声明语法",p:`声明函数的基础语法如下
!img
`,l:"harmonyOS/入门.html#_2-2-4-1-函数声明语法",a:"_2-2-4-1-函数声明语法"},"107.26":{t:"2.2.4.2. 参数详解",p:"",l:"harmonyOS/入门.html#_2-2-4-2-参数详解",a:"_2-2-4-2-参数详解"},"107.27":{t:"2.2.4.2.1. 特殊语法",p:`
可选参数

可选参数通过参数名后的?进行标识，如以下案例中的gender?参数。
function getPersonInfo(name: string, age: number, gender?: ...`,l:"harmonyOS/入门.html#_2-2-4-2-1-特殊语法",a:"_2-2-4-2-1-特殊语法"},"107.28":{t:"2.2.4.2.2. 特殊类型",p:`
联合类型

一个函数可能用于处理不同类型的值，这种情况可以使用联合类型，例如以下案例中的message: number | string
function printNumberOrString(m ...`,l:"harmonyOS/入门.html#_2-2-4-2-2-特殊类型",a:"_2-2-4-2-2-特殊类型"},"107.29":{t:"2.2.4.3. 返回值详解",p:"",l:"harmonyOS/入门.html#_2-2-4-3-返回值详解",a:"_2-2-4-3-返回值详解"},"107.30":{t:"2.2.4.3.1. 特殊类型",p:`若函数没有返回值，则可以使用void作为返回值类型，其含义为空。
function test(): void {
  console.log('hello')
}

`,l:"harmonyOS/入门.html#_2-2-4-3-1-特殊类型",a:"_2-2-4-3-1-特殊类型"},"107.31":{t:"2.2.4.3.2. 类型推断",p:`函数的返回值类型可根据函数内容推断出来，因此可以省略不写。
function test() {
  console.log('hello')
}

function sum(a: number, b: ...`,l:"harmonyOS/入门.html#_2-2-4-3-2-类型推断",a:"_2-2-4-3-2-类型推断"},"107.32":{t:"2.2.4.4. 函数声明特殊语法",p:`
匿名函数

匿名函数的语法结构简洁，特别适用于简单且仅需一次性使用的场景。
let numbers: number[] = [1, 2, 3, 4, 5] numbers.forEach(funct ...`,l:"harmonyOS/入门.html#_2-2-4-4-函数声明特殊语法",a:"_2-2-4-4-函数声明特殊语法"},"107.33":{t:"2.2.5. 类（class）",p:"",l:"harmonyOS/入门.html#_2-2-5-类-class",a:"_2-2-5-类-class"},"107.34":{t:"2.2.5.1. 概述",p:`类（class）是面向对象编程语言中的一个重要概念。
面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程范式，其核心理念在于将程序中的数据与操作数据的方法有 ...`,l:"harmonyOS/入门.html#_2-2-5-1-概述",a:"_2-2-5-1-概述"},"107.35":{t:"2.2.5.2. 语法说明",p:"",l:"harmonyOS/入门.html#_2-2-5-2-语法说明",a:"_2-2-5-2-语法说明"},"107.36":{t:"2.2.5.2.1. 类的定义",p:`定义类的语法如下图所示
!img
代码如下：
class Person {    id: number;    name: string;    age: number = 18;     const ...`,l:"harmonyOS/入门.html#_2-2-5-2-1-类的定义",a:"_2-2-5-2-1-类的定义"},"107.37":{t:"2.2.5.2.2. 对象创建",p:`
语法

创建对象的关键字为new，具体语法如下
let person = new Person(1,'zhangsan');


对象属性的访问

console.log(person.name); ...`,l:"harmonyOS/入门.html#_2-2-5-2-2-对象创建",a:"_2-2-5-2-2-对象创建"},"107.38":{t:"2.2.5.2.3. 静态成员",p:`Typescript 中的类中可以包含静态成员（静态属性和静态方法），静态成员隶属于类本身，而不属于某个对象实例。静态成员通用用于定义一些常量，或者工具方法。

声明静态成员

定义静态成员需要使用s ...`,l:"harmonyOS/入门.html#_2-2-5-2-3-静态成员",a:"_2-2-5-2-3-静态成员"},"107.39":{t:"2.2.5.3. 继承",p:"继承是面向对象编程中的重要机制，允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。子类可以直接使用父类的特性，并根据需要添加新的特性或覆盖现有的特性。这种机制赋予面向对象程序良好的扩展 ...",l:"harmonyOS/入门.html#_2-2-5-3-继承",a:"_2-2-5-3-继承"},"107.40":{t:"2.2.5.4. 访问修饰符",p:`访问修饰符（Access Modifiers）用于控制类成员（属性、方法等）的可访问性。TypeScript 提供了三种访问修饰符，分别是private、protected和public。
class ...`,l:"harmonyOS/入门.html#_2-2-5-4-访问修饰符",a:"_2-2-5-4-访问修饰符"},"107.41":{t:"2.2.6. 接口（interface）",p:"",l:"harmonyOS/入门.html#_2-2-6-接口-interface",a:"_2-2-6-接口-interface"},"107.42":{t:"2.2.6.1. 概述",p:`接口（interface）是面向对象编程中的另一个重要概念。接口通常会作为一种契约或规范让类（class）去遵守，确保类实现某些特定的行为或功能。
`,l:"harmonyOS/入门.html#_2-2-6-1-概述",a:"_2-2-6-1-概述"},"107.43":{t:"2.2.6.2. 语法说明",p:`
接口定义

接口使用interface关键字定义，通常情况下，接口中只会包含属性和方法的声明，而不包含具体的实现细节，具体的细节由其实现类完成。
interface Person {    id:  ...`,l:"harmonyOS/入门.html#_2-2-6-2-语法说明",a:"_2-2-6-2-语法说明"},"107.44":{t:"2.2.6.3. 多态",p:`多态是面相对象编程中的一个重要概念，它可以使同一类型的对象具有不同的行为。下面我们通过一个具体的案例来体会多态这一概念
首先，再创建一个Person接口的实现类Teacher，如下
class Tea ...`,l:"harmonyOS/入门.html#_2-2-6-3-多态",a:"_2-2-6-3-多态"},"107.45":{t:"2.2.6.4. 接口的作用",p:`在传统的面向对象编程的场景中，接口主要用于设计和组织代码，使代码更加容易扩展和维护。下面举例说明。
假如现在需要实现一个订单支付系统，按照面向对象编程的习惯，首先需要定义一个订单类（Order），如下 ...`,l:"harmonyOS/入门.html#_2-2-6-4-接口的作用",a:"_2-2-6-4-接口的作用"},"107.46":{t:"2.2.6.5. TS 中的接口的特殊性",p:`TypeScript 中的接口是一个非常灵活的概念，除了用作类的规范之外，也常用于直接描述对象的类型，例如，现有一个变量的定义如下
let person: { name: string; age: n ...`,l:"harmonyOS/入门.html#_2-2-6-5-ts-中的接口的特殊性",a:"_2-2-6-5-ts-中的接口的特殊性"},"107.47":{t:"2.2.7. 枚举",p:"",l:"harmonyOS/入门.html#_2-2-7-枚举",a:"_2-2-7-枚举"},"107.48":{t:"2.2.7.1. 概述",p:`枚举（Enumeration）是编程语言中常见的一种数据类型，其主要功能是定义一组有限的选项，例如，方向（上、下、左、右）或季节（春、夏、秋、冬）等概念都可以使用枚举类型定义。
`,l:"harmonyOS/入门.html#_2-2-7-1-概述",a:"_2-2-7-1-概述"},"107.49":{t:"2.2.7.2. 语法说明",p:`
枚举定义

枚举的定义需使用enum关键字，如下
enum Season {    SPRING,    SUMMER,    AUTUMN,    WINTER }


枚举使用

枚举的使用记住 ...`,l:"harmonyOS/入门.html#_2-2-7-2-语法说明",a:"_2-2-7-2-语法说明"},"107.50":{t:"2.2.7.3. 赋值",p:`在 TypeScript 中，枚举实际上是一个对象，而每个枚举值都是该对象的一个属性，并且每个属性都有具体的值，属性值只支持两种类型——数字或字符串。
默认情况下，每个属性的值都是数字，并且从 0 开 ...`,l:"harmonyOS/入门.html#_2-2-7-3-赋值",a:"_2-2-7-3-赋值"},"107.51":{t:"2.2.8. 模块化",p:"",l:"harmonyOS/入门.html#_2-2-8-模块化",a:"_2-2-8-模块化"},"107.52":{t:"2.2.8.1. 概述",p:"模块化是指将复杂的程序拆解为多个独立的文件单元，每个文件被称为一个模块。在 TypeScript 中，默认情况下，每个模块都拥有自己的作用域，这意味着在一个模块中声明的任何内容（如变量、函数、类等）在 ...",l:"harmonyOS/入门.html#_2-2-8-1-概述",a:"_2-2-8-1-概述"},"107.53":{t:"2.2.8.2. 语法说明",p:`
导出

导出须使用export关键字，语法如下
export function hello() {    console.log('hello module A'); } export const  ...`,l:"harmonyOS/入门.html#_2-2-8-2-语法说明",a:"_2-2-8-2-语法说明"},"107.54":{t:"2.2.8.3. 避免命名冲突",p:`若多个模块中具有命名相同的变量、函数等内容，将这些内容导入到同一模块下就会出现命名冲突。例如，在上述案例的基础上，又增加了一个 moduleC，内容如下
export function hello() ...`,l:"harmonyOS/入门.html#_2-2-8-3-避免命名冲突",a:"_2-2-8-3-避免命名冲突"},"107.55":{t:"2.2.8.4. 默认导入导出",p:`除了上述导入导出的语法之外，还有一种语法，叫做默认导入导出，这种语法相对简洁一些。

默认导出

默认导出允许一个模块指定一个（最多一个）默认的导出项，语法如下
export default func ...`,l:"harmonyOS/入门.html#_2-2-8-4-默认导入导出",a:"_2-2-8-4-默认导入导出"},"107.56":{t:"2.3. ArkTS 快速入门",p:`ArkTS 在继承了Typescript语法的基础上，主要扩展了声明式 UI 开发相关的能力。
`,l:"harmonyOS/入门.html#_2-3-arkts-快速入门",a:"_2-3-arkts-快速入门"},"107.57":{t:"2.3.1. 声明式 UI",p:`声明式 UI是一种编写用户界面的范式。下面通过一个具体案例来学习这种开发范式，假如现在要实现如下界面
!img
`,l:"harmonyOS/入门.html#_2-3-1-声明式-ui",a:"_2-3-1-声明式-ui"},"107.58":{t:"2.3.1.1. 定义界面状态",p:`按照声明式 UI 的开发范式，首先需要分析和定义页面的各种状态，并声明相应的状态变量用于表示不同的状态。
当前案例中，界面共有两个状态，分别是开灯和关灯状态，所以我们可以使用一个boolean类型的变 ...`,l:"harmonyOS/入门.html#_2-3-1-1-定义界面状态",a:"_2-3-1-1-定义界面状态"},"107.59":{t:"2.3.1.2. 描述界面显示效果",p:`在分析完界面状态后，我们需要准确的描述界面在不同状态下的显示效果。
在当前案例中，具体逻辑如下图所示
!img
`,l:"harmonyOS/入门.html#_2-3-1-2-描述界面显示效果",a:"_2-3-1-2-描述界面显示效果"},"107.60":{t:"2.3.1.3. 改变状态",p:`在明确了界面在不同状态下的显示效果后，我们只需修改状态变量的值，就能触发界面的更新。
在当前案例中，若我们将isOn的值改为true，那么界面上就会显示开灯的图片，否则就会显示关灯的图片。
为了实现点 ...`,l:"harmonyOS/入门.html#_2-3-1-3-改变状态",a:"_2-3-1-3-改变状态"},"107.61":{t:"2.3.1.4. 总结",p:`以上就是声明式 UI 开发范式的大致流程，下面为大家总结一下声明式 UI 的核心思想

声明式描述

开发者只需描述在界面在不同状态下要呈现的最终效果，而无需关注界面变化的具体过程。
!img

状态 ...`,l:"harmonyOS/入门.html#_2-3-1-4-总结",a:"_2-3-1-4-总结"},"107.62":{t:"2.3.2. 组件化",p:"在鸿蒙开发中，组件是构成界面的最小单元，我们所看到的界面，都是由众多组件组合而成的，所以编写界面其实就是组合组件的过程，ArkTS 提供了很多的内置组件，例如：Text、Button、Image等等； ...",l:"harmonyOS/入门.html#_2-3-2-组件化",a:"_2-3-2-组件化"},"107.63":{t:"2.3.3. 入门案例",p:"",l:"harmonyOS/入门.html#_2-3-3-入门案例",a:"_2-3-3-入门案例"},"107.64":{t:"2.3.3.1. 案例效果",p:`案例的最终效果如下图所示
!img
`,l:"harmonyOS/入门.html#_2-3-3-1-案例效果",a:"_2-3-3-1-案例效果"},"107.65":{t:"2.3.3.2. 完整代码",p:`案例的完整代码见Demos/entry/src/main/ets/pages/helloworld/light/solution/Light.ets
@Entry
@Component
struct  ...`,l:"harmonyOS/入门.html#_2-3-3-2-完整代码",a:"_2-3-3-2-完整代码"},"107.66":{t:"2.3.4. 语法说明",p:"",l:"harmonyOS/入门.html#_2-3-4-语法说明",a:"_2-3-4-语法说明"},"107.67":{t:"2.3.4.1. 声明组件",p:"下面通过一个相对简单的案例来系统的学习 ArkTS 声明组件的语法，案例的最终效果如下，完整代码见Demos/entry/src/main/ets/pages/helloworld/delete/De ...",l:"harmonyOS/入门.html#_2-3-4-1-声明组件",a:"_2-3-4-1-声明组件"},"107.68":{t:"2.3.4.2. 自定义组件",p:`除去系统预置的组件外，ArkTS 还支持自定义组件。使用自定义组件，可使代码的结构更加清晰，并且能提高代码的复用性。
`,l:"harmonyOS/入门.html#_2-3-4-2-自定义组件",a:"_2-3-4-2-自定义组件"},"107.69":{t:"2.3.4.2.1. 语法说明",p:`自定义组件的语法如下图所示
!img
各部分语法说明如下：

struct关键字

struct是ArkTS新增的用于自定义组件或者自定义弹窗的关键字。其声明的数据结构和TS中的类十分相似，可包含属性 ...`,l:"harmonyOS/入门.html#_2-3-4-2-1-语法说明",a:"_2-3-4-2-1-语法说明"},"107.70":{t:"2.3.4.2.2. 案例实操",p:`现在需要对前文的开/关灯的案例做出如下改造，由于两个按钮的结构十分相似，所以可考虑自定义一个按钮组件，然后进行复用。
!img
案例的完整代码见：Demos/entry/src/main/ets/pa ...`,l:"harmonyOS/入门.html#_2-3-4-2-2-案例实操",a:"_2-3-4-2-2-案例实操"},"107.71":{t:"2.3.4.3. 渲染控制",p:"",l:"harmonyOS/入门.html#_2-3-4-3-渲染控制",a:"_2-3-4-3-渲染控制"},"107.72":{t:"2.3.4.3.1. 条件渲染",p:"",l:"harmonyOS/入门.html#_2-3-4-3-1-条件渲染",a:"_2-3-4-3-1-条件渲染"},"107.73":{t:"2.3.4.3.1.1. 概述",p:`条件渲染可根据应用的不同状态渲染不同的 UI 界面，例如前文的开/关灯案例，以及以下的播放/暂停案例，均可使用条件渲染实现。
!img
案例的完整代码见：Demos/entry/src/main/et ...`,l:"harmonyOS/入门.html#_2-3-4-3-1-1-概述",a:"_2-3-4-3-1-1-概述"},"107.74":{t:"2.3.4.3.1.2. 语法说明",p:`条件渲染的语法如下
if (...){
  //UI描述
}else if (...){
  //UI描述
}else{
  //UI描述
}

`,l:"harmonyOS/入门.html#_2-3-4-3-1-2-语法说明",a:"_2-3-4-3-1-2-语法说明"},"107.75":{t:"2.3.4.3.2. 循环渲染",p:"",l:"harmonyOS/入门.html#_2-3-4-3-2-循环渲染",a:"_2-3-4-3-2-循环渲染"},"107.76":{t:"2.3.4.3.2.1. 概述",p:`循环渲染可使用ForEach语句基于一个数组来快速渲染一个组件列表，例如以下案例中的选项列表就可通过循环渲染实现。
!img
案例的完整代码见：Demos/entry/src/main/ets/pag ...`,l:"harmonyOS/入门.html#_2-3-4-3-2-1-概述",a:"_2-3-4-3-2-1-概述"},"107.77":{t:"2.3.4.3.2.2. 语法说明",p:`ForEach循环渲染的语法如下
ForEach(
  arr: any[],
  itemGenerator: (item: any, index?: number) =&gt; void,
  k ...`,l:"harmonyOS/入门.html#_2-3-4-3-2-2-语法说明",a:"_2-3-4-3-2-2-语法说明"},"107.78":{t:"3.1. 图片",p:"",l:"harmonyOS/入门.html#_3-1-图片",a:"_3-1-图片"},"107.79":{t:"3.1.1. 概述",p:`Image为图片组件，用于在应用中显示图片。
`,l:"harmonyOS/入门.html#_3-1-1-概述",a:"_3-1-1-概述"},"107.80":{t:"3.1.2. 参数",p:"Image组件的参数类型为string | Resource | media.PixelMap，相关案例见Demos/entry/src/main/ets/pages/component/image/ ...",l:"harmonyOS/入门.html#_3-1-2-参数",a:"_3-1-2-参数"},"107.81":{t:"3.1.3. 常用属性",p:"",l:"harmonyOS/入门.html#_3-1-3-常用属性",a:"_3-1-3-常用属性"},"107.82":{t:"3.1.3.1. 图片尺寸",p:`图片尺寸可通过width()方法和height()方法进行设置。例如
Image($r('app.media.img'))
	.width(100)
	.height(100)

两个方法可接收的参数 ...`,l:"harmonyOS/入门.html#_3-1-3-1-图片尺寸",a:"_3-1-3-1-图片尺寸"},"107.83":{t:"3.1.3.2. 图片缩放",p:`当图片的原始大小与Image组件不同时，可通过objectFit()方法来设置图片的显示效果。该方法的参数类型为ImageFit枚举类型，可选的枚举值如下



名称
描述




ImageFit. ...`,l:"harmonyOS/入门.html#_3-1-3-2-图片缩放",a:"_3-1-3-2-图片缩放"},"107.84":{t:"3.1.3.3. 图片插值",p:`当原图分辨率较低并且需要放大显示时，图片会模糊并出现锯齿。如下图所示
!img
这时可以使用interpolation()方法对图片进行插值，使图片显示得更清晰。该方法的参数为ImageInterpo ...`,l:"harmonyOS/入门.html#_3-1-3-3-图片插值",a:"_3-1-3-3-图片插值"},"107.85":{t:"3.2. 文本",p:"",l:"harmonyOS/入门.html#_3-2-文本",a:"_3-2-文本"},"107.86":{t:"3.2.1. 概述",p:`Text为文本组件，用于显示文字内容。
`,l:"harmonyOS/入门.html#_3-2-1-概述",a:"_3-2-1-概述"},"107.87":{t:"3.2.2. 参数",p:`Text组件的参数类型为string | Resource，下面分别对两个参数类型进行介绍：

string 类型

Text('我是一段文本')


Resource 类型

Resource类型的 ...`,l:"harmonyOS/入门.html#_3-2-2-参数",a:"_3-2-2-参数"},"107.88":{t:"3.2.3. 常用属性",p:"",l:"harmonyOS/入门.html#_3-2-3-常用属性",a:"_3-2-3-常用属性"},"107.89":{t:"3.2.3.1. 字体大小",p:`字体大小可通过fontSize()方法进行设置，该方法的参数类型为string | number| Resource，下面逐一介绍

string 类型

string类型的参数可用于指定字体大小的具 ...`,l:"harmonyOS/入门.html#_3-2-3-1-字体大小",a:"_3-2-3-1-字体大小"},"107.90":{t:"3.2.3.2. 字体粗细",p:`字体粗细可通过fontWeight()方法进行设置，该方法参数类型为number | FontWeight | string，下面逐一介绍

number 类型

number类型的取值范围是[100 ...`,l:"harmonyOS/入门.html#_3-2-3-2-字体粗细",a:"_3-2-3-2-字体粗细"},"107.91":{t:"3.2.3.3. 字体颜色",p:`字体颜色可通过fontColor()方法进行设置，该方法参数类型为Color | string | number | Resource，下面逐一介绍

Color 类型

Color\`为枚举类型，其中 ...`,l:"harmonyOS/入门.html#_3-2-3-3-字体颜色",a:"_3-2-3-3-字体颜色"},"107.92":{t:"3.2.3.4. 文本对齐",p:`文本对齐方向可通过textAlign()方法进行设置，该方法的参数为枚举类型TextAlign，可选的枚举值如下



名称
描述




TextAlign.Start
首部对齐


TextAli ...`,l:"harmonyOS/入门.html#_3-2-3-4-文本对齐",a:"_3-2-3-4-文本对齐"},"107.93":{t:"3.2.3.5. 最大行数和超长处理",p:"可使用maxLines()方法控制文本的最大行数，当内容超出最大行数时，可使用textOverflow()方法处理超出部分，该方法的参数类型为{ overflow: TextOverflow }，其中 ...",l:"harmonyOS/入门.html#_3-2-3-5-最大行数和超长处理",a:"_3-2-3-5-最大行数和超长处理"},"107.94":{t:"3.3. 按钮",p:"",l:"harmonyOS/入门.html#_3-3-按钮",a:"_3-3-按钮"},"107.95":{t:"3.3.1. 概述",p:`Button为按钮组件，通常用于响应用户的点击操作。
`,l:"harmonyOS/入门.html#_3-3-1-概述",a:"_3-3-1-概述"},"107.96":{t:"3.3.2. 参数",p:`Button组件有两种使用方式，分别是不包含子组件和包含子组件，两种方式下，Button 组件所需的参数有所不同，下面分别介绍

不包含子组件

不包含子组件时，Button组件所需的参数如下
But ...`,l:"harmonyOS/入门.html#_3-3-2-参数",a:"_3-3-2-参数"},"107.97":{t:"3.3.3. 常用属性",p:"",l:"harmonyOS/入门.html#_3-3-3-常用属性",a:"_3-3-3-常用属性"},"107.98":{t:"3.3.3.1. 背景颜色",p:`按钮的颜色可使用backgroundColor()方法进行设置，例如
Button('绿色按钮').backgroundColor(Color.Green)

`,l:"harmonyOS/入门.html#_3-3-3-1-背景颜色",a:"_3-3-3-1-背景颜色"},"107.99":{t:"3.3.3.2. 边框圆角",p:`按钮的边框圆角大小可使用borderRadius()方法进行设置，例如
Button('圆角按钮', { type: ButtonType.Normal }).borderRadius(10)

相关 ...`,l:"harmonyOS/入门.html#_3-3-3-2-边框圆角",a:"_3-3-3-2-边框圆角"},"107.100":{t:"3.3.4. 常用事件",p:`对于 Button 组件而言，最为常用的就是点击事件，可以通过onClick()方法为按钮绑定点击事件，该方法的参数为一个回调函数，当按钮被点击时，就会触发该回调函数，例如
Button('点击事件' ...`,l:"harmonyOS/入门.html#_3-3-4-常用事件",a:"_3-3-4-常用事件"},"107.101":{t:"3.4. 切换按钮",p:"",l:"harmonyOS/入门.html#_3-4-切换按钮",a:"_3-4-切换按钮"},"107.102":{t:"3.4.1. 概述",p:`Toggle为切换按钮组件，一般用于两种状态之间的切换，例如下图中的蓝牙开关。
!img
`,l:"harmonyOS/入门.html#_3-4-1-概述",a:"_3-4-1-概述"},"107.103":{t:"3.4.2. 参数",p:`Toggle组件的参数定义如下
Toggle(options: { type: ToggleType, isOn?: boolean })


type

type属性用于设置Toggle组件的类型， ...`,l:"harmonyOS/入门.html#_3-4-2-参数",a:"_3-4-2-参数"},"107.104":{t:"3.4.3. 常用属性：",p:"",l:"harmonyOS/入门.html#_3-4-3-常用属性",a:"_3-4-3-常用属性"},"107.105":{t:"3.4.3.1. 选中状态背景色",p:`可使用selectedColor()方法设置Toggle组件在选中（或打开）状态下的背景色，例如
!img
`,l:"harmonyOS/入门.html#_3-4-3-1-选中状态背景色",a:"_3-4-3-1-选中状态背景色"},"107.106":{t:"3.4.3.2. Swtich 滑块颜色",p:`可使用设置switchPointColor()方法设置Switch类型的 Toggle 组件中的圆形滑块颜色，例如
!img
相关案例见：Demos/entry/src/main/ets/pages/ ...`,l:"harmonyOS/入门.html#_3-4-3-2-swtich-滑块颜色",a:"_3-4-3-2-swtich-滑块颜色"},"107.107":{t:"3.4.4. 常用事件",p:"Toggle组件常用的事件为change事件，每当Toggle组件的状态发生变化，就会触发change事件。开发者可通过onChange()方法为Toggle组件绑定change事件，该方法参数为一个 ...",l:"harmonyOS/入门.html#_3-4-4-常用事件",a:"_3-4-4-常用事件"},"107.108":{t:"3.5. 文本输入",p:"",l:"harmonyOS/入门.html#_3-5-文本输入",a:"_3-5-文本输入"},"107.109":{t:"3.5.1. 概述",p:`TextInput为文本输入组件，用于接收用户输入的文本内容。
`,l:"harmonyOS/入门.html#_3-5-1-概述",a:"_3-5-1-概述"},"107.110":{t:"3.5.2. 参数",p:`TextInput组件的参数定义如下
TextInput(value?:{placeholder?: string|Resource , text?: string|Resource})


plac ...`,l:"harmonyOS/入门.html#_3-5-2-参数",a:"_3-5-2-参数"},"107.111":{t:"3.5.3. 常用属性",p:"",l:"harmonyOS/入门.html#_3-5-3-常用属性",a:"_3-5-3-常用属性"},"107.112":{t:"3.5.3.1. 输入框类型",p:`可通过type()方法设置输入框的类型，该方法的参数为InputType枚举类型，可选的枚举值有



名称
描述




InputType.Normal
基本输入模式


InputType.Pa ...`,l:"harmonyOS/入门.html#_3-5-3-1-输入框类型",a:"_3-5-3-1-输入框类型"},"107.113":{t:"3.5.3.2. 光标样式",p:`可通过caretColor()方法设置光标的颜色，效果如下
!img
`,l:"harmonyOS/入门.html#_3-5-3-2-光标样式",a:"_3-5-3-2-光标样式"},"107.114":{t:"3.5.3.3. placeholder 样式",p:"可通过placeholderFont()和placeholderColor()方法设置 placeholder 的样式，其中placeholderFont()用于设置字体，包括字体大小、字体粗细等，p ...",l:"harmonyOS/入门.html#_3-5-3-3-placeholder-样式",a:"_3-5-3-3-placeholder-样式"},"107.115":{t:"3.5.3.4. 文本样式",p:`输入文本的样式可通过fontSize()、fontWeight()、fontColor()等通用属性方法进行设置。
相关案例见：Demos/entry/src/main/ets/pages/compo ...`,l:"harmonyOS/入门.html#_3-5-3-4-文本样式",a:"_3-5-3-4-文本样式"},"107.116":{t:"3.5.4. 常用事件",p:"",l:"harmonyOS/入门.html#_3-5-4-常用事件",a:"_3-5-4-常用事件"},"107.117":{t:"3.5.4.1. change 事件",p:`每当输入的内容发生变化，就会触发 change 事件，开发者可使用onChange()方法为TextInput组件绑定 change 事件，该方法的参数定义如下
onChange(callback:  ...`,l:"harmonyOS/入门.html#_3-5-4-1-change-事件",a:"_3-5-4-1-change-事件"},"107.118":{t:"3.5.4.2. 焦点事件",p:"焦点事件包括获得焦点和失去焦点两个事件，当输入框获得焦点时，会触发 focus 事件，失去焦点时，会触发 blur 事件，开发者可使用onFocus()和onBlur()方法为 TextInput 组 ...",l:"harmonyOS/入门.html#_3-5-4-2-焦点事件",a:"_3-5-4-2-焦点事件"},"107.119":{t:"3.6. 进度条",p:"",l:"harmonyOS/入门.html#_3-6-进度条",a:"_3-6-进度条"},"107.120":{t:"3.6.1. 概述",p:`Progress为进度条组件，用于显示各种进度。
`,l:"harmonyOS/入门.html#_3-6-1-概述",a:"_3-6-1-概述"},"107.121":{t:"3.6.2. 参数",p:`Progress组件的参数定义如下
Progress(options: {value: number, total?: number, type?: ProgressType})


value

v ...`,l:"harmonyOS/入门.html#_3-6-2-参数",a:"_3-6-2-参数"},"107.122":{t:"3.6.3. 常用属性",p:"",l:"harmonyOS/入门.html#_3-6-3-常用属性",a:"_3-6-3-常用属性"},"107.123":{t:"3.6.3.1. 进度条样式",p:`可通过style()调整进度条的样式，例如进度条的宽度，该方法的参数类型定义如下
style({
  strokeWidth: string | number | Resource,
  scaleC ...`,l:"harmonyOS/入门.html#_3-6-3-1-进度条样式",a:"_3-6-3-1-进度条样式"},"107.124":{t:"3.6.3.2. 进度条颜色",p:`进度条的颜色可通过color()和backgroundColor()方法进行设置，其中color()用于设置前景色，backgroundColor()用于设置背景色，例如
!img
相关案例见：Dem ...`,l:"harmonyOS/入门.html#_3-6-3-2-进度条颜色",a:"_3-6-3-2-进度条颜色"},"107.125":{t:"3.7. 弹窗",p:`弹窗是移动应用中常见的一种用户界面元素，常用于显示一些重要的信息、提示用户进行操作或收集用户输入。ArkTS 提供了多种内置的弹窗供开发者使用，除此之外还支持自定义弹窗，来满足各种不同的需求。
`,l:"harmonyOS/入门.html#_3-7-弹窗",a:"_3-7-弹窗"},"107.126":{t:"3.7.1. 消息提示",p:"",l:"harmonyOS/入门.html#_3-7-1-消息提示",a:"_3-7-1-消息提示"},"107.127":{t:"3.7.1.1. 概述",p:`Toast（消息提示），常用于显示一些简短的消息或提示，一般会在短暂停留后自动消失。具体效果如下
!img
`,l:"harmonyOS/入门.html#_3-7-1-1-概述",a:"_3-7-1-1-概述"},"107.128":{t:"3.7.1.2. 使用说明",p:`可使用@ohos.promptAction模块中的showToast()方法显示 Toast 提示，使用时需要先导入@ohos.promptAction模块，如下
import promptActio ...`,l:"harmonyOS/入门.html#_3-7-1-2-使用说明",a:"_3-7-1-2-使用说明"},"107.129":{t:"3.7.2. 警告对话框",p:"",l:"harmonyOS/入门.html#_3-7-2-警告对话框",a:"_3-7-2-警告对话框"},"107.130":{t:"3.7.2.1. 概述",p:`AlertDialog（警告对话框）用于向用户发出警告或确认操作的提示，确保用户在敏感操作前进行确认。具体效果如下
!img
相关案例见：Demos/entry/src/main/ets/pages/ ...`,l:"harmonyOS/入门.html#_3-7-2-1-概述",a:"_3-7-2-1-概述"},"107.131":{t:"3.7.2.2. 使用说明",p:`可使用全局方法AlertDialog.show()显示警告对话框，具体用法可参考相关案例或者官方文档。
`,l:"harmonyOS/入门.html#_3-7-2-2-使用说明",a:"_3-7-2-2-使用说明"},"107.132":{t:"3.7.3. 操作列表弹框",p:"",l:"harmonyOS/入门.html#_3-7-3-操作列表弹框",a:"_3-7-3-操作列表弹框"},"107.133":{t:"3.7.3.1. 概述",p:`ActionSheet（操作列表弹窗）用于提供一组选项给用户选择，用户从中选择后，可执行相应的操作。具体效果如下
!img
相关案例见：Demos/entry/src/main/ets/pages/c ...`,l:"harmonyOS/入门.html#_3-7-3-1-概述",a:"_3-7-3-1-概述"},"107.134":{t:"3.7.3.2. 使用说明",p:`可使用全局方法ActionSheet.show()显示操作列表弹窗，具体用法可参考相关案例或者官方文档。
`,l:"harmonyOS/入门.html#_3-7-3-2-使用说明",a:"_3-7-3-2-使用说明"},"107.135":{t:"3.7.4. 选择器弹窗",p:"",l:"harmonyOS/入门.html#_3-7-4-选择器弹窗",a:"_3-7-4-选择器弹窗"},"107.136":{t:"3.7.4.1. 概述",p:`选择器弹窗用于让用户从一个列表中选择一个具体的值。ArkTS内置了多种选择器弹窗，例如文本选择器、日期选择器、时间选择器等等，各选择器效果如下
&lt;details class=&quot;lake ...`,l:"harmonyOS/入门.html#_3-7-4-1-概述",a:"_3-7-4-1-概述"},"107.137":{t:"3.7.4.2. 使用说明",p:`具体用法可参考相关案例或者官方文档，各选择器的官方文档地址如下



类型
文档地址




TextPickerDialog（文本滑动选择器弹窗）
官方文档


DatePickerDialog（日 ...`,l:"harmonyOS/入门.html#_3-7-4-2-使用说明",a:"_3-7-4-2-使用说明"},"107.138":{t:"3.7.5. 自定义弹窗",p:"",l:"harmonyOS/入门.html#_3-7-5-自定义弹窗",a:"_3-7-5-自定义弹窗"},"107.139":{t:"3.7.5.1. 概述",p:`当现有组件不满足要求时，可考虑自定义弹窗，自定义弹窗允许开发者自定义弹窗内容和样式。例如
!img
相关案例见：Demos/entry/src/main/ets/pages/component/dia ...`,l:"harmonyOS/入门.html#_3-7-5-1-概述",a:"_3-7-5-1-概述"},"107.140":{t:"3.7.5.2. 使用说明",p:`显示自定义弹窗需要使用CustomDialogController，具体用法可参考相关案例或者官方文档。



\`\`\`json&lt;br/&gt;{&lt;br/&gt; &quot;integer ...`,l:"harmonyOS/入门.html#_3-7-5-2-使用说明",a:"_3-7-5-2-使用说明"},"109.0":{t:"# 如何理解node中模块的概念",p:`模块化规划
`,l:"node/1.如何理解node中模块的概念.html",a:"如何理解node中模块的概念"},"109.1":{t:"软件工程的本质是什么？",p:`
管路数据
管理变量

DB： lesson - blob / chatList - chat -- name text
BE: 数据的组织、查询
FE: runtime 的事件，管理数据

管理变量 ...`,l:"node/1.如何理解node中模块的概念.html#软件工程的本质是什么",a:"软件工程的本质是什么"},"109.2":{t:"模块化的方案",p:"",l:"node/1.如何理解node中模块的概念.html#模块化的方案",a:"模块化的方案"},"110.0":{t:"动态 CSS",p:"",l:"vue-challenge/CSS Features.html",a:"动态-css"},"110.1":{t:"题目",p:`Vue单文件组件 \`

`,l:"vue-challenge/CSS Features.html#题目",a:"题目"},"110.2":{t:"答案",p:`

&lt;template&gt;
  &lt;p&gt;hello&lt;/p&gt;
&lt;/template&gt;



`,l:"vue-challenge/CSS Features.html#答案",a:"答案"},"110.3":{t:"解答",p:`在 css 中使用v-bind可以将 CSS 的值链接到动态的组件状态
`,l:"vue-challenge/CSS Features.html#解答",a:"解答"},"110.4":{t:"全局 CSS",p:"",l:"vue-challenge/CSS Features.html#全局-css",a:"全局-css"},"110.5":{t:"题目",p:`有些时候，我们想在具有CSS作用域的Vue单文件组件设置全局CSS样式， 该怎么设置呢 ? 让我们开始吧 👇:
&lt;template&gt;
  &lt;p&gt;Hello Vue.js&lt ...`,l:"vue-challenge/CSS Features.html#题目",a:"题目"},"110.6":{t:"答案",p:`&lt;template&gt;
  &lt;p&gt;Hello Vue.js&lt;/p&gt;
&lt;/template&gt;




&lt;template&gt;
  &lt;p&gt ...`,l:"vue-challenge/CSS Features.html#答案",a:"答案"},"110.7":{t:"解答",p:`:global 可以把对应的 css 转化为全局作用域，:local 可以将对应的 css 转换为局部作用域。
去掉 style 标签中的 scoped 也可以将其内的 css 转化成全局作用域
`,l:"vue-challenge/CSS Features.html#解答",a:"解答"},"111.0":{t:"DOM 传送门",p:"",l:"vue-challenge/Components.html",a:"dom-传送门"},"111.1":{t:"题目",p:`Vue.js提供了一个内置组件，将其插槽内容渲染到另一个DOM，成为该DOM的一部分


&lt;template&gt;
  &lt;!-- 将以下元素渲染成\`body\`的子元素 --&gt;
   ...`,l:"vue-challenge/Components.html#题目",a:"题目"},"111.2":{t:"答案",p:`

&lt;template&gt;
  &lt;!-- 将以下元素渲染成\`body\`的子元素 --&gt;
  &lt;teleport to=&quot;body&quot;&gt;
    &l ...`,l:"vue-challenge/Components.html#答案",a:"答案"},"111.3":{t:"解答",p:`使用 teleport 将内容渲染到 body 的子元素中
`,l:"vue-challenge/Components.html#解答",a:"解答"},"111.4":{t:"Props 验证",p:"",l:"vue-challenge/Components.html#props-验证",a:"props-验证"},"111.5":{t:"题目",p:`请验证Button组件的Prop类型 ，使它只接收: primary | ghost | dashed | link | text | default ，且默认值为default。


&lt;tem ...`,l:"vue-challenge/Components.html#题目",a:"题目"},"111.6":{t:"答案",p:`

&lt;template&gt;
  &lt;button&gt;Button&lt;/button&gt;
&lt;/template&gt;

`,l:"vue-challenge/Components.html#答案",a:"答案"},"111.7":{t:"解答",p:`自定义类型校验validator函数可以返回特定的枚举类型
`,l:"vue-challenge/Components.html#解答",a:"解答"},"111.8":{t:"函数式组件",p:"",l:"vue-challenge/Components.html#函数式组件",a:"函数式组件"},"111.9":{t:"题目",p:`

&lt;template&gt;
  &lt;list-component
    :list=&quot;list&quot;
    :active-index=&quot;activeInd ...`,l:"vue-challenge/Components.html#题目",a:"题目"},"111.10":{t:"答案",p:`

&lt;template&gt;
  &lt;list-component :list=&quot;list&quot; :active-index=&quot;activeIndex&quot; ...`,l:"vue-challenge/Components.html#答案",a:"答案"},"111.11":{t:"渲染函数[h()]",p:"",l:"vue-challenge/Components.html#渲染函数-h",a:"渲染函数-h"},"111.12":{t:"题目",p:`在这个挑战中，你需要使用h渲染函数来实现一个组件。
请注意: 你应该确保参数被正确传递、事件被正常触发和插槽内容正常渲染。让我们开始吧。

&lt;template&gt;
  &lt;MyButto ...`,l:"vue-challenge/Components.html#题目",a:"题目"},"111.13":{t:"答案",p:`import { defineComponent, h } from 'vue'

export default defineComponent({
  name: 'MyButton',
  ren ...`,l:"vue-challenge/Components.html#答案",a:"答案"},"111.14":{t:"树组件 ",p:"",l:"vue-challenge/Components.html#树组件",a:"树组件"},"111.15":{t:"题目",p:`在这个挑战中，你需要实现一个树组件，让我们开始吧。


&lt;template&gt;
  &lt;!-- do something.... --&gt;
&lt;/template&gt;


`,l:"vue-challenge/Components.html#题目",a:"题目"},"111.16":{t:"答案",p:`

&lt;template&gt;
  &lt;ul v-for=&quot;item in data&quot;&gt;
    &lt;li&gt;
      {{ item.title }} ...`,l:"vue-challenge/Components.html#答案",a:"答案"},"112.0":{t:"切换器",p:"",l:"vue-challenge/Composable Function.html",a:"切换器"},"112.1":{t:"题目",p:`

&lt;template&gt;
  &lt;p&gt;State: {{ state ? 'ON' : 'OFF' }}&lt;/p&gt;
  &lt;p @click=&quot;toggl ...`,l:"vue-challenge/Composable Function.html#题目",a:"题目"},"112.2":{t:"答案",p:`

&lt;template&gt;
  &lt;p&gt;State: {{ state ? 'ON' : 'OFF' }}&lt;/p&gt;
  &lt;p @click=&quot;toggl ...`,l:"vue-challenge/Composable Function.html#答案",a:"答案"},"112.3":{t:"计数器",p:"",l:"vue-challenge/Composable Function.html#计数器",a:"计数器"},"112.4":{t:"题目",p:`


`,l:"vue-challenge/Composable Function.html#题目",a:"题目"},"112.5":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Count: {{ count }}&lt;/p&gt;
    &lt;button @click=&qu ...`,l:"vue-challenge/Composable Function.html#答案",a:"答案"},"112.6":{t:"实现本地存储函数",p:"",l:"vue-challenge/Composable Function.html#实现本地存储函数",a:"实现本地存储函数"},"112.7":{t:"题目",p:`

`,l:"vue-challenge/Composable Function.html#题目",a:"题目"},"112.8":{t:"答案",p:`





`,l:"vue-challenge/Composable Function.html#答案",a:"答案"},"112.9":{t:"鼠标坐标",p:`

&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;

`,l:"vue-challenge/Composable Function.html#鼠标坐标",a:"鼠标坐标"},"112.10":{t:"答案",p:`

&lt;template&gt;Mouse position is at: {{ x }}, {{ y }}&lt;/template&gt;


`,l:"vue-challenge/Composable Function.html#答案",a:"答案"},"113.0":{t:"生命周期钩子",p:"",l:"vue-challenge/Composition API.html",a:"生命周期钩子"},"113.1":{t:"题目",p:`// Child.vue



&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      Child Component: {{ count }}
     ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.2":{t:"答案",p:`// Child.vue



&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Child Component: {{ count }}&lt;/p&gt;
  ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.3":{t:"ref 全家桶",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;msg&lt;/h1&gt;
    &lt;p&gt;
      &lt;span @click=&q ...`,l:"vue-challenge/Composition API.html#ref-全家桶",a:"ref-全家桶"},"113.4":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;msg&lt;/h1&gt;
    &lt;p&gt;
      &lt;span @click=&q ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.5":{t:"响应性丢失",p:"",l:"vue-challenge/Composition API.html#响应性丢失",a:"响应性丢失"},"113.6":{t:"题目",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      &lt;span @click=&quot;update(count-1)&quot;&gt; ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.7":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      &lt;span @click=&quot;update(count - 1)&quot;&g ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.8":{t:"可写的计算属性",p:"",l:"vue-challenge/Composition API.html#可写的计算属性",a:"可写的计算属性"},"113.9":{t:"题目",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ count }}&lt;/p&gt;
    &lt;p&gt;{{ plusOne }}&lt;/p ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.10":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;{{ count }}&lt;/p&gt;
    &lt;p&gt;{{ plusOne }}&lt;/p ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.11":{t:"watch 全家桶",p:"",l:"vue-challenge/Composition API.html#watch-全家桶",a:"watch-全家桶"},"113.12":{t:"题目",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ count }}
    &lt;/p&gt;
    &lt;p ref=&quot; ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.13":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ count }}
    &lt;/p&gt;
    &lt;p ref=&quot; ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.14":{t:"解释",p:`

immediate：在侦听器创建时立即触发回调。第一次调用时旧值是 undefined。


deep：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考深层侦听器。


flush：调 ...`,l:"vue-challenge/Composition API.html#解释",a:"解释"},"113.15":{t:"浅层 ref",p:"",l:"vue-challenge/Composition API.html#浅层-ref",a:"浅层-ref"},"113.16":{t:"题目",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ state.count }}
    &lt;/p&gt;
  &lt;/div&gt; ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.17":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ state.count }}
    &lt;/p&gt;
  &lt;/div&gt; ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.18":{t:"解释",p:`triggerRef：强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用
`,l:"vue-challenge/Composition API.html#解释",a:"解释"},"113.19":{t:"依赖注入",p:"",l:"vue-challenge/Composition API.html#依赖注入",a:"依赖注入"},"113.20":{t:"题目",p:`在这个挑战中，你将使用 组合式 API: 依赖注入 来完成它。 以下是你要实现的内容 👇:
// Child.vue 



&lt;template&gt;
  {{ count }}
&lt;/ ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.21":{t:"答案",p:`// App.vue


&lt;template&gt;
  &lt;Child /&gt;
&lt;/template&gt;

//Child.vue


&lt;template&gt;
 输 ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.22":{t:"Effect 作用域 API",p:"",l:"vue-challenge/Composition API.html#effect-作用域-api",a:"effect-作用域-api"},"113.23":{t:"题目",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ doubled }}
    &lt;/p&gt;
  &lt;/div&gt;
&lt ...`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.24":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ doubled }}
    &lt;/p&gt;
  &lt;/div&gt;
&lt ...`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.25":{t:"解释",p:`effectScope.run(fn:Function),调用 stop 可以停止监听
`,l:"vue-challenge/Composition API.html#解释",a:"解释"},"113.26":{t:"自定义 Ref",p:"",l:"vue-challenge/Composition API.html#自定义-ref",a:"自定义-ref"},"113.27":{t:"题目",p:`

&lt;template&gt;
  &lt;input v-model=&quot;text&quot; /&gt;
&lt;/template&gt;

`,l:"vue-challenge/Composition API.html#题目",a:"题目"},"113.28":{t:"答案",p:`

&lt;template&gt;
  &lt;input v-model=&quot;text&quot; /&gt;
&lt;/template&gt;

`,l:"vue-challenge/Composition API.html#答案",a:"答案"},"113.29":{t:"解释",p:`customRef语法
return customRef((track, trigger) =&gt; {
    return {
      get() {
        track()
    ...`,l:"vue-challenge/Composition API.html#解释",a:"解释"},"114.0":{t:"大写",p:"",l:"vue-challenge/Directives.html",a:"大写"},"114.1":{t:"题目",p:`

&lt;template&gt;
  &lt;input type=&quot;text&quot; v-model.capitalize=&quot;&quot; /&gt;
&lt;/temp ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.2":{t:"答案",p:`

&lt;template&gt;
  &lt;input type=&quot;text&quot; v-model.capitalize=&quot;iptText&quot; /&gt;
&l ...`,l:"vue-challenge/Directives.html#答案",a:"答案"},"114.3":{t:"优化性能的指令",p:"",l:"vue-challenge/Directives.html#优化性能的指令",a:"优化性能的指令"},"114.4":{t:"题目",p:`Vue.js 提供了一个指令，以便只渲染一次元素和组件，并且跳过以后的更新。


&lt;template&gt;
  &lt;span&gt;使它从不更新: {{ count }}&lt;/span ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.5":{t:"答案",p:`

&lt;template&gt;
  &lt;span v-once&gt;使它从不更新: {{ count }}&lt;/span&gt;
&lt;/template&gt;

`,l:"vue-challenge/Directives.html#答案",a:"答案"},"114.6":{t:"解答",p:`v-once: 仅渲染元素和组件一次，并跳过之后的更新。在随后的重新渲染，元素/组件及其所有子项将被当作静态内容并跳过渲染。这可以用来优化更新时的性能。
v-text: 更新元素的文本内容。
v-ht ...`,l:"vue-challenge/Directives.html#解答",a:"解答"},"114.7":{t:"切换焦点的指令",p:"",l:"vue-challenge/Directives.html#切换焦点的指令",a:"切换焦点的指令"},"114.8":{t:"题目",p:`

&lt;template&gt;
  &lt;input v-focus=&quot;state&quot; type=&quot;text&quot;&gt;
&lt;/template&gt; ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.9":{t:"答案",p:`

&lt;template&gt;
  &lt;input v-focus=&quot;state&quot; type=&quot;text&quot; /&gt;
&lt;/template&g ...`,l:"vue-challenge/Directives.html#答案",a:"答案"},"114.10":{t:"防抖点击指令",p:"",l:"vue-challenge/Directives.html#防抖点击指令",a:"防抖点击指令"},"114.11":{t:"题目",p:`

&lt;template&gt;
  &lt;button v-debounce-click:200=&quot;onClick&quot;&gt;
    Click on it many ti ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.12":{t:"答案",p:`

&lt;template&gt;
  &lt;button v-debounce-click:200=&quot;onClick&quot;&gt;Click on it many times q ...`,l:"vue-challenge/Directives.html#答案",a:"答案"},"114.13":{t:"激活的样式-指令",p:"",l:"vue-challenge/Directives.html#激活的样式-指令",a:"激活的样式-指令"},"114.14":{t:"题目",p:`

&lt;template&gt;
  &lt;ul&gt;
    &lt;li
      v-for=&quot;(item, index) in list&quot;
      :key= ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.15":{t:"答案",p:`

&lt;template&gt;
  &lt;ul&gt;
    &lt;li
      v-for=&quot;(item, index) in list&quot;
      :key= ...`,l:"vue-challenge/Directives.html#答案",a:"答案"},"114.16":{t:"实现简易的`v-model`指令",p:"",l:"vue-challenge/Directives.html#实现简易的-v-model-指令",a:"实现简易的-v-model-指令"},"114.17":{t:"题目",p:`

&lt;template&gt;
  &lt;input v-oh-model=&quot;value&quot; type=&quot;text&quot; /&gt;
&lt;/templat ...`,l:"vue-challenge/Directives.html#题目",a:"题目"},"114.18":{t:"答案",p:`

&lt;template&gt;
  &lt;input v-oh-model=&quot;vatltexue&quot; type=&quot;text&quot; /&gt;
&lt;/tem ...`,l:"vue-challenge/Directives.html#答案",a:"答案"},"115.0":{t:"阻止冒泡事件",p:"",l:"vue-challenge/Event Handling.html",a:"阻止冒泡事件"},"115.1":{t:"题目",p:`在这个挑战中，你需要阻止点击事件的冒泡，让我们开始吧。


&lt;template&gt;
  &lt;div @click=&quot;click1()&quot;&gt;
   &lt;div  ...`,l:"vue-challenge/Event Handling.html#题目",a:"题目"},"115.2":{t:"答案",p:`
stop 修饰符



&lt;template&gt;
  &lt;div @click=&quot;click1&quot;&gt;
    &lt;div @click.stop=&quot; ...`,l:"vue-challenge/Event Handling.html#答案",a:"答案"},"115.3":{t:"按键修饰符",p:"",l:"vue-challenge/Event Handling.html#按键修饰符",a:"按键修饰符"},"115.4":{t:"题目",p:"在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许为 v-on 或者 @ 在监听键盘事件时添加按键修饰符：，例如：\n&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.su ...",l:"vue-challenge/Event Handling.html#题目",a:"题目"},"115.5":{t:"答案",p:`&lt;template&gt;
  &lt;!-- 添加按键修饰符让即使 Alt 或 Shift 被一同按下时也会触发 --&gt;
  &lt;button @click.alt.shift=&q ...`,l:"vue-challenge/Event Handling.html#答案",a:"答案"},"116.0":{t:"下一次 DOM 更新",p:"",l:"vue-challenge/Global APT General.html",a:"下一次-dom-更新"},"116.1":{t:"题目",p:`

&lt;template&gt;
  &lt;button id=&quot;counter&quot; @click=&quot;increment&quot;&gt;
    {{ count ...`,l:"vue-challenge/Global APT General.html#题目",a:"题目"},"116.2":{t:"答案",p:`

&lt;template&gt;
  &lt;button id=&quot;counter&quot; @click=&quot;increment&quot;&gt;
    {{ count ...`,l:"vue-challenge/Global APT General.html#答案",a:"答案"},"117.0":{t:"生命周期钩子",p:"",l:"vue-challenge/LifeCycle.html",a:"生命周期钩子"},"117.1":{t:"题目",p:`// Child.vue



&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      Child Component: {{ count }}
     ...`,l:"vue-challenge/LifeCycle.html#题目",a:"题目"},"117.2":{t:"答案",p:`// Child.vue



&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;Child Component: {{ count }}&lt;/p&gt;
  ...`,l:"vue-challenge/LifeCycle.html#答案",a:"答案"},"118.0":{t:"原始值 API",p:"",l:"vue-challenge/Reactivity Advanced.html",a:"原始值-api"},"118.1":{t:"题目",p:`在这个挑战中，你将使用 响应式 API: [xx]Raw 来完成它。 以下是你要实现的内容 👇:


&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
    ...`,l:"vue-challenge/Reactivity Advanced.html#题目",a:"题目"},"118.2":{t:"答案",p:`

&lt;template&gt;
  &lt;div&gt;
    &lt;p&gt;
      {{ reactiveState.count }}
    &lt;/p&gt;
  &lt; ...`,l:"vue-challenge/Reactivity Advanced.html#答案",a:"答案"},"118.3":{t:"解释",p:`toRaw(reactiveObj):根据一个 Vue 创建的代理返回其原始对象
`,l:"vue-challenge/Reactivity Advanced.html#解释",a:"解释"},"119.0":{t:"Until",p:"",l:"vue-challenge/Unility Function.html",a:"until"},"119.1":{t:"题目",p:`有些时候，我们需要依赖于异步的返回结果做一些后续处理，until函数在这种场景下非常有用，你能实现它吗 ? 让我们来试试吧 👇:


`,l:"vue-challenge/Unility Function.html#题目",a:"题目"},"119.2":{t:"答案",p:`

&lt;template&gt;
  &lt;p @click=&quot;increase&quot;&gt;Increase&lt;/p&gt;
&lt;/template&gt;


`,l:"vue-challenge/Unility Function.html#答案",a:"答案"},"120.0":{t:"自定义元素",p:"",l:"vue-challenge/Web Component.html",a:"自定义元素"},"120.1":{t:"题目",p:`

&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;/template&gt;

`,l:"vue-challenge/Web Component.html#题目",a:"题目"},"121.0":{t:"1. Options API 和 Composition API",p:`
Vue2 的API设计是Option(配置)风格的。
Vue3 的API设计是Composition(组合)风格的。

`,l:"vue教程/Vue3核心语法/setup语法糖.html",a:"_1-options-api-和-composition-api"},"121.1":{t:"Options API 的弊端",p:"Options类型的API，数据、方法、计算属性等，是分散在：data、methods、computed中的，若想新增或者修改一个需求，就需要分别修改data、methods、computed，不便于 ...",l:"vue教程/Vue3核心语法/setup语法糖.html#options-api-的弊端",a:"options-api-的弊端"},"121.2":{t:"2.拉开序幕的 setup",p:"",l:"vue教程/Vue3核心语法/setup语法糖.html#_2-拉开序幕的-setup",a:"_2-拉开序幕的-setup"},"121.3":{t:"setup 概述",p:"setup 是 Vue3 中一个新的配置项 ，值是一个函数，它是 Composition API &quot;表演的舞台&quot;，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在 se ...",l:"vue教程/Vue3核心语法/setup语法糖.html#setup-概述",a:"setup-概述"},"121.4":{t:"3. 【ref 创建：基本类型的响应式数据】",p:`
**作用：**定义响应式变量。
语法：let xxx = ref(初始值)。
**返回值：**一个RefImpl的实例对象，简称ref对象或ref，ref对象的value属性是响应式的。
注意点：
 ...`,l:"vue教程/Vue3核心语法/setup语法糖.html#_3-【ref-创建-基本类型的响应式数据】",a:"_3-【ref-创建-基本类型的响应式数据】"},"121.5":{t:"4. 【reactive 创建：对象类型的响应式数据】",p:`
作用：定义一个响应式对象（基本类型不要用它，要用ref，否则报错）
语法：let 响应式对象= reactive(源对象)。
**返回值：**一个Proxy的实例对象，简称：响应式对象。
注意点：r ...`,l:"vue教程/Vue3核心语法/setup语法糖.html#_4-【reactive-创建-对象类型的响应式数据】",a:"_4-【reactive-创建-对象类型的响应式数据】"},"121.6":{t:"5. 【ref 创建：对象类型的响应式数据】",p:`
其实ref接收的数据可以是：基本类型、对象类型。
若ref接收的是对象类型，内部其实也是调用了reactive函数。

`,l:"vue教程/Vue3核心语法/setup语法糖.html#_5-【ref-创建-对象类型的响应式数据】",a:"_5-【ref-创建-对象类型的响应式数据】"},"121.7":{t:"6. 【ref 对比 reactive】",p:`宏观角度看：



ref用来定义：基本类型数据、对象类型数据；


reactive用来定义：对象类型数据。




区别：




ref创建的变量必须使用.value（可以使用volar插件自动 ...`,l:"vue教程/Vue3核心语法/setup语法糖.html#_6-【ref-对比-reactive】",a:"_6-【ref-对比-reactive】"},"121.8":{t:"7. 【toRefs 与 toRef】",p:`

作用：将一个响应式对象中的每一个属性，转换为ref对象。


备注：toRefs与toRef功能一致，但toRefs可以批量转换。


语法如下：
&lt;template&gt;
  &lt;d ...`,l:"vue教程/Vue3核心语法/setup语法糖.html#_7-【torefs-与-toref】",a:"_7-【torefs-与-toref】"},"122.0":{t:"目录",p:`
核心语法

setup语法糖



`,l:"vue教程/index.html",a:"目录"}},n={previewLength:100,buttonLabel:"搜索",placeholder:"请输入关键词",allow:[],ignore:[]},r={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:n};export{r as default};
