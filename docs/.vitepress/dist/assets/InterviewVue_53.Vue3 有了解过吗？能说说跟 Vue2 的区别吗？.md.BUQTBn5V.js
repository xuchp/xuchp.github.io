import{_ as e,c as _,o as t,a7 as i}from"./chunks/framework.BvW0rtPM.js";const f=JSON.parse('{"title":"53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？.md","filePath":"InterviewVue/53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？.md"}'),u={name:"InterviewVue/53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？.md"},a=i('<h1 id="_53-vue3-有了解过吗-能说说跟-vue2-的区别吗" tabindex="-1">53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？ <a class="header-anchor" href="#_53-vue3-有了解过吗-能说说跟-vue2-的区别吗" aria-label="Permalink to &quot;53.Vue3 有了解过吗？能说说跟 Vue2 的区别吗？&quot;">​</a></h1><ul><li>Vue3.0 更注重模块上的拆分，在 2.0 中无法单独使用的模块，需要引入完整的 Vuejs(例如只想使用响应式部分，但是需要引入完整的 Vuejs)，Vue3 中的模块之间耦合度低，模块可以独立使用，拆分模块</li><li>Vue2 中很多方法挂遭到了实例中导致没有使用也会被打包(还有很多组件也是一样)。通过构建工具 Tree-shaking 机制实现按需引入，减少用户打包后的体积。重写 API</li><li>Vue3 允许自定义渲染器，扩展能力强，不会发生以前的事情，改写 Vue 源码改造渲染方式，扩展更方便</li><li>在 Vue2 的时候使用 defineProperty 来进行数据的劫持，需要对属性进行重写添加 getter 及 setter 的性能差</li><li>当新增属性和删除属性时无法监控变化。需要通过 $set、$delete 实现</li><li>数组不采用 defineProperty 来进行劫持(浪费性能，对所有索引进行劫持会造成性能浪费)需要对数组单独进行处理</li><li>Diff 算法也进行了重写</li><li>Vue3 模块编译优化，采用 parchFlags 优化动态节点，采用 BlockTree 进行靶向更新等</li><li>相比 Vue2 来说 Vue3 新增了很多新的特性</li></ul>',2),l=[a];function r(V,o,s,n,c,d){return t(),_("div",null,l)}const h=e(u,[["render",r]]);export{f as __pageData,h as default};
