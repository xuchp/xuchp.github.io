import{_ as e,c as i,o as a,a7 as t}from"./chunks/framework.DIkKG9z6.js";const h=JSON.parse('{"title":"19. Vue 中 diff 算法原理","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/19.Vue中diff算法原理.md","filePath":"InterviewVue/19.Vue中diff算法原理.md"}'),f={name:"InterviewVue/19.Vue中diff算法原理.md"},l=t('<h1 id="_19-vue-中-diff-算法原理" tabindex="-1">19. Vue 中 diff 算法原理 <a class="header-anchor" href="#_19-vue-中-diff-算法原理" aria-label="Permalink to &quot;19. Vue 中 diff 算法原理&quot;">​</a></h1><h3 id="_1-1-diff-概念" tabindex="-1">1.1 Diff 概念 <a class="header-anchor" href="#_1-1-diff-概念" aria-label="Permalink to &quot;1.1 Diff 概念&quot;">​</a></h3><p>vue 基于虚拟 DOM 做更新。diff 的核心就比较两个虚拟节点的差异。Vue 的 diff 算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式 + 双指针的方式进行比较。</p><h3 id="_1-2-diff-比较流程" tabindex="-1">1.2 Diff 比较流程 <a class="header-anchor" href="#_1-2-diff-比较流程" aria-label="Permalink to &quot;1.2 Diff 比较流程&quot;">​</a></h3><ol><li>先比较是否是相同节点 key tag</li><li>相同节点比较属性，并复用老节点(将老的虚拟 DOM 复用给新的虚拟节点 DOM)</li><li>比较儿子节点，考虑老节点和新节点儿子的情况 <ol><li>老的没儿子，现在有儿子。直接插入新的儿子</li><li>老的有儿子，新的没儿子。直接删除页面节点</li><li>老的儿子是文本，新的文字是文本。直接更新文本节点即可</li><li>老的儿子是一个列表，新的儿子也是一个列表。<code>updateChildren</code></li></ol></li><li>列表优化比较：头头、尾尾、头尾、尾头</li><li>比对查找进行复用</li></ol><blockquote><p>Vue3 中采用最长递增子序列来实现 diff 优化</p></blockquote><p><img src="https://gitee.com/xuchp/typora-pics/raw/master/images/image-20240314160716656.png" alt="image-20240314160716656"></p><p><img src="https://gitee.com/xuchp/typora-pics/raw/master/images/image-20240314160803893.png" alt="image-20240314160803893"></p>',8),o=[l];function r(d,_,c,s,n,u){return a(),i("div",null,o)}const m=e(f,[["render",r]]);export{h as __pageData,m as default};
