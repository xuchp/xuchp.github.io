import{_ as e,c as t,o as a,a7 as r}from"./chunks/framework.DIkKG9z6.js";const m=JSON.parse('{"title":"15. new Vue()这个过程中究竟做了什么","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/15.new Vue()这个过程中究竟做了什么.md","filePath":"InterviewVue/15.new Vue()这个过程中究竟做了什么.md"}'),_={name:"InterviewVue/15.new Vue()这个过程中究竟做了什么.md"},n=r('<h1 id="_15-new-vue-这个过程中究竟做了什么" tabindex="-1">15. new Vue()这个过程中究竟做了什么 <a class="header-anchor" href="#_15-new-vue-这个过程中究竟做了什么" aria-label="Permalink to &quot;15. new Vue()这个过程中究竟做了什么&quot;">​</a></h1><ul><li>在 new Vue 的时候，内部会进行初始化操作</li><li>内部会初始化组件绑定的事件，初始化组件的父子关系$parent $children $root</li><li>初始化响应式数据 data、computed、watch、method。同时也初始化了 provide 和 inject 方法。内哦不会对数据进行劫持。对象采用 defineProperty，数组采用方法重写</li><li>再看一下用户是否传入了 el 属性和 template 或者 render。render 优先级更高，如果用户写的是 template，会做模板编译(三部曲)，最终就拿到了 render 函数</li><li>内部挂在的时候会产生一个 watcher，会调用 render 函数会触发依赖收集。内部还会给所有的响应式数据增加 <code>dep</code> 属性，让属性记录自己当前的 watcher(用户后续的修改可以触发 watcher 重新渲染)</li><li>vue 更新的时候采用虚拟 DOM 的方式进行 diff 算法更新</li></ul><p><img src="https://gitee.com/xuchp/typora-pics/raw/master/images/lifecycle.png" alt="Vue 实例生命周期"></p>',3),i=[n];function c(o,l,d,s,u,p){return a(),t("div",null,i)}const w=e(_,[["render",c]]);export{m as __pageData,w as default};
