import{_ as t,c as e,o as a,a7 as d}from"./chunks/framework.DIkKG9z6.js";const p=JSON.parse('{"title":"2. 谈谈你对 SPA 的理解","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/02.谈谈你对spa的理解.md","filePath":"InterviewVue/02.谈谈你对spa的理解.md"}'),o={name:"InterviewVue/02.谈谈你对spa的理解.md"},r=d('<h1 id="_2-谈谈你对-spa-的理解" tabindex="-1">2. 谈谈你对 SPA 的理解 <a class="header-anchor" href="#_2-谈谈你对-spa-的理解" aria-label="Permalink to &quot;2. 谈谈你对 SPA 的理解&quot;">​</a></h1><h3 id="_1-1-理解基本概念" tabindex="-1">1.1 理解基本概念 <a class="header-anchor" href="#_1-1-理解基本概念" aria-label="Permalink to &quot;1.1 理解基本概念&quot;">​</a></h3><ul><li>SPA(Single Page Application)单页应用，默认情况下我们编写 Vue、React 都只有一个 html 页面，并且提供一个挂载点，最终打包后会在此页面中引入对应的资源。(页面的渲染全部是由 JS 动态进行渲染的)。切换页面时通过监听路由变化，渲染对应的页面<strong>Client Side Rendering，客户端渲染 CSR</strong></li><li>MPA(Multi Page Application)多页引用，多个 html 页面。每个页面必须重新加载js、css等相关资源。(服务端返回完整的 html，同时数据也可以在后端进行获取一并返回&quot;模板引擎&quot;)。多页应用跳转需要整页资源刷新。<strong>Server Side Rendering，服务端渲染 SSR</strong></li></ul><blockquote><p>如何分清在哪渲染：HTML 是在前端动态生成的&quot;客户端渲染&quot;，在服务端处理好并返回的是&quot;服务端渲染&quot;。</p></blockquote><h3 id="_1-2-优缺点" tabindex="-1">1.2 优缺点 <a class="header-anchor" href="#_1-2-优缺点" aria-label="Permalink to &quot;1.2 优缺点&quot;">​</a></h3><table><thead><tr><th></th><th>单页面应用 SPA</th><th>多页面应用 MPA</th></tr></thead><tbody><tr><td>组成</td><td>一个主页面和页面组件</td><td>多个完整的页面</td></tr><tr><td>刷新方式</td><td>局部刷新</td><td>整页刷新</td></tr><tr><td>SEO 搜索引擎优化</td><td>无法实现</td><td>容易实现</td></tr><tr><td>页面切换</td><td>速度快，用户体验良好</td><td>切换加载资源，速度慢，用户体验差</td></tr><tr><td>维护成本</td><td>相对容易</td><td>相对复杂</td></tr></tbody></table><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，服务器压力小</li><li>SPA 应用不利于搜索引擎的抓取</li><li>首次渲染速度相对较慢(第一次返回空的 html，需要再次请求首屏数据)白屏时间长。</li></ul><h3 id="_1-3-解决方案" tabindex="-1">1.3 解决方案 <a class="header-anchor" href="#_1-3-解决方案" aria-label="Permalink to &quot;1.3 解决方案&quot;">​</a></h3><ul><li>静态页面预渲染(Static Site Generation)SSG，在构建时生成完整的 html 页面。(就是在打包的时候，先将页面放到浏览器中运行一下，将 HTML 保存起来)，仅适合静态页面网站。变化率不高的网站</li><li><code>SSR</code>+<code>CSR</code>的方式，首屏采用服务端渲染的方式，后续交互采用客户端渲染的方式。<code>NuxtJs</code></li></ul>',9),i=[r];function l(n,_,s,c,h,u){return a(),e("div",null,i)}const m=t(o,[["render",l]]);export{p as __pageData,m as default};
