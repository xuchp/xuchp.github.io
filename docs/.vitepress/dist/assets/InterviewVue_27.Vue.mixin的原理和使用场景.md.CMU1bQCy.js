import{_ as e,c as i,o as t,a7 as a}from"./chunks/framework.BvW0rtPM.js";const x=JSON.parse('{"title":"27. Vue.mixin的使用场景和原理","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewVue/27.Vue.mixin的原理和使用场景.md","filePath":"InterviewVue/27.Vue.mixin的原理和使用场景.md"}'),n={name:"InterviewVue/27.Vue.mixin的原理和使用场景.md"},o=a('<h1 id="_27-vue-mixin的使用场景和原理" tabindex="-1">27. Vue.mixin的使用场景和原理 <a class="header-anchor" href="#_27-vue-mixin的使用场景和原理" aria-label="Permalink to &quot;27. Vue.mixin的使用场景和原理&quot;">​</a></h1><h3 id="_1-1-vue-mixin-概念" tabindex="-1">1.1 Vue.mixin 概念 <a class="header-anchor" href="#_1-1-vue-mixin-概念" aria-label="Permalink to &quot;1.1 Vue.mixin 概念&quot;">​</a></h3><p>mixin可以用来扩展组件，将公共逻辑进行抽离。在需要该逻辑时进行“混入”，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件中的数据冲突，会采用“就近原则”以组件的数据为准、</p><blockquote><p>mixin有很多缺陷“命名冲突问题”、“数据来源问题”，Vue3 采用 <code>CompisitionAPI</code> 提取公共逻辑非常方便。</p></blockquote><h3 id="_1-2-混入方式" tabindex="-1">1.2 混入方式 <a class="header-anchor" href="#_1-2-混入方式" aria-label="Permalink to &quot;1.2 混入方式&quot;">​</a></h3><p>在Vue中我们可以<strong>局部混入</strong>跟<strong>全局混入</strong>。一般情况下全局混入用于编写组件。局部混入用于复用逻辑。</p><h3 id="_1-3-mixin合并策略" tabindex="-1">1.3 mixin合并策略 <a class="header-anchor" href="#_1-3-mixin合并策略" aria-label="Permalink to &quot;1.3 mixin合并策略&quot;">​</a></h3><p>核心就是：对象的合并处理</p><ul><li>props、methods、inject、computed同名时会被替换</li><li>data会被合并</li><li>生命周期和watch方法会被合并成队列</li><li>components、directives、filters会在原型链上叠加</li></ul><blockquote><p>组件的扩展除了mixin之外，还有一个属性叫做<code>extends</code>，但是不怎么常用。</p></blockquote>',10),r=[o];function _(c,l,s,u,m,d){return t(),i("div",null,r)}const p=e(n,[["render",_]]);export{x as __pageData,p as default};
