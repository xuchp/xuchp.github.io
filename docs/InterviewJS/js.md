# 语言基础

### 语法

##### 区分大小写

ECMAScript 中一切都是区分大小写的。无论是变量、函数名还是操作符，都区分大小写。换句话说。变量 `test` 和变量 `Test` 是两个不同的变量。类似地，`typeof` 不能作为函数名，因为它是一个关键字，但是 `Typeof` 是一个完全有效的函数名。

##### 标识符

所谓标识符，就是变量、函数、属性或者函数参数的名称。标识符可以由一个或多个下列字符组成：

第一个字符必须是一个**字母、下划线(\_)或美元符号($)**；

剩下的其他字符可以是**字母、下划线、美元符号或数字**；

**关键字、保留字、true、false 和 null**不能作为标识符。

##### 注释

ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。

单行注释以两个斜杠字符`(//)`开头，如

```js
// 单行注释
```

块注释以一个斜杠和一个星号`(/*)`开头，以它们的反向组合`(*/)`结尾。如

```js
/*
这是多行注释
*/
```

##### 严格模式

`ECMAScript 5` 新增了严格模式的概念。严格模式是一种不同的 JavaScript 解析和执行模型，`ECMAScript 3` 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本使用严格模式，在脚本的开头加上这一行

```js
'use strict'
```

虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令，任何支持的 `JavaScript` 引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏 `ECMAScript 3` 语法。

也可以单独指定一个函数在严格模式下执行，只要把这个预处理命令放到函数头的开头即可：

```js
function doSomething() {
  'use strict'
  // 函数体
}
```

### 关键字和保留字

#### 关键字

```bash
break 	do		in		typeof		case		else		instanceof
var		catch		export		new		void		class		extends
return		while		const		finally		super		with		try
continue			for		switch		yield		debugger	 import
function		this		default	if		throw		delete

```

#### 保留字

ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束， 或者执行特定的操作。按照规定，保留的关键字不能用作标识符或属性名。

##### 始终保留

```
enum
```

##### 严格模式下保留

```
implements		interface		let		package		protected
private		public		static
```

##### 模块代码中保留

```
await
```

### 变量

ECMAScript 中有 3 个关键字可以声明变量：`var`、`const` 和`let`。其中`var`在 ECMAScript 的所有版本中都可以使用，而`const`和`let`只能在 ECMAScript 6 及更晚的版本中使用。

#### var 关键字

要定义变量，可以使用 `var` 操作符（注意`var`是一个关键字），后跟变量名（即标识符）

```js
var message
var message = 'hi'
message = 'hi' // 合法，但不推荐
```

不初始化的情况下，变量会保存一个特殊值`undefined`

##### var 声明作用域

使用`var`操作符定义的变量会成为包含它的函数的局部变量。比如，使用`var`在一个函数内部定义了一个变量，就意味着该变量将在函数退出时被销毁

```js
function test() {
  var message = 'hi' // 局部变量
}
test()
console.log(message) // 出错 Uncaught ReferenceError: message is not defined
```

这里，`message`变量是在函数内部使用 `var`定义的。函数叫 `test()`，调用它会创建这个变量并给它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省去`var`操作符，可以创建一个全局变量：

```
function test () {
    message = 'hi' // 没有 var，会被挂载到 window 上，变成全局变量
}
test()
console.log(message);// "hi"
```

去掉之前的`var`操作符后，message 就变成了全局变量。只要调用了一次函数`test()`，就会定义这个变量，并且可以在函数外部访问到。

> 虽然可以通过省略`var`操作符定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量基恩男维护，也会造成困惑。这是因为不能一下子断定省略`var`是不是有意为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出`ReferenceError`

如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）。

```js
var message = 'hi',
  found = false,
  age = 29
```

在严格模式下，不能定义名为`eval`和`arguments`的变量，否则会导致语法错误

##### var 声明提升

使用`var`时，下面的代码不会报错。这是因为使用了这个关键字声明的变量会自动提升到函数的作用域顶部：

```js
function foo() {
  console.log(age)
  var age = 26
}
foo() // undefined
```

之所以不会报错，是因为`ECMAScript`运行时把它看成等价于如下代码

```js
function foo() {
  var age
  console.log(age)
  age = 26
}
foo()
```

这个就是所谓的提升（`hoist`） ，也就是把所有变量声明都拉到函数作用域的顶部。此外反复多次使用 `var`声明同一个变量也没有问题。

```js
function foo() {
  var age = 16
  var age = 26
  var age = 36
  console.log(age)
}
foo()
```

#### let 声明

`let`和`var`的作用差不多，但是有着非常重要的区别。最明显的区别就是，`let`声明的范围是块作用域，而`var`声明的范围是函数作用域。

```js
if (true) {
  var name = 'Matt'
  console.log(name) // "Matt"
}
console.log(name) // "Matt"

if (true) {
  let age = 26
  console.log(age) // 26
}
console.log(age) // ReferenceError: age 没有定义
```

在这里，age 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该块内部。快作用域是函数作用域的子集，因此使用与`var`的作用域限制也适用于`let`。

`let`不允许同一个块作用域中出现冗余声明。这样会导致报错

```js
let age
let age // SyntaxError: 标识符已经声明过了
```

##### 1. 暂时性死区

`let`与`var`的另一个重要区别，就是`let`声明的变量不会在作用域中被提升。

```js
// name 会被提升
console.log(name) // undefined
var name = 'Matt'
// age 不会被提升
console.log(age) // Uncaught ReferenceError: Cannot access 'age' before initialization
let age = 26
```

在`let`声明之前的执行瞬间被称为"暂时性死区"(temporal dead zone)，在此阶段引用任何后面才声明的变量都会抛出 `ReferenceError`

##### 2. 全局声明

与`var`关键字不同，使用 `let`在全局作用域中声明的变量不会成为 `window` 对象的属性(`var` 声明的变量则会)

```js
var name = 'Matt'
console.log(window.name) // 'Matt'

let age = 26
console.log(window.age) // undefined
```

##### 3. 条件声明

因为 `let`是块级作用域，所以不可能检查前面是否声明过同名变量，同时也就不可能在没有声明的情况下去声明它，因此不能依赖条件声明模式

##### for 循环中的 let

在`let`出现之前，`for`循环定义的迭代变量会渗透到循环体外部。改用`let`之后，这个问题就消失了，因为迭代变量的作用域仅限于 `for` 循环块内部

```js
for (var i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// 5 5 5 5 5

for (let i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// 0 1 2 3 4
```

#### const 声明

`const`的行为与`let`基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 `const` 声明的变量会导致运行时错误

```js
const age = 26
age = 36 // TypeError: 给常量赋值

// const 也不允许重复声明
const name = 'Matt'
const name = 'Nicholas' // SyntaxError
// const 声明的作用域也是块 const name = 'Matt';
if (true) {
  const name = 'Nicholas'
}
console.log(name) // Matt
```

`const`声明的限制只适用于它指向的变量的引用。换句话说，如果`const`变量引用的是一个对象，那么修改对象内部的属性并不违反 `const` 的限制

```js
const person = {}
person.name = 'Matt' // ok
```

`for` 循环中，不能用 `const` 声明迭代变量（迭代变量会自增），但是可以用在`for-in`和`for-of `中，因为每次迭代只是创建一个新的变量。

#### 声明风格及最佳实践

1. 不使用 var
2. const 优先，let 次之

### 数据类型

**ECMAScript 有两大数据类型**

基本数据类型(原始数据类型)：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`

复杂数据类型：`Object`

##### typeof 操作符

因为 ECMAScript 的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof 操作符就是为此而生的。对一个值使用 typeof 会返回下列字符串之一：

1. "undefined"表示值未定义；
2. "boolean"表示值为布尔值；
3. "string"表示值为字符串；
4. "number"表示值为数值
5. "object"表示值为对象（而不是函数）或 null
6. "function"表示值为函数
7. "symbol"表示值为符号

##### Undefined 类型

`Undefined` 类型只有一个值，就是特殊值`undefined`。当 `var`或`let`声明了变量但没有初始化时，就相当于给变量赋予了`undefined`值

**注意**：包含 `undefined`值的变量跟未定义变量是有区别的

```js
let message // 这个变量被声明了，只是值为undefined
console.log(message) // "undefined"

console.log(age) // Uncaught ReferenceError: age is not defined
```

对未声明的变量，只能执行一个有用的操作，就是对它调用`typeof`。（对未声明的变量调用 delete 也不会报错，但是这个操作没什么用，实际上在严格模式下会抛出错误）

```js
let message // 这个变量被声明了，只是值为undefined
console.log(typeof message) // "undefined"

console.log(typeof age) // "undefined"
```

##### Null 类型

`Null`类型同样只有一个值，即特殊值`null`。逻辑上讲，`null`值表示一个空对象指针，这也是给 `typeof`传一个`null`会返回`"object"`的原因。

在定义一个将来要保存对象值的变量时，建议使用`null`来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 `null` 就可以知道这个变量是否在后面被重新赋予了一个对象的引用，比如

```js
if (car !== null) {
  // car 是一个对象的引用
}
```

`undefined`值是由`null`派生而来的，因此在 ECMA-262 将他们定义为表面上相等，如

```js
console.log(undefined == null) // true
```

用等于操作符(`==`)比较`null`和`undefined`始终返回`true`。但要注意，这个操作符会为了比较而转换它的操作数。

##### Boolean 类型

`Boolean`类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值：`true`和`false`。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。

**注意**：布尔值字面量 true`和`false` 是区分大小写的，因此`True`和`False`（及其他大小混写形式）是有效的标识符，但不是布尔值。

###### 布尔值和不同类型之间的转换规则

| 数据类型  | 转换为 true 的值       | 转换为 false 的值 |
| --------- | ---------------------- | ----------------- |
| Boolean   | true                   | false             |
| String    | 非空字符串             | ""(空字符串)      |
| Number    | 非零数值（包括无穷值） | 0、NaN            |
| Object    | 任意对象               | Null              |
| Undefined | N/A（不存在）          | undefined         |

##### Number 类型

`Number`类型使用 `IEEE 754`格式表示正式和浮点数(在某些语言中也叫双精度值)、不同的数值类型相应地也有不同的数值字面量格式。

###### 数值字面量格式

**十进制：** 直接写出来即可

**八进制：** 对于八进制字面量，第一个数字必须是零(0)，然后是相应的八进制数字(0-7)。如果字面量中包含的数字超出了应有的范围，就回忽略前缀的 0，后面的数字被当做十进制

**十六进制：** 要创建十六进制字面量，必须让真正的数值前缀 0x(区分大小写)，然后是十六进制数字(0~9 以及 A~F)。十六进制数字中的字母大小写均可。

###### 浮点值

要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。

```js
let floatNumber1 = 1.1
let floatNumber2 = 0.1
let floatNumber3 = 0.1 // 有效,但不推荐
```

因为存储浮点数值使用的内存空间是存储整数值的两倍，所以 `ECMAScript`总是想方设法把值转换为整数。在小数点后面没有数字或者全是 0 的情况下，就会变成整数。

```js
let floatNum1 = 1 // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0 // 小数点后面是零，当成整数 10 处理
```

对于非常大或者非常小的数值，浮点值可以用科学计数法来表示。科学计数法用于表示一个应该乘以 10 的给定次幂的数值，ECMAScript 中科学计数法的格式要求是一个数值(整数或者浮点数)后跟一个大写或者小写字母 e，再加上一个要乘的 10 的多少次幂

```js
let floatNum1 = 3.125e7 // 等于 31250000
```

`ECMAScript`会将小数点后至少包含 6 个零的浮点值转换为科学计数法

###### 值的范围

`ECMAScript`可以保存的最小数值保存在`Number.MIN_VALUE`中，这个值多数浏览器是`5e-324`，可以保存的最小数值保存在`Number.MAX_VALUE`中，这个值多数浏览器是`1.797 693 134 862 315 7e+308`。如果某个计算得出的值超出这个范围，那么这个数值会被自动转为一个特殊的`Infinity`(无穷)值。任何无法表示的负数以`-Infinity`(负无穷大)表示。任何无法表示的正数以`Infinity`表示。

**注意：** 一旦得到`Infinity`，就不能再进一步用于任何计算。因为`Infinity`没有可用于计算的数值表示形式。

要确定一个值是不是有限大（介于 JavaScript 能表示的最小值和最大值之间），可以使用`isInfinite()`函数：

```js
let result = Number.MAX_VALUE + Number.MAX_VALUE
console.log(isFinite(result)) // false
```

**注意：** 使用`Number.NEGATIVE_INFINITY`和`Number.POSITIVE_INFINITY`也可以获取正、负 `Infinity`。这两个属性包含的值分别就是`-Infinity` 和 `Infinity`。

###### NaN

有一个特殊的值叫`"NaN"`，意思是"不是数值`"(Not a Number)`，用于表示本来要返回数值的操作失败了(而不是抛出错误)。在 ECMAScript 中，0、+0、-0 相除会返回 NaN；分子是非 0 值，分母是有符号或无符号的 0，则会返回 `Infinity` 或者`-Infinity`

```js
console.log(0 / 0) // NaN
console.log(+0 / -0) // NaN

console.log(5 / 0) // Infinity
console.log(5 / -0) // -Infinity
```

**独特属性：**

1. 任何涉及 `NaN` 的操作始终返回 `NaN`，在连续多步计算时这可能是个问题。
1. `NaN`不等于包括`NaN`在内的任何值。

`ECMAScript`提供了`isNaN()`函数。该函数接受一个参数，可以是任意数据类型，然后判断这个参数是否"不是数值"。把一个值传给`isNaN()`后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串 10 或布尔值。任何不能转换为数值的值都会导致这个函数返回 `true`。

```js
console.log(isNaN(NaN)) // true
console.log(isNaN(10)) // false，10 是数值
console.log(isNaN('10')) // false，可以转换为数值10
console.log(isNaN('blue')) // true，不可以转换为数值
console.log(isNaN(true)) // false，可以转换为数值1
```

###### 数值转换

有 3 个函数可以将非数值转换为数值：`Number()`、`parseInt()`、`parseFloat()`。`Number()`是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转化为数值。

`Number()`函数基于如下规则执行转换

- 布尔值，`true` 转换为 1，`false` 转换为 0
- 数值，直接返回
- `null`，返回 0
- `undefined`，返回 `NaN`
- 字符串，应用一下规则
  - 如果字符串包含数值字符，包括数字字符前面带加、减号的情况，则转换为一个十进制数。因此 Number("1")返回 1，Number("011")返回 11（忽略前面的 0）
  - 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样忽略前面的 0)
  - 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。
  - 如果是空字符串(不包含字符)，则返回 0
  - 如果字符串包含出上述情况之外的其他字符，则返回`NaN`
- 对象，调用`valueOf()`方法，并按照上述规则转换返回的值。如果转换结果为`NaN`，则调用`toString()`方法，在按照转换字符串的规则转换。

```js
let num1 = Number('Hello world!') // NaN
let num2 = Number('') // 0
let num3 = Number('000011') // 11
let num4 = Number(true) // 1
```

考虑到`Number()`函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用`parseInt()`函数。`parseInt()`函数更专注于字符串是否包函数值模式。字符串最前面的空格会被忽略，从第一个非空的字符串开始转换。如果第一个字符不是数值字符、加号或减号，`parseInt()`立即返回`NaN`；如果第一个字符是数值字符、加号或者减号，则继续依次检测每一个字符，直到字符串末尾，或碰到非数值字符。

假设字符串中第一个字符是数值字符，`parseInt()`函数也能识别不同的整数格式(十进制、八进制、十六进制)。换句话说，如果字符串以"0x"开头，就会被解释为十六进制；如果字符串以"0"开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制。

```js
let num1 = parseInt('1234blue') // 1234
let num2 = parseInt('') // NaN
let num3 = parseInt('0xA') // 10, 解释为十六进制
let num4 = parseInt(22.5) // 22,
let num5 = parseInt('70') // 70, 解释为十进制
let num6 = parseInt('0xf') // 15, 解释为十六进制
```

`parseInt()`函数还有第二个参数，用于指定底数(进制数)，默认是 10；通过第二个参数，可以极大扩展转换后获得的结果类型。

```js
let num1 = parseInt('AF', 16) // 175
let num2 = parseInt('AF') // NaN
let num3 = parseInt('10', 2) // 2, 按二进制解析
let num4 = parseInt('10', 8) // 8, 按八进制解析
let num5 = parseInt('10', 10) // 10, 按十进制解析
let num6 = parseInt('10', 16) // 16, 按十六进制解析
```

`parseFloat()`函数的工作方式和`parseInt()`函数相似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但是第二次出现的小数点就无效了，此时剩余的字符会被忽略。因此 `22.34.5`将转换为`22.34`。

`parseFloat()`函数的另一个不同之处在于，他始终忽略字符串开头的零。这个函数能识别前面讨论的所有的浮点格式，以及十进制格式(开头的 0 始终被忽略)。十六进制数值最终会返回 0。因为 `parseFloat()`只解析十进制值，因此不能指定底数(进制数)。最后，如果字符串表示整数(没有小数点或者小数点后面全是 0)，则`parseFloat()`返回整数

```js
let num1 = parseFloat('1234blue') // 1234
let num2 = parseFloat('0xA') // 10
let num3 = parseFloat('22.00') // 22
let num4 = parseFloat('22.34.5') // 22.34
let num5 = parseFloat('0908.5') // 908.5
let num6 = parseFloat('3.125e7') // 31250000
```

##### String 类型

String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(")、单引号(')或反引号(`)标示。必须成对出现，否则会导致语法错误。

###### 字符字面量

字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符

| 字面量 | 含义                                                                                   |
| ------ | -------------------------------------------------------------------------------------- |
| \n     | 换行                                                                                   |
| \t     | 制表                                                                                   |
| \b     | 退格                                                                                   |
| \r     | 回车                                                                                   |
| \f     | 换页                                                                                   |
| \\\    | 反斜杠(\)                                                                              |
| \\'    | 单引号(')，在字符串以单引号标记时使用，例如'He said,\\'hey.\ \' '                      |
| \\"    | 单引号(")，在字符串以单引号标记时使用，例如"He said,\\"hey.\ \" "                      |
| \\`    | 单引号(`)，在字符串以单引号标记时使用，例如                                            |
| \xnn   | 以十六进制编码 nn 表示的字符(其中 n 是十六进制的 0-f)，例如"\x41" 等于"A"              |
| \unnn  | 以十六进制编码 nnnn 表示的字符(其中 n 是十六进制的 0-f)，例如"\x03a3" 表示希腊字符"￡" |

###### 字符串的特点

字符串是不可变的，意思就是一旦创建，他们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。

###### 转换为字符串

有两种方式将一个值转换为字符串。一个是`toString()`，一个是直接在后面加空串`""`

数值调用`toString()`时，可以传入一个参数作为底数，默认情况下返回的是十进制

###### 模板字面量

`ECMAScript 6`新增了模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以夸行定义字符串。

```js
let str = `first line
second line`
```

###### 字符串插值

模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个 值。技术上讲，模板字面量不是字符串，而是一种特殊的 `JavaScript` 句法表达式，只不过求值后得到的 是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。

字符串插值通过在${}中使用一个 JavaScript 表达式实现:

```js
let title = 'aaa'
let subtitle = 'bbbb'
let header = `${title}  ${subtitle}`
```

###### 模板字面量标签函数

模板字面量也支持定义标签函数(tag function)，而通过标签函数可以自定义插值行为。标签函数 会接收被插值记号分隔后的模板和对每个表达式求值的结果。

标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数 接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求 值得到的字符串

###### 原始字符串

使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数:

##### Symbol 类型

`Symbol`(符号)是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的风险。

###### 符号的基本使用

符号需要使用`Symbol()`函数初始化，因为符号本身是基本类型，所以`typeof`操作符对符号返回`symbol`

```js
let symbol = Symbol()
```

**注意：** `Symbol()`函数不能与 new 关键字一起作为构造函数使用，这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原 始值的包装对象:

```js
let mySymbol = new Symbol() // TypeError: Symbol is not a constructor
```

如果你确实想使用符号包装对象，可以借用 Object()函数:

```js
let mySymbol = Symbol()
let myWrappedSymbol = Object(mySymbol)
console.log(typeof myWrappedSymbol) // "object"
```

###### 使用全局符号注册表

如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。

Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。

```js
let fooGlobalSymbol = Symbol.for('foo') // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo') // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol) // true
```

全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转化成字符串。

还可以使用 Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字 符串键。如果查询的不是全局符号，则返回 `undefined`。

```js
// 创建全局符号
let s = Symbol.for('foo')
console.log(Symbol.keyFor(s)) // foo

// 创建普通符号
let s2 = Symbol('bar')
console.log(Symbol.keyFor(s2)) // undefined
```

###### 使用符号作为属性

凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 `Object.defineProperty()`/`Object.defineProperties()`定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。

###### 常用内置符号

ECMAScript 6 也引入了一批常用内置符号(well-known symbol)，用于暴露语言内部行为，开发者 可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。

这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道`for-of` 循环会在相关对象上使用 `Symbol.iterator` 属性，那么就可以通过在自定义对象上重新定义`Symbol.iterator` 的值，来改变 `for-of` 在迭代该对象时的行为。

这些内置符号也没有什么特别之处，它们就是全局函数 `Symbol` 的普通字符串属性，指向一个符号 的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。

###### Symbol.asyncIterator

###### Symbol.hasInstance

###### Symbol.isConcatSpreadable

###### Symbol.iterator

###### Symbol.match

###### Symbol.replace

###### Symbol.search

###### Symbol.species

###### Symbol.split

###### Symbol.toPrimitive

###### Symbol.toStringTag

###### Symbol.unscopables

80 页

##### Object 类型

每个 Object 实例都有如下属性和方法：

1. `constructor`：用于创建当前对象的函数。
2. `hasOwnProperty(propertyName)`：用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串或者符号
3. isPropertyOf(Object)：用于判断当前对象是否为另一个对象的原型。
4. `propertyIsEnumerable(propertyName)`：用于判断给定属性是否可用 `for-in` 语句枚举，属性名必须是字符串
5. `toLocalString()`：返回对象的字符串表示，该字符串反应对象所在的本地化执行环境。
6. `toString()`：返回对象的字符串表示。
7. `valueOf()`：返回对象对应的字符串、数值或布尔值表示。通常与 `toString()`的返回值相同。

### 操作符

##### 一元操作符

只操作一个值的操作符叫一元操作符(`unary operator`)。一元操作符是 `ECMAScript` 中最简单的操作符。

###### 递增/递减操作符

递增和递减操作符有两个版本：前缀版和后缀版。

两个版本的区别是后缀版的递增和递减在语句被求值后才发生。

这 2 对操作符可以用作于任何值，意思就是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则

1. 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。
2. 对于字符串，如果不是有效的数值形式，则将变量值设置为 `NaN`。变量类型从字符串变为数值。
3. 对于布尔值，如果是 `false`，则转换成 0 再应用改变。变量类型从布尔值变成数值。
4. 对于布尔值，如果是 `true`，则转换成 1 再应用改变。变量类型从布尔值变成数值。
5. 对于浮点数，加 1 或减 1
6. 如果是对象，则调用其`valueOf()`方法取得可以操作的值。对得到的值应用上述规则。如果是 `NaN`，则调用 `toString()`并再次应用其他规则。变量类型从对象变成数值。

###### 一元加和减

一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。一元加由一个加号(+)表示，放在变量前头，对数值没有任何影响。

一元减由一个减号(-)表示，放在变量前头，主要用于把数值变成负值，如把 1 转换为-1。

##### 位操作符

正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。第一位(称为第 0 位)表示 20，第二位表示 21，依此类推。

负值以一种称为二补数(或补码)的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算 得到:

    1. 确定绝对值的二进制表示(如，对于18，先确定 18 的二进制表示);
    1. 找到数值的一补数(或反码)，换句话说，就是每个 0 都变成 1，每个 1 都变成 0;
    1.  给结果加 1

**注意：** 在位操作中，特殊值`NaN`和`Infinity`会被当成 0 处理。

###### 按位非

按位非操作符用波浪符(`~`)表示，它的作用是返回数值的一补数。

```js
let num1 = 25 // 二进制00000000000000000000000000011001
let num2 = ~num1 // 二进制11111111111111111111111111100110 console.log(num2); // -26
```

###### 按位与

按位与操作符用和号(`&`)表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作。

| 第一个数值的位 | 第二个数值的位 | 结果 |
| :------------: | :------------: | :--: |
|       1        |                |  1   |
|       1        |       0        |  0   |
|       0        |       1        |  0   |
|       0        |       0        |  0   |

###### 按位或

按位或操作符用管道符(`|`)表示，同样有两个操作数。按位或遵循如下真值表:

| 第一个数值的位 | 第二个数值的位 | 结果 |
| :------------: | :------------: | :--: |
|       1        |       1        |  1   |
|       1        |       0        |      |
|       0        |       1        |  1   |
|       0        |       0        |  0   |

按位异或

按位异或用脱字符(`^`)表示，同样有两个操作数。下面是按位异或的真值表:

| 第一个数值的位 | 第二个数值的位 | 结果 |
| :------------: | :------------: | :--: |
|       1        |       1        |  0   |
|       1        |       0        |  1   |
|       0        |       1        |  1   |
|       0        |       0        |  0   |

###### 左移

左移操作符用两个小于号(`<<`)表示，会按照指定的位数将数值的所有位向左移动。

###### 有符号右移

有符号右移由两个大于号(`>>`)表示，会将数值的所有 32 位都向右移，同时保留符号(正或负)。 有符号右移实际上是左移的逆运算。

###### 无符号右移

无符号右移用 3 个大于号表示(`>>>`)，会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。

对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是 什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变 得非常之大，

##### 布尔操作符

###### 逻辑非

逻辑非操作符由一个叹号(`!`)表示，可应用给 `ECMAScript` 中的任何值。这个操作符始终返回布 尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。

逻辑非操作符会遵循如下规则。

    1. 如果操作数是对象，则返回 `false`。
    1. 如果操作数是空字符串，则返回 `true`。
    1. 如果操作数是非空字符串，则返回 `false`。
    1. 如果操作数是数值 0，则返回 `true`。
    1. 如果操作数是非 0 数值(包括 `Infinity`)，则返回 `false`。
    1.  如果操作数是 `null`，则返回 `true`。
    1. 如果操作数是 `NaN`，则返回 `true`。
    1. 如果操作数是 `undefined`，则返回 `true`。

###### 逻辑与

逻辑与操作符由两个和号(`&&`)表示，应用到两个值。

逻辑与操作符遵循如下真值表

| 第一个操作数 | 第二个操作数 | 结果  |
| :----------: | :----------: | :---: |
|     true     |     true     | true  |
|     true     |    false     | false |
|    false     |     true     | false |
|    false     |    false     | false |

逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：

1. 如果第一个操作数是对象，则返回第二个操作数。
1. 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。
1. 如果两个操作数都是对象，则返回第二个操作数。
1. 如果有一个操作数是 null，则返回 null。
1. 如果有一个操作数是 NaN，则返回 NaN。
1. 如果有一个操作数是 undefined，则返回 undefined。

逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。

###### 逻辑或

逻辑或操作符由两个管道符(`||`)表示

逻辑或操作符遵循如下真值表

| 第一个操作数 | 第二个操作数 | 结果  |
| :----------: | :----------: | :---: |
|     true     |     true     | true  |
|     true     |    false     | true  |
|    false     |     true     | true  |
|    false     |    false     | false |

与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如 下规则。

    1. 如果第一个操作数是对象，则返回第一个操作数。
    1. 如果第一个操作数求值为 false，则返回第二个操作数。
    1. 如果两个操作数都是对象，则返回第一个操作数。
    1. 如果两个操作数都是 null，则返回 null。
    1. 如果两个操作数都是 NaN，则返回 NaN。
    1. 如果两个操作数都是 undefined，则返回 undefined。

同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为 true，第二个操作数就不会再被求值了。

##### 乘性操作符

`ECMAScript` 定义了 3 个乘性操作符:乘法、除法和取模

###### 乘法操作符

乘法操作符由一个星号(`*`)表示，可以用于计算两个数值的乘积。

**特殊值处理**

    1. 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 `ECMAScript` 不能表示乘积，则返回 `Infinity` 或`-Infinity`。
    1.  如果有任一操作数是 `NaN`，则返回 `NaN`。
    1. 如果是 Infinity 乘以 0，则返回 `NaN`。
    1. 如果是 `Infinity` 乘以非 0 的有限数值，则根据第二个操作数的符号返回 `Infinity` 或`-Infinity`。
    1. 如果是 `Infinity` 乘以 `Infinity`，则返回 `Infinity`。
    1. 如果有不是数值的操作数，则先在后台用 `Number()`将其转换为数值，然后再应用上述规则。

###### 除法运算符

除法操作符由一个斜杠(`/`)表示，可以用于计算第一个操作数除以第二个操作数的商

**特殊值处理**

    1. 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果 `ECMAScript` 不能表示商，则返回 `Infinity` 或`-Infinity`。
    1.  如果有任一操作数是 `NaN`，则返回 `NaN`。
    1. 如果是 `Infinity` 除以 `Infinity`，则返回 `NaN`。
    1. 如果是 0 除以 0，则返回 `NaN`。
    1. 如果是 `Infinity` 除以任何数值，则根据第二个操作数的符号返回 `Infinity` 或`-Infinity`。
    1. 如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 `Infinity` 或`-Infinity`。
    1.  如果有不是数值的操作数，则先在后台用 `Number()` 函数将其转换为数值，然后再应用上述规则

###### 取模运算符

取模(余数)操作符由一个百分比符号(`%`)表示

**特殊值处理**

1. 如果操作数是数值，则执行常规除法运算，返回余数。
2. 如果被除数是无限值，除数是有限值，则返回 `NaN`。
3. 如果被除数是有限值，除数是 0，则返回`NaN`。
4. 如果被除数是 0，除数不是 0，则返回 0。
5. 如果是 `Infinity` 除以 `Infinity`，则返回 `NaN`。
6. 如果被除数是有限值，除数是无限值，则返回被除数。
7. 如果有不是数值的操作数，则先在后台用 `Number()` 函数将其转换为数值，然后再应用上述规则

##### 指数操作符

`ECMAScript 7` 新增了指数操作符，`Math.pow()`现在有了自己的操作符`**`

不仅如此，指数操作符也有自己的指数赋值操作符\*\*=，该操作符执行指数运算和结果的赋值操作

```js
let squared = 3
squared **= 2
console.log(squared) // 9
```

##### 加性操作符

加性操作符，即加法和减法操作符

###### 加法操作符

加法操作符(`+`)用于求两个数的和

**两个操作数都是数值执行规则**

1. 如果有任一操作数是 NaN，则返回 NaN;
2. 如果是 `Infinity` 加 `Infinity`，则返回 `Infinity`;
3. 如果是`-Infinity` 加`-Infinity`，则返回`-Infinity`;
4. 如果是 `Infinity` 加`-Infinity`，则返回 `NaN`;
5. 如果是+0 加+0，则返回+0;
6. 如果是-0 加+0，则返回+0;
7. 如果是-0 加-0，则返回-0。

**有一个是字符串的规则**

1. 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面;
2. 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起

如果有任一操作数是对象、数值或布尔值，则调用它们的 `toString()`方法以获取字符串，然后再应用前面的关于字符串的规则。对于 `undefined` 和 `null`，则调用 `String()`函数，分别获取 `"undefined"`和`"null"`。

###### 减法操作符

减法操作符(`-`)也是使用很频繁的一种操作符。

**计算规则**

1. 如果两个操作数都是数值，则执行数学减法运算并返回结果。
2. 如果有任一操作数是 NaN，则返回 NaN。
3. 如果是 Infinity 减 Infinity，则返回 NaN。
4. 如果是-Infinity 减-Infinity，则返回 NaN。
5. 如果是 Infinity 减-Infinity，则返回 Infinity。
6. 如果是-Infinity 减 Infinity，则返回-Infinity。
7. 如果是+0 减+0，则返回+0。
8. 如果是+0 减-0，则返回-0。
9. 如果是-0 减-0，则返回+0。
10. 如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是 NaN。
11. 如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。

##### 关系操作符

关系操作符执行比较两个值的操作，包括小于(`<`)、大于(`>`)、小于等于(`<=`)和大于等于(`>=`)

**执行规则**

1. 如果操作数都是数值，则执行数值比较。
2. 如果操作数都是字符串，则逐个比较字符串中对应字符的编码。
3. 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。
4. 如果有任一操作数是对象，则调用其 `valueOf()`方法，取得结果后再根据前面的规则执行比较。 如果没有 `valueOf()`操作符，则调用 `toString()`方法，取得结果后再根据前面的规则执行比较。
5. 如果有任一操作数是布尔值，则将其转换为数值再执行比较

##### 相等操作符

第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换

###### 等于和不等于

`ECMAScript` 中的等于操作符用两个等于号(`==`)表示，如果操作数相等，则会返回 `true`。不等于操作符用叹号和等于号(`!=`)表示，如果两个操作数不相等，则会返回 `true`。这两个操作符都会先进行类型转换(通常称为强制类型转换)再确定操作数是否相等。

**转换规则**

1. 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。`false` 转换为 0，`true` 转换为 1。
2. 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。
3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()`方法取得其原始值，再根据前面的规则进行比较。

**比较规则**

1. `null` 和 `undefined` 相等
2. `null` 和 `undefined`不能转换为其他类型的值在进行比较
3. 如果有任一操作数是`NaN`，则相等操作符返回`false`，不相等操作符返回`true`。**记住：** 即使两个操作数都是`NaN`，相等操作符也是返回`false`。因为按照规则，`NaN`不等于`NaN`
4. 如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回`true`。否则，两者不不相等

**特殊情况**

|      表达式       | 结果  |
| :---------------: | :---: |
| null == undefined | true  |
|   "NaN" == NaN    | false |
|     5 == NaN      | false |
|    NaN == NaN     | false |
|    Nan != NaN     | true  |
|    false == 0     | true  |
|     true == 1     | true  |
|     true == 2     | false |
|  undefined == 0   | false |
|     null == 0     | false |
|     "5" == 5      | true  |

###### 全等和不全等

全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号(`===`)表示，只有两个操作数在不转换的前提下相等才返回 `true`

不全等操作符用一个叹号和两个等于号(`!==`)表示，只有两个操作数在不转换的前提下不相等才返回 `true`

##### 条件操作符

```
 variable = boolean_expression ? true_value : false_value;
```

上面的代码执行了条件赋值操作，即根据条件表达式 `boolean_expression` 的值决定将哪个值赋给变量 `variable` 。 如果 `boolean_expression` 是 `true` ， 则赋值 `true_value` ; 如果 `boolean_expression` 是 `false`，则赋值 `false_value`。

##### 赋值操作符

简单赋值用等于号(`=`)表示，将右手边的值赋给左手边的变量

**复合赋值操作符**

- 乘后赋值(\*=)
- 除后赋值(/=)
- 取模后赋值(%=)
- 加后赋值(+=)
- 减后赋值(-=)
- 左移后赋值(<<=)
- 右移后赋值(>>=)
- 无符号右移后赋值(>>>=)

##### 逗号操作符

逗号操作符可以用来在一条语句中执行多个操作，如下所示:

```js
let num1 = 1,
  num2 = 2,
  num3 = 3
```

也可以使用逗号操作符来辅助 赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值:

```js
let num = (5, 1, 4, 8, 0) // num的值为0
```

### 语句(后续整理)

P98
