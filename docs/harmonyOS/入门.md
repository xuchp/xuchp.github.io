![image.png](https://gitee.com/xuchp/typora-pics/raw/master/images/1703475631788-6cf04e96-5622-4869-bf43-3d044586bf33-20240126154011307.png)

# 1. 鸿蒙应用开发快速体验

## 1.1. 准备开发环境

### 1.1.1. 安装IDE

鸿蒙应用开发需要使用配套的IDE——**HUAWEI DevEco Studio**。 **DevEco Studio**基于IntelliJ IDEA Community（IDEA社区版）构建，为鸿蒙应用提供了一站式开发环境，集成了开发、运行、调试以及发布应用的各项功能。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703418519281-49b097a6-fe7f-493e-ac4d-6b49ba767a59-20240126154030510.png)

以下是具体的安装步骤：

1. 获取**DevEco Studio**安装包，官方下载地址为：https://developer.huawei.com/consumer/cn/deveco-studio/
2. 解压之后双击`deveco-studio-3.1.0.501.exe`，进入安装向导，点击`next`即可

![image.png](https://gitee.com/xuchp/typora-pics/raw/master/images/1703416812602-a841bf55-9915-4f30-8920-aa31d34542a6-20240126154046146.png)

1. 选择安装路径，完成后点击`next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703416934176-e5a0b1a4-a4c2-4a72-84ad-db0b1c6c3e6f-20240126154057237.png)

1. 配置安装选项，勾选第一项创建桌面快捷方式即可，完成后点击`next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703417138148-eb2afdb6-5415-497e-89df-0be4c44e1504-20240126154108915.png)

1. 点击`Install`开始安装

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703417719470-3272f18e-309f-4b46-ab67-1ecf73a5ab06-20240126154116140.png)

1. 等待几十秒后，点击`Finish`完成安装

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703417848514-36691af1-3969-4d69-a1bb-94a99dfb21c9-20240126154129008.png)

### 1.1.2. 配置IDE

安装完成后，可按以下步骤完成初始化配置

1. 双击桌面快捷方式，启动**DevEco Studio**

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703418868007-fc38cca6-cdba-4ab5-8634-d16bbba029c2-20240126154134203.png)

1. 阅读各项条款，点击`Agree`表示同意

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703419063610-5c9db394-3c32-4d16-bb8b-b2a89db0c049-20240126154137470.png)

1. 初次启动会出现如下设置向导，首先需要为`nodejs`和`ohpm`选择合适的安装路径，完成后点击`Next`即可

**注**：

- - `nodejs`用于为鸿蒙应用的自动化构建工具提供运行环境。
  - `ohpm`（OpenHarmony Package Manager）是鸿蒙生态第三方库的包管理工具，支持共享包的发布、安装和依赖管理。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703421837815-a65220ec-ec8e-4e2f-b49c-7f7014c6443c-20240126154144588.png)

1. 为`HarmonyOS SDK`选择安装目录，完成后点击`Next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703422146793-18a91f0d-b5a4-44bf-aed4-8d9dfda51b10-20240126154149421.png)

1. 阅读相关协议，勾选`Accept`表示同意，完成后点击`Next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703422260146-fe37d57c-8b3e-4510-8b1b-7502c1f4584e-20240126154154973.png)

1. 浏览配置汇总页，确认无误后点击`Next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703422335999-521658e2-ae48-41bf-b179-f77bd19868dc-20240126154201298.png)

1. 等待下载

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703422369922-97f2a7c9-e03e-47de-8c4a-9cfa2aa2bdf4-20240126154206866.png)

1. 下载完成后，点击`Finish`完成配置

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703423137326-e62dc659-032b-4f75-80a1-014abe63f6cf-20240126155358925.png)

1. 完成配置后，可根据喜好调整**DevEco Studio**主题风格，点击`Configure`下的`Settings`。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703426204014-37b5aa6a-b53c-43b1-ad5a-30d4f6351798-20240126154214498.png)

1. 在**Appearance & Behavior/Appearance**的`Theme`中可选择主题

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703426422186-40216ef3-8946-4694-a59e-ae53018fc421-20240126154222076.png)

## 1.2. 创建项目

下面我们创建第一个鸿蒙应用项目

1. 点击`Create Project`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703426466429-26247241-6f6e-4ce6-81aa-bd5f9c663f28-20240126154227420.png)

1. 选择项目模版，此处选择第一个`Empty Ability`即可。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703426497714-b22a1838-27f4-454c-975e-872c7e103bcd-20240126154236307.png)

1. 配置项目

可能需要调整的配置项如下，其余保持默认即可，配置完成后，点击`Finish`即可

- - **Project name**：项目名称
  - **Bundle name**：包名，通常为公司域名倒置
  - **Save location**：项目目录

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703426667469-3998788f-b6ed-47d2-bae4-487a144e8caf-20240126154241769.png)

1. IDE界面说明

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703578233998-d2cc6315-3fe4-467c-8b9e-5a0428fd1c10-20240126154246998.png)

1. 项目结构概述

项目结构相对复杂，先简单了解即可，随之后序学习的深入再逐步为大家介绍

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703466460134-c83b8590-df86-496f-a733-7b60c026058f-20240126154300696.png)

## 1.3. 运行项目

**DevEco Studio**提供了多种方式用于运行项目，包括预览、模拟器和真机运行。下面逐一演示

### 1.3.1. Preview 预览

`Previewer`预览用于查看应用的UI界面效果，方便随时调整界面UI布局。只需打开需要预览的页面文件，例如下图中的`Index.ets`，然后点击IDE右侧的`Perviewer`即可看到预览效果。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703501329180-b51fec1a-dee6-4806-b911-a6ef9ddd4831-20240126154309933.png)

### 1.3.2. 模拟器运行

`Previewer`预览器主要用于查看界面UI效果，如需对项目进行更加深入的测试，可以使用模拟器运行项目。初次使用需要先安装模拟器，安装步骤如下

1. 点击`Tools`菜单下的`Device Manager`，打开设备管理器

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703430612698-d08aed63-1491-44e4-ae38-02f6819a5c87-20240126154318636.png)

1. 点击`Install`，安装模拟器

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703430673152-e6514211-2059-4059-ab27-c2fdd48b0449-20240126154324668.png)

1. 点击`Install`后，会首先下载模拟器相关的SDK，下载完成后点击`Finish`即可。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703430784956-c69b9e03-748d-4597-9f8d-e98d63088cd5.png)

1. 选择模拟的安装目录，完成后点击`New Emulator`。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431200009-a3e6d7d6-6ef0-4b18-a38d-43ad86a7b61d.png)

1. 选择设备类型——`Phone`，完成后点击`Next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431380189-b4c3723e-e462-44d5-bf20-bfa7dc463e68.png)

1. 下载系统镜像，注意选择`api9`版本

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431490979-0e320465-e066-4b73-89d8-06d72d769098-20240126154358819.png)

1. 等待下载完成后，点击`Finish`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431880994-1cda26d0-db58-4031-8ae9-a71920e89483-20240126154406421.png)

1. 系统镜像下载完毕后，点击`Next`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431914812-75333d24-28be-4c30-b187-2b567420a13b-20240126154413603.png)

1. 配置模拟器（可选），完成后点击`Finish`，至此模拟器安装完毕

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703431987849-8ec12ce0-216c-4d6e-87c2-b1ebe78d8469.png)

1. 若想将项目运行到模拟器，首先需要启动模拟器，点击下图中的启动按钮，稍等片刻，等待模拟器开机

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703432081697-d0e75e63-4b48-4705-9cc9-a1861cca7fa9-20240126154426027.png)

1. 开机后的模拟器如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703432213802-741624ce-a194-4e7e-b72f-e8d14b82f033.png)

1. 回到IDE，在右上角的设备列表中选择刚刚创建的模拟器（默认已经选中）

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703432325643-7be149d2-20b5-4556-b692-a99b9e18cca3.png)

1. 点击运行按钮

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703432449669-b4921937-cb59-4609-9a70-fff142e917c9.png)

1. 查看模拟器

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703432509303-17a3b03e-40f1-4d39-a997-4a725a3e0bbe-20240126154441951.png)

### 1.3.3. 真机运行

使用模拟器运行应用时，会占用电脑较多的资源，并且有些功能无法进行测试。当模拟器不满足要求时，可选择真机运行。真机运行的步骤如下

1. 准备一台装有`Harmony OS`系统的手机，系统版本最好为`4.0.0`及以上，系统版本可在**设置/关于手机**中查看

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703466476747-229d9fc3-1c8f-4942-979f-c79ada945b0b.png)

1. 打开手机的开发者模式。在**设置/关于手机**中，连续多次点击系统版本号，直至出现**您正处在开发者模式!**的提示信息 

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703466996870-7c078f91-75ab-4295-9413-606142fa807c.png)

1. 开启USB调试。在**系统与更新/开发人员选项**中，打开**USB调试**开关

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703467285227-93430993-e2e8-4e46-b68c-a25ce2cc7c86-20240126154505966-20240126154529890.png)

1. 使用USB数据线将手机和电脑相连，手机会弹框提示选择**USB 连接方式**，需要选择**传输文件**。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703467860454-c0f8a931-06ca-425b-a148-49aa0edd519c-20240126154517483.png)

1. 之后会弹窗询问**是否允许USB调试？**，可勾选`始终允许使用这台计算机进行调试`，然后点击`确定`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703468012658-07e44b46-961e-411e-8f80-cf9e3250359f-20240126154548627.png)

1. 回到IDE，在右上角的设备列表中选择连接的手机（默认已选中）

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703468350904-22f37577-96ed-447b-9e71-063ad33556ce-20240126154607094.png)

1. 最后点击运行按钮，即可将项目运行到真机中。首次运行会提示缺少签名信息，点击`Open signing configs`进行配置即可。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703473716491-afefd7e5-246f-45ef-ba03-78c1c767b464.png)

1. 生成签名信息需要先登陆华为开发者账号，点击`Sign In`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703473878388-a4debf7c-4a68-4167-bb6e-d3b0a1e81a18.png)

1. 浏览器会自动跳转到登录页面，按照要求完成注册、登录即可

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703474254598-d785eab3-b8d9-4134-a3ce-b45228d0d9e7-20240126154625194.png)

1. 登录成功后，回到IDE，再次点击运行按钮，即可将应用运行到真机。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703474341483-c7201050-fbdf-4c9e-a243-d5a323306f04.png)

# 2. 鸿蒙应用开发语言

## 2.1. 概述

HarmonyOS 应用的主要开发语言是 ArkTS，它由 TypeScript（简称TS）扩展而来，在继承TypeScript语法的基础上进行了一系列优化，使开发者能够以更简洁、更自然的方式开发应用。值得注意的是，TypeScript 本身也是由另一门语言 JavaScript 扩展而来。因此三者的关系如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703580979389-f995ab93-440c-479e-b671-739c9a13853a-20240126154638903.png)



## 2.2. TypeScript 快速入门

### 2.2.1. 运行环境说明

#### 2.2.1.1. 线上Playground

TypeScript提供了一个线上的 Playground 供练习使用，地址为https://www.typescriptlang.org/zh/play。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1702957105136-a367c43a-9485-4d00-a7ea-926b6b28f1c8.png)

#### 2.2.1.2. 本地运行环境

除去线上的运行环境，我们也可以在本地搭建一个 TS 的运行环境。

1. **安装 VSCode 编辑器**

**VSCode**是一款轻量级、开源且功能丰富的集成开发环境（IDE），支持多种编程语言，具有强大的插件系统。下载地址为：https://code.visualstudio.com/

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703671680831-16d7054d-dc66-4390-b6e3-db62d34c7c8b.png)

1. **安装Code Runner 插件**

**Code Runner**是一款在**VSCode**中使用的插件，它提供了简便的代码执行功能，支持多种编程语言，使开发者能够快速运行和调试代码片段。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703661362605-9b437167-7c74-46b4-8a05-828a52b7edf9-20240126154659383.png)

1. **安装ts-node**

**ts-node**是一个 TypeScript 的运行环境，它允许我们直接运行 TypeScript 代码。**ts-node**的安装和运行依赖于**Node.js**环境，因此在安装**ts-node**之前，我们需要准备好**Node.js**环境。

准备**Node.js**环境需要完成以下两步操作

**安装Node.js****配置环境变量**

在配置完**Node.js**环境后，便可在终端执行以下命令来安装**ts-node**了。

```
npm install -g ts-node
```

注：完成后需要重新启动**VSCode**，另其重新加载环境变量和相关依赖。

1. **编写程序并运行**

在完成上述环境的准备后，就可以编写Typescript程序并运行了，具体操作如下

首先在合适的位置创建一个工程目录，例如`D:\workspace\hello-ts`，然后使用**VSCode**打开目录

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703676392963-1bbd5bfb-f536-46f8-a637-7fa395c3ec36-20240126154707427.png)

之后创建Typescript文件，点击**New File**

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703676477994-074da7ac-47b5-4545-9acb-b0dcd903f5f3.png)

注意，文件的后缀为`.ts`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703676597198-b5ce5641-c643-4669-8983-f24df77fbf0a.png)

之后就可以编写Typescript代码并运行了

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703676742755-e51b2216-0dd7-4ff7-b871-d414cb91dd96.png)

### 2.2.2. 声明

#### 2.2.2.1. 变量声明

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704157934863-fa0d8e6e-3cda-4ce5-8f74-de95b31797f5.png)

#### 2.2.2.2. 常量声明

`let`用于声明变量，而`const`用于声明常量，两者的区别是变量在赋值后可以修改，而常量在赋值后便不能再修改。

```typescript
const b:number = 200;
```

#### 2.2.2.3. 类型推断

如果一个变量或常量的声明包含了初始值，TS 便可以根据初始值进行类型推断，此时我们就可以不显式指定其类型，例如

```typescript
let c = 60;
console.log(typeof c); //number
```

### 2.2.3. 常用数据类型

#### 2.2.3.1. number

```
number`表示数字，包括整数和浮点数，例如： `100`、`-33` 、`2.5`、`-3.9
let a :number = 100
let b :number = -33
let c :number = 2.5
let d :number = -3.9
```

#### 2.2.3.2. string

```
string`表示字符串，例如： `你好`、`hello
let a:string = '你好'
let b:string = 'hello'
```

#### 2.2.3.3. boolean

```
boolean`表示布尔值，可选值为：`true`、`false
let isOpen:boolean = true
let isDone:boolean = false
```

#### 2.2.3.4. 数组

数组类型定义由两部分组成，`元素类型[]`，例如`number[]`表示数字数组，`string[]`表示字符串数组，数组类型的变量可由数组字面量——`[item1,item2,item3]`进行初始化。

```typescript
let a: number[] = []

let b: string[] = ['你好', 'hello']
```

#### 2.2.3.5. 对象

在TS中，对象（object）是一种一系列由**属性名称**和**属性值**组成的数据结构，例如`姓名:'张三', 年龄:10, 性别:'男'`。对象类型的声明需要包含所有属性的**名称**及**类型**，例如`{name: string, age: number, gender: string}`，对象类型的变量可以通过对象字面量——`{name:'张三', age:10, gender:'男'}`进行初始化。

```typescript
let person: {name:string, age:number, gender:string} = {name:'张三', age:10, gender:'男'};
```

### 2.2.4. 函数

#### 2.2.4.1. 函数声明语法

声明函数的基础语法如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703646988460-79ac5a74-8af0-443a-aab1-01c66ef92dd1-20240126154730664.png)

#### 2.2.4.2. 参数详解

##### 2.2.4.2.1. 特殊语法

- **可选参数**

可选参数通过参数名后的`?`进行标识，如以下案例中的`gender?`参数。

```
function getPersonInfo(name: string, age: number, gender?: string): string {    if (gender === undefined) {        gender = '未知'    }    return `name:${name},age:${age},gender:${gender}`; } let p1 = getPersonInfo('zhagnsan', 10, '男') let p2 = getPersonInfo('lisi', 15); console.log(p1); console.log(p2);
```

注：调用函数时，未传递可选参数，则该参数的值为`undefined`。

- **默认参数**

可在函数的参数列表为参数指定默认值，如以下案例中的`gender: string='未知'`参数。

```
function getPersonInfo(name: string, age: number, gender: string='未知'): string {    return `name:${name},age:${age},gender:${gender}`; } let p1 = getPersonInfo('zhagnsan', 10, '男') let p2 = getPersonInfo('lisi', 15); console.log(p1); console.log(p2);
```

##### 2.2.4.2.2. 特殊类型

- **联合类型**

一个函数可能用于处理不同类型的值，这种情况可以使用联合类型，例如以下案例中的`message: number | string`

```
function printNumberOrString(message: number | string) {  console.log(message) } printNumberOrString('a') printNumberOrString(1)
```

- **任意类型**

若函数需要处理任意类型的值，则可以使用`any`类型，例如以下案例中的`message: any`

```
function print(message:any) {  console.log(message) } print('a') print(1) print(true)
```

#### 2.2.4.3. 返回值详解

##### 2.2.4.3.1. 特殊类型

若函数没有返回值，则可以使用`void`作为返回值类型，其含义为空。

```typescript
function test(): void {
    console.log('hello');
}
```

##### 2.2.4.3.2. 类型推断

函数的返回值类型可根据函数内容推断出来，因此可以省略不写。

```typescript
function test() {
    console.log('hello');
}

function sum(a: number, b: number) {
    return a + b;
}
```

#### 2.2.4.4. 函数声明特殊语法

- **匿名函数**

匿名函数的语法结构简洁，特别适用于简单且仅需一次性使用的场景。

```
let numbers: number[] = [1, 2, 3, 4, 5] numbers.forEach(function (number) {    console.log(number); })
```

**注意**：匿名函数能够根据上下文推断出参数类型，因此参数类型可以省略。

- **箭头函数**

匿名函数的语法还可以进一步的简化，只保留参数列表和函数体两个核心部分，两者用`=>`符号连接。

```
let numbers: number[] = [1, 2, 3, 4, 5] numbers.forEach((num) => { console.log(num) })
```

### 2.2.5. 类（class）

#### 2.2.5.1. 概述

类（class）是面向对象编程语言中的一个重要概念。

面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，其核心理念在于将程序中的数据与操作数据的方法有机地组织成对象，从而使程序结构更加模块化和易于理解。通过对象之间的协同合作，实现更为复杂的程序功能。

类（class）是对象的蓝图或模板，它定义了对象的属性（数据）和行为（方法）。通过类可以创建多个具有相似结构和行为的对象。例如定义一个 `Person`类，其对象可以有`张三`、`李四`等等。

#### 2.2.5.2. 语法说明

##### 2.2.5.2.1. 类的定义

定义类的语法如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703579687783-3b6dc11f-1b73-4627-a6e5-9b65a8efada3.png)

代码如下：

```
class Person {    id: number;    name: string;    age: number = 18;     constructor(id: number, name: string) {        this.id = id;        this.name = name;    }     introduce(): string {        return `hello,I am ${this.name},and I am ${this.age} years old`    } }
```

##### 2.2.5.2.2. 对象创建

- **语法**

创建对象的关键字为`new`，具体语法如下

```
let person = new Person(1,'zhangsan');
```

- **对象属性的访问**

```
console.log(person.name); //读 person.name = 'lisi'; //写 console.log(person.name);
```

- **对象方法的调用**

对象创建后，便可通过对象调用类中声明的方法，如下

```
let intro = person.introduce(); console.log(intro);
```

##### 2.2.5.2.3. 静态成员

Typescript 中的类中可以包含静态成员（静态属性和静态方法），静态成员隶属于类本身，而不属于某个对象实例。静态成员通用用于定义一些常量，或者工具方法。

- **声明静态成员**

定义静态成员需要使用`static`关键字。

```
class Constants{    static count:number=1; } class Utils{    static toLowerCase(str:string){        return str.toLowerCase();    } } console.log(Constants.count); console.log(Utils.toLowerCase('Hello World'));
```

- **使用静态成员**

静态成员无需通过对象实例访问，直接通过类本身访问即可。

```
console.log(Constants.count); console.log(Utils.toLowerCase('Hello World'));
```

#### 2.2.5.3. 继承

继承是面向对象编程中的重要机制，允许一个类（子类或派生类）继承另一个类（父类或基类）的属性和方法。子类可以直接使用父类的特性，并根据需要添加新的特性或覆盖现有的特性。这种机制赋予面向对象程序良好的扩展性。

下面通过一个例子演示继承的特性

```typescript
class Student extends Person {
    classNumber: string;
    constructor(id: number, name: string, classNumber: string) {
        super(id, name);
        this.classNumber = classNumber;
    }

    introduce(): string {
        return super.introduce()+`, and I am a student`;
    }
}

let student = new Student(1,'xiaoming','三年二班');
console.log(student.introduce());
```

**注意：**

- 类的继承需要使用关键字`extends`
- 子类构造器中需使用`super()`调用父类构造器对继承自父类的属性进行初始化。
- 在子类中可以使用`this`关键字访问继承自父类的属性和方法。
- 在子类中可以使用`super`关键字访问父类定义的方法。

#### 2.2.5.4. 访问修饰符

访问修饰符（Access Modifiers）用于控制类成员（属性、方法等）的可访问性。TypeScript提供了三种访问修饰符，分别是**private**、**protected**和**public**。

```typescript
class Person {
    private id: number;
    protected name: string;
    public age: number;

    constructor(id: number, name: string, age: number) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    
}
```

**说明：**

- **private** 修饰的属性或方法是私有的，只能在声明它的类中的被访问。
- **protected** 修饰的属性或方法是受保护的，只能在声明它的类和其子类中被访问。
- **public** 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的。

### 2.2.6. 接口（interface）

#### 2.2.6.1. 概述

接口（interface）是面向对象编程中的另一个重要概念。接口通常会作为一种契约或规范让类（class）去遵守，确保类实现某些特定的行为或功能。

#### 2.2.6.2. 语法说明

- **接口定义**

接口使用`interface`关键字定义，通常情况下，接口中只会包含属性和方法的声明，而不包含具体的实现细节，具体的细节由其实现类完成。

```
interface Person {    id: number;    name: string;    age: number;      introduce(): void; }
```

- **接口实现**

接口的实现需要用到`implements`关键字，实现类中，需要包含接口属性的赋值逻辑，以及接口方法的实现逻辑。

```
class Student implements Person {    id: number;    name: string;    age: number;     constructor(id: number, name: string, age: number) {        this.id = id;        this.name = name;        this.age = age;    }     introduce(): void {        console.log('Hello,I am a student');    } }
```

#### 2.2.6.3. 多态

**多态**是面相对象编程中的一个重要概念，它可以使同一类型的对象具有不同的行为。下面我们通过一个具体的案例来体会**多态**这一概念

首先，再创建一个`Person`接口的实现类`Teacher`，如下

```typescript
class Teacher implements Person {
    id: number;
    name: string;
    age: number;

    constructor(id: number, name: string, age: number) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    introduce(): void {
        console.log('Hello,I am a teacher');
    }
}
```

然后分别创建一个`Student`对象和一个`Teacher`对象，注意两个对象的类型均可以设置`Person`，如下

```typescript
let p1: Person = new Student(1, 'zhangsan', 17);
let p2: Person = new Teacher(2, 'lisi', 35);
```

最后分别调用`p1`和`p2`的`introduce()`方法，你会发现，同样是`Person`类型的两个对象，调用同一个`introduce()`方法时，表现出了不同的行为，这就是**多态**。

```typescript
p1.introduce();//Hello,I am a student
p2.introduce();//Hello,I am a teacher
```

#### 2.2.6.4. 接口的作用

在传统的面向对象编程的场景中，接口主要用于设计和组织代码，使代码更加容易扩展和维护。下面举例说明。

假如现在需要实现一个订单支付系统，按照面向对象编程的习惯，首先需要定义一个订单类（Order），如下

```typescript
class Order {
    totalAmount: number;

    constructor(totalAmount: number) {
        this.totalAmount = totalAmount;
    }

    pay() {
        console.log(`AliPay:${this.totalAmount}`);
    }
}
```

很容易预想到，这个系统将来可能需要支持其他的支付方式，为了方便代码支持新的支付方式，我们可以对代码进行如下改造。

首先定义一个支付策略的接口，接口中声明一个`pay`方法，用来规范实现类必须实现支付逻辑。

```typescript
interface PaymentStrategy {
    pay(amount: number): void;
}
```

然后在订单类中增加一个`PaymentStrategy`的属性，并且在订单类中的`pay`方法中调用`PaymentStrategy`的`pay`方法，如下

```typescript
class Order {
    totalAmount: number;
    paymentStrategy: PaymentStrategy;

    constructor(totalAmount: number, paymentStrategy: PaymentStrategy) {
        this.totalAmount = totalAmount;
        this.paymentStrategy = paymentStrategy;
    }

    pay() {
        this.paymentStrategy.pay(this.totalAmount);
    }
}
```

这样改造完之后，就可以很容易的在不改变现有代码的情况下，支持新的支付方式了。

比如现在需要支持`AliPay`，那我们就可以创建`AliPay`这个类（class）并实现（implement）`PaymentStrategy`这个接口，如下

```typescript
class AliPay implements PaymentStrategy {
    pay(amount: number): void {
        console.log(`AliPay:${amount}`);
    }
}
```

这样一来，之后创建的订单就可以使用`AliPay`这个支付方式了。

```typescript
let order = new Order(1000,new AliPay());
order.pay();
```

#### 2.2.6.5. TS 中的接口的特殊性

TypeScript 中的接口是一个非常灵活的概念，除了用作类的规范之外，也常用于直接描述对象的类型，例如，现有一个变量的定义如下

```typescript
let person: {name:string, age:number, gender:string} = {name:'张三', age:10, gender:'男'};
```

可以看到变量的值为一个一般对象，变量的类型为`{name:string, age:number, gender:string}`，此时就可以声明一个接口来描述该对象的类型，如下

```typescript
interface Person {
    name: string;
    age: number;
    gender: string;
}

let person: Person = {name:'张三', age:10, gender:'男'};
```

### 2.2.7. 枚举

#### 2.2.7.1. 概述

枚举（Enumeration）是编程语言中常见的一种数据类型，其主要功能是定义一组有限的选项，例如，方向（上、下、左、右）或季节（春、夏、秋、冬）等概念都可以使用枚举类型定义。

#### 2.2.7.2. 语法说明

- **枚举定义**

枚举的定义需使用`enum`关键字，如下

```
enum Season {    SPRING,    SUMMER,    AUTUMN,    WINTER }
```

- **枚举使用**

枚举的使用记住两个原则即可

- - **枚举值的访问**

像访问对象属性一样访问枚举值，例如`Season.SPRING`

- - **枚举值的类型**

枚举值的类型为`enum`的名称，例如`Season.SPRING`和`Season.SUMMER`等值的类型都是`Season`

```
let spring:Season = Season.SPRING;
```

- **使用场景**

现需要编写一个函数`move`，其功能是根据输入的方向（上、下、左、右）进行移动，此时就可以先使用枚举定义好所有可能的输入选项，如下

```
enum Direction {    UP,    BOTTOM,    LEFT,    RIGHT }
```

`move`函数的实现如下

```
function move(direction: Direction) {    if(direction===Direction.UP){        console.log('向上移动');    }else if(direction===Direction.BOTTOM){        console.log('向下移动');    }else if(direction===Direction.LEFT){        console.log('向左移动');    }else{        console.log('向右移动');    } } move(Direction.UP);
```

#### 2.2.7.3. 赋值

在TypeScript 中，枚举实际上是一个对象，而每个枚举值都是该对象的一个属性，并且每个属性都有具体的值，属性值只支持两种类型——数字或字符串。

默认情况下，每个属性的值都是数字，并且从 `0` 开始递增，例如上述案例中的`Direction`枚举中，`Direction.UP`的值为`0`，`Direction.BOTTOM`的值为`1`，依次类推，具体如下

```typescript
console.log(Direction.UP) //0
console.log(Direction.BOTTOM) //1
console.log(Direction.LEFT) //2
console.log(Direction.RIGHT) //3
```

除了使用默认的数字作为属性的值，我们还能手动为每个属性赋值，例如

```typescript
enum Direction {
    UP = 1,
    BOTTOM = 2,
    LEFT = 3,
    RIGHT = 4
}

console.log(Direction.UP) //1
console.log(Direction.BOTTOM) //2
console.log(Direction.LEFT) //3
console.log(Direction.RIGHT) //4
```

再例如

```typescript
enum Direction {
    UP = 'up',
    BOTTOM = 'bottom',
    LEFT = 'left',
    RIGHT = 'right'
}

console.log(Direction.UP) //up
console.log(Direction.BOTTOM) //bottom
console.log(Direction.LEFT) //left
console.log(Direction.RIGHT) //right
```

通过为枚举属性赋值，可以赋予枚举属性一些更有意义的信息，例如以下枚举

```typescript
enum Color {
    Red = 0xFF0000,
    Green = 0x00FF00,
    Blue = 0x0000FF
}

enum FontSize {
    Small = 12,
    Medium = 16,
    Large = 20,
    ExtraLarge = 24
}
```

### 2.2.8. 模块化

#### 2.2.8.1. 概述

模块化是指将复杂的程序拆解为多个独立的文件单元，每个文件被称为一个模块。在 TypeScript 中，默认情况下，每个模块都拥有自己的作用域，这意味着在一个模块中声明的任何内容（如变量、函数、类等）在该模块外部是不可见的。为了在一个模块中使用其他模块的内容，必须对这些内容进行**导入**、**导出**。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703146094550-78659c82-12f1-484c-a503-6e507938ae77.png)

#### 2.2.8.2. 语法说明

- **导出**

导出须使用`export`关键字，语法如下

```
export function hello() {    console.log('hello module A'); } export const str = 'hello world'; const num = 1;
```

- **导入**

导入须使用`import`关键字，语法如下

```
import { hello, str } from './moduleA'; hello(); console.log(str);
```

#### 2.2.8.3. 避免命名冲突

若多个模块中具有命名相同的变量、函数等内容，将这些内容导入到同一模块下就会出现命名冲突。例如，在上述案例的基础上，又增加了一个 moduleC，内容如下

```typescript
export function hello() {
    console.log('hello module C');
}

export const str = 'module C';
```

moduleB 同时引入 moduleA 和 moduleC 的内容，如下，显然就会出命名冲突

```typescript
import { hello, str } from "./moduleA";
import { hello, str } from "./moduleC";

hello() //?
console.log(str); //？
```

有多种方式可以用来解决命名冲突，下面逐一介绍

- **导入重命名**

语法如下

```
import { hello as helloFromA, str as strFromA } from "./moduleA"; import { hello as helloFromC, str as strFromC } from "./moduleC"; helloFromA(); console.log(strFromA); helloFromC(); console.log(strFromC);
```

- **创建模块对象**

上述导入重命名的方式能够很好的解决命名冲突的问题，但是当冲突内容较多时，这种写法会比较冗长。除了导入重命名外，还可以将某个模块的内容统一导入到一个**模块对象**上，这样就能简洁有效的解决命名冲突的问题了，具体语法如下

```
import * as A from "./moduleA"; import * as C from "./moduleC"; A.hello(); console.log(A.str); C.hello(); console.log(C.str);
```

#### 2.2.8.4. 默认导入导出

除了上述导入导出的语法之外，还有一种语法，叫做**默认导入导出**，这种语法相对简洁一些。

- **默认导出**

默认导出允许一个模块指定一个（最多一个）默认的导出项，语法如下

```
export default function hello(){    console.log('moduleA'); }
```

- **默认导入**

由于每个模块最多有一个默认导出，因此默认导入无需关注导入项的原始名称，并且无需使用`{}`。

```
import helloFromA from "./moduleA";
```

由于默认导入时无需关注导入项的名称，所以默认导出支持匿名内容，比如匿名函数，语法如下

```
export default function () {    console.log('moduleB'); }
```

## 2.3. ArkTS 快速入门

**ArkTS** 在继承了**Typescript**语法的基础上，主要扩展了**声明式UI开发**相关的能力。

### 2.3.1. 声明式UI

**声明式UI**是一种编写用户界面的范式。下面通过一个具体案例来学习这种开发范式，假如现在要实现如下界面

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703237085013-55f427be-a7da-41f7-b15a-9015a1a26b81-20240126154808029.gif)

#### 2.3.1.1. 定义界面状态

按照声明式UI的开发范式，首先需要分析和定义页面的各种状态，并声明相应的状态变量用于表示不同的状态。

当前案例中，界面共有两个状态，分别是**开灯**和**关灯**状态，所以我们可以使用一个`boolean`类型的变量来表示这两个状态，`true`表示**开灯**，`false`表示**关灯**。如下：

```typescript
@State isOn: boolean = false;
```

**说明：**`@State`用于声明该变量为状态变量。

#### 2.3.1.2. 描述界面显示效果

在分析完界面状态后，我们需要准确的描述界面在不同状态下的显示效果。

在当前案例中，具体逻辑如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704434408976-2b14c9dd-b0bc-499e-997b-56e58d57e5b8-20240126154819160.png)

#### 2.3.1.3. 改变状态

在明确了界面在不同状态下的显示效果后，我们只需修改状态变量的值，就能触发界面的更新。

在当前案例中，若我们将`isOn`的值改为`true`，那么界面上就会显示**开灯**的图片，否则就会显示**关灯**的图片。

为了实现点击按钮开/关灯的效果，我们可以为按钮绑定点击事件：

- 当用户点击**开灯按钮**时，我们就将`isOn`的值改为`true`。
- 当用于点击**关灯按钮**时，我们就将`isOn`的值改为`false`。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704434360881-16a69757-598d-4191-8b45-68c61749b346-20240126154825626.png)

#### 2.3.1.4. 总结

以上就是声明式UI开发范式的大致流程，下面为大家总结一下声明式UI的核心思想

- **声明式描述**

开发者只需描述在界面在不同状态下要呈现的最终效果，而无需关注界面变化的具体过程。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704434408976-2b14c9dd-b0bc-499e-997b-56e58d57e5b8-20240126154831106.png)

- **状态数据驱动界面更新**

开发者只需修改状态变量的值，界面就会自动更新。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704438862397-b1b2a8a4-4a0d-43a0-86b6-da425fb7219c-20240126154836954.png)

### 2.3.2. 组件化

在鸿蒙开发中，组件是构成界面的最小单元，我们所看到的界面，都是由众多组件组合而成的，所以编写界面其实就是组合组件的过程，ArkTS提供了很多的内置组件，例如：`Text`、`Button`、`Image`等等；并且ArkTS还支持自定义组件，让开发者可根据具体需求自定义组件中的内容。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704455073153-bd9a69bc-cb45-4fa5-a5d1-e01fc1379e6d-20240126154841925.png)

### 2.3.3. 入门案例

#### 2.3.3.1. 案例效果

案例的最终效果如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703237085013-55f427be-a7da-41f7-b15a-9015a1a26b81-20240126154848260.gif)

#### 2.3.3.2. 完整代码

案例的完整代码见`Demos/entry/src/main/ets/pages/helloworld/light/solution/Light.ets`

```arkts
@Entry
@Component
struct LightPage {
  @State isOn: boolean = false;

  build() {
    Column({ space: 20 }) {
      if (this.isOn) {
        Image('pages/helloworld/light/solution/images/img_light.png')
          .height(300)
          .width(300)
          .borderRadius(20)
      } else {
        Image('pages/helloworld/light/solution/images/img_dark.png')
          .height(300)
          .width(300)
          .borderRadius(20)
      }
      Row({ space: 50 }) {
        Button('关灯')
          .onClick(() => {
            this.isOn = false
          })
        Button('开灯')
          .onClick(() => {
            this.isOn = true;
          })
      }
    }
    .height('100%')
      .width('100%')
      .justifyContent(FlexAlign.Center)
  }
}
```

### 2.3.4. 语法说明

#### 2.3.4.1. 声明组件

下面通过一个相对简单的案例来系统的学习 ArkTS 声明组件的语法，案例的最终效果如下，完整代码见`Demos/entry/src/main/ets/pages/helloworld/delete/DeleteButton.ets`

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704637408146-e2b48cb0-620d-43d0-8977-714be3269bb5-20240126154857134.png)

声明组件的完整语法如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704682711403-d9f1000f-96af-4f36-8d9e-305f33a0a793-20240126154902172.png)

各部分语法说明如下

- **组件参数**

如果组件的定义包含参数，可在组件名称后面的`()`中配置相应参数。各组件支持的参数，可查看 API 文档，查看方式如下

- - 首先将鼠标在相应组件悬停

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703321745528-d5522e39-738d-490a-a628-2fc1f22757e7.png)

- - 点击`Show in API Reference`，就会弹出 API 文档

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703322071786-45a35b1b-e8fb-4146-8a48-cfe295ff954b.png)

- **子组件**

如果组件支持子组件配置，可在`()`后的`{}`中添加子组件，若不支持子组件，则不需要写`{}`。

- **属性方法**

属性方法用于配置组件的样式和其他属性，可以在组件声明的末尾进行链式调用。各组件支持的属性可查看 API 文档，除去每个组件的专有属性，还有各组件都能配置的通用属性，通用属性也可通过 API 文档查看。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703321870076-5216f5a7-0f9d-40a1-a132-3dbaf428a071.png)

- **事件方法**

事件方法用于为组件绑定交互事件，可以在组件声明的末尾进行链式调用。各组件的支持的事件可查看 API 文档，除去每个组件的专有事件，还有各组件都支持的通用事件，通用事件也可通过 API 文档查看。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1703322402695-748f7625-394f-4fc2-839a-427bb87cc306-20240126154919989.png)

#### 2.3.4.2. 自定义组件

除去系统预置的组件外，ArkTS 还支持自定义组件。使用自定义组件，可使代码的结构更加清晰，并且能提高代码的复用性。

##### 2.3.4.2.1. 语法说明

自定义组件的语法如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704699871481-0836b3f5-c217-45b5-a226-18df5cf5b299-20240126154926941.png)

各部分语法说明如下：

- `**struct**`**关键字**

`struct`是**ArkTS**新增的用于自定义组件或者自定义弹窗的关键字。其声明的数据结构和**TS**中的类十分相似，可包含属性和方法。

- `**build**`**方法**

`build()`方法用于声明自定义组件的UI结构。

- **组件属性**

组件属性可用作自定义组件的参数，使得自定义组件更为通用。

- `**@Compnent**`**装饰器**

`@Component`装饰器用于装饰`struct`关键字声明的数据结构。`struct`被`@Component`装饰后才具备组件化的能力。

注： 装饰器是Typescript中的一种特殊语法，常用于装饰类、方法、属性，用于修改或扩展其原有的行为。

在学完自定义组件的语法之后，我们会发现前文案例中的每个页面实际上都是一个自定义组件。但是和自定义组件的语法相比，前边的每个案例还会多出一个`@Entry`装饰器，那`@Entry`的作用又是啥呢？

在鸿蒙应用中，每个页面都是由一些列组件组合而成的，并且这些组件都是逐层嵌套的，因此这些组件最终形成了一个组件树的结构，如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704678599322-bdcbdd78-fbd5-4143-8eec-5b339854e935.png)

我们前边所编写的每个页面就相当于是组件树的根节点，而`@Entry`装饰器的作用就是标识该组件为组件树的根节点，也就是一个页面的入口组件。

##### 2.3.4.2.2. 案例实操

现在需要对前文的开/关灯的案例做出如下改造，由于两个按钮的结构十分相似，所以可考虑自定义一个按钮组件，然后进行复用。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704644212102-0813cdf7-795d-41ae-a358-b69ccd883c91.png)

案例的完整代码见：`Demos/entry/src/main/ets/pages/helloworld/custom/solution/Light.ets`

#### 2.3.4.3. 渲染控制

##### 2.3.4.3.1. 条件渲染

###### 2.3.4.3.1.1. 概述

条件渲染可根据应用的不同状态渲染不同的UI界面，例如前文的开/关灯案例，以及以下的播放/暂停案例，均可使用条件渲染实现。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704710442256-fd29900d-1298-4efc-a5a9-d9363dd7ae15.gif)

案例的完整代码见：`Demos/entry/src/main/ets/pages/helloworld/condition/solution/PlayAndPausePage.ets`

###### 2.3.4.3.1.2. 语法说明

条件渲染的语法如下

```typescript
if (...){
  //UI描述 
}else if (...){
  //UI描述
}else{
  //UI描述
}
```

##### 2.3.4.3.2. 循环渲染

###### 2.3.4.3.2.1. 概述

循环渲染可使用`ForEach`语句基于一个数组来快速渲染一个组件列表，例如以下案例中的选项列表就可通过循环渲染实现。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704770800365-d2b9614a-2207-4d3d-b091-ba8520e15938.png)

案例的完整代码见：`Demos/entry/src/main/ets/pages/helloworld/foreach/solution/FruitPage.ets`

###### 2.3.4.3.2.2. 语法说明

`ForEach`循环渲染的语法如下

```typescript
ForEach(
  arr: any[], 
  itemGenerator: (item: any, index?: number) => void,
  keyGenerator?: (item: any, index?: number) => string
)
```

各参数的含义如下

- **arr**

需要进行循环渲染的数据源，必须为数组类型，例如上述案例中的

```
@State options: string[] = ["苹果", "桃子", "香蕉", "橘子"];
```

- **itemGenerator**

组件生成函数，用于为`arr`数组中的每个元素创建对应的组件。该函数可接收两个参数，分别是

- - item：`arr`数组中的数据项
  - index（可选）：`arr`数组中的数据项的索引

例如上述案例中的

```
(item: string) => {        Button(item)          .width(100)          .backgroundColor(Color.Green)          .onClick(() => {            this.answer = item;          })      }
```

- **keyGenerator**（可选）：

**key**生成函数，用于为`arr`数组中的每个数据项生成唯一的**key**。

**key的作用**

`ForEach`在数组发生变化（修改数组元素或者向数组增加或删除元素）时，需要重新渲染组件列表，在重新渲染时，它会尽量复用原来的组件对象，而不是为每个元素都重新创建组件对象。**key**的作用就是辅助`ForEach`完成组件对象的复用。具体逻辑如下：`ForEach`在进行初次渲染时，会使用**keyGenerator**为数组中的每个元素生成一个唯一的**key**，并将**key**作为组件对象的标识。当数组发生变化导致`ForEach`需要重新渲染时，`ForEach`会再次使用**keyGenerator**为每个元素重新生成一遍**key**，然后`ForEach`会检查新生成的**key**在上次渲染时是否已经存在，若存在，`ForEach`就会认为这个**key**对应的数组元素没有发生变化，那它就会直接复用这个**key**所对应的组件对象；若不存在，`ForEach`就会认为这个**key**对应的元素发生了变化，或者该元素为新增元素，此时，就会为该元素重新创建一个组件对象。

开发者可以通过**keyGenerator**函数自定义**key**的生成规则。如果开发者没有定义**keyGenerator**函数，则系统会使用默认的**key**生成函数，即

```
(item: any, index: number) => { return index + '__' + JSON.stringify(item); }
```

在某些情况下默认的**key**生成函数，会导致界面渲染效率低下，此时可考虑通过**keyGenerator**函数自定义生成逻辑，例如如下场景

状态变量数组定义如下

```
@State arr:string[] = ["zhangsan","lisi","wangwu"]
```

ForEach语句如下

```
Column(){  ForEach(this.arr,(item)=>{ Text(item) }) }
```

初次渲染时，每个元素对应的**key**依次为`0__"zhagnsan"`、`1__"lisi"`、`2__"wangwu"`。若现有一个操作是向`arr`数组头部插入新的元素，例如新元素为**wanger**，按照默认的**key**生成逻辑，插入新元素之后每个元素的**key**就会依次变为`0__"wanger"`、`1__"zhagnsan"`、`2__"lisi"`、`3__"wangwu"`，也就是所有元素的**key**都发生了变化，因此UI界面更新时需要为每个元素都重新创建组件对象，即便原有的元素没有发生变化也无法复用之前的组件，这样一来就导致了性能浪费。此时我们就可以考虑提供第三个参数，如下

```
Column(){  ForEach(this.arr, (item)=>{ Text(item) }, item => JSON.stringify(item)) }
```

# 3. 常用组件

## 3.1. 图片

### 3.1.1. 概述

`Image`为图片组件，用于在应用中显示图片。

### 3.1.2. 参数

`**Image**`组件的参数类型为`string | Resource | media.PixelMap`，相关案例见`Demos/entry/src/main/ets/pages/component/image/parameter/solution/ImageParameter.ets`。

下面对三种参数类型逐一进行介绍。

- **`string`类型**

`string`类型的参数用于通过路径的方式引用图片，包括本地图片和网络图片。

**本地图片**

`Image('images/demo.jpg')`**注意**：使用这种方式引入本地图片，需要将图片置于`ets`目录下，并且需要为`Image`组件提供图片相对于`ets`目录的路径。

- - **网络图片**

`Image('http://xxx/xxx.jpg')`**注意：**真机中运行的鸿蒙应用，访问网络图片需要配置网络访问权限，不过在预览器和模拟器中测试时不受限制。权限配置相关的内容在后续章节会系统介绍。

- `**Resource**`**类型**

`Resource`类型的参数用于引入 **resources** 目录下的图片。

**resources**目录用于统一存放应用所需的各种资源，包括图片、音频、视频、文本等等。下面简要介绍 **resources** 目录的用法，首先需要了解 **resources** 的目录结构，如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705113697723-fde3d429-5497-4db6-8e56-318b11593350.png)

**resources** 目录下，用于存放资源的子目录有（**element**、**media**、**profile**）和**rawfile**。下面分别介绍

**element、media、profile** 

（**element**、**media**、**profile**）可存在多种版本，用于适配不同的环境，例如语言环境（**zh_CN**和**en_US**）、系统主题（**dark**和**light**）、设备类型（**phone** 和 **tablet**） 等等。我们可以为上述每种环境各自准备一套资源文件，每种环境对应 **resources** 下的一个目录，例如上述的 **zh_CN** 和 **en_US**。我们在使用**resources**下的资源时，无需指定具体的环境版本，系统会根据设备所处的环境自动选择匹配的版本，例如当设备系统语言为中文时，则会使用**zh_CN**目录下的资源，为英文时，则会使用**en_US**目录下的资源。若没有与当前所处环境相对应的版本，则使用 **base** 目录下资源**。**各目录存储的具体资源如下

- **media**

  存放媒体资源，包括图片、音频、视频等文件。

- **element**

  存放用于描述页面元素的尺寸、颜色、样式等的各种类型的值，每种类型的值都定义在一个相应的 **JSON** 文件中。

- **profile**

  ​	存放自定义配置文件。

**rawfile**

用于存储任意格式的原始文件，需要注意的是**rawfile**不会根据设备所处的环境去匹配不同的资源。

**总结：**

**resources**目录下可用于存放图片的目录有**resources/\*/****media** 以及 **resources/****rawfile**，两个目录下图片的使用方式有所不同，下面逐一介绍

- - **media目录**

该目录下的资源，需要使用`$r('app.media.<filename>')`的方式引用。

**注意**：无需指定具体版本，系统会自动根据所处环境选择相应版本

例如上图中的**img.png**图片，可通过`$r('app.media.img')`引用。需要注意的是`$r()`的返回值即为 `**Resource**` 类型，因此可以直接将`$r('app.media.img')`作为 **Image** 组件的参数，例如`Image($r('app.media.img'))`。

- - **rawfile目录**

该目录下的资源，可通过`$rawfile('path/to/your/file')`的方式引用，文件的路径为相对于 **rawfile** 的路径。例如上图中的**icon.png**，须使用`$rawfile('icon.png)`引用。需要注意的是，`$rawfile()`的返回值也是**Resource**类型，因此其也可以直接作为 **Image** 组件的参数，如`Image($rawfile('icon.png))`。

- **media.PixelMap**

PixelMap指的是图片的**像素位图**，其通常是一个二维数组，数组中的每个元素对应着图片中的一个像素，其包含了该像素的颜色等信息。像素位图主要用于图片编辑的场景，例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1704990949079-f4563728-1e56-4771-aa21-dd443dcc338c.png)

### 3.1.3. 常用属性

#### 3.1.3.1. 图片尺寸

图片尺寸可通过`width()`方法和`height()`方法进行设置。例如

```arkts
Image($r('app.media.img'))
	.width(100)
	.height(100)
```

两个方法可接收的参数类型均为`string | number | Resource`，相关案例见`Demos/entry/src/main/ets/pages/component/image/attribute/size/solution/ImageSize.ets`。

下面对三种参数类型逐一进行介绍。

- `**string**`**类型**

`string`类型的参数可为百分比，例如`'100%'`，或者为具体尺寸，例如`'100px'`。

具体尺寸的单位，常用的有两个，分别是`px`和`vp`，下面逐个介绍

**前置知识（屏幕参数）**

- - `**px(Pixel)`

物理像素，以像素个数来定义图像尺寸。这种方式的弊端是，在不同像素密度的屏幕上，相同的像素个数对应的物理尺寸是不同的。这样一来就会导致我们的应用在不同设备上显示的尺寸可能不同。如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705029198461-ba2c7bc4-e470-4089-9e86-47a3ff9d2768-20240126154959693.png)

- - `**vp(Virtual Pixel)**`

为了保证一致的观感，我们可以使用虚拟像素作为单位。虚拟像素是一种可根据屏幕像素密度灵活缩放的单位。**1vp**相当于像素密度为**160ppi**的屏幕上的**1px**。在不同像素密度的屏幕上，HarmonyOS会根据如下公式将虚拟像素换算为对应的物理像素

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705027051277-007d5b2e-d4d2-4666-91cf-8fdf9877fe04.png)

根据上述公式，不难看出，使用虚拟像素作为单位时，同一尺寸，在像素密度低的屏幕上（单个像素的物理尺寸大），对应的物理像素会更少，相反在像素密度高的屏幕上（单个像素的物理尺寸小），对应的物理像素会更多。因此就能在不同像素密度的屏幕上，获得基本一致的观感了。如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705029255205-ba1cdfbe-dea7-44cc-9233-607b46a6d405-20240126155015380.png)

- `**number**`**类型**

`number`类型的参数，默认以`vp`作为单位。

- `**Resource**`**类型**

`Resource`类型参数用于引用**resources**下的**element**目录中定义的数值。

引用**element**目录中的数值，同样需要使用`$r()`函数。要了解具体语法，需要先熟悉**element**目录下的文件内容。

前文提到过，**element**目录中可保存各种类型的数值，且每种类型的值分别定义在一个JSON文件中。文件中的内容为键值对(`name-value`)的形式。具体内容如下

```json
{  "string": [
  {      
    "name": "module_desc",      
    "value": "模块描述"    
  },    
  { 
    "name": "greeting",
    "value": "你好"   
  }  
] }
```

```json
{  "integer": [ 
  {      
    "name": "width",     
   "value": 150    },   
  {    
    "name": "height",   
    "value": 150  
  }  
] }
```

我们可以通过 `name` 引用相应的 `value`。具体语法为`$r('app.<data_type>.<name>')`。

**注意**：无需指定具体版本，系统会自动根据所处环境选择相应版本

例如上述的 `greeting` 的值，可通过`$r('app.string.greeting')`引用，`width`的值可通过`$r('app.integer.width')`。

#### 3.1.3.2. 图片缩放

当图片的原始大小与**Image**组件不同时，可通过`objectFit()`方法来设置图片的显示效果。该方法的参数类型为`ImageFit`枚举类型，可选的枚举值如下

| **名称**             | **描述**                                                     |
| -------------------- | ------------------------------------------------------------ |
| `ImageFit.None`      | 保持原有尺寸显示，不做任何缩放，超出显示区域的部分不显示。   |
| `ImageFit.Contain`   | 保持宽高比进行缩小或者放大，使得显示区域刚好包含整个图片。   |
| `ImageFit.Cover`     | 保持宽高比进行缩小或者放大，使得图片刚好完全覆盖显示区域。   |
| `ImageFit.Fill`      | 不保持宽高比进行放大缩小，使得图片充满显示区域。             |
| `ImageFit.ScaleDown` | 保持宽高比进行缩小或不变（不会放大），使得图片完全显示在显示区域内。 |
| `ImageFit.Auto`      | 自适应显示                                                   |

各选项的效果如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705040099409-be5f78b8-7d4a-419e-91d4-9c72658ff041.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/image/attribute/objectFit/solution/ImageObjectFit.ets`

#### 3.1.3.3. 图片插值

当原图分辨率较低并且需要放大显示时，图片会模糊并出现锯齿。如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705367450398-47b5ec26-3be9-4fad-b999-bc7b88201262.png)

这时可以使用`interpolation()`方法对图片进行插值，使图片显示得更清晰。该方法的参数为`ImageInterpolation`枚举类型，可选的值有

| 名称                        | 描述                                   |
| --------------------------- | -------------------------------------- |
| `ImageInterpolation.None`   | 不使用图片插值。                       |
| `ImageInterpolation.High`   | 高质量插值，可能会影响图片渲染的速度。 |
| `ImageInterpolation.Medium` | 中等质量插值。                         |
| `ImageInterpolation.Low`    | 低等质量插值。                         |

各选项效果如下图所示

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705367498087-c7da7395-041f-4b1f-a788-24cd176d6722.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/image/attribute/interpolation/solution/Interpolation.ets`

## 3.2. 文本

### 3.2.1. 概述

`**Text**`为文本组件，用于显示文字内容。

### 3.2.2. 参数

`**Text**`组件的参数类型为`string | Resource`，下面分别对两个参数类型进行介绍：

- **string类型**

```
Text('我是一段文本')
```

- **Resource 类型**

`Resource`类型的参数用于引用 `resources/*/element`目录中定义的字符串，同样需要使用`$r()`引用。

例如`resources/base/element`目录中有一个`string.json`文件，内容如下

```
{  "string": [    {      "name": "greeting",      "value": "你好"    }  ] }
```

此时我们便可通过如下方式引用并显示`greeting`的内容。

```
Text($r('app.string.greeting'))
```

相关案例见`Demos/entry/src/main/ets/pages/component/text/parameter/solution/TextParameterPage.ets`

### 3.2.3. 常用属性

#### 3.2.3.1. 字体大小

字体大小可通过`fontSize()`方法进行设置，该方法的参数类型为`string | number| Resource`，下面逐一介绍

- **string类型**

`string`类型的参数可用于指定字体大小的具体单位，例如`fontSize('100px')`，字体大小的单位支持`px`、`fp`。其中`fp(font pixel)`与`vp`类似，具体大小也会随屏幕的像素密度变化而变化。

- **number类型**

`number`类型的参数，默认以`fp`作为单位。

- **Resource类型**

`Resource`类型参数用于引用**resources**下的**element**目录中定义的数值。

相关案例见`Demos/entry/src/main/ets/pages/component/text/attribute/fontsize/solution/FontSizePage.ets`

#### 3.2.3.2. 字体粗细

字体粗细可通过`fontWeight()`方法进行设置，该方法参数类型为`number | FontWeight | string`，下面逐一介绍

- **number类型**

`number`类型的取值范围是`[100,900]`，取值间隔为`100`，默认为`400`，取值越大，字体越粗。

- **FontWeight类型**

`FontWeight`为枚举类型，可选枚举值如下

名称描述`FontWeight.Lighter`字体较细。`FontWeight.Normal`字体粗细正常。`FontWeight.Regular`字体粗细正常。`FontWeight.Medium`字体粗细适中。`FontWeight.Bold`字体较粗。`FontWeight.Bolder`字体非常粗。

- **string类型**

`string`类型的参数仅支持`number`类型和`FontWeight`类型参数的字符串形式，例如例如`'100'`和`bold`。

相关案例见`Demos/entry/src/main/ets/pages/component/text/attribute/fontweight/solution/FontWeightPage.ets`

#### 3.2.3.3. 字体颜色

字体颜色可通过`fontColor()`方法进行设置，该方法参数类型为`Color | string | number | Resource`，下面逐一介绍

- **Color类型**

```
Color`为枚举类型，其中包含了多种常用颜色，例如`Color.Green
```

- **string类型**

```
string`类型的参数可用于设置 **rgb** 格式的颜色，具体写法可以为`'rgb(0, 128, 0)'`或者`'#008000'
```

- **number类型**

```
number`类型的参数用于使用16进制的数字设置 **rgb** 格式的颜色，具体写法为`0x008000
```

- **Resource类型**

`Resource`类型的参数用于应用**resources**下的**element**目录中定义的值。

相关案例见`Demos/entry/src/main/ets/pages/component/text/attribute/fontcolor/solution/FontColor.ets`

#### 3.2.3.4. 文本对齐

文本对齐方向可通过`textAlign()`方法进行设置，该方法的参数为枚举类型`TextAlign`，可选的枚举值如下

| 名称               | 描述     |
| ------------------ | -------- |
| `TextAlign.Start`  | 首部对齐 |
| `TextAlign.Center` | 居中对齐 |
| `TextAlign.End`    | 尾部对齐 |

各选项效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705393902347-ab7c7c4a-fa5a-4c80-bd44-1b13d3c6fc72.png)

相关案例见`Demos/entry/src/main/ets/pages/component/text/attribute/textalign/solution/TextAlignPage.ets`

#### 3.2.3.5. 最大行数和超长处理

可使用`maxLines()`方法控制文本的最大行数，当内容超出最大行数时，可使用`textOverflow()`方法处理超出部分，该方法的参数类型为`{ overflow: TextOverflow }`，其中`TextOverflow`为枚举类型，可用枚举值有

| 名称                    | 描述                                     |
| ----------------------- | ---------------------------------------- |
| `TextOverflow.Clip`     | 文本超长时，进行裁剪显示。               |
| `TextOverflow.Ellipsis` | 文本超长时，显示不下的文本用省略号代替。 |

各选项效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705394107851-56262789-553a-428e-9fad-59ab8e20e2ae.png)

相关案例见`Demos/entry/src/main/ets/pages/component/text/attribute/textoverflow/solution/TextOverFlowPage.ets`

## 3.3. 按钮

### 3.3.1. 概述

`Button`为按钮组件，通常用于响应用户的点击操作。

### 3.3.2. 参数

`Button`组件有两种使用方式，分别是**不包含子组件**和**包含子组件**，两种方式下，`Button` 组件所需的参数有所不同，下面分别介绍

- **不包含子组件**

不包含子组件时，`Button`组件所需的参数如下

```
Button(label?: string, options?: { type?: ButtonType, stateEffect?: boolean })
```

- - **label**

`label`为按钮上显示的文字内容。

- - **options.type**

`options.type`为按钮形状，该属性的类型`ButtonType`，可选的枚举值有

名称描述效果`ButtonType.Capsule`胶囊形状![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705472084251-d81de4a5-2e59-4a2d-b996-7ee3bc2f7a75.png)`ButtonType.Circle`圆形![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705472168882-2f3aff83-822e-451e-ae4b-fc23285d429b-20240126155056720.png)`ButtonType.Normal`普通形状![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705472188698-8ccb2c61-ae7e-4365-977d-6f83416660b6.png)

- - **options.stateEffect**

`options.stateEffect`表示是否开启点击效果，点击效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705473239702-9380300a-59a0-4a05-b0f3-ac3fcc08beb1-20240126155105190.gif)

- **包含子组件**

子组件会作为按钮上显示的内容，可以是图片、文字等。这种方式下，`Button`组件就不在需要`label`参数了，具体如下

```
Button(options?: {type?: ButtonType, stateEffect?: boolean})
```

相关案例见：`Demos/entry/src/main/ets/pages/component/button/parameter/solution/ButtonParameter.ets`

### 3.3.3. 常用属性

#### 3.3.3.1. 背景颜色

按钮的颜色可使用`backgroundColor()`方法进行设置，例如

```arkts
Button('绿色按钮').backgroundColor(Color.Green)
```

#### 3.3.3.2. 边框圆角

按钮的边框圆角大小可使用`borderRadius()`方法进行设置，例如

```arkts
Button('圆角按钮', { type: ButtonType.Normal }).borderRadius(10)
```

相关案例见：`Demos/entry/src/main/ets/pages/component/button/attribute/ButtonAttributePage.ets`

### 3.3.4. 常用事件

对于Button组件而言，最为常用的就是点击事件，可以通过`onClick()`方法为按钮绑定点击事件，该方法的参数为一个回调函数，当按钮被点击时，就会触发该回调函数，例如

```arkts
Button('点击事件').onClick(() => {
  console.log('我被点击了')
})
```

相关案例见：`Demos/entry/src/main/ets/pages/component/button/event/ButtonEventPage.ets`

## 3.4. 切换按钮

### 3.4.1. 概述

`**Toggle**`为切换按钮组件，一般用于两种状态之间的切换，例如下图中的蓝牙开关。

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705502435961-b33d3a00-1b20-4652-b7f5-da55a879756e.png)

### 3.4.2. 参数

`Toggle`组件的参数定义如下

```arkts
Toggle(options: { type: ToggleType, isOn?: boolean })
```

- **type**

`type`属性用于设置`Toggle`组件的类型，可通过`ToggleType`枚举类型进行设置，可选的枚举值如下

名称描述效果`ToggleType.Switch`开关![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705503037175-1cd45ef3-18fc-4faa-af14-0e76428bc15e-20240126155118769.png)`ToggleType.Checkbox`复选框![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705503065502-96724a39-515e-4526-a382-b67922831810.png)`ToggleType.Button`按钮![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705503090488-b82a5fad-c4a6-47db-83c6-78020d1be2e7.png)

- **isOn**

`isOn`属性用于设置`Toggle`组件的状态，例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705540938478-7a27640c-5061-4cda-842b-551e52aa9199-20240126155130515.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/toggle/parameter/ToggleParameter.ets`

### 3.4.3. 常用属性：

#### 3.4.3.1. 选中状态背景色

可使用`selectedColor()`方法设置`Toggle`组件在选中（或打开）状态下的背景色，例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705505104427-a804d42c-5033-4474-b59d-a3e5d10ab91a.png)

#### 3.4.3.2. Swtich滑块颜色

可使用设置`switchPointColor()`方法设置**Switch**类型的Toggle组件中的圆形滑块颜色，例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705505180816-c686418d-0f89-447d-8b70-820d51c0c8ef-20240126155140332.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/toggle/attribute/ToggleAttributePage.ets`

### 3.4.4. 常用事件

`Toggle`组件常用的事件为**change**事件，每当`Toggle`组件的状态发生变化，就会触发`change`事件。开发者可通过`onChange()`方法为`Toggle`组件绑定**change**事件，该方法参数为一个回调函数，具体定义如下

```arkts
onChange(callback: (isOn: boolean) => void)
```

当`Toggle`组件的状态由关闭切换为打开时，`isOn`为`true`，从打开切换为关闭时，`isOn`为`false`。

相关案例见：`Demos/entry/src/main/ets/pages/component/toggle/event/solution/Light.ets`

## 3.5. 文本输入

### 3.5.1. 概述

`TextInput`为文本输入组件，用于接收用户输入的文本内容。

### 3.5.2. 参数

`TextInput`组件的参数定义如下

```typescript
TextInput(value?:{placeholder?: string|Resource , text?: string|Resource})
```

- **placeholder**

`placeholder`属性用于设置无输入时的提示文本，效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705565272162-bee40900-687b-4710-a469-8042f32b5c1f.png)

- **text**

`text`用于设置输入框当前的文本内容，效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705565721335-af2d5359-3bfa-483b-8ac0-6be93757e3cc-20240126155150137.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/input/parameter/TextInputParameter.ets`

### 3.5.3. 常用属性

#### 3.5.3.1. 输入框类型

可通过`type()`方法设置输入框的类型，该方法的参数为`InputType`枚举类型，可选的枚举值有

| **名称**             | **描述**       |
| -------------------- | -------------- |
| `InputType.Normal`   | 基本输入模式   |
| `InputType.Password` | 密码输入模式   |
| `InputType.Number`   | 纯数字输入模式 |

#### 3.5.3.2. 光标样式

可通过`caretColor()`方法设置光标的颜色，效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705568653940-c442d186-20bd-4b98-846d-aa0f7b9183ea.png)

#### 3.5.3.3. placeholder样式

可通过`placeholderFont()`和`placeholderColor()`方法设置 **placeholder** 的样式，其中`placeholderFont()`用于设置字体，包括字体大小、字体粗细等，`placeholderColor()`用于设置字体颜色，效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705580150516-55ca06c2-2553-4e16-a9fe-cf3670af565a.png)

#### 3.5.3.4. 文本样式

输入文本的样式可通过`fontSize()`、`fontWeight()`、`fontColor()`等通用属性方法进行设置。

相关案例见：`Demos/entry/src/main/ets/pages/component/input/attribute/TextInputAttribute.ets`

### 3.5.4. 常用事件

#### 3.5.4.1. change事件

每当输入的内容发生变化，就会触发 **change** 事件，开发者可使用`onChange()`方法为`TextInput`组件绑定 **change** 事件，该方法的参数定义如下

```typescript
onChange(callback: (value: string) => void)
```

其中`value`为最新内容。

#### 3.5.4.2. 焦点事件

焦点事件包括**获得焦点**和**失去焦点**两个事件，当输入框获得焦点时，会触发 **focus** 事件，失去焦点时，会触发 **blur** 事件，开发者可使用`onFocus()`和`onBlur()`方法为 `TextInput` 组件绑定相关事件，两个方法的参数定义如下

```typescript
onFocus(event: () => void)	
onBlur(event: () => void)
```

相关案例见：`Demos/entry/src/main/ets/pages/component/input/event/TextInputEvent.ets`

## 3.6. 进度条

### 3.6.1. 概述

`Progress`为进度条组件，用于显示各种进度。

### 3.6.2. 参数

`Progress`组件的参数定义如下

```arkts
Progress(options: {value: number, total?: number, type?: ProgressType})
```

- **value**

`value`属性用于设置当前进度值。

- **total**

`total`属性用于设置总值。

- **type**

`type`属性用于设置进度条类型，可通过`ProgressType`枚举类型进行设置，可选的枚举值如下

名称描述效果`ProgressType.Linear`线性样式![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705583662928-baf06d0e-2206-4c8e-b25a-18439aee4ef2-20240126155206656.png)`ProgressType.Ring`环形无刻度样式![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705583677665-45efd4c4-7036-42d3-875f-aac374bb48a9-20240126155212554.png)`ProgressType.Eclipse`月食样式![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705583691409-d7603e0e-da8a-4861-9a01-40add2f429d0.png)`ProgressType.ScaleRing`环形有刻度样式![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705584403714-01f4bc41-a3c8-4304-beaf-368936a06770.png)`ProgressType.Capsule`胶囊样式![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705583731185-d98eabf1-61cd-4689-ad7f-4501c239a723.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/progress/parameter/ProgressParameter.ets`

### 3.6.3. 常用属性

#### 3.6.3.1. 进度条样式

可通过`style()`调整进度条的样式，例如进度条的宽度，该方法的参数类型定义如下

```typescript
style({strokeWidth?: string|number|Resource,scaleCount?: number,scaleWidth?: string|number|Resource})
```

- **strokeWidth**

`strokeWidth`属性用于设置进度条的宽度，默认值为`4vp`。该属性可用于`Linear`、`Ring`、`ScaleRing`三种类型，效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705586079637-860814ab-8e0a-4d2a-b78f-36aca48c479e.png)

- **scaleCount**

`scaleCount`属性用于设置`ScaleRing`的刻度数，默认值为`120`。效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705586764957-f65104b5-266d-4401-b96a-6950be60806c-20240126155246644.png)

- **scaleWidth**

`scaleCount`属性用于设置`ScaleRing`的刻度线的宽度，默认值为`2vp`。效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705586839581-31cb18b3-6e28-4c32-81a2-7c7c7ea2362a.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/progress/attribute/style/ProgressStyle.ets`

#### 3.6.3.2. 进度条颜色

进度条的颜色可通过`color()`和`backgroundColor()`方法进行设置，其中`color()`用于设置前景色，`backgroundColor()`用于设置背景色，例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705585514780-7b680226-796d-4ac0-94ca-b4b2d0bf91e4.png)

相关案例见：`Demos/entry/src/main/ets/pages/component/progress/attribute/color/ProgressColor.ets`

## 3.7. 弹窗

弹窗是移动应用中常见的一种用户界面元素，常用于显示一些重要的信息、提示用户进行操作或收集用户输入。ArkTS提供了多种内置的弹窗供开发者使用，除此之外还支持自定义弹窗，来满足各种不同的需求。

### 3.7.1. 消息提示

#### 3.7.1.1. 概述

**Toast**（消息提示），常用于显示一些简短的消息或提示，一般会在短暂停留后自动消失。具体效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705671191468-48f6f6a1-09e2-4c48-bdc2-905f57fd3308.gif)

#### 3.7.1.2. 使用说明

可使用`@ohos.promptAction`模块中的`showToast()`方法显示 **Toast** 提示，使用时需要先导入`@ohos.promptAction`模块，如下

```typescript
import promptAction from '@ohos.promptAction'
```

`showToast()`方法的参数定义如下

```typescript
showToast(options: { message: string | Resource,duration?: number,bottom?: string | number})
```

- **message**

`message`属性用于设置提示信息

- **duration**

`duration`属性用于设置提示信息停留时长，单位为毫秒，取值范围是[1500,10000]

- **bottom**

`bottom`属性用于设置提示信息到底部的距离

相关案例见：`Demos/entry/src/main/ets/pages/component/dialog/toast/ToastPage.ets`

### 3.7.2. 警告对话框

#### 3.7.2.1. 概述

**AlertDialog**（警告对话框）用于向用户发出警告或确认操作的提示，确保用户在敏感操作前进行确认。具体效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705719216968-584c4c1f-970f-4062-9de2-01846ee65d33.gif)

相关案例见：`Demos/entry/src/main/ets/pages/component/dialog/alertDialog/solution/AlertDialogPage.ets`

#### 3.7.2.2. 使用说明

可使用全局方法`AlertDialog.show()`显示警告对话框，具体用法可参考相关案例或者[官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-methods-alert-dialog-box-0000001478341185-V2)。

### 3.7.3. 操作列表弹框

#### 3.7.3.1. 概述

**ActionSheet**（操作列表弹窗）用于提供一组选项给用户选择，用户从中选择后，可执行相应的操作。具体效果如下

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705686219305-ee32e921-aa08-4798-b70a-5ce11bf160d0.gif)

相关案例见：`Demos/entry/src/main/ets/pages/component/dialog/actionSheet/solution/ActionSheetPage.ets`

#### 3.7.3.2. 使用说明

可使用全局方法`ActionSheet.show()`显示操作列表弹窗，具体用法可参考相关案例或者[官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-methods-action-sheet-0000001478061737-V2)。

### 3.7.4. 选择器弹窗

#### 3.7.4.1. 概述

选择器弹窗用于让用户从一个列表中选择一个具体的值。`ArkTS`内置了多种选择器弹窗，例如文本选择器、日期选择器、时间选择器等等，各选择器效果如下

<details class="lake-collapse"><summary id="ucbbb1a17"><strong><span class="ne-text">TextPickerDialog（文本滑动选择器弹窗）</span></strong></summary></details>

<details class="lake-collapse"><summary id="u8ed6fe33"><strong><span class="ne-text">DatePickerDialog（日期滑动选择期弹窗）</span></strong></summary></details>

<details class="lake-collapse"><summary id="uc3dbfab7"><strong><span class="ne-text">TimePickerDialog（时间滑动选择器弹窗）</span></strong></summary></details>

#### 3.7.4.2. 使用说明

具体用法可参考相关案例或者官方文档，各选择器的官方文档地址如下

| 类型                                       | 文档地址                                                     |
| ------------------------------------------ | ------------------------------------------------------------ |
| **TextPickerDialog（文本滑动选择器弹窗）** | [官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-methods-textpicker-dialog-0000001427584912-V2) |
| **DatePickerDialog（日期滑动选择期弹窗）** | [官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-methods-datepicker-dialog-0000001427902500-V2) |
| **TimePickerDialog（时间滑动选择器弹窗）** | [官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V2/ts-methods-timepicker-dialog-0000001428061780-V2) |

### 3.7.5. 自定义弹窗

#### 3.7.5.1. 概述

当现有组件不满足要求时，可考虑自定义弹窗，自定义弹窗允许开发者自定义弹窗内容和样式。例如

![img](https://gitee.com/xuchp/typora-pics/raw/master/images/1705686891246-d950cdd9-4e14-46bb-8c90-70b2f87851f7-20240126155315219.gif)

相关案例见：`Demos/entry/src/main/ets/pages/component/dialog/custom/solution/CustomDialogPage.ets`

#### 3.7.5.2. 使用说明

显示自定义弹窗需要使用`CustomDialogController`，具体用法可参考相关案例或者[官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V2/arkts-common-components-custom-dialog-0000001450754206-V2)。







| ```json<br/>{<br/>  "integer": [<br/>    {<br/>      "name": "width",<br/>      "value": 150<br/>    },<br/>    {<br/>      "name": "height",<br/>      "value": 150<br/>    }<br/>  ]<br/>} | ```json<br/>{<br/>  "integer": [<br/>    {<br/>      "name": "width",<br/>      "value": 150<br/>    },<br/>    {<br/>      "name": "height",<br/>      "value": 150<br/>    }<br/>  ]<br/>} |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

